var tt=Object.defineProperty;var st=(r,e,t)=>e in r?tt(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var g=(r,e,t)=>st(r,typeof e!="symbol"?e+"":e,t);import{d,e as h,_ as We,af as at,ak as it,m as je,H as Qe}from"./patternBoards-59tNjMFd.js";import{E as Te,a as Le,b as A,k as rt,T as ot,O as Oe}from"./Vector2Property-mpypjo8N.js";import"./PhetioControlledVisibilityProperty-C-W8fgEx.js";import"./localStorage-B8VWGy9j.js";import{P as nt}from"./PatternRule-DfusC3Hu.js";const ct=(r,e)=>{if(r.forwardHalf.next.edge===e)return r.forwardHalf;if(r.reversedHalf.next.edge===e)return r.reversedHalf;if(e.forwardHalf.next.edge===r)return e.forwardHalf;if(e.reversedHalf.next.edge===r)return e.reversedHalf;throw new Error("Edges are not connected")},O=class O extends Te{};g(O,"WHITE",new O),g(O,"BLACK",new O),g(O,"RED",new O),g(O,"enumeration",new Le(O));let y=O;const P=(r,e)=>{const t=r.edges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return d()&&h(t),t},B=r=>({start:{x:r.start.logicalCoordinates.x,y:r.start.logicalCoordinates.y},end:{x:r.end.logicalCoordinates.x,y:r.end.logicalCoordinates.y}});class Q{constructor(e,t=new Map){this.board=e,this.edgeStateMap=t}apply(e){for(const[t,s]of this.edgeStateMap)e.setEdgeState(t,s)}getUndo(e){const t=new Map;for(const s of this.edgeStateMap.keys())t.set(s,e.getEdgeState(s));return new Q(this.board,t)}isEmpty(){return this.edgeStateMap.size===0}serializeAction(){return{type:"GeneralEdgeAction",edges:Array.from(this.edgeStateMap.entries()).map(([e,t])=>({edge:B(e),state:t.name}))}}static deserializeAction(e,t){return new Q(e,new Map(t.edges.map(s=>[P(e,s.edge),y.enumeration.getValue(s.state)])))}}const be=(r,e)=>({type:"EdgeData",edges:r.edges.filter(t=>e.getEdgeState(t)!==y.WHITE).map(t=>({edge:B(t),state:e.getEdgeState(t).name}))});class ne extends Q{constructor(t,s,a=new Map){super(t,a);g(this,"edgeStateChangedEmitter",new A);this.parentState=s}getEdgeState(t){return this.edgeStateMap.has(t)?this.edgeStateMap.get(t):this.parentState.getEdgeState(t)}setEdgeState(t,s){const a=this.getEdgeState(t);a!==s&&(this.edgeStateMap.set(t,s),this.edgeStateChangedEmitter.emit(t,s,a))}clone(){return new ne(this.board,this.parentState,new Map(this.edgeStateMap))}createDelta(){return new ne(this.board,this,new Map)}serializeState(t){return be(t,this)}}class X{constructor(e,t){g(this,"edgeStateChangedEmitter",new A);g(this,"edgeStateMap",new Map);this.board=e,e.edges.forEach(s=>{this.edgeStateMap.set(s,t(s))})}getEdgeState(e){return d()&&h(this.edgeStateMap.has(e)),this.edgeStateMap.get(e)}setEdgeState(e,t){d()&&h(this.edgeStateMap.has(e));const s=this.edgeStateMap.get(e);s!==t&&(this.edgeStateMap.set(e,t),this.edgeStateChangedEmitter.emit(e,t,s))}clone(){return new X(this.board,e=>this.getEdgeState(e))}createDelta(){return new ne(this.board,this)}serializeState(e){return be(e,this)}static deserializeState(e,t){const s=new Map(t.edges.map(a=>[P(e,a.edge),y.enumeration.getValue(a.state)]));return new X(e,a=>s.get(a)??y.WHITE)}}const L=(r,e)=>{const t=r.faces.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return d()&&h(t),t};class ie{constructor(e,t){this.id=e,this.colorState=t}}class lt{constructor(e,t,s,a,i,o){this.board=e,this.addedFaceColors=t,this.removedFaceColors=s,this.faceChangeMap=a,this.oppositeChangeMap=i,this.invalidFaceColor=o,d()&&h(s.size<=a.size)}apply(e){e.modifyFaceColors(this.addedFaceColors,this.removedFaceColors,this.faceChangeMap,this.oppositeChangeMap,this.invalidFaceColor)}getUndo(e){throw new Error("getUndo unimplemented in GeneralFaceColorAction")}isEmpty(){return this.addedFaceColors.size===0&&this.removedFaceColors.size===0&&this.faceChangeMap.size===0&&this.oppositeChangeMap.size===0}serializeAction(){throw new Error("serializeAction unimplemented in GeneralFaceColorAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in GeneralFaceColorAction")}}const b=r=>({x:r.logicalCoordinates.x,y:r.logicalCoordinates.y}),V=class V extends Te{};g(V,"OUTSIDE",new V),g(V,"INSIDE",new V),g(V,"UNDECIDED",new V),g(V,"enumeration",new Le(V));let z=V;const ht=(r,e,t)=>({id:r.id,colorState:r.colorState.toString(),faces:e.map(b),oppositeFaceColorId:t}),ke=r=>({type:"FaceColorData",colors:r.getFaceColors().map(e=>{var t;return ht(e,r.getFacesWithColor(e),((t=r.getOppositeFaceColor(e))==null?void 0:t.id)??null)}),invalidFaceColor:r.hasInvalidFaceColors()});class ce extends lt{constructor(t,s,a=new Set,i=new Set,o=new Map,l=new Map,n=!1){super(t,a,i,o,l,n);g(this,"faceColorsChangedEmitter",new A);this.parentState=s}getFaceColors(){return[...[...this.parentState.getFaceColors()].filter(t=>!this.removedFaceColors.has(t)),...this.addedFaceColors]}getInsideColor(){return this.parentState.getInsideColor()}getOutsideColor(){return this.parentState.getOutsideColor()}getFaceColor(t){return this.faceChangeMap.has(t)?this.faceChangeMap.get(t):this.parentState.getFaceColor(t)}getFacesWithColor(t){let s;this.addedFaceColors.has(t)?s=new Set:s=new Set(this.parentState.getFacesWithColor(t));for(const[a,i]of this.faceChangeMap.entries())i===t?s.add(a):s.has(a)&&s.delete(a);return[...s]}getFaceColorMap(){const t=new Map(this.parentState.getFaceColorMap());for(const[s,a]of this.faceChangeMap.entries())t.set(s,a);return t}getOppositeFaceColor(t){const s=this.oppositeChangeMap.get(t);return s!==void 0?s:this.parentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.invalidFaceColor||this.parentState.hasInvalidFaceColors()}modifyFaceColors(t,s,a,i,o){for(const c of t)this.addedFaceColors.add(c);for(const c of s)this.addedFaceColors.has(c)?this.addedFaceColors.delete(c):this.removedFaceColors.add(c);for(const[c,u]of a.entries())this.faceChangeMap.set(c,u);for(const[c,u]of i.entries())this.oppositeChangeMap.set(c,u);const l=new Set(s);for(const c of this.oppositeChangeMap.keys()){const u=this.oppositeChangeMap.get(c);u&&l.has(u)&&this.oppositeChangeMap.set(c,null)}const n=new Set(i.keys());this.invalidFaceColor=o,this.faceColorsChangedEmitter.emit(t,s,n,[...a.keys()])}clone(){return new ce(this.board,this.parentState,new Set(this.addedFaceColors),new Set(this.removedFaceColors),new Map(this.faceChangeMap),new Map(this.oppositeChangeMap),this.invalidFaceColor||this.parentState.hasInvalidFaceColors())}createDelta(){return new ce(this.board,this)}serializeState(t){return ke(this)}}const Ve=()=>rt.nextInt(Number.MAX_SAFE_INTEGER);class H{constructor(e,t,s,a,i,o,l,n){g(this,"faceColorsChangedEmitter",new A);g(this,"faceColors");g(this,"colorMap");g(this,"colorInverseMap");g(this,"oppositeColorMap");g(this,"outsideColor");g(this,"insideColor");g(this,"invalidFaceColor");this.board=e,d()&&h(!t||l,"Provide all or none of the optional arguments"),this.outsideColor=o||new ie(Ve(),z.OUTSIDE),this.insideColor=l||new ie(Ve(),z.INSIDE),this.colorMap=new Map(s||[...e.faces].map(c=>[c,new ie(Ve(),z.UNDECIDED)])),this.faceColors=new Set(t||[this.outsideColor,this.insideColor,...e.faces.map(c=>this.colorMap.get(c))]),d()&&h(this.board.faces.every(c=>this.colorMap.has(c))),d()&&h(this.board.faces.every(c=>this.faceColors.has(this.colorMap.get(c)))),this.colorInverseMap=new Map(a?[...a.keys()].map(c=>[c,new Set([...a.get(c)])]):[...this.faceColors].map(c=>[c,new Set([...this.colorMap.keys()].filter(u=>this.colorMap.get(u)===c))])),this.oppositeColorMap=new Map(i||[[this.outsideColor,this.insideColor],[this.insideColor,this.outsideColor]]),this.invalidFaceColor=!!n}getFaceColors(){return[...this.faceColors]}getInsideColor(){return this.insideColor}getOutsideColor(){return this.outsideColor}getFaceColor(e){const t=this.colorMap.get(e);return d()&&h(t),t}getFacesWithColor(e){d()&&h(this.faceColors.has(e));const t=this.colorInverseMap.get(e);return d()&&h(t),[...t]}getFaceColorMap(){return new Map(this.colorMap)}getOppositeFaceColor(e){return this.oppositeColorMap.get(e)??null}hasInvalidFaceColors(){return this.invalidFaceColor}modifyFaceColors(e,t,s,a,i){for(const n of e)this.faceColors.add(n),this.colorInverseMap.set(n,new Set);for(const[n,c]of s.entries()){const u=this.colorMap.get(n);d()&&h(u),this.colorMap.set(n,c),this.colorInverseMap.get(u).delete(n),this.colorInverseMap.get(c).add(n)}for(const[n,c]of a.entries())this.oppositeColorMap.set(n,c),this.oppositeColorMap.set(c,n);const o=new Set;for(const n of t)o.add(n),this.faceColors.delete(n),this.colorInverseMap.delete(n),this.oppositeColorMap.delete(n);for(const n of this.faceColors)this.oppositeColorMap.has(n)&&o.has(this.oppositeColorMap.get(n))&&this.oppositeColorMap.delete(n);const l=new Set(a.keys());if(this.invalidFaceColor=i,d()&&h(this.board.faces.every(n=>this.colorMap.has(n))),d()&&h(this.board.faces.every(n=>this.faceColors.has(this.colorMap.get(n)))),d()){const n=new Set(this.getFaceColors());for(const c of n){const u=this.getOppositeFaceColor(c);u&&!n.has(u)&&h(!1,`opposite color ${u} of color ${c} is not in the set of colors`)}}this.faceColorsChangedEmitter.emit(e,t,l,[...s.keys()])}clone(){return new H(this.board,this.faceColors,this.colorMap,this.colorInverseMap,this.oppositeColorMap,this.outsideColor,this.insideColor,this.invalidFaceColor)}createDelta(){return new ce(this.board,this)}serializeState(e){return ke(this)}static deserializeState(e,t){const s=t.colors.map(c=>{const u=c.id,m=z.enumeration.getValue(c.colorState);return d()&&h(m),new ie(u,m)}),a=new Map,i=new Map,o=new Map;s.forEach((c,u)=>{const m=t.colors[u].faces.map(F=>L(e,F));m.forEach(F=>a.set(F,c)),i.set(c,new Set(m));const M=t.colors[u].oppositeFaceColorId;if(M!==null){const F=s.find(f=>f.id===M);d()&&h(F),o.set(c,F)}});const l=s.find(c=>c.colorState===z.OUTSIDE);d()&&h(l);const n=s.find(c=>c.colorState===z.INSIDE);return d()&&h(n),new H(e,new Set(s),a,i,o,l,n,t.invalidFaceColor)}}const k=[],Xe=r=>{for(;k.length<=r;)k.push(k.length===0?1:k[k.length-1]*k.length);return k},Je=(r,e,t)=>t[r]/(t[e]*t[r-e]),re=(r,e)=>{r=We.sortBy(r);const t=Xe(e);let s=0;const a=r.length;for(let i=0;i<a;i++){const o=r[i-1]+1,l=r[i];for(let n=i==0?0:o;n<l;n++)s+=Je(e-n-1,a-i-1,t)}return s},dt=(r,e)=>Je(r,e,Xe(r)),oe=(r,e)=>{let t=0;for(let s=0;s<r.length;s++)t+=1<<e-r[s]-1;return t},gt=r=>1<<r,Ge=r=>{const e=new Uint8Array(Math.ceil(r.length/8));for(let s=0;s<r.length;s++)r[s]&&(e[Math.floor(s/8)]|=1<<7-s%8);const t=btoa(String.fromCharCode(...e));if(d()){const s=Ne(t,r.length);h(r.length===s.length&&r.every((a,i)=>a===s[i]))}return t},Ne=(r,e)=>{const t=Uint8Array.from(atob(r),a=>a.charCodeAt(0)),s=[];for(let a=0;a<t.length*8;a++)s.push((t[Math.floor(a/8)]&1<<7-a%8)!==0);return s.slice(0,e)};class C{constructor(e,t,s,a){g(this,"order");g(this,"possibilityCount");g(this,"matrix");this.face=e,this.faceValue=t,this.order=e.edges.length,s?this.matrix=s:this.matrix=We.range(0,C.getMatrixSize(this.order,this.faceValue)).map(()=>!0),a!==void 0?this.possibilityCount=a:this.possibilityCount=this.matrix.filter(i=>i).length,d()&&h(this.matrix.length===C.getMatrixSize(this.order,this.faceValue)),d()&&h(this.possibilityCount===this.matrix.filter(i=>i).length)}isAny(){return this.possibilityCount===C.getMatrixSize(this.order,this.faceValue)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.allowsBlackEdges([])}allowsBlackEdges(e){return this.matrix[this.getBlackEdgesIndex(e)]}getAllowedCombinations(){const e=[];return C.forEachEdgeCombination(this.face.edges,this.faceValue,(t,s)=>{this.matrix[this.getIndexFromIndices(t)]&&e.push(s.slice())}),d()&&h(e.length===this.possibilityCount),e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedCombinations())s.includes(e)?t.add(y.BLACK):t.add(y.RED);return this.allowsEmpty()&&t.add(y.RED),t}getBlackEdgesIndex(e){const t=e.map(s=>this.face.edges.indexOf(s));return d()&&h(t.every(s=>s>=0)),this.getIndexFromIndices(t)}getIndexFromIndices(e){return this.faceValue===null?oe(e,this.order):re(e,this.order)}equals(e){return this.face===e.face&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return d()&&h(this.face===e.face),new C(this.face,this.faceValue,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return d()&&h(this.face===e.face),new C(this.face,this.faceValue,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withBlackEdges(e,t){const s=this.getBlackEdgesIndex(e);return new C(this.face,this.faceValue,this.matrix.slice(0,s).concat(t,this.matrix.slice(s+1)))}serialize(){if(this.isAny())return{faceValue:this.faceValue,matrix:"",isAny:!0};const e={faceValue:this.faceValue,matrix:Ge(this.matrix),isAny:!1};return d()&&h(this.equals(C.deserialize(this.face,e))),e}static getMatrixSize(e,t){return t===null?gt(e):dt(e,t)}static forEachIndexCombination(e,t,s){let a=[];const i=()=>{if(t!==null){if(a.length===t){s(a);return}}else s(a);const o=a.length>0?a[a.length-1]+1:0;for(let l=o;l<e;l++)a.push(l),i(),a.pop()};i()}static forEachEdgeCombination(e,t,s){let a=[],i=[];const o=()=>{if(t!==null){if(a.length===t){s(a,i);return}}else s(a,i);const l=a.length>0?a[a.length-1]+1:0;for(let n=l;n<e.length;n++)a.push(n),i.push(e[n]),o(),a.pop(),i.pop()};o()}static fromLookup(e,t,s){const a=e.edges.length,i=new Array(C.getMatrixSize(a,t)).fill(!1);return C.forEachEdgeCombination(e.edges,t,(o,l)=>{if(s(l)){const c=t===null?oe(o,a):re(o,a);i[c]=!0}}),new C(e,t,i)}static none(e,t){const s=C.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!1);return new C(e,t,a,0)}static any(e,t){const s=C.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!0);return new C(e,t,a,s)}static withOnlyBlackEdges(e,t,s){const a=C.getMatrixSize(e.edges.length,t),i=new Array(a).fill(!1),o=s.map(n=>e.edges.indexOf(n)),l=t===null?oe(o,e.edges.length):re(o,e.edges.length);return i[l]=!0,new C(e,t,i,1)}static withoutBlackEdges(e,t,s){const a=C.getMatrixSize(e.edges.length,t),i=new Array(a).fill(!0),o=s.map(n=>e.edges.indexOf(n)),l=t===null?oe(o,e.edges.length):re(o,e.edges.length);return i[l]=!1,new C(e,t,i,a-1)}static fromVertexAndColorData(e,t,s){const i=e.vertices.map(u=>s.getVertexState(u)).map(u=>{const m=u.vertex.edges.filter(M=>M.faces.includes(e));return d()&&h(m.length===2),{edgeA:m[0],edgeB:m[1],...u.getBinaryCombinationsAllowed(m[0],m[1])}}),o=new Map(e.edges.map(u=>{const m=u.getOtherFace(e);return[u,m?s.getFaceColor(m):s.getOutsideColor()]})),l=s.getFaceColor(e),n=new Set([...o.values(),l]),c=new Map([...n].map(u=>[u,s.getOppositeFaceColor(u)]));return C.fromLookup(e,s.getFaceValue(e),u=>{const m=new Set(u);for(const f of i){const p=m.has(f.edgeA),S=m.has(f.edgeB);if(p&&S&&!f.allowsBoth||p&&!S&&!f.allowsAOnly||!p&&S&&!f.allowsBOnly||!p&&!S&&!f.allowsNone)return!1}const M=new Set([l]),F=new Set;for(const f of e.edges){const p=o.get(f);d()&&h(p),m.has(f)?F.add(p):M.add(p)}for(const f of M){if(F.has(f))return!1;const p=c.get(f);if(p&&M.has(p))return!1}for(const f of F){const p=c.get(f);if(p&&F.has(p))return!1}if(m.size===e.edges.length){for(const f of t.faces)if(s.getFaceValue(f)!==null){for(const p of f.edges)if(!m.has(p))return!1}}return!0})}static deserialize(e,t){return t.isAny?C.any(e,t.faceValue):new C(e,t.faceValue,Ne(t.matrix,C.getMatrixSize(e.edges.length,t.faceValue)))}}class le{constructor(e,t=new Map){this.board=e,this.faceStateMap=t}apply(e){for(const[t,s]of this.faceStateMap)e.setFaceState(t,s)}getUndo(e){const t=new Map;for(const s of this.faceStateMap.keys())t.set(s,e.getFaceState(s));return new le(this.board,t)}isEmpty(){return this.faceStateMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceStateMap.entries()).map(([e,t])=>({face:b(e),state:t.serialize()}))}}static deserializeAction(e,t){return new le(e,new Map(t.faces.map(s=>[L(e,s.face),C.deserialize(L(e,s.face),s.state)])))}}const Ue=(r,e)=>({type:"FaceStateData",faces:r.faces.map(t=>({face:b(t),state:e.getFaceState(t).serialize()}))});class he extends le{constructor(t,s,a=new Map){super(t,a);g(this,"faceStateChangedEmitter",new A);this.parentState=s}getFaceState(t){return this.faceStateMap.has(t)?this.faceStateMap.get(t):this.parentState.getFaceState(t)}setFaceState(t,s){const a=this.getFaceState(t);a.equals(s)||(this.faceStateMap.set(t,s),this.faceStateChangedEmitter.emit(t,s,a))}clone(){return new he(this.board,this.parentState,new Map(this.faceStateMap))}createDelta(){return new he(this.board,this,new Map)}serializeState(t){return Ue(t,this)}}class q{constructor(e,t){g(this,"faceStateChangedEmitter",new A);g(this,"faceStateMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceStateMap.set(s,t(s))})}getFaceState(e){return d()&&h(this.faceStateMap.has(e)),this.faceStateMap.get(e)}setFaceState(e,t){d()&&h(this.faceStateMap.has(e));const s=this.faceStateMap.get(e);s.equals(t)||(this.faceStateMap.set(e,t),this.faceStateChangedEmitter.emit(e,t,s))}clone(){return new q(this.board,e=>this.getFaceState(e))}createDelta(){return new he(this.board,this)}serializeState(e){return Ue(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>{const i=L(e,a.face);return[i,C.deserialize(i,a.state)]}));return new q(e,a=>{const i=s.get(a);return d()&&h(i),i})}}class J{constructor(e,t=new Map){this.board=e,this.faceValueMap=t}apply(e){for(const[t,s]of this.faceValueMap)e.setFaceValue(t,s)}getUndo(e){const t=new Map;for(const s of this.faceValueMap.keys())t.set(s,e.getFaceValue(s));return new J(this.board,t)}isEmpty(){return this.faceValueMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceValueMap.entries()).map(([e,t])=>({face:b(e),state:t}))}}static deserializeAction(e,t){return new J(e,new Map(t.faces.map(s=>[L(e,s.face),s.state])))}}const Pe=(r,e)=>({type:"FaceValueData",faces:r.faces.filter(t=>e.getFaceValue(t)!==null).map(t=>({face:b(t),state:e.getFaceValue(t)}))});class de extends J{constructor(t,s,a=new Map){super(t,a);g(this,"faceValueChangedEmitter",new A);this.parentState=s}getFaceValue(t){return this.faceValueMap.has(t)?this.faceValueMap.get(t):this.parentState.getFaceValue(t)}setFaceValue(t,s){this.getFaceValue(t)!==s&&(this.faceValueMap.set(t,s),this.faceValueChangedEmitter.emit(t,s))}clone(){return new de(this.board,this.parentState,new Map(this.faceValueMap))}createDelta(){return new de(this.board,this,new Map)}serializeState(t){return Pe(t,this)}}class G{constructor(e,t){g(this,"faceValueChangedEmitter",new A);g(this,"faceValueMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceValueMap.set(s,t(s))})}getFaceValue(e){return d()&&h(this.faceValueMap.has(e)),this.faceValueMap.get(e)}setFaceValue(e,t){d()&&h(this.faceValueMap.has(e)),this.faceValueMap.get(e)!==t&&(this.faceValueMap.set(e,t),this.faceValueChangedEmitter.emit(e,t))}clone(){return new G(this.board,e=>this.getFaceValue(e))}createDelta(){return new de(this.board,this)}serializeState(e){return Pe(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>[L(e,a.face),a.state]));return new G(e,a=>s.get(a)??null)}}const De=(r,e)=>{const t=r.halfEdges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return d()&&h(t),t},Re=r=>({start:{x:r.start.logicalCoordinates.x,y:r.start.logicalCoordinates.y},end:{x:r.end.logicalCoordinates.x,y:r.end.logicalCoordinates.y}}),w=class w extends Te{constructor(e,t,s,a){super(),this.zero=e,this.one=t,this.two=s,this.serializedValue=a}allows(e){return d()&&h(e===0||e===1||e===2),e===0&&this.zero||e===1&&this.one||e===2&&this.two}isSubsetOf(e){return(!this.zero||e.zero)&&(!this.one||e.one)&&(!this.two||e.two)}and(e){return w.getWithValue(this.zero&&e.zero,this.one&&e.one,this.two&&e.two)}or(e){return w.getWithValue(this.zero||e.zero,this.one||e.one,this.two||e.two)}withZero(e){return w.getWithValue(e,this.one,this.two)}withOne(e){return w.getWithValue(this.zero,e,this.two)}withTwo(e){return w.getWithValue(this.zero,this.one,e)}with(e){return d()&&h(e===0||e===1||e===2),w.getWithValue(e===0?!0:this.zero,e===1?!0:this.one,e===2?!0:this.two)}withAllowZero(){return this.withZero(!0)}withAllowOne(){return this.withOne(!0)}withAllowTwo(){return this.withTwo(!0)}withDisallowZero(){return this.withZero(!1)}withDisallowOne(){return this.withOne(!1)}withDisallowTwo(){return this.withTwo(!1)}serialize(){return this.serializedValue}static getWithValue(e,t,s){return w.enumeration.values.find(a=>a.zero===e&&a.one===t&&a.two===s)}static getOnly(e){return d()&&h(e===0||e===1||e===2),w.getWithValue(e===0,e===1,e===2)}static getNot(e){return d()&&h(e===0||e===1||e===2),w.getWithValue(e!==0,e!==1,e!==2)}static deserialize(e){const t=pt.get(e);return d()&&h(t,`invalid serialized value: ${e}`),t}};g(w,"NONE",new w(!1,!1,!1,0)),g(w,"ONLY_ZERO",new w(!0,!1,!1,1)),g(w,"ONLY_ONE",new w(!1,!0,!1,2)),g(w,"ONLY_TWO",new w(!1,!1,!0,3)),g(w,"NOT_ZERO",new w(!1,!0,!0,4)),g(w,"NOT_ONE",new w(!0,!1,!0,5)),g(w,"NOT_TWO",new w(!0,!0,!1,6)),g(w,"ANY",new w(!0,!0,!0,7)),g(w,"enumeration",new Le(w)),g(w,"trivialStates",[w.NONE,w.ONLY_ZERO,w.ONLY_TWO,w.ANY]);let T=w;const pt=new Map(T.enumeration.values.map(r=>[r.serializedValue,r]));class ge{constructor(e,t=new Map){this.board=e,this.sectorStateMap=t}apply(e){for(const[t,s]of this.sectorStateMap)e.setSectorState(t,s)}getUndo(e){const t=new Map;for(const s of this.sectorStateMap.keys())t.set(s,e.getSectorState(s));return new ge(this.board,t)}isEmpty(){return this.sectorStateMap.size===0}serializeAction(){return{type:"GeneralSectorAction",sectors:Array.from(this.sectorStateMap.entries()).map(([e,t])=>({sector:Re(e),state:t.serialize()}))}}static deserializeAction(e,t){return new ge(e,new Map(t.sectors.map(s=>[De(e,s.sector),T.deserialize(s.state)])))}}const Be=(r,e)=>({type:"SectorStateData",sectors:r.halfEdges.filter(t=>e.getSectorState(t)!==T.ANY).map(t=>({sector:Re(t),state:e.getSectorState(t).serialize()}))});class pe extends ge{constructor(t,s,a=new Map){super(t,a);g(this,"sectorStateChangedEmitter",new A);this.parentState=s}getSectorState(t){return this.sectorStateMap.has(t)?this.sectorStateMap.get(t):this.parentState.getSectorState(t)}setSectorState(t,s){const a=this.getSectorState(t);a!==s&&(this.sectorStateMap.set(t,s),this.sectorStateChangedEmitter.emit(t,s,a))}clone(){return new pe(this.board,this.parentState,new Map(this.sectorStateMap))}createDelta(){return new pe(this.board,this,new Map)}serializeState(t){return Be(t,this)}}class Z{constructor(e,t=()=>T.ANY){g(this,"sectorStateChangedEmitter",new A);g(this,"sectorStateMap",new Map);this.board=e,e.halfEdges.forEach(s=>{this.sectorStateMap.set(s,t(s))})}getSectorState(e){return d()&&h(this.sectorStateMap.has(e)),this.sectorStateMap.get(e)}setSectorState(e,t){d()&&h(this.sectorStateMap.has(e));const s=this.sectorStateMap.get(e);s!==t&&(this.sectorStateMap.set(e,t),this.sectorStateChangedEmitter.emit(e,t,s))}clone(){return new Z(this.board,e=>this.getSectorState(e))}createDelta(){return new pe(this.board,this)}serializeState(e){return Be(e,this)}static deserializeState(e,t){const s=new Map(t.sectors.map(a=>[De(e,a.sector),T.deserialize(a.state)]));return new Z(e,a=>s.get(a)??T.ANY)}}class _{constructor(e,t,s=!1){g(this,"edges");g(this,"a");g(this,"b");if(this.id=e,this.halfEdges=t,this.isSolved=s,this.a=t[0].start,this.b=t[t.length-1].end,this.edges=t.map(a=>a.edge),d()){h(t.length>0);for(let a=0;a<t.length-1;a++)h(t[a].end===t[a+1].start)}}static deserializeSimpleRegion(e,t){return new _(t.id,t.halfEdges.map(s=>De(e,s)),t.isSolved)}}const ze=r=>({id:r.id,halfEdges:r.halfEdges.map(Re),isSolved:r.isSolved}),xt=r=>{const e=r.getSimpleRegions();return e.length===1&&e[0].isSolved&&r.getWeirdEdges().length===0},He=r=>({type:"SimpleRegionData",simpleRegions:r.getSimpleRegions().map(ze),weirdEdges:r.getWeirdEdges().map(B)});class ee{constructor(e,t=new Set,s=new Set,a=new Set,i=new Set){this.board=e,this.addedRegions=t,this.removedRegions=s,this.addedWeirdEdges=a,this.removedWeirdEdges=i}apply(e){e.modifyRegions(this.addedRegions,this.removedRegions,this.addedWeirdEdges,this.removedWeirdEdges)}getUndo(e){return new ee(this.board,this.removedRegions,this.addedRegions,this.removedWeirdEdges,this.addedWeirdEdges)}isEmpty(){return this.addedRegions.size===0&&this.removedRegions.size===0&&this.addedWeirdEdges.size===0&&this.removedWeirdEdges.size===0}serializeAction(){return{type:"GeneralSimpleRegionAction",addedRegions:Array.from(this.addedRegions).map(ze),removedRegions:Array.from(this.removedRegions).map(ze),addedWeirdEdges:Array.from(this.addedWeirdEdges).map(B),removedWeirdEdges:Array.from(this.removedWeirdEdges).map(B)}}static deserializeAction(e,t){return new ee(e,new Set(t.addedRegions.map(s=>_.deserializeSimpleRegion(e,s))),new Set(t.removedRegions.map(s=>_.deserializeSimpleRegion(e,s))),new Set(t.addedWeirdEdges.map(s=>P(e,s))),new Set(t.removedWeirdEdges.map(s=>P(e,s))))}}class ue extends ee{constructor(t,s,a=new Set,i=new Set,o=new Set,l=new Set){super(t,a,i,o,l);g(this,"simpleRegionsChangedEmitter",new A);this.parentState=s}getSimpleRegions(){return[...this.parentState.getSimpleRegions().filter(t=>!this.removedRegions.has(t)),...this.addedRegions]}getSimpleRegionWithVertex(t){for(const s of this.getSimpleRegions())if(s.a===t||s.b===t)return s;return null}getSimpleRegionWithEdge(t){for(const s of this.getSimpleRegions())if(s.edges.includes(t))return s;return null}getSimpleRegionWithId(t){for(const s of this.getSimpleRegions())if(s.id===t)return s;return null}getWeirdEdges(){return[...this.parentState.getWeirdEdges().filter(t=>!this.removedWeirdEdges.has(t)),...this.addedWeirdEdges]}modifyRegions(t,s,a,i){for(const o of s)this.addedRegions.has(o)?this.addedRegions.delete(o):this.removedRegions.add(o);for(const o of t)this.addedRegions.add(o);for(const o of i)this.addedWeirdEdges.has(o)?this.addedWeirdEdges.delete(o):this.removedWeirdEdges.add(o);for(const o of a)this.addedWeirdEdges.add(o);this.simpleRegionsChangedEmitter.emit(t,s,a,i)}clone(){return new ue(this.board,this.parentState,new Set(this.addedRegions),new Set(this.removedRegions),new Set(this.addedWeirdEdges),new Set(this.removedWeirdEdges))}createDelta(){return new ue(this.board,this)}serializeState(t){return He(this)}}class Y{constructor(e,t,s){g(this,"simpleRegionsChangedEmitter",new A);g(this,"simpleRegions");g(this,"weirdEdges");this.board=e,this.simpleRegions=new Set(t),this.weirdEdges=new Set(s)}getSimpleRegions(){return[...this.simpleRegions]}getSimpleRegionWithVertex(e){for(const t of this.simpleRegions)if(t.a===e||t.b===e)return t;return null}getSimpleRegionWithEdge(e){for(const t of this.simpleRegions)if(t.edges.includes(e))return t;return null}getSimpleRegionWithId(e){for(const t of this.simpleRegions)if(t.id===e)return t;return null}getWeirdEdges(){return[...this.weirdEdges]}modifyRegions(e,t,s,a){for(const i of t)this.simpleRegions.delete(i);for(const i of e)this.simpleRegions.add(i);for(const i of a)this.weirdEdges.delete(i);for(const i of s)this.weirdEdges.add(i);this.simpleRegionsChangedEmitter.emit(e,t,s,a)}clone(){return new Y(this.board,this.simpleRegions,this.weirdEdges)}createDelta(){return new ue(this.board,this)}serializeState(e){return He(this)}static deserializeState(e,t){return new Y(e,t.simpleRegions.map(s=>_.deserializeSimpleRegion(e,s)),t.weirdEdges.map(s=>P(e,s)))}}const Ie=(r,e)=>{const t=r.vertices.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return d()&&h(t),t},_e=r=>({x:r.logicalCoordinates.x,y:r.logicalCoordinates.y}),ut=r=>r.incomingHalfEdges,ft=r=>{let e=ut(r);return e=[...e.slice(1),e[0]],d()&&h(e[0].edge===r.edges[1]&&e[0].next.edge===r.edges[0]),e};class E{constructor(e,t,s){g(this,"order");g(this,"possibilityCount");g(this,"matrix");this.vertex=e,this.order=e.edges.length,t?this.matrix=t:this.matrix=We.range(0,E.getMatrixSize(this.order)).map(()=>!0),s!==void 0?this.possibilityCount=s:this.possibilityCount=this.matrix.filter(a=>a).length,d()&&h(this.matrix.length===E.getMatrixSize(this.order)),d()&&h(this.possibilityCount===this.matrix.filter(a=>a).length)}isAny(){return this.possibilityCount===E.getMatrixSize(this.order)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.matrix[E.getMatrixSize(this.order)-1]}allowsPair(e,t){return this.matrix[this.getPairIndex(e,t)]}getBinaryCombinationsAllowed(e,t){let s=this.allowsEmpty(),a=!1,i=!1,o=!1;for(const l of this.getAllowedPairs()){const n=l[0]===e||l[1]===e,c=l[0]===t||l[1]===t;n&&c?a=!0:n?i=!0:c?o=!0:s=!0}return{allowsNone:s,allowsBoth:a,allowsAOnly:i,allowsBOnly:o}}getAllowedPairs(){const e=[];let t=0;for(let s=0;s<this.order;s++)for(let a=s+1;a<this.order;a++)this.matrix[t++]&&e.push([this.vertex.edges[s],this.vertex.edges[a]]);return e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedPairs())s[0]===e||s[1]===e?t.add(y.BLACK):t.add(y.RED);return this.allowsEmpty()&&t.add(y.RED),t}getPairIndex(e,t){const s=this.vertex.edges.indexOf(e),a=this.vertex.edges.indexOf(t),i=Math.min(s,a),o=Math.max(s,a);return E.getIndex(i,o,this.order)}equals(e){return this.vertex===e.vertex&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return d()&&h(this.vertex===e.vertex),new E(this.vertex,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return d()&&h(this.vertex===e.vertex),new E(this.vertex,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withEmpty(e){return new E(this.vertex,this.matrix.slice(0,-1).concat(e))}withPair(e,t,s){const a=this.getPairIndex(e,t);return new E(this.vertex,this.matrix.slice(0,a).concat(s,this.matrix.slice(a+1)))}serialize(){const e=Ge(this.matrix);return d()&&h(this.equals(E.deserialize(this.vertex,e))),e}static getIndex(e,t,s){return e*(2*s-e-1)/2+(t-e-1)}static getMatrixSize(e){return e*(e-1)/2+1}static fromLookup(e,t,s){const a=e.edges.length,i=[];for(let o=0;o<a;o++)for(let l=o+1;l<a;l++)i.push(t(e.edges[o],e.edges[l]));return i.push(s),new E(e,i)}static none(e){return E.fromLookup(e,()=>!1,!1)}static any(e){return E.fromLookup(e,()=>!0,!0)}static withOnlyEmpty(e){return E.fromLookup(e,()=>!1,!0)}static withOnlyPair(e,t,s){return E.fromLookup(e,(a,i)=>a===t&&i===s||a===s&&i===t,!1)}static withoutEmpty(e){return E.fromLookup(e,()=>!0,!1)}static withoutPair(e,t,s){return E.fromLookup(e,(a,i)=>a!==t&&a!==s||i!==t&&i!==s,!0)}static fromEdgeColorSectorData(e,t){const s=e.edges.length,a=[],i=e.edges.filter(p=>t.getEdgeState(p)===y.BLACK);if(i.length>2)return E.none(e);if(i.length===2)return E.withOnlyPair(e,i[0],i[1]);const o=i.length?i[0]:null,l=new Set(e.edges.filter(p=>t.getEdgeState(p)===y.RED));if(l.size===s)return E.withOnlyEmpty(e);const n=ft(e),c=n.map(p=>t.getSectorState(p)),u=c.every(p=>p.zero),m=n.map(p=>p.face?t.getFaceColor(p.face):t.getOutsideColor()),M=new Set(m),F=new Map([...M].map(p=>[p,t.getOppositeFaceColor(p)])),f=[...F.values()].every(p=>!p||!M.has(p));for(let p=0;p<s;p++){const S=e.edges[p];if(l.has(S)){for(let x=p+1;x<s;x++)a.push(!1);continue}for(let x=p+1;x<s;x++){let v=!0;const ae=e.edges[x];if(v&&l.has(ae)&&(v=!1),v&&o&&S!==o&&ae!==o&&(v=!1),v&&(v=v&&c.every(($,j)=>{const R=n[j];let I=0;return(S===R.edge||S===R.next.edge)&&I++,(ae===R.edge||ae===R.next.edge)&&I++,$.allows(I)})),v){const $=m.slice(p,x),j=[...m.slice(x),...m.slice(0,p)];$.some(R=>j.includes(R))&&(v=!1),v&&$.some(R=>{const I=F.get(R);return I&&$.includes(I)})&&(v=!1),v&&j.some(R=>{const I=F.get(R);return I&&j.includes(I)})&&(v=!1)}a.push(v)}}return a.push(i.length===0&&u&&f),new E(e,a)}static deserialize(e,t){return new E(e,Ne(t,E.getMatrixSize(e.edges.length)))}}class fe{constructor(e,t=new Map){this.board=e,this.vertexStateMap=t}apply(e){for(const[t,s]of this.vertexStateMap)e.setVertexState(t,s)}getUndo(e){const t=new Map;for(const s of this.vertexStateMap.keys())t.set(s,e.getVertexState(s));return new fe(this.board,t)}isEmpty(){return this.vertexStateMap.size===0}serializeAction(){return{type:"GeneralVertexAction",vertices:Array.from(this.vertexStateMap.entries()).map(([e,t])=>({vertex:_e(e),state:t.serialize()}))}}static deserializeAction(e,t){return new fe(e,new Map(t.vertices.map(s=>[Ie(e,s.vertex),E.deserialize(Ie(e,s.vertex),s.state)])))}}const qe=(r,e)=>({type:"VertexStateData",vertices:r.vertices.filter(t=>!e.getVertexState(t).isAny()).map(t=>({vertex:_e(t),state:e.getVertexState(t).serialize()}))});class me extends fe{constructor(t,s,a=new Map){super(t,a);g(this,"vertexStateChangedEmitter",new A);this.parentState=s}getVertexState(t){return this.vertexStateMap.has(t)?this.vertexStateMap.get(t):this.parentState.getVertexState(t)}setVertexState(t,s){const a=this.getVertexState(t);a.equals(s)||(this.vertexStateMap.set(t,s),this.vertexStateChangedEmitter.emit(t,s,a))}clone(){return new me(this.board,this.parentState,new Map(this.vertexStateMap))}createDelta(){return new me(this.board,this,new Map)}serializeState(t){return qe(t,this)}}class K{constructor(e,t=E.any){g(this,"vertexStateChangedEmitter",new A);g(this,"vertexStateMap",new Map);this.board=e,e.vertices.forEach(s=>{this.vertexStateMap.set(s,t(s))})}getVertexState(e){return d()&&h(this.vertexStateMap.has(e)),this.vertexStateMap.get(e)}setVertexState(e,t){d()&&h(this.vertexStateMap.has(e));const s=this.vertexStateMap.get(e);s.equals(t)||(this.vertexStateMap.set(e,t),this.vertexStateChangedEmitter.emit(e,t,s))}clone(){return new K(this.board,e=>this.getVertexState(e))}createDelta(){return new me(this.board,this)}serializeState(e){return qe(e,this)}static deserializeState(e,t){const s=new Map(t.vertices.map(a=>{const i=Ie(e,a.vertex);return[i,E.deserialize(i,a.state)]}));return new K(e,a=>s.get(a)??E.any(a))}}class se{apply(e){}getUndo(e){return this}isEmpty(){return!0}serializeAction(){return{type:"NoOpAction"}}static deserializeAction(e,t){return new se}}class Ze extends se{constructor(){super(...arguments);g(this,"isUserLoadPuzzleAutoSolveAction",!0)}serializeAction(){return{type:"UserLoadPuzzleAutoSolveAction"}}static deserializeAction(t,s){return new Ze}}class Ye extends se{constructor(){super(...arguments);g(this,"isUserRequestSolveAction",!0)}serializeAction(){return{type:"UserRequestSolveAction"}}static deserializeAction(t,s){return new Ye}}class Se{constructor(e,t=!0){this.edge=e,this.forward=t}apply(e){const t=e.getEdgeState(this.edge);t===y.WHITE?e.setEdgeState(this.edge,this.forward?y.BLACK:y.RED):t===y.BLACK?e.setEdgeState(this.edge,this.forward?y.RED:y.WHITE):e.setEdgeState(this.edge,this.forward?y.WHITE:y.BLACK)}getUndo(e){return new Se(this.edge,!this.forward)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateCycleAction",edge:B(this.edge),forward:this.forward}}static deserializeAction(e,t){return new Se(P(e,t.edge),t.forward)}}class we{constructor(e,t){this.edge=e,this.state=t}apply(e){e.setEdgeState(this.edge,this.state)}getUndo(e){const t=e.getEdgeState(this.edge);return new we(this.edge,t)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateSetAction",edge:B(this.edge),state:this.state.name}}static deserializeAction(e,t){return new we(P(e,t.edge),y.enumeration.getValue(t.state))}}const Ce=(r,e)=>e.type==="face"?r.getFaceColor(e.face):e.isOutside?r.getOutsideColor():r.getInsideColor(),Ee=(r,e)=>e.type==="face"?{type:"face",face:L(r,e.face)}:{type:"absolute",isOutside:e.isOutside},ye=r=>r.type==="face"?{type:"face",face:b(r.face)}:{type:"absolute",isOutside:r.isOutside};class U{constructor(e,t){this.a=e,this.b=t,d()&&h(e),d()&&h(t)}apply(e){const t=Ce(e,this.a),s=Ce(e,this.b);if(t===s)return;const a=e.getOppositeFaceColor(t),i=e.getOppositeFaceColor(s);if(d()){const M=new Set(e.getFaceColors());h(M.has(t)),h(M.has(s)),a&&h(M.has(a)),i&&h(M.has(i))}if(a&&a===s||i&&i===t){e.modifyFaceColors([],[],new Map,new Map,!0);return}const o=[],l=new Map,n=new Map,c=U.combineFaces(t,s,e,o,l),u=a&&i?U.combineFaces(a,i,e,o,l):a||i;c===t&&u===a||c===s&&u===i||(n.set(c,u),u&&n.set(u,c)),e.modifyFaceColors([],o,l,n,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeSameAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeSameAction",a:ye(this.a),b:ye(this.b)}}static deserializeAction(e,t){return new U(Ee(e,t.a),Ee(e,t.b))}static combineFaces(e,t,s,a,i){let o=null;if(e.colorState!==z.UNDECIDED)o=t;else if(t.colorState!==z.UNDECIDED)o=e;else{const n=s.getFacesWithColor(e),c=s.getFacesWithColor(t);o=n.length>c.length?t:e}const l=o===e?t:e;a.push(o);for(const n of s.getFacesWithColor(o))i.set(n,l);return l}}class Ke{constructor(e,t){this.a=e,this.b=t,d()&&h(e),d()&&h(t)}apply(e){const t=Ce(e,this.a),s=Ce(e,this.b);if(t===s){e.modifyFaceColors([],[],new Map,new Map,!0);return}const a=e.getOppositeFaceColor(t),i=e.getOppositeFaceColor(s);if(d()){const m=new Set(e.getFaceColors());h(m.has(t)),h(m.has(s)),a&&h(m.has(a)),i&&h(m.has(i))}if(a&&a===s||i&&i===t)return;if(a&&a===i){e.modifyFaceColors([],[],new Map,new Map,!0);return}const o=[],l=new Map,n=new Map,c=i?U.combineFaces(t,i,e,o,l):t,u=a?U.combineFaces(s,a,e,o,l):s;n.set(c,u),n.set(u,c),e.modifyFaceColors([],o,l,n,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeOppositeAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeOppositeAction",a:ye(this.a),b:ye(this.b)}}static deserializeAction(e,t){return new Ke(Ee(e,t.a),Ee(e,t.b))}}class $e{constructor(e,t){this.face=e,this.isInside=t,d()&&h(e)}apply(e){const t=e.getOutsideColor(),s=e.getInsideColor(),a=this.isInside?s:t,i=this.isInside?t:s,o=e.getFaceColor(this.face),l=e.getOppositeFaceColor(o);if(d()){const n=new Set(e.getFaceColors());h(n.has(o)),l&&h(n.has(l))}if(o!==a)if(o===i)e.modifyFaceColors([],[],new Map([[this.face,a]]),new Map,!1);else{const n=[o,...l?[l]:[]],c=new Map;for(const u of e.getFacesWithColor(o))c.set(u,a);if(l)for(const u of e.getFacesWithColor(l))c.set(u,i);e.modifyFaceColors([],n,c,new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in FaceColorSetAbsoluteAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorSetAbsoluteAction",face:b(this.face),isInside:this.isInside}}static deserializeAction(e,t){const s=L(e,t.face),a=t.isInside;return new $e(s,a)}}class Me{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceValue(this.face,this.state)}getUndo(e){const t=e.getFaceValue(this.face);return new Me(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceValueSetAction",edge:b(this.face),state:this.state}}static deserializeAction(e,t){return new Me(L(e,t.edge),t.state)}}class xe{constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new xe(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:Re(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new xe(De(e,t.sector),T.deserialize(t.state))}}class mt extends at{constructor(t){const s=new Map(t.vertices.map((i,o)=>[i,o])),a=i=>{const o=s.get(i);return d()&&h(o!==void 0),o};super({numNonExitVertices:t.vertices.length,numExitVertices:0,type:"faces",vertexLists:[...t.faces.map(i=>i.vertices.map(a)),t.outerBoundary.map(i=>a(i.start)),...t.innerBoundaries.map(i=>i.map(o=>a(o.start)))]});g(this,"vertexToIndexMap");g(this,"edgeToPatternEdgeMap",new Map);g(this,"patternEdgeToEdgeMap",new Map);g(this,"sectorToPatternSectorMap",new Map);g(this,"patternSectorToSectorMap",new Map);g(this,"outsidePatternFace",null);g(this,"faceToPatternFaceMap",new Map);g(this,"patternFaceToFaceMap",new Map);this.board=t,d()&&h(this.vertices.length===t.vertices.length),d()&&h(this.edges.length===t.edges.length),d()&&h(this.faces.length===t.faces.length+1+t.innerBoundaries.length),this.vertexToIndexMap=s,this.edges.forEach((i,o)=>{d()&&h(i.vertices.length===2);const l=this.getVertex(i.vertices[0]),n=this.getVertex(i.vertices[1]),c=l.getEdgeTo(n);d()&&h(c),this.edgeToPatternEdgeMap.set(c,i),this.patternEdgeToEdgeMap.set(i,c)}),this.sectors.forEach(i=>{d()&&h(i.edges.length===2);const o=this.getEdge(i.edges[0]),l=this.getEdge(i.edges[1]),n=ct(o,l);this.sectorToPatternSectorMap.set(n,i),this.patternSectorToSectorMap.set(i,n)}),this.faces.forEach(i=>{d()&&h(i.sectors.length>=3);const l=this.getSector(i.sectors[0]).face;l===null?this.outsidePatternFace=i:this.faceToPatternFaceMap.set(l,i),this.patternFaceToFaceMap.set(i,l)})}getVertex(t){const s=t.index;return d()&&h(s>=0&&s<this.vertices.length),this.board.vertices[s]}getPatternVertex(t){const s=this.vertexToIndexMap.get(t);return d()&&h(s!==void 0),this.vertices[s]}getEdge(t){const s=this.patternEdgeToEdgeMap.get(t);return d()&&h(s!==void 0),s}getPatternEdge(t){const s=this.edgeToPatternEdgeMap.get(t);return d()&&h(s!==void 0),s}getSector(t){const s=this.patternSectorToSectorMap.get(t);return d()&&h(s!==void 0),s}getPatternSector(t){const s=this.sectorToPatternSectorMap.get(t);return d()&&h(s!==void 0),s}getFace(t){const s=this.patternFaceToFaceMap.get(t);return d()&&h(s!==void 0),s}getPatternFace(t){const s=this.faceToPatternFaceMap.get(t);return d()&&h(s!==void 0),s}getOutsidePatternFace(){return d()&&h(this.outsidePatternFace!==null),this.outsidePatternFace}}class Fe{constructor(e,t,s){this.action=e,this.annotation=t,this.board=s}apply(e){this.action.apply(e)}getUndo(e){return new Fe(this.action.getUndo(e),this.annotation,this.board)}isEmpty(){return this.action.isEmpty()}serializeAction(){let e=null;if(this.annotation.type==="Pattern"){const t=a=>({faceValues:a.faceValues.map(i=>({face:i.face===null?null:s.faces.indexOf(i.face),value:i.value})),blackEdges:a.blackEdges.map(i=>s.edges.indexOf(i)),redEdges:a.redEdges.map(i=>s.edges.indexOf(i)),sectorsNotZero:a.sectorsNotZero.map(i=>s.halfEdges.indexOf(i)),sectorsNotOne:a.sectorsNotOne.map(i=>s.halfEdges.indexOf(i)),sectorsNotTwo:a.sectorsNotTwo.map(i=>s.halfEdges.indexOf(i)),sectorsOnlyOne:a.sectorsOnlyOne.map(i=>s.halfEdges.indexOf(i)),faceColorDuals:a.faceColorDuals.map(i=>({primaryFaces:i.primaryFaces.map(o=>o===null?null:s.faces.indexOf(o)),secondaryFaces:i.secondaryFaces.map(o=>o===null?null:s.faces.indexOf(o))}))}),s=this.annotation.boardPatternBoard.board;e={type:"Pattern",rule:this.annotation.rule.serialize(),embedding:this.annotation.embedding.serialize(),input:t(this.annotation.input),output:t(this.annotation.output),affectedEdges:[...this.annotation.affectedEdges].map(a=>s.edges.indexOf(a)),affectedSectors:[...this.annotation.affectedSectors].map(a=>s.halfEdges.indexOf(a)),affectedFaces:[...this.annotation.affectedFaces].map(a=>s.faces.indexOf(a))}}else this.annotation.type==="ForcedSolveLoop"?e={type:"ForcedSolveLoop",a:this.board.vertices.indexOf(this.annotation.a),b:this.board.vertices.indexOf(this.annotation.b),regionEdges:[...this.annotation.regionEdges].map(t=>this.board.edges.indexOf(t)),pathEdges:[...this.annotation.pathEdges].map(t=>this.board.edges.indexOf(t))}:this.annotation.type;if(e!==null)return{type:"AnnotatedAction",action:this.action.serializeAction(),annotation:e};throw new Error("unimplemented")}static deserializeAction(e,t){d()&&h(t.type==="AnnotatedAction");const s=t.annotation.type,a=W(e,t.action);let i=null;if(s==="Pattern"){const o=p=>({faceValues:p.faceValues.map(S=>({face:S.face===null?null:e.faces[S.face],value:S.value})),blackEdges:p.blackEdges.map(S=>e.edges[S]),redEdges:p.redEdges.map(S=>e.edges[S]),sectorsNotZero:p.sectorsNotZero.map(S=>e.halfEdges[S]),sectorsNotOne:p.sectorsNotOne.map(S=>e.halfEdges[S]),sectorsNotTwo:p.sectorsNotTwo.map(S=>e.halfEdges[S]),sectorsOnlyOne:p.sectorsOnlyOne.map(S=>e.halfEdges[S]),faceColorDuals:p.faceColorDuals.map(S=>({primaryFaces:S.primaryFaces.map(x=>x===null?null:e.faces[x]),secondaryFaces:S.secondaryFaces.map(x=>x===null?null:e.faces[x])}))}),l=nt.deserialize(t.annotation.rule),n=new mt(e),c=it.deserialize(l.patternBoard,n,t.annotation.embedding),u=o(t.annotation.input),m=o(t.annotation.output),M=new Set(t.annotation.affectedEdges.map(p=>e.edges[p])),F=new Set(t.annotation.affectedSectors.map(p=>e.halfEdges[p])),f=new Set(t.annotation.affectedFaces.map(p=>e.faces[p]));i={type:"Pattern",rule:l,boardPatternBoard:n,embedding:c,input:u,output:m,affectedEdges:M,affectedSectors:F,affectedFaces:f}}else s==="ForcedSolveLoop"?i={type:"ForcedSolveLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(o=>e.edges[o]),pathEdges:t.annotation.pathEdges.map(o=>e.edges[o])}:s==="PrematureForcedLoop"&&(i={type:"PrematureForcedLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(o=>e.edges[o]),pathEdges:t.annotation.pathEdges.map(o=>e.edges[o])});if(i!==null)return new Fe(a,i,e);throw new Error("unimplemented deserializeAction on AnnotatedAction")}}class ve{constructor(e){this.actions=e}apply(e){for(let t=0;t<this.actions.length;t++)this.actions[t].apply(e)}getUndo(e){return new ve(this.actions.map(t=>t.getUndo(e)).reverse())}isEmpty(){return this.actions.some(e=>!e.isEmpty())}serializeAction(){return{type:"CompositeAction",actions:this.actions.map(e=>e.serializeAction())}}static deserializeAction(e,t){return new ve(t.actions.map(s=>W(e,s)))}}const W=(r,e)=>{const t=e.type;if(t==="CompositeAction")return ve.deserializeAction(r,e);if(t==="AnnotatedAction")return Fe.deserializeAction(r,e);if(t==="CompleteAction")return te.deserializeAction(r,e);if(t==="EdgeStateCycleAction")return Se.deserializeAction(r,e);if(t==="EdgeStateSetAction")return we.deserializeAction(r,e);if(t==="GeneralEdgeAction")return Q.deserializeAction(r,e);if(t==="FaceValueSetAction")return Me.deserializeAction(r,e);if(t==="GeneralFaceAction")return J.deserializeAction(r,e);if(t==="GeneralSimpleRegionAction")return ee.deserializeAction(r,e);if(t==="NoOpAction")return se.deserializeAction(r,e);if(t==="UserLoadPuzzleAutoSolveAction")return Ze.deserializeAction(r,e);if(t==="UserRequestSolveAction")return Ye.deserializeAction(r,e);if(t==="FaceColorMakeOppositeAction")return Ke.deserializeAction(r,e);if(t==="FaceColorMakeSameAction")return U.deserializeAction(r,e);if(t==="FaceColorSetAbsoluteAction")return $e.deserializeAction(r,e);if(t==="SectorStateSetAction")return xe.deserializeAction(r,e);throw new Error(`Unknown action type: ${t}, could not deserialize`)};class te{constructor(e,t,s,a,i,o,l){this.faceValueAction=e,this.edgeStateAction=t,this.simpleRegionAction=s,this.faceColorAction=a,this.sectorStateAction=i,this.vertexStateAction=o,this.faceStateAction=l}apply(e){this.faceValueAction.apply(e),this.edgeStateAction.apply(e),this.simpleRegionAction.apply(e),this.faceColorAction.apply(e),this.sectorStateAction.apply(e),this.vertexStateAction.apply(e),this.faceStateAction.apply(e)}getUndo(e){return new te(this.faceValueAction.getUndo(e),this.edgeStateAction.getUndo(e),this.simpleRegionAction.getUndo(e),this.faceColorAction.getUndo(e),this.sectorStateAction.getUndo(e),this.vertexStateAction.getUndo(e),this.faceStateAction.getUndo(e))}isEmpty(){return this.faceValueAction.isEmpty()&&this.edgeStateAction.isEmpty()&&this.simpleRegionAction.isEmpty()&&this.faceColorAction.isEmpty()&&this.sectorStateAction.isEmpty()&&this.vertexStateAction.isEmpty()&&this.faceStateAction.isEmpty()}serializeAction(){return{type:"CompleteAction",faceValueAction:this.faceValueAction.serializeAction(),edgeStateAction:this.edgeStateAction.serializeAction(),simpleRegionAction:this.simpleRegionAction.serializeAction(),faceColorAction:this.faceColorAction.serializeAction(),sectorStateAction:this.sectorStateAction.serializeAction(),vertexStateAction:this.vertexStateAction.serializeAction(),faceStateAction:this.faceStateAction.serializeAction()}}static deserializeAction(e,t){return new te(W(e,t.faceStateAction),W(e,t.edgeStateAction),W(e,t.simpleRegionAction),W(e,t.faceColorAction),W(e,t.sectorStateAction),W(e,t.vertexStateAction),W(e,t.faceStateAction))}}const et=(r,e)=>({type:"CompleteData",faceValueData:Pe(r,e),edgeStateData:be(r,e),simpleRegionData:He(e),faceColorData:ke(e),sectorStateData:Be(r,e),vertexStateData:qe(r,e),faceStateData:Ue(r,e)});class Ae extends te{constructor(t,s,a,i,o,l,n){super(t,s,a,i,o,l,n);g(this,"anyStateChangedEmitter",new A);this.faceValueDelta=t,this.edgeStateDelta=s,this.simpleRegionDelta=a,this.faceColorDelta=i,this.sectorStateDelta=o,this.vertexStateDelta=l,this.faceStateDelta=n;const c=()=>this.anyStateChangedEmitter.emit();t.faceValueChangedEmitter.addListener(c),s.edgeStateChangedEmitter.addListener(c),a.simpleRegionsChangedEmitter.addListener(c),i.faceColorsChangedEmitter.addListener(c),o.sectorStateChangedEmitter.addListener(c),l.vertexStateChangedEmitter.addListener(c),n.faceStateChangedEmitter.addListener(c)}getFaceValue(t){return this.faceValueDelta.getFaceValue(t)}setFaceValue(t,s){this.faceValueDelta.setFaceValue(t,s)}get faceValueChangedEmitter(){return this.faceValueDelta.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateDelta.getEdgeState(t)}setEdgeState(t,s){this.edgeStateDelta.setEdgeState(t,s)}get edgeStateChangedEmitter(){return this.edgeStateDelta.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDelta.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDelta.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDelta.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDelta.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDelta.getWeirdEdges()}modifyRegions(t,s,a,i){this.simpleRegionDelta.modifyRegions(t,s,a,i)}get simpleRegionsChangedEmitter(){return this.simpleRegionDelta.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorDelta.getFaceColors()}getInsideColor(){return this.faceColorDelta.getInsideColor()}getOutsideColor(){return this.faceColorDelta.getOutsideColor()}getFaceColor(t){return this.faceColorDelta.getFaceColor(t)}getFacesWithColor(t){return this.faceColorDelta.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorDelta.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorDelta.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorDelta.hasInvalidFaceColors()}modifyFaceColors(t,s,a,i,o){this.faceColorDelta.modifyFaceColors(t,s,a,i,o)}get faceColorsChangedEmitter(){return this.faceColorDelta.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateDelta.getSectorState(t)}setSectorState(t,s){this.sectorStateDelta.setSectorState(t,s)}get sectorStateChangedEmitter(){return this.sectorStateDelta.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateDelta.getVertexState(t)}setVertexState(t,s){this.vertexStateDelta.setVertexState(t,s)}get vertexStateChangedEmitter(){return this.vertexStateDelta.vertexStateChangedEmitter}getFaceState(t){return this.faceStateDelta.getFaceState(t)}setFaceState(t,s){this.faceStateDelta.setFaceState(t,s)}get faceStateChangedEmitter(){return this.faceStateDelta.faceStateChangedEmitter}clone(){return new Ae(this.faceValueDelta.clone(),this.edgeStateDelta.clone(),this.simpleRegionDelta.clone(),this.faceColorDelta.clone(),this.sectorStateDelta.clone(),this.vertexStateDelta.clone(),this.faceStateDelta.clone())}createDelta(){return new Ae(this.faceValueDelta.createDelta(),this.edgeStateDelta.createDelta(),this.simpleRegionDelta.createDelta(),this.faceColorDelta.createDelta(),this.sectorStateDelta.createDelta(),this.vertexStateDelta.createDelta(),this.faceStateDelta.createDelta())}serializeState(t){return et(t,this)}}class D{constructor(e,t,s,a,i,o,l){g(this,"anyStateChangedEmitter",new A);this.faceValueData=e,this.edgeStateData=t,this.simpleRegionData=s,this.faceColorData=a,this.sectorStateData=i,this.vertexStateData=o,this.faceStateData=l;const n=()=>this.anyStateChangedEmitter.emit();e.faceValueChangedEmitter.addListener(n),t.edgeStateChangedEmitter.addListener(n),s.simpleRegionsChangedEmitter.addListener(n),a.faceColorsChangedEmitter.addListener(n),i.sectorStateChangedEmitter.addListener(n),o.vertexStateChangedEmitter.addListener(n),l.faceStateChangedEmitter.addListener(n)}static fromFacesEdges(e,t,s){const a=new G(e,t);return new D(a,new X(e,s),new Y(e),new H(e),new Z(e),new K(e),new q(e,i=>C.any(i,a.getFaceValue(i))))}static fromFaces(e,t){return D.fromFacesEdges(e,t,()=>y.WHITE)}static fromFaceValueData(e,t){return D.fromFaces(e,s=>t.getFaceValue(s))}static empty(e){return D.fromFaces(e,()=>null)}static faceMapLookup(e){const t=new Map(Array.from(e.entries()).map(([s,a])=>[`${s.x},${s.y}`,a]));return s=>{const a=t.get(`${s.logicalCoordinates.x},${s.logicalCoordinates.y}`);return a!==void 0?a:null}}getFaceValue(e){return this.faceValueData.getFaceValue(e)}setFaceValue(e,t){this.faceValueData.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueData.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateData.getEdgeState(e)}setEdgeState(e,t){this.edgeStateData.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateData.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionData.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionData.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionData.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionData.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionData.getWeirdEdges()}modifyRegions(e,t,s,a){this.simpleRegionData.modifyRegions(e,t,s,a)}get simpleRegionsChangedEmitter(){return this.simpleRegionData.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorData.getFaceColors()}getInsideColor(){return this.faceColorData.getInsideColor()}getOutsideColor(){return this.faceColorData.getOutsideColor()}getFaceColor(e){return this.faceColorData.getFaceColor(e)}getFacesWithColor(e){return this.faceColorData.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorData.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorData.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorData.hasInvalidFaceColors()}modifyFaceColors(e,t,s,a,i){this.faceColorData.modifyFaceColors(e,t,s,a,i)}get faceColorsChangedEmitter(){return this.faceColorData.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateData.getSectorState(e)}setSectorState(e,t){this.sectorStateData.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateData.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateData.getVertexState(e)}setVertexState(e,t){this.vertexStateData.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateData.vertexStateChangedEmitter}getFaceState(e){return this.faceStateData.getFaceState(e)}setFaceState(e,t){this.faceStateData.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateData.faceStateChangedEmitter}clone(){return new D(this.faceValueData.clone(),this.edgeStateData.clone(),this.simpleRegionData.clone(),this.faceColorData.clone(),this.sectorStateData.clone(),this.vertexStateData.clone(),this.faceStateData.clone())}createDelta(){return new Ae(this.faceValueData.createDelta(),this.edgeStateData.createDelta(),this.simpleRegionData.createDelta(),this.faceColorData.createDelta(),this.sectorStateData.createDelta(),this.vertexStateData.createDelta(),this.faceStateData.createDelta())}serializeState(e){return et(e,this)}static deserializeState(e,t){const s=G.deserializeState(e,t.faceValueData);return new D(s,X.deserializeState(e,t.edgeStateData),t.simpleRegionData?Y.deserializeState(e,t.simpleRegionData):new Y(e),t.faceColorData?H.deserializeState(e,t.faceColorData):new H(e),t.sectorStateData?Z.deserializeState(e,t.sectorStateData):new Z(e),t.vertexStateData?K.deserializeState(e,t.vertexStateData):new K(e),t.faceStateData?q.deserializeState(e,t.faceStateData):new q(e,a=>C.any(a,s.getFaceValue(a))))}}class N{constructor(e,t){g(this,"stateProperty");this.board=e,this.stateProperty=new ot(t)}static fromSolvedPuzzle(e){return new N(e.board,e.cleanState)}static loadDefaultPuzzle(){return N.loadFromSimpleString("10x18 .3.1....1..032....0......3.1....02.3...02....3.1...........2011.01..01.......3...2302..........1102...3.......22..03.0322...........3.2....13...2.30....2.2......1....103..2....1.3.")}static loadFromSimpleString(e){const[t,s]=e.split(" "),[a,i]=t.split("x").map(n=>parseInt(n)),o=new je(a,i),l=D.fromFaces(o,n=>{const c=n.logicalCoordinates.y*a+n.logicalCoordinates.x,u=s[c];return u==="."?null:parseInt(u)});return new N(o,l)}static loadDeprecatedScalaString(e){if(!e.includes("!"))return N.loadFromSimpleString(e);const t=1,s=2,a=4,i=8,[o,l]=e.split(" "),[n,c]=o.split("x").map(f=>parseInt(f)),u=new je(n,c),m=f=>3*(f.logicalCoordinates.y*n+f.logicalCoordinates.x)+1,M=(f,p)=>{const S=m(f),x=parseInt(l[S+1]),v=parseInt(l[S+2]);return x&p?y.BLACK:v&p?y.RED:y.WHITE},F=D.fromFacesEdges(u,f=>{const p=l[m(f)];return p==="."?null:parseInt(p)},f=>{if((f.start.logicalCoordinates.x===f.end.logicalCoordinates.x?Oe.VERTICAL:Oe.HORIZONTAL)===Oe.HORIZONTAL){const S=f.start.logicalCoordinates.x<f.end.logicalCoordinates.x?f.forwardFace:f.reversedFace,x=f.start.logicalCoordinates.x<f.end.logicalCoordinates.x?f.reversedFace:f.forwardFace;return S?M(S,s):M(x,i)}else{const S=f.start.logicalCoordinates.y<f.end.logicalCoordinates.y?f.reversedFace:f.forwardFace,x=f.start.logicalCoordinates.y<f.end.logicalCoordinates.y?f.forwardFace:f.reversedFace;return S?M(S,t):M(x,a)}});return new N(u,F)}static loadPointyTopHexagonalString(e){d()&&h(e.startsWith("h")||e.startsWith("H"));const[t,s]=e.slice(1).split(" "),a=parseInt(t),i=new Qe(a,Math.sqrt(3)/2,e.startsWith("h")),o=Qe.enumeratePointyFaceCoordinates(a),l=new Map;for(let c=0;c<s.length;c++){const u=s[c];if(u===".")continue;const m=o[c];l.set(m,parseInt(u))}const n=D.fromFaces(i,D.faceMapLookup(l));return new N(i,n)}}export{Fe as A,N as B,D as C,_ as D,y as E,z as F,G,ee as H,ct as I,T as S,Ze as U,E as V,X as a,Y as b,mt as c,C as d,B as e,P as f,ie as g,Ve as h,b as i,L as j,Re as k,De as l,U as m,Ke as n,we as o,ve as p,$e as q,xe as r,xt as s,Ye as t,W as u,_e as v,Ie as w,ft as x,ut as y,lt as z};
