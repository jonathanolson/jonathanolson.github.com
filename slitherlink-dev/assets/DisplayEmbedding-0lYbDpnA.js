var bo=Object.defineProperty;var Do=(h,e,t)=>e in h?bo(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var f=(h,e,t)=>Do(h,typeof e!="symbol"?e+"":e,t);import{K as xt,u as xo,c as fe,V as kt,L as B,W as ko,X as No,Y as Io,Z as Ro,f as Bo,g as Mo,h as Mt,J as Wo,s as Wt,i as Ho,j as zo,v as Ht,k as Uo,m as zt,w as Ko,n as we,o as jo,q as Yo,x as Go,y as Xo,I as Se,G as qo,E as Jo,A as _o,C as Zo,M as $o,_ as Qo,T as es,r as ts}from"./Theme-8u5h1Tq8.js";import{E as me,a as ve,d as os,V as oe,k as st,o as Xe,b as ye,T as u,P as Ke,l as ss,c as lo,C as rs,B as Pt}from"./Vector2Property-CFyCN_2h.js";import{a as j,N as H,S as U,F as Me,t as Ut,P as $,M as Ee,u as Kt,T as co,G as is,C as ho,h as K,B as Ie,g as as,j as jt,v as ns,R as ls,H as uo,L as cs}from"./PhetioControlledVisibilityProperty-thEXBwUY.js";import{a as ds,P as po}from"./TextPushButton-ps8wVt8M.js";import{d as b,e as D,_ as ne,a4 as go,P as hs,S as us,H as ps,a5 as gs,h as Yt,k as fs,n as ws,l as Ss,i as ys}from"./patternBoards-DzVBPT7g.js";import{E as m,g as k,i as x,V as dt,j as fo,k as Tt,l as Ot,m as At,n as bt,o as rt,p as it,q as Cs,r as Es,h as wo,A as X,C as Q,a as J,b as ze,F as We,S as ht,t as ms,u as vs,U as Ft,v as Gt,s as Ps,w as Xt,x as Fs,B as qt,d as Vs}from"./BasicPuzzle-DTNX_hiE.js";import{I as W,a as q,V as Ls,C as Pe,h as So,j as Nt,i as at,S as yo,b as Co,c as Eo,k as mo,l as vo,w as Jt,s as Ts}from"./SATSolver-Bo8XdtXN.js";import{A as Os}from"./SpinningIndicatorNode-wGbDYIGh.js";import{a as As,B as bs,R as Ds,b as xs,c as ks,d as Ns,S as Is,e as Rs}from"./PatternRule-B98-ERhf.js";const Te=class Te extends me{};f(Te,"PAN_ONLY",new Te),f(Te,"DRAG_ONLY",new Te),f(Te,"enumeration",new ve(Te));let je=Te;const Po=new xt("panDragModeProperty",je.PAN_ONLY),Fo=new j([Po],h=>h===je.DRAG_ONLY);class It extends H{constructor(t,o,s,r){super();f(this,"triggerDrag");const l=new Set;if(r!=null&&r.delayInteractionEmitter){const p=r==null?void 0:r.delayInteractionEmitter,g=S=>{l.add(S),setTimeout(()=>{l.delete(S)},700)};p.addListener(g),this.disposeEmitter.addListener(()=>p.removeListener(g))}const c=new U,a=t.map(p=>{const g=o(p);return g.makeImmutable(),c.subpaths.push(...g.subpaths),g});this.mouseArea=this.touchArea=c.makeImmutable();const i=p=>{const g=p.trail.globalToLocalPoint(p.pointer.point);for(let S=0;S<a.length;S++){const C=a[S];if(C.bounds.containsPoint(g)&&C.containsPoint(g)){const E=t[S];if(!l.has(E))return E}}return!1},n=(p,g)=>{const S=i(p);S!==!1&&s(S,g)};this.cursor="pointer";const d=new Me({mouseButton:0,fire:p=>{var g;return n(p,(g=p.domEvent)!=null&&g.shiftKey?2:0)}}),y=new Me({mouseButton:2,fire:p=>{var g;return n(p,(g=p.domEvent)!=null&&g.shiftKey?0:2)}}),w=new Me({mouseButton:1,fire:p=>n(p,1)});if(this.disposeEmitter.addListener(()=>{d.dispose(),y.dispose(),w.dispose()}),r!=null&&r.isDragModeProperty){const p=r.isDragModeProperty,g=(P,F)=>{var T,A;const O=i(P);O!==!1?(T=r.onDragStart)==null||T.call(r,O,F):r.noItemItem!==void 0&&((A=r.onDragStart)==null||A.call(r,r.noItemItem,F))},S=P=>{var T,A;const F=P.trail.globalToLocalPoint(P.pointer.point),O=i(P);O!==!1?(T=r.onDrag)==null||T.call(r,O,F):r.noItemItem!==void 0&&((A=r.onDrag)==null||A.call(r,r.noItemItem,F))},C=()=>{var P;(P=r.onDragEnd)==null||P.call(r)},E=P=>P?i(P)!==!1||r.noItemItem!==void 0:!1,v=new Ut({mouseButton:0,start:P=>{var F;return g(P,(F=P.domEvent)!=null&&F.shiftKey?2:0)},drag:S,end:C,canStartPress:E}),L=new Ut({mouseButton:2,start:P=>{var F;return g(P,(F=P.domEvent)!=null&&F.shiftKey?0:2)},drag:S,end:C,canStartPress:E});this.triggerDrag=P=>{P.domEvent.button===2?L.press(P,this):v.press(P,this)},this.disposeEmitter.addListener(()=>{v.dispose(),L.dispose()});const N=P=>{this.inputListeners=P?[v,L]:[d,y,w]};p.link(N),this.disposeEmitter.addListener(()=>p.unlink(N))}else this.addInputListener(d),this.addInputListener(y),this.addInputListener(w)}}class Bs extends It{constructor(e,t,o){super(e.edges,s=>{const r=s.start.viewCoordinates,l=s.end.viewCoordinates,c=new U;let a;if(s.faces.length===2)a=[r,s.faces[0].viewCoordinates,l,s.faces[1].viewCoordinates];else{b()&&D(s.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const i=s.forwardHalf.face===null?s.forwardHalf:s.reversedHalf;b()&&D(i.previous.face===null),b()&&D(i.next.face===null);const n=i.start.viewCoordinates,d=i.end.viewCoordinates,y=i.previous.start.viewCoordinates,w=i.next.end.viewCoordinates,p=(C,E,v)=>{const L=E.minus(C).normalized(),N=v.minus(E).normalized();let P=L.minus(N);return P.getMagnitude()<1e-6?P=L.getPerpendicular():P=P.normalized(),os.triangleAreaSigned(C,E,E.plus(P))<0&&(P=P.negated()),P},g=p(y,n,d),S=p(n,d,w);a=[n,s.faces[0].viewCoordinates,d,d.plus(S.times(o.backgroundOffsetDistance)),n.plus(g.times(o.backgroundOffsetDistance))]}return c.polygon(a),c.makeImmutable(),c},o.edgePressListener,{delayInteractionEmitter:t,isDragModeProperty:Fo,onDragStart:o.onEdgeDragStart,onDrag:o.onEdgeDrag,onDragEnd:o.onEdgeDragEnd})}}class Ms extends H{constructor(e,t,o,s){const r=new $(null,{lineWidth:.02,stroke:s.theme.whiteLineColorProperty}),l=new $(null,{stroke:s.theme.xColorProperty,lineWidth:.025}),c=new $(null,{lineWidth:.02,fill:s.theme.redLineColorProperty});super({children:[r,l,c],pickable:!1});const a=e.edges.map(g=>m.BLACK);let i=!1,n=!1,d=!1,y=!1,w=null;const p=Ee.multilink([t,o,s.whiteLineVisibleProperty,s.redXsVisibleProperty,s.redXsAlignedProperty,s.redLineVisibleProperty,s.redLineStyleProperty],(g,S,C,E,v,L,N)=>{if(this.visible=!S,r.visible=C,l.visible=E,c.visible=L,this.visible){let P=!1;for(let F=0;F<e.edges.length;F++){const O=g.getEdgeState(e.edges[F]);O!==a[F]&&(P=!0,a[F]=O)}if(i!==v&&(P=!0,i=v),n!==C&&(P=!0,n=C),d!==E&&(P=!0,d=E),y!==L&&(P=!0,y=L),w!==N&&(P=!0,w=N),P){const F=new U,O=new U,T=new U;for(let A=0;A<e.edges.length;A++){const M=a[A];if(C&&M===m.WHITE){const V=e.edges[A];F.moveTo(V.start.viewCoordinates.x,V.start.viewCoordinates.y),F.lineTo(V.end.viewCoordinates.x,V.end.viewCoordinates.y)}if(M===m.RED){if(E){const V=e.edges[A],I=.07;let R=V.start.viewCoordinates.blend(V.end.viewCoordinates,.5);if(v){const G=V.end.viewCoordinates.minus(V.start.viewCoordinates).getAngle(),ee=new oe(-I,-I).rotate(G).add(R),ae=new oe(I,I).rotate(G).add(R),he=new oe(-I,I).rotate(G).add(R),Ae=new oe(I,-I).rotate(G).add(R);O.moveTo(ee.x,ee.y),O.lineTo(ae.x,ae.y),O.moveTo(he.x,he.y),O.lineTo(Ae.x,Ae.y)}else O.moveTo(R.x-I,R.y-I),O.lineTo(R.x+I,R.y+I),O.moveTo(R.x-I,R.y+I),O.lineTo(R.x+I,R.y-I)}if(L){const V=e.edges[A],I=.4,R=.017,G=V.start.viewCoordinates.blend(V.end.viewCoordinates,.5),ee=G.blend(V.start.viewCoordinates,I),ae=G.blend(V.end.viewCoordinates,I);for(let he=0;he<5;he++){const Ae=ee.blend(ae,he/4);T.moveTo(Ae.x+R,Ae.y),T.arc(Ae.x,Ae.y,R,0,2*Math.PI,!1)}}}}F.makeImmutable(),O.makeImmutable(),T.makeImmutable(),r.shape=F,l.shape=O,c.shape=T}}});this.disposeEmitter.addListener(()=>p.dispose())}}class Ws extends H{constructor(t,o,s){const r=new H;super({pickable:!1,children:[r]});f(this,"faceColorNodeMap",new Map);f(this,"faceColorIdMap",new Map);f(this,"adjacentFacesMap",new Map);f(this,"faceColorNodeContainer");f(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.style=s,this.faceColorNodeContainer=r,t.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(n=>n.getOtherFace(i)).filter(n=>n!==null))});{const i=o.value.getFaceColors();for(const n of i)this.addFaceColor(n,o.value.getFacesWithColor(n));this.addDualColorViews(o.value,i)}this.updateHues();let l=o.value.clone();const c=i=>{const n=l;l=i.clone();const d=n.getFaceColors(),y=i.getFaceColors(),w=[],p=[],g=[];go(d,y,w,p,g);const S=new Set(w),C=this.removeInvalidDualColorViews(i),E=[...C];for(const v of p)if(C.add(v),this.faceColorIdMap.has(v.id)){const L=this.faceColorIdMap.get(v.id);this.replaceFaceColor(L,v,i.getFacesWithColor(v)),S.delete(L)}else this.addFaceColor(v,i.getFacesWithColor(v));for(const v of g)this.updateFaceColor(v,i.getFacesWithColor(v));for(const v of S)C.delete(v),this.removeFaceColor(v);this.addDualColorViews(i,[...C]),(p.length||w.length||E.length)&&this.updateHues()};o.lazyLink(c),this.disposeEmitter.addListener(()=>o.unlink(c)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const a=()=>this.updateHues();s.theme.faceColorBasicHueLUTProperty.lazyLink(a),s.theme.faceColorLightHueLUTProperty.lazyLink(a),s.theme.faceColorDarkHueLUTProperty.lazyLink(a),s.theme.faceColorInsideColorProperty.lazyLink(a),s.theme.faceColorOutsideColorProperty.lazyLink(a),s.theme.faceColorDefaultColorProperty.lazyLink(a),s.faceColorThresholdProperty.lazyLink(a),this.updateHues(),this.disposeEmitter.addListener(()=>{s.theme.faceColorBasicHueLUTProperty.unlink(a),s.theme.faceColorLightHueLUTProperty.unlink(a),s.theme.faceColorDarkHueLUTProperty.unlink(a),s.theme.faceColorInsideColorProperty.unlink(a),s.theme.faceColorOutsideColorProperty.unlink(a),s.theme.faceColorDefaultColorProperty.unlink(a),s.faceColorThresholdProperty.unlink(a)})}addFaceColor(t,o){const s=new Ue(t,o,this.style);this.faceColorNodeMap.set(t,s),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(s)}replaceFaceColor(t,o,s){b()&&D(t.id===o.id);const r=this.faceColorNodeMap.get(t);r.updateFaceColor(o,s),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,r),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const s=this.faceColorNodeMap.get(t);let r=s.faces.length!==o.length;if(!r)for(let l=0;l<o.length;l++){const c=s.faces[l],a=o[l];if(c!==a){r=!0;break}}r&&s.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const s=new Set(o);for(;s.size;){const r=s.values().next().value;s.delete(r);const l=this.faceColorNodeMap.get(r);b()&&D(l);const c=t.getOppositeFaceColor(r);if(c){b()&&D(s.has(c)),s.delete(c);const a=this.faceColorNodeMap.get(c);b()&&D(a),this.dualColorViews.add(new _t([l,a],this.style))}else this.dualColorViews.add(new _t([l],this.style))}}removeInvalidDualColorViews(t){const o=new Set,s=new Set(t.getFaceColors());for(const r of[...this.dualColorViews])if(!r.isStillValidInState(this.stateProperty.value,s)){for(const l of r.colorNodes)o.add(l.faceColor);this.dualColorViews.delete(r),r.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==k.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new oe(0,0),s=()=>{for(const n of t)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(st.nextDouble()-.5,st.nextDouble()-.5).normalize()},r=new Map,l=[];this.board.faces.forEach(n=>{r.set(n,[])});for(const n of t){const d=new Set;for(const w of n.faces)d.add(w);const y=new Set;for(const w of d){y.add(w);for(const p of this.adjacentFacesMap.get(w))y.add(p)}for(const w of y){const p=r.get(w);if(p){if(p.length)for(const g of p){let S=!1;for(const C of l)if(C.a===g&&C.b===n){C.weight++,S=!0;break}S||l.push({a:g,b:n,weight:1})}p.push(n)}}}const c=new Map;for(const n of t)c.set(n,oe.ZERO.copy());const a=(n,d,y)=>{const w=c.get(n),p=c.get(d),g=n.hueVector.dot(d.hueVector),S=o.set(d.hueVector).subtract(n.hueVector);S.magnitudeSquared>1e-11&&S.normalize();const C=.2,E=Math.abs(g),v=y*((Math.max(C,E)-C)/(1-C))**3;S.multiplyScalar(v),w.subtract(S),p.add(S)};let i=1;for(let n=0;n<100;n++){i*=.99;for(const d of t)c.get(d).setXY(0,0);for(const d of l){const y=d.a,w=d.b,p=d.weight;a(y,w,p)}if(t.length<8)for(let d=0;d<t.length;d++){const y=t[d];for(let w=d+1;w<t.length;w++)a(y,t[w],.2)}for(const d of t){const y=c.get(d);y.multiplyScalar(i/d.faceCount),d.hueVector.add(y),c.get(d).setXY(0,0)}s()}}for(const o of this.dualColorViews)o.updateHue()}getDualColorViews(){return this.dualColorViews}}const pe=class pe extends me{};f(pe,"BASIC",new pe),f(pe,"PRIMARY",new pe),f(pe,"SECONDARY",new pe),f(pe,"enumeration",new ve(pe));let ce=pe;class _t{constructor(e,t){f(this,"hueVector");f(this,"faceCount");f(this,"hueVectorOverride",null);if(this.colorNodes=e,this.style=t,b()&&D(e.length===1||e.length===2),this.faceCount=ne.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=ce.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],s=o===e[0]?e[1]:e[0];let r;o.type===ce.PRIMARY?r=o:s.type===ce.PRIMARY||o.type===ce.SECONDARY?r=s:(s.type,ce.SECONDARY,r=o);const l=r===o?s:o;this.hueVector=o.hueVector.copy(),r.type=ce.PRIMARY,l.type=ce.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVectorOverride??this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}overrideHueVector(e){this.hueVectorOverride=e,this.updateHue()}isUndecided(){return this.colorNodes.every(e=>e.faceColor.colorState===k.UNDECIDED)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class Ue extends ${constructor(t,o,s){const r=oe.createPolar(1,st.nextDoubleBetween(0,2*Math.PI));super(Ue.toShape(o));f(this,"hueVector");f(this,"faceCount");f(this,"dualColorView",null);f(this,"type",ce.BASIC);this.faceColor=t,this.faces=o,this.style=s,this.hueVector=r,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==k.UNDECIDED?this.fill=Ue.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:oe.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const s=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=Ue.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=s)}static hueVectorToPaint(t,o,s,r){const l=s===ce.BASIC?r.theme.faceColorBasicHueLUTProperty.value:s===ce.PRIMARY?r.theme.faceColorLightHueLUTProperty.value:r.theme.faceColorDarkHueLUTProperty.value,c=(Math.round(t.getAngle()*180/Math.PI)+360)%360;b()&&D(c>=0&&c<l.length);const a=l[c];if(o===k.UNDECIDED)return a;{const n=(o===k.INSIDE?r.theme.faceColorInsideColorProperty:r.theme.faceColorOutsideColorProperty).value,d=n.alpha,y=new Kt(a);return new Kt((1-d)*y.red+d*n.red,(1-d)*y.green+d*n.green,(1-d)*y.blue+d*n.blue).toCSS()}}static toShape(t){const o=new U;for(const s of t)o.polygon(s.vertices.map(r=>r.viewCoordinates));return o.makeImmutable()}}class Hs extends co{constructor(e,t){const o=Xe()({font:xo,fill:fe.uiForegroundColorProperty},t);super(e,o)}}class zs extends H{constructor(e,t,o){super({translation:e.viewCoordinates}),this.face=e;const r=t.value.getFaceState(e),l=r.possibilityCount===0||r.possibilityCount>9;let c;const a=r.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(l)c=new Hs(r.possibilityCount,{font:kt,maxWidth:.4,maxHeight:.4});else{const i=new Set(e.vertices);c=new is({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(r.possibilityCount)),children:r.getAllowedCombinations().map(n=>{const d=new H,y=new Set(n.map(g=>g.start)),w=new Set(n.map(g=>g.end)),p=g=>g.minus(e.viewCoordinates);if(d.addChild(new $(U.polygon(e.vertices.map(g=>p(g.viewCoordinates))),{stroke:a,lineWidth:.03,opacity:.2})),y.size){const g=new U;if(n.length===e.edges.length)g.polygon(e.vertices.map(S=>p(S.viewCoordinates)));else{const S=new Set(n);for(;S.size;){const C=[...i].find(L=>[...S].filter(N=>N.start===L||N.end===L).length===1);b()&&D(C);let E=C,v=[...S].find(L=>L.start===E||L.end===E)??null;for(g.moveToPoint(p(E.viewCoordinates));v;)S.delete(v),E=v.getOtherVertex(E),g.lineToPoint(p(E.viewCoordinates)),v=[...S].find(L=>L.start===E||L.end===E)??null}}d.addChild(new $(g,{stroke:a,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of e.vertices)!y.has(g)&&!w.has(g)&&d.addChild(new ho(.1,{fill:a,translation:p(g.viewCoordinates)}));return d}),maxWidth:.6,maxHeight:.6})}c.center=oe.ZERO,this.addChild(c)}}class Us extends H{constructor(e,t,o,s){super({pickable:!1});const r=Ee.multilink([t,s.faceStateVisibleProperty],(c,a)=>{this.children.forEach(i=>i.dispose()),this.children=[],a&&e.faces.forEach(i=>{this.addChild(new zs(i,t,s))})});this.disposeEmitter.addListener(()=>r.dispose());const l=c=>{this.visible=!c};o.link(l),this.disposeEmitter.addListener(()=>{o.unlink(l),this.children.forEach(c=>c.dispose())})}}class Ks extends It{constructor(e,t){super(e.faces,o=>o?U.polygon(o.vertices.map(s=>s.viewCoordinates)):new U,t.facePressListener,{isDragModeProperty:Fo,onDragStart:t.onFaceDragStart,onDrag:t.onFaceDrag,onDragEnd:t.onFaceDragEnd,noItemItem:null})}}const Be=class Be{constructor(e,t){this.incorrectEdges=e,this.incorrectFaces=t}isCorrect(){return this.incorrectEdges.size===0&&this.incorrectFaces.size===0}with(e){return this.isCorrect()?e:e.isCorrect()?this:new Be(new Set([...this.incorrectEdges,...e.incorrectEdges]),new Set([...this.incorrectFaces,...e.incorrectFaces]))}static with(e){return e.reduce((t,o)=>t.with(o),Be.CORRECT)}};f(Be,"CORRECT",new Be(new Set,new Set));let He=Be;class Zt{constructor(e,t,o){f(this,"edgeStateChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(b()&&D(this.board.edges.includes(e)),t!==m.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new W(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const s=new Set;for(const r of e.edges){const l=t.getEdgeState(r);l!==m.WHITE&&l!==o.getEdgeState(r)&&s.add(r)}return new He(s,new Set)}}class $t{constructor(e,t,o){f(this,"faceColorsChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,s,r){if(r)throw new W("invalid face color?");const l=new Set([...o.values(),...s.keys(),...o.values()]),c=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())c.set(n,o.get(n));const a=n=>s.has(n)?s.get(n):[...e].includes(n)?this.currentState.getOppositeFaceColor(n):null,i=new Map;for(const n of c.keys()){const d=c.get(n);i.has(d)||i.set(d,new Set([n])),i.get(d).add(n)}for(const n of l){const d=i.get(n);if(!d)continue;const y=[...d];b()&&D(y.length>0);const w=this.solvedState.getFaceColor(y[0]);for(const g of y)if(this.solvedState.getFaceColor(g)!==w)throw new W("invalid face color");const p=a(n);if(p){let g;if(p.colorState===k.INSIDE?g=this.solvedState.getInsideColor():p.colorState===k.OUTSIDE?g=this.solvedState.getOutsideColor():g=this.solvedState.getFaceColor([...i.get(p)][0]),w===g)throw new W("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const s=new Set,r=new Set,l=t.getOutsideColor(),c=t.getInsideColor(),a=o.getOutsideColor(),i=o.getInsideColor();for(const n of t.getFaceColors()){if(r.has(n))continue;const d=t.getOppositeFaceColor(n);r.add(n),d&&r.add(d);const y=t.getFacesWithColor(n),w=d?t.getFacesWithColor(d):[],p=(g,S)=>{o.getFaceColor(g)!==S&&s.add(g)};if(n===l)y.forEach(g=>p(g,a)),w.forEach(g=>p(g,i));else if(n===c)y.forEach(g=>p(g,i)),w.forEach(g=>p(g,a));else if(y.length){let g=y.filter(C=>o.getFaceColor(C)===a).length+w.filter(C=>o.getFaceColor(C)===i).length,S=y.length+w.length;if(g>0&&g<S){const C=g>S/2,E=C?a:i,v=C?i:a;y.forEach(L=>p(L,E)),w.forEach(L=>p(L,v))}}}return new He(new Set,s)}}class js{constructor(e,t,o){f(this,"faceStateChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){b()&&D(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new W(`Attempt to make face ${t} when it should be ${o}`);const s=this.currentState.getFaceState(e);if(!t.isSubsetOf(s))throw new W("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Ys{constructor(e,t,o){f(this,"faceValueChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new W("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Qt{constructor(e,t,o){f(this,"sectorStateChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){b()&&D(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new W(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const s=new Set;for(const r of e.halfEdges){const l=r.edge,c=r.next.edge,a=t.getSectorState(r),i=(o.getEdgeState(l)===m.BLACK?1:0)+(o.getEdgeState(c)===m.BLACK?1:0);a.allows(i)||(s.add(l),s.add(c))}return new He(s,new Set)}}class Gs{constructor(e,t,o){f(this,"simpleRegionsChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,s){if([...o].length)throw new W("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Xs{constructor(e,t,o){f(this,"vertexStateChangedEmitter",new ye);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){b()&&D(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new W(`Attempt to make vertex ${t} when it should be ${o}`);const s=this.currentState.getVertexState(e);if(!t.isSubsetOf(s))throw new W("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class qs{constructor(e,t,o){f(this,"anyStateChangedEmitter",new ye);f(this,"edgeStateValidator");f(this,"faceValueValidator");f(this,"simpleRegionDataValidator");f(this,"faceColorValidator");f(this,"sectorStateValidator");f(this,"vertexStateValidator");f(this,"faceStateValidator");b()&&D(e),b()&&D(o),this.edgeStateValidator=new Zt(e,t,o),this.faceValueValidator=new Ys(e,t,o),this.simpleRegionDataValidator=new Gs(e,t,o),this.faceColorValidator=new $t(e,t,o),this.sectorStateValidator=new Qt(e,t,o),this.vertexStateValidator=new Xs(e,t,o),this.faceStateValidator=new js(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,s){this.simpleRegionDataValidator.modifyRegions(e,t,o,s)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,s,r){this.faceColorValidator.modifyFaceColors(e,t,o,s,r)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){return He.with([Zt.getCorrectnessState(e,t,o),$t.getCorrectnessState(e,t,o),Qt.getCorrectnessState(e,t,o)])}}const Js=h=>[h.forwardHalf,h.reversedHalf,h.forwardHalf.previous,h.reversedHalf.previous];class Ye{constructor(e){this.edge=e,b()&&D(e)}apply(e){e.getEdgeState(this.edge)!==m.WHITE&&e.setEdgeState(this.edge,m.WHITE);const o=this.edge.forwardFace,s=this.edge.reversedFace,r=e.getOutsideColor(),l=e.getInsideColor(),c=o?e.getFaceColor(o):r,a=s?e.getFaceColor(s):r,i=e.getOppositeFaceColor(c);if(c===a||i===a){const n=[...e.getFacesWithColor(c),...c===r?[null]:[]],d=i?[...e.getFacesWithColor(i),...i===r?[null]:[]]:[],y=[...n,...d],w=g=>{const S=new Set,C=new Set([g]);for(;C.size>0;){const E=C.values().next().value;if(C.delete(E),S.add(E),E){for(const v of E.edges)if(e.getEdgeState(v)!==m.WHITE){const L=v.getOtherFace(E),N=L?e.getFaceColor(L):r;(N===c||N===i)&&!S.has(L)&&C.add(L)}}else for(const v of y)if(v&&!S.has(v))for(const L of v.edges)L.getOtherFace(v)===null&&e.getEdgeState(L)!==m.WHITE&&C.add(v)}return S},p=w(o);if(!p.has(s)){const g=w(s);b()&&D(p.size>0&&g.size>0),b()&&D([...p].every(T=>!g.has(T)));const S=y.filter(T=>!p.has(T)&&!g.has(T)),C=[],E=[],v=new Map,L=new Map,N=(T,A,M)=>{const V=T.filter(R=>(R?e.getFaceColor(R):r)===c),I=T.filter(R=>(R?e.getFaceColor(R):r)===i);if(A!==null)A!==r&&A!==l&&(V.length||E.push(A),M&&!I.length&&E.push(M));else if(b()&&D(T.every(R=>R)),A=new At(bt(),k.UNDECIDED),C.push(A),V.length&&I.length){M=new At(bt(),k.UNDECIDED),C.push(M),L.set(A,M),L.set(M,A);for(const R of V)b()&&D(R),v.set(R,A);for(const R of I)b()&&D(R),v.set(R,M)}else{const R=V.length?V:I;b()&&D(R.length);for(const G of R)b()&&D(G),v.set(G,A)}},P=[...p],F=[...g],O=ne.sortBy([...S.length?[S]:[],P,F],T=>-T.length+(T.some(A=>!A)?-1e7:0));for(let T=0;T<O.length;T++)N(O[T],T===0?c:null,T===0?i:null);e.modifyFaceColors(C,E,v,L,!1)}}for(const n of Js(this.edge))e.setSectorState(n,x.ANY);for(const n of this.edge.vertices)e.setVertexState(n,dt.any(n));for(const n of this.edge.faces)e.setFaceState(n,fo.any(n,e.getFaceValue(n)))}getUndo(e){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:Tt(this.edge)}}static deserializeAction(e,t){const o=Ot(e,t.edge);return new Ye(o)}}class Ge{constructor(e){this.face=e,b()&&D(e)}apply(e){this.face.edges.forEach(t=>{new Ye(t).apply(e)})}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:rt(this.face)}}static deserializeAction(e,t){const o=it(e,t.face);return new Ge(o)}}class Rt{constructor(e){this.sector=e,b()&&D(e)}apply(e){e.setSectorState(this.sector,x.ANY);const t=this.sector.end;e.setVertexState(t,dt.any(t));const o=this.sector.face;o&&e.setFaceState(o,fo.any(o,e.getFaceValue(o)))}getUndo(e){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:Cs(this.sector)}}static deserializeAction(e,t){const o=Es(e,t.sector);return new Rt(o)}}class ut{constructor(e,t,o,s){f(this,"dirtyFaces",new Set);f(this,"edgeListener");f(this,"faceColorListener");this.board=e,this.state=t,this.options=o,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,l,c,a)=>{const i=n=>{this.dirtyFaces.add(n);for(const d of n.edges){const y=d.getOtherFace(n);y&&this.dirtyFaces.add(y)}};for(const n of a)i(n);for(const n of[...r,...c]){const d=this.state.getFacesWithColor(n);for(const y of d)i(y)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,l)=>{for(const c of r.faces)this.dirtyFaces.add(c)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new W("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,t=s=>{const r=s.getOtherFace(e),l=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new _s(l,s)},o=e.edges.filter(s=>this.state.getEdgeState(s)===m.WHITE).map(t);if(o.length){const s=this.state.getFaceValue(e);if(s===null){const r=o[0].color;if(e.edges.map(t).every(a=>a.color===r)&&this.options.solveToRed&&wo(this.board,this.state,new Set([e]))){const a=e.edges.map(n=>n.getOtherFace(e)).filter(n=>n!==null);if(this.board.faces.some(n=>n!==e&&this.state.getFaceValue(n)!==null&&!a.includes(n)))return new X(new Q(o.map(n=>new J(n.edge,m.RED))),{type:"FaceColorNoTrivialLoop",face:e},this.board)}}else{const r=e.edges.filter(a=>this.state.getEdgeState(a)===m.BLACK).length,l=(a,i,n)=>{let d=[];for(const P of i){const F=P.color;let O=!1;for(const T of d)if(T.mainColor===F){T.mainColorSides.add(P),O=!0;break}else if(T.oppositeColor===F){T.oppositeColorSides.add(P),O=!0;break}if(!O){const T=this.state.getOppositeFaceColor(F),A=new Zs(F,T,0,0);d.push(A),A.mainColorSides.add(P)}}d=ne.sortBy(d,P=>-P.size);const w=ne.sortBy(d.flatMap(P=>{const F=[new eo(P.mainColor,P.mainCount,P.mainColorSides)];return P.oppositeColor&&P.oppositeColorSides.size&&F.push(new eo(P.oppositeColor,P.oppositeCount,P.oppositeColorSides)),F}),P=>-P.size)[0],p=w.size,g=a,S=i.length-g,C=Math.max(g,S),E=p>g,v=p>S,L=p===C;if(E&&v)throw new W("Too many adjacent faces with the same color");const N=()=>{const P=F=>[F[0].map(O=>O.edge),F[1].map(O=>O.edge)];return{face:e,remainingValue:a,availableSideCount:i.length,balancedPairs:n.map(P)}};if(E&&this.options.solveToRed)return new X(new Q([...w.sides].map(P=>new J(P.edge,m.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...w.sides].map(P=>P.edge),...N()},this.board);if(v&&this.options.solveToBlack)return new X(new Q([...w.sides].map(P=>new J(P.edge,m.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...w.sides].map(P=>P.edge),...N()},this.board);if(L&&this.options.solveColors){const P=w.color,F=i.filter(T=>T.color!==P),O=ne.uniq(F.map(T=>T.color)).filter(T=>T!==this.state.getOppositeFaceColor(P));if(O.length)return b()&&D(O.every(T=>this.state.getFaceColors().includes(T))),new X(new Q(O.map(T=>new ze(q(this.state,P),q(this.state,T)))),{type:"FaceColorBalance",matchingEdges:[...w.sides].map(T=>T.edge),oppositeEdges:[...F].map(T=>T.edge),...N()},this.board)}if(this.options.allowPartialReduction)for(const P of d){if(P.size<1)continue;const F=[...P.mainColorSides].slice(0,P.size),O=[...P.oppositeColorSides].slice(0,P.size),T=i.filter(A=>!F.includes(A)&&!O.includes(A));if(T.length){const A=l(g-P.size,T,n.concat([[F,O]]));if(A)return A}}return null},c=l(s-r,o,[]);if(c)return c}}this.dirtyFaces.delete(e)}return null}clone(e){return new ut(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class _s{constructor(e,t){this.color=e,this.edge=t}}class Zs{constructor(e,t,o,s){f(this,"mainColorSides",new Set);f(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=t,this.mainCount=o,this.oppositeCount=s}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class eo{constructor(e,t,o){this.color=e,this.count=t,this.sides=o}get size(){return this.sides.size}}class pt{constructor(e,t,o,s){f(this,"dirtyFaces",[]);f(this,"vertexListener");this.board=e,this.state=t,this.options=o,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new W("Face has no possibilities");const o=[],s=[];for(const r of e.edges)if(this.state.getEdgeState(r)===m.WHITE){const c=t.getFinalStatesOfEdge(r);if(c.size===1){const a=[...c][0];a===m.RED&&this.options.solveToRed&&o.push(r),a===m.BLACK&&this.options.solveToBlack&&s.push(r)}}if(o.length||s.length)return new X(new Q([...o.map(r=>new J(r,m.RED)),...s.map(r=>new J(r,m.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:o,toBlackEdges:s},this.board)}return null}clone(e){return new pt(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class gt{constructor(e,t,o){f(this,"dirtyFaces",[]);f(this,"faceListener");this.board=e,this.state=t,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new W("Face has no possibilities");const o=new Map(e.edges.map(a=>{const i=a.getOtherFace(e);return[a,i?this.state.getFaceColor(i):this.state.getOutsideColor()]})),s=[e,...e.edges.map(a=>a.getOtherFace(e)).filter(ne.identity)],r=this.state.getFaceColor(e),l=new Set([...o.values(),r]);if(l.size!==1){const a=new Map([...l].map(n=>[n,new Map([...l].map(d=>[d,!1]))])),i=new Map([...l].map(n=>[n,new Map([...l].map(d=>[d,!1]))]));for(const n of t.getAllowedCombinations()){const d=new Set([r]),y=new Set;for(const p of e.edges)n.includes(p)?y.add(o.get(p)):d.add(o.get(p));const w=p=>{for(let g=0;g<p.length;g++)for(let S=g+1;S<p.length;S++)a.get(p[g]).set(p[S],!0),a.get(p[S]).set(p[g],!0)};w([...d]),w([...y]);for(const p of d)for(const g of y)p!==g&&(i.get(p).set(g,!0),i.get(g).set(p,!0))}for(const n of l)for(const d of l){if(n===d)continue;const y=a.get(n).get(d),w=i.get(n).get(d);if(y&&!w)return new X(new We(q(this.state,n),q(this.state,d)),{type:"FaceStateToSameFaceColor",face:e,facesA:s.filter(p=>this.state.getFaceColor(p)===n),facesB:s.filter(p=>this.state.getFaceColor(p)===d)},this.board);if(w&&!y&&this.state.getOppositeFaceColor(n)!==d)return new X(new ze(q(this.state,n),q(this.state,d)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:s.filter(p=>this.state.getFaceColor(p)===n),facesB:s.filter(p=>this.state.getFaceColor(p)===d)},this.board)}}const c=this.dirtyFaces.pop();b()&&D(c===e)}return null}clone(e){return new gt(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class ft{constructor(e,t,o){f(this,"dirtyFaces",[]);f(this,"faceListener");this.board=e,this.state=t,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new W("Face has no possibilities");const o=e.halfEdges,s=o.map(i=>this.state.getSectorState(i)),r=o.map(i=>x.NONE);for(const i of t.getAllowedCombinations())for(let n=0;n<o.length;n++){const d=o[n],y=d.edge,w=d.next.edge,p=(i.includes(y)?1:0)+(i.includes(w)?1:0);r[n]=r[n].with(p)}for(let i=0;i<o.length;i++)r[i]=r[i].and(s[i]);for(const i of r)if(i===x.NONE)throw new W("Sector has no possibilities");const l=[],c=[],a=[];for(let i=0;i<o.length;i++)s[i]!==r[i]&&(l.push(o[i]),c.push(s[i]),a.push(r[i]));if(l.length)return new X(new Q(l.map((i,n)=>new ht(i,a[n]))),{type:"FaceStateToSector",face:e,sectors:l,beforeStates:c,afterStates:a},this.board)}return null}clone(e){return new ft(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class wt{constructor(e,t,o){f(this,"dirtyFaces",[]);f(this,"faceListener");this.board=e,this.state=t,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new W("Face has no possibilities");const o=e.vertices.map(c=>this.state.getVertexState(c)),s=o.map(c=>{const a=c.vertex.edges.filter(i=>i.faces.includes(e));return b()&&D(a.length===2),{vertex:c.vertex,vertexState:c,edgeA:a[0],edgeB:a[1],...c.getBinaryCombinationsAllowed(a[0],a[1])}}),r=s.map(c=>({vertex:c.vertex,vertexState:c.vertexState,edgeA:c.edgeA,edgeB:c.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const c of t.getAllowedCombinations())for(const a of r){const i=c.includes(a.edgeA),n=c.includes(a.edgeB);i&&n&&(a.allowsBoth=!0),i&&!n&&(a.allowsAOnly=!0),!i&&n&&(a.allowsBOnly=!0),!i&&!n&&(a.allowsNone=!0)}const l=[];for(let c=0;c<r.length;c++){const a=s[c],i=r[c];if(i.allowsBoth&&(i.allowsBoth=a.allowsBoth),i.allowsAOnly&&(i.allowsAOnly=a.allowsAOnly),i.allowsBOnly&&(i.allowsBOnly=a.allowsBOnly),i.allowsNone&&(i.allowsNone=a.allowsNone),i.allowsBoth!==a.allowsBoth||i.allowsAOnly!==a.allowsAOnly||i.allowsBOnly!==a.allowsBOnly||i.allowsNone!==a.allowsNone){const n=a.vertexState,d=dt.fromLookup(a.vertex,(y,w)=>{if(!n.allowsPair(y,w))return!1;const g=y===i.edgeA||w===i.edgeA,S=y===i.edgeB||w===i.edgeB;if(g&&S)return i.allowsBoth;if(g&&!S)return i.allowsAOnly;if(!g&&S)return i.allowsBOnly;if(!g&&!S)return i.allowsNone;throw new Error("Unreachable")},n.allowsEmpty()&&i.allowsNone);b()&&D(d.isSubsetOf(n)),n.equals(d)||l.push(d)}}if(l.length)return new X(new Q(l.map(c=>new Ls(c.vertex,c))),{type:"FaceStateToVertexState",face:e,vertices:l.map(c=>c.vertex),beforeStates:l.map(c=>o.find(a=>a.vertex===c.vertex)),afterStates:l},this.board)}return null}clone(e){return new wt(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class be{constructor(e,t,o,s){f(this,"dirtyEdges",new Set);f(this,"faceColorListener");this.board=e,this.state=t,this.options=o,s?this.dirtyEdges=new Set(s):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,l,c,a)=>{for(const i of a)for(const n of i.edges)this.dirtyEdges.add(n);for(const i of c){const n=this.state.getFacesWithColor(i);for(const d of n)for(const y of d.edges)this.dirtyEdges.add(y)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new W("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===m.WHITE){const o=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),s=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=o===s,l=this.state.getOppositeFaceColor(o)===s;if(this.options.solveToBlack&&l)return new X(new J(e,m.BLACK),{type:"FaceColorToBlack",edge:e},this.board);if(this.options.solveToRed&&r)return new X(new J(e,m.RED),{type:"FaceColorToRed",edge:e},this.board)}this.dirtyEdges.delete(e)}return null}clone(e){return new be(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class qe{constructor(e,t,o,s){f(this,"dirtyFaces",[]);f(this,"faceListener");f(this,"edgeListener");this.board=e,this.state=t,this.options=o,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceListener=(r,l)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,l)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceValue(e);if(t!==null){const o=e.edges;let s=0,r=0,l=0;if(o.forEach(c=>{const a=this.state.getEdgeState(c);return a===m.BLACK?s++:a===m.RED?r++:l++,a}),s>t)throw new W("Too many black edges on face");if(r>e.edges.length-t)throw new W("Too many red edges on face");if(l>0){if(this.options.solveToRed&&s===t){const c=o.filter(i=>this.state.getEdgeState(i)===m.WHITE),a=o.filter(i=>this.state.getEdgeState(i)===m.BLACK);return new X(new Q(c.map(i=>new J(i,m.RED))),{type:"FaceSatisfied",face:e,whiteEdges:c,blackEdges:a},this.board)}else if(this.options.solveToBlack&&r===e.edges.length-t){const c=o.filter(i=>this.state.getEdgeState(i)===m.WHITE),a=o.filter(i=>this.state.getEdgeState(i)===m.RED);return new X(new Q(c.map(i=>new J(i,m.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:c,redEdges:a},this.board)}}}}return null}clone(e){return new qe(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Je{constructor(e,t,o,s){f(this,"dirtySimpleRegions");f(this,"hasDirtyWeirdEdges",!1);f(this,"simpleRegionListener");f(this,"edgeListener");this.board=e,this.state=t,this.options=o,s?this.dirtySimpleRegions=new Set(s):this.dirtySimpleRegions=new Set(t.getSimpleRegions()),this.simpleRegionListener=(r,l,c,a)=>{for(const i of l)this.dirtySimpleRegions.delete(i);for(const i of r)this.dirtySimpleRegions.add(i);this.hasDirtyWeirdEdges=t.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,l,c)=>{if(l===m.RED){const a=this.state.getSimpleRegions(),i=n=>{let d=n,y=null,w=0;do{if(w++>1e4)throw new Error("infinite loop detected");const p=d.edges.filter(C=>this.state.getEdgeState(C)===m.BLACK);if(p.length===1){for(const C of a)(C.a===d||C.b===d)&&this.dirtySimpleRegions.add(C);break}if(p.length!==0)break;const g=d.edges.filter(C=>this.state.getEdgeState(C)===m.WHITE);if(g.length!==2)break;const S=g[0].getOtherVertex(d)===y?g[1]:g[0];y=d,d=S.getOtherVertex(d)}while(d!==n)};i(r.start),i(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new W("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const t=e.values().next().value;if(!t.isSolved){const o=t.a,s=t.b,r=t.halfEdges[0].edge;for(const l of o.edges){if(l===r||this.state.getEdgeState(l)===m.RED)continue;const c=[l];let a=l,i=l.getOtherVertex(o);for(;i!==s;){let n=!1;const d=i.edges.filter(y=>{if(y===a)return!1;const w=this.state.getEdgeState(y);return w===m.BLACK&&(n=!0),w===m.WHITE});if(d.length!==1||n)break;a=d[0],c.push(a),i=a.getOtherVertex(i)}if(i===s){if(this.isSolvedWithAddedEdges(t,c)){if(this.options.solveToBlack)return new X(new Q(c.map(n=>new J(n,m.BLACK))),{type:"ForcedSolveLoop",a:o,b:s,regionEdges:t.edges,pathEdges:c},this.board)}else if(this.options.solveToRed)return new X(new Q(c.map(n=>new J(n,m.RED))),{type:"PrematureForcedLoop",a:o,b:s,regionEdges:t.edges,pathEdges:c},this.board)}}}e.delete(t)}return null}isSolvedWithAddedEdges(e,t){const o=new Set(e.edges);for(const s of t)o.add(s);for(const s of this.board.faces){const r=this.state.getFaceValue(s);if(r!==null&&s.edges.filter(c=>o.has(c)).length!==r)return!1}return!0}clone(e){return new Je(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class St{constructor(e,t,o){f(this,"dirtySectors");f(this,"edgeListener");f(this,"sectorListener");this.board=e,this.state=t,o?this.dirtySectors=new Set(o):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(s,r,l)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,r,l)=>{this.dirtySectors.add(s)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,o=e.next.edge,s=this.state.getSectorState(e);if(s===x.NONE)throw new W(`invalid sector state: ${s}`);const r=this.state.getEdgeState(t),l=this.state.getEdgeState(o),c=(r===m.WHITE?1:0)+(l===m.WHITE?1:0),a=(r===m.BLACK?1:0)+(l===m.BLACK?1:0),i=(n,d)=>new X(new Q([...n.map(y=>new J(y,m.BLACK)),...d.map(y=>new J(y,m.RED))]),{type:"ForcedSector",sector:e,sectorState:s,toRedEdges:d,toBlackEdges:n},this.board);if(c===0){if(!s.allows(a))throw new W(`invalid state: ${s} with ${a} black edges with no white`)}else if(c===1){const n=s.allows(a),d=s.allows(a+1);if(!n&&!d)throw new W(`invalid state: ${s} with ${a} black edges and 1 white`);if(n&&!d)return i([],[r===m.WHITE?t:o]);if(d&&!n)return i([r===m.WHITE?t:o],[])}else if(c===2){if(s===x.ONLY_ZERO)return i([],[t,o]);if(s===x.ONLY_TWO)return i([t,o],[])}else throw new W(`invalid white count: ${c}`)}return null}clone(e){return new St(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class _e{constructor(e,t,o,s){f(this,"dirtyVertices",[]);f(this,"edgeListener");this.board=e,this.state=t,this.options=o,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,l)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=e.edges;let o=0,s=0;if(t.forEach(r=>{const l=this.state.getEdgeState(r);return l===m.BLACK?o++:l===m.WHITE&&s++,l}),o>2)throw new W("Too many black edges on vertex");if(o===1&&s===0)throw new W("Nowhere for the single edge to go");if(s>0){if(this.options.solveJointToRed&&o===2){const r=t.filter(c=>this.state.getEdgeState(c)===m.WHITE),l=t.filter(c=>this.state.getEdgeState(c)===m.BLACK);return b()&&D(l.length===2),new X(new Q(r.map(c=>new J(c,m.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:l},this.board)}else if(this.options.solveForcedLineToBlack&&o===1&&s===1){const r=t.find(c=>this.state.getEdgeState(c)===m.WHITE),l=t.find(c=>this.state.getEdgeState(c)===m.BLACK);return b()&&D(r),b()&&D(l),new X(new J(r,m.BLACK),{type:"ForcedLine",vertex:e,blackEdge:l,whiteEdge:r,redEdges:t.filter(c=>this.state.getEdgeState(c)===m.RED)},this.board)}else if(this.options.solveAlmostEmptyToRed&&o===0&&s===1){const r=t.find(l=>this.state.getEdgeState(l)===m.WHITE);return b()&&D(r),new X(new J(r,m.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:t.filter(l=>this.state.getEdgeState(l)===m.RED)},this.board)}}}return null}clone(e){return new _e(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const to=(h,e)=>h.start===e||h.end===e,tt=h=>{const e=[];for(const t of h.edges){const o=t.getOtherFace(h);o&&e.push(o)}return e};class yt{constructor(e,t,o){f(this,"dirtyFaces");f(this,"faceListener");this.board=e,this.state=t,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceListener=(s,r)=>{this.dirtyFaces.add(s);for(const l of tt(s))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),o=e.edges.length;if(t===o-1)for(const s of e.edges){const r=s.getOtherFace(e);if(r){const l=this.state.getFaceValue(r),c=r.edges.length;if(l===c-1){const a=new Set([...tt(e),...tt(r)]);if(this.board.faces.some(i=>(this.state.getFaceValue(i)??0)>0&&!a.has(i))){const i=S=>!to(S,s.start)&&!to(S,s.end),n=e.edges.filter(i),d=r.edges.filter(i),y=S=>!S.faces.some(C=>C===e||C===r),w=[...s.start.edges.filter(y),...s.end.edges.filter(y)],p=[s,...n,...d].filter(S=>this.state.getEdgeState(S)!==m.BLACK),g=w.filter(S=>this.state.getEdgeState(S)!==m.RED);if((p.length||g.length)&&wo(this.board,this.state,new Set([e,r])))return new X(new Q([...p.map(S=>new J(S,m.BLACK)),...g.map(S=>new J(S,m.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:p,toRedEdges:g},this.board)}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new yt(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class Ze{constructor(e,t,o){f(this,"dirtyFaces");f(this,"faceListener");this.board=e,this.state=t,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceListener=(s,r)=>{this.dirtyFaces.add(s);for(const l of tt(s))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),o=e.edges.length;let s=null;if(t===0?s=x.ONLY_ZERO:t===1?s=x.NOT_TWO:t===o-1?s=x.NOT_ZERO:t===o&&(s=x.ONLY_TWO),s){const r=e.halfEdges,l=[],c=[];for(const a of r){const i=this.state.getSectorState(a),n=i.and(s);if(n===x.NONE)throw new W(`invalid sector state: ${i}`);i!==n&&(l.push(new ht(a,n)),c.push(a))}if(l.length)return new X(new Q(l),{type:"StaticFaceSectors",face:e,sectors:c},this.board)}this.dirtyFaces.delete(e)}return null}clone(e){return new Ze(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class Ct{constructor(e,t,o,s){f(this,"dirtyVertices",[]);f(this,"vertexListener");this.board=e,this.state=t,this.options=o,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new W("Vertex has no possibilities");const o=[],s=[];for(const r of e.edges)if(this.state.getEdgeState(r)===m.WHITE){const c=t.getFinalStatesOfEdge(r);if(c.size===1){const a=[...c][0];a===m.RED&&this.options.solveToRed&&o.push(r),a===m.BLACK&&this.options.solveToBlack&&s.push(r)}}if(o.length||s.length)return new X(new Q([...o.map(r=>new J(r,m.RED)),...s.map(r=>new J(r,m.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:o,toBlackEdges:s},this.board)}return null}clone(e){return new Ct(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Et{constructor(e,t,o){f(this,"dirtyVertices",[]);f(this,"vertexListener");this.board=e,this.state=t,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=s=>{this.dirtyVertices.push(s)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new W("Vertex has no possibilities");const s=ms(e).map(c=>c.face?this.state.getFaceColor(c.face):this.state.getOutsideColor()),r=new Set(s);if(r.size!==1){const c=new Map([...r].map(i=>[i,new Map([...r].map(n=>[n,!1]))])),a=new Map([...r].map(i=>[i,new Map([...r].map(n=>[n,!1]))]));for(const i of t.getAllowedPairs()){const n=e.edges.indexOf(i[0]),d=e.edges.indexOf(i[1]),y=Math.min(n,d),w=Math.max(n,d),p=s.slice(y,w),g=[...s.slice(w),...s.slice(0,y)],S=C=>{for(let E=0;E<C.length;E++)for(let v=E+1;v<C.length;v++)c.get(C[E]).set(C[v],!0),c.get(C[v]).set(C[E],!0)};S(p),S(g);for(const C of p)for(const E of g)C!==E&&(a.get(C).set(E,!0),a.get(E).set(C,!0))}for(const i of r)for(const n of r){if(i===n)continue;const d=t.allowsEmpty()||c.get(i).get(n),y=a.get(i).get(n);if(d&&!y)return new X(new We(q(this.state,i),q(this.state,n)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(w=>this.state.getFaceColor(w)===i),facesB:e.faces.filter(w=>this.state.getFaceColor(w)===n)},this.board);if(y&&!d&&this.state.getOppositeFaceColor(i)!==n)return new X(new ze(q(this.state,i),q(this.state,n)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(w=>this.state.getFaceColor(w)===i),facesB:e.faces.filter(w=>this.state.getFaceColor(w)===n)},this.board)}}const l=this.dirtyVertices.pop();b()&&D(l===e)}return null}clone(e){return new Et(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class mt{constructor(e,t,o){f(this,"dirtyVertices",[]);f(this,"vertexListener");this.board=e,this.state=t,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=s=>{this.dirtyVertices.push(s)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new W("Vertex has no possibilities");const o=vs(e),s=o.map(i=>this.state.getSectorState(i)),r=o.map(i=>x.NONE);for(const i of t.getAllowedPairs())for(let n=0;n<o.length;n++){const d=o[n],y=d.edge,w=d.next.edge,p=i[0],g=i[1],S=(y===p||y===g?1:0)+(w===p||w===g?1:0);r[n]=r[n].with(S)}if(t.allowsEmpty())for(let i=0;i<o.length;i++)r[i]=r[i].withZero(!0);for(let i=0;i<o.length;i++)r[i]=r[i].and(s[i]);for(const i of r)if(i===x.NONE)throw new W("Sector has no possibilities");const l=[],c=[],a=[];for(let i=0;i<o.length;i++)s[i]!==r[i]&&(l.push(o[i]),c.push(s[i]),a.push(r[i]));if(l.length)return new X(new Q(l.map((i,n)=>new ht(i,a[n]))),{type:"VertexStateToSector",vertex:e,sectors:l,beforeStates:c,afterStates:a},this.board)}return null}clone(e){return new mt(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}const $s=new B("autoSolveEnabledProperty",!0),Qs=new B("autoSolveToBlackProperty",!1),er=new B("autoSolveSimpleLoopsProperty",!1),tr=new B("autoSolveSimpleVertexJointToRedProperty",!0),or=new B("autoSolveSimpleVertexForcedLineToBlackProperty",!0),sr=new B("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),rr=new B("autoSolveSimpleFaceToRedProperty",!0),ir=new B("autoSolveSimpleFaceToBlackProperty",!0),ar=new B("autoSolveSimpleLoopToRedProperty",!0),nr=new B("autoSolveSimpleLoopToBlackProperty",!1),lr=new B("autoSolveDoubleMinusOneFacesProperty",!1),cr=new B("autoSolveStaticFaceSectorProperty",!0),dr=new B("autoSolveSimpleSectorProperty",!1),hr=new B("autoSolveVertexToRedEdgeProperty",!1),ur=new B("autoSolveVertexToBlackEdgeProperty",!1),pr=new B("autoSolveVertexToSectorsProperty",!1),gr=new B("autoSolveVertexToFaceColorProperty",!1),fr=new B("autoSolveFaceColorToRedProperty",!1),wr=new B("autoSolveFaceColorToBlackProperty",!1),Sr=new B("autoSolveFaceColorParityToRedProperty",!1),yr=new B("autoSolveFaceColorParityToBlackProperty",!1),Cr=new B("autoSolveFaceColorParityColorsProperty",!1),Er=new B("autoSolveFaceColorParityPartialReductionProperty",!1),mr=new B("autoSolveVertexColorToFaceProperty",!1),vr=new B("autoSolveFaceToRedProperty",!1),Pr=new B("autoSolveFaceToBlackProperty",!1),Fr=new B("autoSolveFaceToSectorsProperty",!1),Vr=new B("autoSolveFaceToFaceColorsProperty",!1),Lr=new B("autoSolveFaceToVertexProperty",!1),Tr=new j([tr,or,sr,rr,ir,ar,nr,lr,cr,dr,hr,ur,pr,gr,fr,wr,Sr,yr,Cr,Er,mr,vr,Pr,Fr,Vr,Lr],(h,e,t,o,s,r,l,c,a,i,n,d,y,w,p,g,S,C,E,v,L,N,P,F,O,T)=>(A,M,V)=>new Pe([...h||e||t?[new _e(A,M,{solveJointToRed:h,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},V?void 0:[])]:[],...o||s?[new qe(A,M,{solveToRed:o,solveToBlack:s},V?void 0:[])]:[],...c?[new yt(A,M,V?void 0:[])]:[],So(A,M),...a?[new Ze(A,M,V?void 0:[])]:[],...i?[new St(A,M,V?void 0:[])]:[],...r||l?[new Je(A,M,{solveToRed:r,solveToBlack:l,resolveAllRegions:!1},V?void 0:[])]:[],...n||d?[new Ct(A,M,{solveToRed:n,solveToBlack:d},V?void 0:[])]:[],...y?[new mt(A,M,V?void 0:[])]:[],...p||g?[new be(A,M,{solveToRed:p,solveToBlack:g},V?void 0:[])]:[],...S||C||E?[new ut(A,M,{solveToRed:S,solveToBlack:C,solveColors:E,allowPartialReduction:v},V?void 0:[])]:[],...w?[new Et(A,M,V?void 0:[])]:[],...L?[new Nt(A,M,V?void 0:[])]:[],...N||P?[new pt(A,M,{solveToRed:N,solveToBlack:P},V?void 0:[])]:[],...F?[new ft(A,M,V?void 0:[])]:[],...O?[new gt(A,M,V?void 0:[])]:[],...T?[new wt(A,M,V?void 0:[])]:[]]));class Vt extends Error{constructor(e){super(e)}}const oo=(h,e,t)=>{at(t,h,e,!0)},Or=(h,e,t)=>new Pe([new yo(h,e),new Co(h,e),new Eo(h,e),new _e(h,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new qe(h,e,{solveToRed:!0,solveToBlack:!0}),new Je(h,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new yt(h,e),new mo(h,e),new Ze(h,e),new St(h,e),new vo(h,e),new Ct(h,e,{solveToRed:!0,solveToBlack:!0}),new mt(h,e),new be(h,e,{solveToRed:!0,solveToBlack:!0}),new ut(h,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new Et(h,e),new Nt(h,e),new pt(h,e,{solveToRed:!0,solveToBlack:!0}),new ft(h,e),new gt(h,e),new wt(h,e)]),Vo=(h,e,t,o)=>(s,r,l)=>{const c=[new yo(s,r),new Co(s,r)];return(h||e||t||o)&&(c.push(new Eo(s,r)),(e||t||o)&&(c.push(new mo(s,r)),(t||o)&&(c.push(new vo(s,r)),o&&c.push(new Nt(s,r))))),new Pe(c)},Ar={allowEdgeEditProperty:ko,allowAbsoluteFaceColorEditProperty:No,allowFaceColorEditProperty:Io,allowSectorEditProperty:Ro,edgesVisibleProperty:Bo,edgesHaveColorsProperty:Mo,faceColorsVisibleProperty:Mt,faceColorThresholdProperty:Wo,sectorsVisibleProperty:Wt,sectorsNextToEdgesVisibleProperty:Ho,sectorsTrivialVisibleProperty:zo,vertexStateVisibleProperty:Ht,allVertexStateVisibleProperty:Uo,faceStateVisibleProperty:zt,whiteLineVisibleProperty:Ko,redLineVisibleProperty:we,verticesVisibleProperty:jo,smallVertexProperty:Yo,redXsVisibleProperty:Go,redXsAlignedProperty:Xo,faceValueStyleProperty:Se,redLineStyleProperty:qo,vertexStyleProperty:Jo,joinedLinesJoinProperty:_o,joinedLinesCapProperty:Zo,safeSolverFactoryProperty:new j([Mt,Wt,Ht,zt],(h,e,t,o)=>Vo(h,e,t,o)),autoSolverFactoryProperty:Tr,theme:fe},Fe=(h,e,t,o,s)=>{const r=Vo(h,e,t,o);return{faceColorsVisibleProperty:new Ie(h),sectorsVisibleProperty:new Ie(e),vertexStateVisibleProperty:new Ie(t),faceStateVisibleProperty:new Ie(o),safeSolverFactoryProperty:new Ke(r),autoSolverFactoryProperty:s?new j([s],l=>(c,a,i)=>new Pe([r(c,a,i),l(c,a,i)])):new Ke(r)}},De=new j([Qs,er],(h,e)=>(t,o,s)=>new Pe([new _e(t,o,{solveJointToRed:!0,solveForcedLineToBlack:h,solveAlmostEmptyToRed:!0},s?void 0:[]),new qe(t,o,{solveToRed:!0,solveToBlack:h},s?void 0:[]),...e?[new Je(t,o,{solveToRed:!0,solveToBlack:h,resolveAllRegions:!1},s?void 0:[])]:[]])),br=new j([De],h=>(e,t,o)=>new Pe([h(e,t,o),new be(e,t,{solveToRed:!0,solveToBlack:!0})])),Lo=new j([De],h=>(e,t,o)=>new Pe([h(e,t,o),new Ze(e,t,o?void 0:[])])),Dr=new j([Lo],h=>(e,t,o)=>new Pe([h(e,t,o),new be(e,t,{solveToRed:!0,solveToBlack:!0})])),xr=h=>({...Fe(!0,!1,!1,!1,De),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!0),allowFaceColorEditProperty:new u(!1),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!0),faceColorThresholdProperty:new u(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),kr=h=>({...Fe(!0,!1,!1,!1,br),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!0),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(2),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Nr=h=>({...Fe(!0,!1,!1,!1,new Ke((e,t,o)=>new Pe([new be(e,t,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:h,allowEdgeEditProperty:new u(!1),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!0),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!1),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(2),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!1),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Ir=h=>({...Fe(!1,!1,!1,!1,De),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!1),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!1),redLineVisibleProperty:we,verticesVisibleProperty:new u(!0),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!0),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("square"),joinedLinesJoinProperty:new u("miter"),joinedLinesCapProperty:new u("square")}),ki=h=>({...Fe(!1,!0,!1,!1,De),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!1),allowSectorEditProperty:new u(!0),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!1),redLineVisibleProperty:we,verticesVisibleProperty:new u(!0),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!0),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("square"),joinedLinesJoinProperty:new u("miter"),joinedLinesCapProperty:new u("square")}),Rr=h=>({...Fe(!0,!0,!1,!1,Lo),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!0),allowFaceColorEditProperty:new u(!1),allowSectorEditProperty:new u(!0),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!0),faceColorThresholdProperty:new u(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Br=h=>({...Fe(!0,!0,!1,!1,Dr),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!0),allowSectorEditProperty:new u(!0),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(2),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Mr=h=>({...Fe(!0,!1,!0,!1,De),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!0),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(2),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Wr=h=>({...Fe(!0,!1,!1,!0,De),theme:h,allowEdgeEditProperty:new u(!0),allowAbsoluteFaceColorEditProperty:new u(!1),allowFaceColorEditProperty:new u(!0),allowSectorEditProperty:new u(!1),edgesVisibleProperty:new u(!0),edgesHaveColorsProperty:new u(!1),faceColorThresholdProperty:new u(2),sectorsNextToEdgesVisibleProperty:new u(!1),sectorsTrivialVisibleProperty:new u(!1),allVertexStateVisibleProperty:new u(!1),whiteLineVisibleProperty:new u(!0),redLineVisibleProperty:we,verticesVisibleProperty:new u(!1),smallVertexProperty:new u(!1),redXsVisibleProperty:new u(!1),redXsAlignedProperty:new u(!1),faceValueStyleProperty:Se,redLineStyleProperty:new u("middle"),vertexStyleProperty:new u("round"),joinedLinesJoinProperty:new u("round"),joinedLinesCapProperty:new u("round")}),Hr=xr(fe),zr=kr(fe),Ur=Nr(fe),To=Ir(fe),Kr=Rr(fe),jr=Br(fe),Yr=Mr(fe),Gr=Wr(fe),Lt={basicLines:Hr,basicFaceColoring:zr,pureFaceColor:Ur,classic:To,basicSectors:Kr,sectorsWithColors:jr,vertexState:Yr,faceState:Gr,custom:Ar},so=To,Xr=h=>({allowEdgeEditProperty:new K(h,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new K(h,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new K(h,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new K(h,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new K(h,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new K(h,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new K(h,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new K(h,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new K(h,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new K(h,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new K(h,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new K(h,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new K(h,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new K(h,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new K(h,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new K(h,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new K(h,{derive:"verticesVisibleProperty"}),smallVertexProperty:new K(h,{derive:"smallVertexProperty"}),redXsVisibleProperty:new K(h,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new K(h,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new K(h,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new K(h,{derive:"redLineStyleProperty"}),vertexStyleProperty:new K(h,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new K(h,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new K(h,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new K(h,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new K(h,{derive:"autoSolverFactoryProperty"}),theme:Qo(new j([h],e=>e.theme))}),qr=new $o("puzzleStyle",{serialize:h=>Object.keys(Lt).find(e=>Lt[e]===h),deserialize:h=>h?Lt[h]??so:so}),te=Xr(qr),Ni=new B("showPuzzleStyleProperty",!0),Ii=new B("showPuzzleTimerProperty",!1),Ri=new B("showSectorViewModesProperty",!1),Y=class Y extends me{constructor(e){super(),this.isEnabledProperty=e}};f(Y,"EDGE_STATE",new Y(te.allowEdgeEditProperty)),f(Y,"EDGE_STATE_REVERSED",new Y(te.allowEdgeEditProperty)),f(Y,"FACE_COLOR_INSIDE",new Y(te.allowAbsoluteFaceColorEditProperty)),f(Y,"FACE_COLOR_OUTSIDE",new Y(te.allowAbsoluteFaceColorEditProperty)),f(Y,"FACE_COLOR_MATCH",new Y(te.allowFaceColorEditProperty)),f(Y,"FACE_COLOR_OPPOSITE",new Y(te.allowFaceColorEditProperty)),f(Y,"SECTOR_STATE",new Y(te.allowSectorEditProperty)),f(Y,"VERTEX_STATE",new Y(te.vertexStateVisibleProperty)),f(Y,"FACE_STATE",new Y(te.faceStateVisibleProperty)),f(Y,"FACE_VALUE",new Y(new Ie(!1))),f(Y,"DELETE_FACE",new Y(new Ie(!1))),f(Y,"enumeration",new ve(Y));let z=Y;const _=new xt("editModeProperty",z.EDGE_STATE);z.enumeration.values.forEach(h=>{h.isEnabledProperty.lazyLink(e=>{if(!_.value.isEnabledProperty.value){const t=z.enumeration.values.find(o=>o.isEnabledProperty.value)??null;t&&(_.value=t)}})});const $e=new B("eraserEnabledProperty",!1),Bi=h=>{h.isEnabledProperty.value&&(_.value=h)},Jr=new j([_],h=>h===z.EDGE_STATE||h===z.EDGE_STATE_REVERSED),Bt=new j([_],h=>h===z.FACE_COLOR_MATCH||h===z.FACE_COLOR_OPPOSITE),Mi=Bt,_r=new j([_],h=>h===z.FACE_COLOR_OUTSIDE||h===z.FACE_COLOR_INSIDE),Zr=new j([_],h=>h===z.SECTOR_STATE),$r=new j([_],h=>h===z.VERTEX_STATE),Qr=new j([_,Bt,_r],(h,e,t)=>e||t||h===z.FACE_STATE||h===z.FACE_VALUE||h===z.DELETE_FACE),le=class le extends me{};f(le,"NONE",new le),f(le,"ABSOLUTE_PAINT",new le),f(le,"MAKE_SAME",new le),f(le,"MAKE_OPPOSITE",new le),f(le,"enumeration",new ve(le));let se=le;class ei{constructor(e){f(this,"paintFaceSet",new Set);f(this,"paintFaceOppositeSet",new Set);f(this,"absolutePaintState",k.INSIDE);f(this,"lastFace",null);f(this,"faceDragStateProperty",new u(se.NONE));f(this,"dragIndex",0);this.board=e}isNoOpSingleFace(){return(this.faceDragStateProperty.value===se.MAKE_SAME||this.faceDragStateProperty.value===se.MAKE_OPPOSITE)&&this.paintFaceSet.size===1&&this.paintFaceOppositeSet.size===0}onAbsolutePaintStart(e,t){this.faceDragStateProperty.value=se.ABSOLUTE_PAINT,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeSameStart(e){this.faceDragStateProperty.value=se.MAKE_SAME,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=k.UNDECIDED,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeOppositeStart(e){this.faceDragStateProperty.value=se.MAKE_OPPOSITE,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=k.UNDECIDED,this.lastFace=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(e){const s=e.viewCoordinates.distance(t),r=e.vertices.map(l=>l.viewCoordinates.distance(t)).reduce((l,c)=>Math.min(l,c),Number.POSITIVE_INFINITY);if(s>.3&&r/s<.7)return!1}const o=this.lastFace;return this.lastFace=e,!this.paintFaceSet.has(e)&&!this.paintFaceOppositeSet.has(e)?(this.faceDragStateProperty.value===se.MAKE_OPPOSITE&&this.paintFaceSet.has(o)?(b()&&D(!this.paintFaceSet.has(e)),this.paintFaceOppositeSet.add(e)):(b()&&D(!this.paintFaceOppositeSet.has(e)),this.paintFaceSet.add(e)),!0):!1}onDragEnd(){this.faceDragStateProperty.value=se.NONE}}const re=class re extends me{};f(re,"DEFAULT",new re),f(re,"LOADING",new re),f(re,"SEARCHING",new re),f(re,"FOUND",new re),f(re,"NOT_FOUND",new re),f(re,"enumeration",new ve(re));let ue=re;const ge=class ge extends me{};f(ge,"NONE",new ge),f(ge,"LINE_DRAG",new ge),f(ge,"EDGE_PAINT",new ge),f(ge,"enumeration",new ve(ge));let de=ge;class ti{constructor(e){f(this,"firstEdge");f(this,"edgeStack",[]);f(this,"vertexStack",[]);f(this,"paintEdgeSet",new Set);f(this,"paintEdgeState",m.WHITE);f(this,"lineDragStateProperty",new u(de.NONE));f(this,"dragIndex",0);this.board=e}onLineDragStart(e){this.firstEdge=e,this.lineDragStateProperty.value=de.LINE_DRAG,this.edgeStack.length=0,this.edgeStack.push(e),this.vertexStack.length=0,this.dragIndex=Math.ceil(Math.random()*1e10)}onPaintDragStart(e,t){this.firstEdge=e,this.lineDragStateProperty.value=de.EDGE_PAINT,this.paintEdgeSet.clear(),this.paintEdgeSet.add(e),this.paintEdgeState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(this.lineDragStateProperty.value===de.LINE_DRAG){const o=this.edgeStack[this.edgeStack.length-1],s=this.edgeStack.length>1?this.edgeStack[this.edgeStack.length-2]:null;if(e===o)return!1;if(e===s)return this.edgeStack.pop(),this.vertexStack.pop(),!0;if(this.edgeStack.includes(e))return!1;if(this.vertexStack.length===0){const r=o.vertices.find(l=>e.vertices.includes(l))??null;return r?(this.edgeStack.push(e),this.vertexStack.push(r),!0):!1}else{const r=this.vertexStack[this.vertexStack.length-1];if(e.vertices.includes(r))return this.edgeStack.pop(),this.edgeStack.push(e),!0;{const l=o.getOtherVertex(r);return e.vertices.includes(l)?(this.edgeStack.push(e),this.vertexStack.push(l),!0):!1}}}else if(this.lineDragStateProperty.value===de.EDGE_PAINT){const o=e.start.viewCoordinates.distance(e.end.viewCoordinates),s=Math.min(...e.vertices.map(l=>l.viewCoordinates.distance(t))),r=Math.min(...e.faces.map(l=>l.viewCoordinates.distance(t)));if(Math.min(s,r)/o<.3)return!1;if(!this.paintEdgeSet.has(e))return this.paintEdgeSet.add(e),!0}return!1}onDragEnd(){this.lineDragStateProperty.value=de.NONE}}const Z=class Z extends me{constructor(e,t,o){super(),this.fromWhite=e,this.fromBlack=t,this.fromRed=o}apply(e){return e===m.WHITE?this.fromWhite:e===m.BLACK?this.fromBlack:this.fromRed}};f(Z,"CYCLE",new Z(m.BLACK,m.RED,m.WHITE)),f(Z,"REVERSE_CYCLE",new Z(m.RED,m.WHITE,m.BLACK)),f(Z,"BLACK_TOGGLE",new Z(m.BLACK,m.WHITE,m.BLACK)),f(Z,"RED_TOGGLE",new Z(m.RED,m.RED,m.WHITE)),f(Z,"WHITE_SET",new Z(m.WHITE,m.WHITE,m.WHITE)),f(Z,"BLACK_SET",new Z(m.BLACK,m.BLACK,m.BLACK)),f(Z,"RED_SET",new Z(m.RED,m.RED,m.RED)),f(Z,"enumeration",new ve(Z));let Ve=Z;const ie=class ie extends me{constructor(e,t,o){super(),this.fromUndecided=e,this.fromInside=t,this.fromOutside=o}apply(e){return e===k.UNDECIDED?this.fromUndecided:e===k.OUTSIDE?this.fromOutside:this.fromInside}};f(ie,"CYCLE",new ie(k.INSIDE,k.OUTSIDE,k.UNDECIDED)),f(ie,"REVERSE_CYCLE",new ie(k.OUTSIDE,k.UNDECIDED,k.INSIDE)),f(ie,"INSIDE_TOGGLE",new ie(k.INSIDE,k.UNDECIDED,k.INSIDE)),f(ie,"OUTSIDE_TOGGLE",new ie(k.OUTSIDE,k.OUTSIDE,k.UNDECIDED)),f(ie,"UNDECIDED_SET",new ie(k.UNDECIDED,k.UNDECIDED,k.UNDECIDED)),f(ie,"enumeration",new ve(ie));let Le=ie;const Oe=class Oe extends me{constructor(e,t){super(),this.edgePressStyles=e,this.faceColorPressStyles=t}};f(Oe,"CYCLIC",new Oe([Ve.CYCLE,Ve.WHITE_SET,Ve.REVERSE_CYCLE],[Le.CYCLE,Le.UNDECIDED_SET,Le.REVERSE_CYCLE])),f(Oe,"TOGGLE",new Oe([Ve.BLACK_TOGGLE,Ve.WHITE_SET,Ve.RED_TOGGLE],[Le.INSIDE_TOGGLE,Le.UNDECIDED_SET,Le.OUTSIDE_TOGGLE])),f(Oe,"enumeration",new ve(Oe));let Dt=Oe;const Qe=new xt("stateTransitionModeProperty",Dt.CYCLIC);class nt{constructor(e,t,o,s){this.firstEdge=e,this.edges=t,this.state=o,this.dragIndex=s}apply(e){for(const t of this.edges)e.setEdgeState(t,this.state)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.edges.length===0}serializeAction(){return{type:"UserEdgeDragAction",firstEdge:Tt(this.firstEdge),edges:this.edges.map(e=>Tt(e)),state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new nt(Ot(e,t.firstEdge),t.edges.map(o=>Ot(e,o)),m.enumeration.getValue(t.state),t.dragIndex)}}class lt{constructor(e){this.face=e,b()&&D(e)}apply(e){const t=e.getFaceColor(this.face),o=e.getOppositeFaceColor(t),s=e.getFacesWithColor(t);for(const r of this.face.edges)e.getEdgeState(r)!==m.WHITE&&e.setEdgeState(r,m.WHITE);if(t.colorState!==k.UNDECIDED||o||s.length>1)if(t.colorState===k.UNDECIDED&&s.length===1)b()&&D(o),e.modifyFaceColors([],[],new Map,new Map([[t,null],[o,null]]),!1);else{const r=new At(bt(),k.UNDECIDED);e.modifyFaceColors([r],[],new Map([[this.face,r]]),new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceOnlyCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceOnlyCompleteAction",face:rt(this.face)}}static deserializeAction(e,t){const o=it(e,t.face);return new lt(o)}}class ct{constructor(e,t,o,s,r){this.primaryFaces=e,this.secondaryFaces=t,this.isAbsolute=o,this.state=s,this.dragIndex=r}apply(e){console.log(this.state,this.primaryFaces,this.secondaryFaces);const t=(s,r,l)=>s&&(e.getOppositeFaceColor(r)===l||e.getOppositeFaceColor(l)===r)?(new lt(s).apply(e),!0):!1,o=(s,r,l)=>s&&r===l?(new lt(s).apply(e),!0):!1;if(this.state!==k.UNDECIDED){const s=this.state===k.OUTSIDE;console.log("absolute",s?"outside":"inside");const r=s?e.getOutsideColor():e.getInsideColor();for(const l of this.primaryFaces){let c=l?e.getFaceColor(l):e.getOutsideColor();r!==c&&(t(l,c,r),c=l?e.getFaceColor(l):e.getOutsideColor(),new We(q(e,c),{type:"absolute",isOutside:s}).apply(e))}}else if(this.isAbsolute){console.log("absolute erase");for(const s of this.primaryFaces)s&&new Ge(s).apply(e)}else{if(console.log("normal"),this.primaryFaces.length&&this.secondaryFaces.length){const r=this.primaryFaces[0],l=this.secondaryFaces[0];let c=r?e.getFaceColor(r):e.getOutsideColor(),a=l?e.getFaceColor(l):e.getOutsideColor();o(l,c,a),c=r?e.getFaceColor(r):e.getOutsideColor(),a=l?e.getFaceColor(l):e.getOutsideColor(),new ze(q(e,c),q(e,a)).apply(e)}const s=r=>{for(let l=1;l<r.length;l++){const c=r[l-1],a=r[l];let i=c?e.getFaceColor(c):e.getOutsideColor(),n=a?e.getFaceColor(a):e.getOutsideColor();i!==n&&(t(a,i,n)&&(i=c?e.getFaceColor(c):e.getOutsideColor(),n=a?e.getFaceColor(a):e.getOutsideColor()),new We(q(e,i),q(e,n)).apply(e))}};s(this.primaryFaces),s(this.secondaryFaces)}}getUndo(e){throw new Error("unimplemented")}isEmpty(){return(this.primaryFaces.length===0||this.state===k.UNDECIDED&&this.primaryFaces.length===1)&&this.secondaryFaces.length===0}serializeAction(){return{type:"UserFaceDragAction",primaryFaces:this.primaryFaces.map(e=>e?rt(e):null),secondaryFaces:this.secondaryFaces.map(e=>e?rt(e):null),isAbsolute:this.isAbsolute,state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new ct(t.primaryFaces.map(o=>o?it(e,o):null),t.secondaryFaces.map(o=>o?it(e,o):null),t.isAbsolute,k.enumeration.getValue(t.state),t.dragIndex)}}class oi{constructor(e){this.hintAction=e}get annotation(){return this.hintAction.annotation}apply(e){this.hintAction.apply(e)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}const si=h=>h instanceof hs?{type:"PolygonGeneratorBoard",generator:h.generator.name,parameters:h.parameters}:h instanceof us?{type:"SquareBoard",width:h.width,height:h.height}:h instanceof ps?{type:"HexagonalBoard",radius:h.radius,scale:h.scale,isPointyTop:h.isPointyTop,holeRadius:h.holeRadius}:{type:"BaseBoard",vertices:h.vertices.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vx:e.viewCoordinates.x,vy:e.viewCoordinates.y})),faces:h.faces.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vertices:e.vertices.map(t=>h.vertices.indexOf(t))}))},Oo=h=>({version:1,board:si(h.board),state:h.stateProperty.value.serializeState(h.board)}),ri=h=>{const e=Oo(h);return gs(JSON.stringify(e))},ii=h=>{const e=Oo(h),t=h.solution.cleanState.serializeState(h.board),o=h.solution.solvedState.serializeState(h.board),s=[...h.solution.blackEdges].map(r=>h.board.edges.indexOf(r));return{puzzle:e,cleanState:t,solvedState:o,blackEdges:s}};function ai(h){return new Worker(""+new URL("hintWorker-CTzw_gIY.js",import.meta.url).href,{name:h==null?void 0:h.name})}let xe=null;const ot=new u(!1),Ao=()=>(xe||(xe=new ai,xe==null||xe.addEventListener("message",h=>{h.data.type==="hint-worker-loaded"&&(ot.value=!0)})),xe);Ao();const ni=new B("uiHintUsesBuiltInSolve",!1),Wi=new B("showUndoRedoAllProperty",!1),ro=new B("dimCompletedNumbersProperty",!0),io=new B("highlightIncorrectNumbersProperty",!0),Hi=new B("highlightIncorrectMovesProperty",!0),li=new B("highlightIntersectionsProperty",!0),zi=new es("highlightIncorrectMovesDelayProperty",.7);class Ui extends ss{constructor(t,o){const s=Xe()({style:te,initialTimeElapsed:0},o),r=s.style;super();f(this,"timeElapsedProperty",new u(0));f(this,"hintStateProperty",new u(ue.DEFAULT));f(this,"edgeAutoSolvedEmitter",new ye);f(this,"stack");f(this,"stackLengthProperty",new u(0));f(this,"stackPositionProperty",new u(0));f(this,"undoPossibleProperty");f(this,"redoPossibleProperty");f(this,"currentSnapshotProperty");f(this,"hasErrorProperty");f(this,"correctnessStateProperty");f(this,"isSolvedProperty");f(this,"hintWorkerMessageID",0);f(this,"addedHintListener",!1);f(this,"pendingHintActionProperty",new u(null));f(this,"displayedAnnotationProperty");f(this,"pendingActionFaceColorProperty",new u(null));f(this,"pendingActionSectorProperty",new u(null));f(this,"selectedFaceColorHighlightProperty");f(this,"selectedSectorEditProperty");f(this,"autoSolverFactoryProperty");f(this,"style");f(this,"lineDrag");f(this,"faceDrag");this.puzzle=t,this.style=r,this.timeElapsedProperty.value=s.initialTimeElapsed,this.lineDrag=new ti(t.board),this.faceDrag=new ei(t.board),this.autoSolverFactoryProperty=new j([$s,r.safeSolverFactoryProperty,r.autoSolverFactoryProperty],(a,i,n)=>a?n:i),this.displayedAnnotationProperty=new j([this.pendingHintActionProperty],a=>a?a.annotation:null);const l=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(l),_.lazyLink(l),this.disposeEmitter.addListener(()=>_.unlink(l)),this.selectedFaceColorHighlightProperty=new j([t.stateProperty,_,this.pendingActionFaceColorProperty],(a,i,n)=>{if((i===z.FACE_COLOR_MATCH||i===z.FACE_COLOR_OPPOSITE)&&n){const d=a.getFacesWithColor(n.color);return{faceColor:n.color,face:n.face,faces:d}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new j([t.stateProperty,_,this.pendingActionSectorProperty],(a,i,n)=>i===z.SECTOR_STATE&&n?{sector:n,currentState:a.getSectorState(n)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const a=t.stateProperty.value.clone();oo(t.board,a,this.style.safeSolverFactoryProperty.value),t.stateProperty.value=a}this.stack=[this.getSnapshot(null,t.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new j([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new j([this.currentSnapshotProperty],a=>!a.correctnessState.isCorrect()),this.correctnessStateProperty=new j([this.currentSnapshotProperty],a=>a.correctnessState),this.isSolvedProperty=new j([this.currentSnapshotProperty],a=>{if(a.state.getWeirdEdges().length||a.state.hasInvalidFaceColors())return!1;const i=a.state.getSimpleRegions();return i.length===1&&i[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new j([this.stackPositionProperty],a=>a>0),this.redoPossibleProperty=new j([this.stackPositionProperty,this.stackLengthProperty],(a,i)=>a<i-1);const c=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(c),this.style.safeSolverFactoryProperty.lazyLink(c),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(c),this.style.safeSolverFactoryProperty.unlink(c)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(t){this.isSolvedProperty.value||(this.timeElapsedProperty.value+=Math.min(t,5),localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value)))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",ri(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(t){this.wipeStackTop(),this.stack.push(t),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(t,o){const s=(o==null?void 0:o.forceDirty)||t instanceof Ft;let l=this.stack[this.stackPositionProperty.value].state;o!=null&&o.erase&&(l=l.clone(),o.erase(l));let c=new Set;const a=d=>{c.add(d)};let i=l.createDelta();try{if(i.edgeStateChangedEmitter.addListener(a),Jt(this.autoSolverFactoryProperty.value,this.puzzle.board,i,()=>{t.apply(i)},s),i.edgeStateChangedEmitter.removeListener(a),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(i)))throw new Vt("Auto-solver did not respect user action")}catch(d){if(c=new Set,d instanceof W||d instanceof Vt)d instanceof W?console.log("error"):d instanceof Vt&&console.log("skipping autosolve due to undo"),i=l.createDelta(),i.edgeStateChangedEmitter.addListener(a),Jt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,i,()=>{t.apply(i)},s),i.edgeStateChangedEmitter.removeListener(a);else throw d}const n=l.clone();i.apply(n),this.pushTransitionAtCurrentPosition(this.getSnapshot(t,n));for(const d of c)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(d))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(d))}computeCorrectnessState(t=this.puzzle.stateProperty.value){return qs.getCorrectnessState(this.puzzle.board,t,this.puzzle.solution.solvedState)}getSnapshot(t,o){return new ci(this.puzzle.board,t,o,this.computeCorrectnessState(o))}addAutoSolveDelta(){const t=this.puzzle.stateProperty.value.createDelta();try{if(at(this.autoSolverFactoryProperty.value,this.puzzle.board,t,!0),!t.isEmpty()){const o=this.puzzle.stateProperty.value.clone();t.apply(o),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Ft,o))}}catch(o){if(!(o instanceof W))throw o}}onAutoSolveChange(){const t=this.stack[this.stackPositionProperty.value];t.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(t.action||new Ft,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(t,o,s){s&&(o=2-o);const r=Qe.value.edgePressStyles[o];return console.log(Qe.value,r,o,t),r.apply(t)}getNewFaceColorState(t,o,s){s&&(o=2-o);const r=Qe.value.faceColorPressStyles[o];return console.log(Qe.value,r,o,t),r.apply(t)}getNextEdgeState(t,o){const s=$e.value,r=this.puzzle.stateProperty.value.getEdgeState(t);return s?m.WHITE:this.getNewEdgeState(r,o,_.value===z.EDGE_STATE_REVERSED)}getNextFaceColorState(t,o){const s=this.puzzle.stateProperty.value.getOutsideColor(),r=this.puzzle.stateProperty.value.getInsideColor(),l=this.puzzle.stateProperty.value.getFaceColor(t),c=l===s?k.OUTSIDE:l===r?k.INSIDE:k.UNDECIDED;return this.getNewFaceColorState(c,o,_.value===z.FACE_COLOR_OUTSIDE)}onUserEdgePress(t,o){const s=this.puzzle.stateProperty.value.getEdgeState(t),r=this.getNextEdgeState(t,o);if(s!==r){const l=this.stack[this.stackPositionProperty.value];l.action&&l.action instanceof J&&l.action.edge===t&&this.stackPositionProperty.value--;let c;s!==m.WHITE&&(c=i=>{new Ye(t).apply(i)});const a=new J(t,r);this.applyUserActionToStack(a,{erase:c,checkAutoSolve:i=>i.getEdgeState(t)===r,excludedEdges:new Set([t])}),this.updateState()}}onUserEdgeDragStart(t,o){if(this.lineDrag.lineDragStateProperty.value!==de.NONE)return;const s=this.getNextEdgeState(t,o);s===m.BLACK?this.lineDrag.onLineDragStart(t):this.lineDrag.onPaintDragStart(t,s),this.updateEdgeDrag()}onUserEdgeDrag(t,o){this.lineDrag.onDrag(t,o)&&this.updateEdgeDrag()}onUserEdgeDragEnd(){this.lineDrag.onDragEnd()}updateEdgeDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof nt&&(t.action.dragIndex===this.lineDrag.dragIndex||t.action.firstEdge===this.lineDrag.firstEdge)&&this.stackPositionProperty.value--,b()&&D(this.lineDrag.lineDragStateProperty.value!==de.NONE,"line drag state should not be NONE");const o=this.lineDrag.lineDragStateProperty.value===de.LINE_DRAG?this.lineDrag.edgeStack.slice():Array.from(this.lineDrag.paintEdgeSet),s=this.lineDrag.lineDragStateProperty.value===de.LINE_DRAG?m.BLACK:this.lineDrag.paintEdgeState,r=o.filter(a=>this.puzzle.stateProperty.value.getEdgeState(a)!==m.WHITE),l=new Q(r.map(a=>new Ye(a))),c=new nt(this.lineDrag.firstEdge,o,s,this.lineDrag.dragIndex);this.applyUserActionToStack(c,{erase:a=>l.apply(a),checkAutoSolve:a=>o.every(i=>a.getEdgeState(i)===s),excludedEdges:new Set(this.puzzle.board.edges)}),this.updateState()}onUserFacePress(t,o){const s=$e.value,r=_.value;if(s){if(t){const l=new Ge(t);this.applyUserActionToStack(l,{erase:c=>l.apply(c)}),this.updateState()}}else if(r===z.FACE_COLOR_MATCH||r===z.FACE_COLOR_OPPOSITE){let l=_.value===z.FACE_COLOR_MATCH;o===2&&(l=!l);const c=t?this.puzzle.stateProperty.value.getFaceColor(t):this.puzzle.stateProperty.value.getOutsideColor(),a=this.pendingActionFaceColorProperty.value;if(a){if(t!==a.face){const i=a.color;i!==c&&(l?this.applyUserActionToStack(new We(q(this.puzzle.stateProperty.value,c),q(this.puzzle.stateProperty.value,i))):this.applyUserActionToStack(new ze(q(this.puzzle.stateProperty.value,c),q(this.puzzle.stateProperty.value,i))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:t,color:c}}else if((r===z.FACE_COLOR_OUTSIDE||r===z.FACE_COLOR_INSIDE)&&t){const l=this.puzzle.stateProperty.value.getOutsideColor(),c=this.puzzle.stateProperty.value.getInsideColor(),a=this.puzzle.stateProperty.value.getFaceColor(t),i=a===l?k.OUTSIDE:a===c?k.INSIDE:k.UNDECIDED,n=this.getNewFaceColorState(i,o,r===z.FACE_COLOR_OUTSIDE);if(i!==n){const d=this.stack[this.stackPositionProperty.value];d.action&&d.action instanceof Gt&&d.action.face===t&&this.stackPositionProperty.value--;let y;const w=new Ge(t);i!==k.UNDECIDED&&(y=p=>{w.apply(p)}),n===k.UNDECIDED?this.applyUserActionToStack(w,{erase:y}):this.applyUserActionToStack(new Gt(t,n===k.INSIDE),{erase:y}),this.updateState()}}}onUserFaceDragStart(t,o){if(this.faceDrag.faceDragStateProperty.value!==se.NONE)return;const s=_.value;if($e.value)this.faceDrag.onAbsolutePaintStart(t,k.UNDECIDED);else if(s===z.FACE_COLOR_MATCH||s===z.FACE_COLOR_OPPOSITE)s===z.FACE_COLOR_MATCH==(o===0)?this.faceDrag.onMakeSameStart(t):this.faceDrag.onMakeOppositeStart(t);else if(s===z.FACE_COLOR_INSIDE||s===z.FACE_COLOR_OUTSIDE){const r=t?this.getNextFaceColorState(t,o):z.FACE_COLOR_OUTSIDE;this.faceDrag.onAbsolutePaintStart(t,r)}this.updateFaceDrag()}onUserFaceDrag(t,o){this.faceDrag.onDrag(t,o)&&this.updateFaceDrag()}onUserFaceDragEnd(){if(this.faceDrag.isNoOpSingleFace()){const t=_.value===z.FACE_COLOR_MATCH==(this.faceDrag.faceDragStateProperty.value===se.MAKE_SAME);this.onUserFacePress([...this.faceDrag.paintFaceSet][0],t?0:2)}this.faceDrag.onDragEnd()}updateFaceDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof ct&&t.action.dragIndex===this.faceDrag.dragIndex&&this.stackPositionProperty.value--;const o=this.faceDrag.faceDragStateProperty.value;if(b()&&D(o!==se.NONE,"line drag state should not be NONE"),this.faceDrag.isNoOpSingleFace())return;const s=[...this.faceDrag.paintFaceSet],r=o===se.MAKE_OPPOSITE?[...this.faceDrag.paintFaceOppositeSet]:[],l=this.faceDrag.absolutePaintState,c=o===se.ABSOLUTE_PAINT,a=new ct(s,r,c,l,this.faceDrag.dragIndex);this.applyUserActionToStack(a,{checkAutoSolve:i=>{if(s.length){const n=s[0]?i.getFaceColor(s[0]):i.getOutsideColor();if(s.some(d=>(d?i.getFaceColor(d):i.getOutsideColor())!==n))return!1;if(r.length){const d=r[0]?i.getFaceColor(r[0]):i.getOutsideColor();if(r.some(y=>(y?i.getFaceColor(y):i.getOutsideColor())!==d)||i.getOppositeFaceColor(n)!==d)return!1}}return!0}}),this.updateState()}onUserSectorPress(t,o){if($e.value){const r=new Rt(t);this.applyUserActionToStack(r,{erase:l=>r.apply(l)}),this.updateState()}else this.pendingActionSectorProperty.value=t}onUserSectorSet(t,o){this.applyUserActionToStack(new ht(t,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const t=this.puzzle.stateProperty.value;if(!Ps(t))if(ni.value){const o=t.clone();at(Or,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Xt,o)),this.updateState()}else{const o=Ts(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const s=this.puzzle.stateProperty.value.clone();o[0].forEach(r=>{s.setEdgeState(r,m.BLACK)}),oo(this.puzzle.board,s,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Xt,s)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ue.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(t){this.hintStateProperty.value=t?ue.FOUND:ue.NOT_FOUND,t&&(this.pendingHintActionProperty.value=t)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const t=te.allowEdgeEditProperty.value,o=te.allowFaceColorEditProperty.value,s=te.allowSectorEditProperty.value,r=te.vertexStateVisibleProperty.value,l=te.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const c=Ao();if(!this.addedHintListener){this.addedHintListener=!0;const a=i=>{if(i.data.type==="hint-response"&&i.data.id===this.hintWorkerMessageID){const n=i.data.action?Fs(this.puzzle.board,i.data.action):null;this.onHintReceived(n)}};c.addEventListener("message",a),this.disposeEmitter.addListener(()=>self.removeEventListener("message",a))}if(c.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:t,solveColors:o,solveSectors:s,solveVertexState:r,solveFaceState:l,serializedSolvablePuzzle:ii(this.puzzle)}),ot.value)this.hintStateProperty.value=ue.SEARCHING;else{this.hintStateProperty.value=ue.LOADING;const a=i=>{i&&(this.hintStateProperty.value===ue.LOADING&&(this.hintStateProperty.value=ue.SEARCHING),ot.unlink(a))};ot.link(a)}}onUserApplyHint(){const t=this.pendingHintActionProperty.value;t&&(this.clearPendingHint(),this.applyUserActionToStack(new oi(t)),this.updateState())}}class ci{constructor(e,t,o,s){this.board=e,this.action=t,this.state=o,this.correctnessState=s}}class di extends H{constructor(e,t,o,s){super({pickable:!1}),this.board=e;const r=e.faces.map(i=>null),l=()=>{const i=[],n=o.faceValueStyleProperty.value,d=o.theme.faceValueColorProperty.value,y=o.theme.faceValueCompletedColorProperty.value,w=o.theme.faceValueErrorColorProperty.value,p=o.theme.faceValueRatioColorProperty.value,g=o.faceStateVisibleProperty.value,S=ro.value,C=io.value;this.visible=!g;for(let E=0;E<e.faces.length;E++){const v=r[E];if(v!==null){const L=e.faces[E],N=new as("",lo({subScale:.7},s==null?void 0:s.textOptions)),P=Ee.multilink([t],F=>{let O,T,A=!1,M=!1;if(v===null)O="",T=null;else{let V=0,I=0;for(const R of L.edges){const G=F.getEdgeState(R);G===m.BLACK?V++:G===m.WHITE&&I++}if(n==="static"||v===0)O=`${v}`;else if(n==="remaining")O=`${v-V}`,A=V>0;else if(n==="ratio")v-V===0?O="0":(O=`${v-V}<sub style="color: ${p.toCSS()};">/<sub>${I}</sub></sub>`,M=!0),A=V>0;else throw new Error(`unhandled faceValueStyle: ${n}`);V>v&&C?T=w:V===v&&S?T=y:T=d}N.string=O,N.fill=T,N.maxWidth=M?.8:.9,N.maxHeight=M?.8:.9,N.center=L.viewCoordinates});N.disposeEmitter.addListener(()=>P.dispose()),i.push(N)}}this.children.forEach(E=>E.dispose()),this.children=i},c=Ee.multilink([t],i=>{let n=!1;for(let d=0;d<e.faces.length;d++){const y=i.getFaceValue(e.faces[d]);y!==r[d]&&(n=!0,r[d]=y)}n&&l()}),a=Ee.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,ro,io],l);this.disposeEmitter.addListener(()=>{c.dispose(),a.dispose(),this.children.forEach(i=>i.dispose())})}}const hi=(h,e,t)=>{const o=new Me({mouseButton:0,fire:l=>{var c;return e&&e((c=l.domEvent)!=null&&c.shiftKey?2:0)}}),s=new Me({mouseButton:2,fire:l=>{var c;return e&&e((c=l.domEvent)!=null&&c.shiftKey?0:2)}}),r=new Me({mouseButton:1,fire:l=>e&&e(1)});h.addInputListener({down:l=>{Po.value===je.DRAG_ONLY&&t&&t(l)}}),h.addInputListener(o),h.addInputListener(s),h.addInputListener(r),h.cursor="pointer",h.disposeEmitter.addListener(()=>{o.dispose(),s.dispose(),r.dispose()})};class vt extends H{constructor(e,t,o,s){const r=Xe()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceBackgroundDragStartListener:()=>{},noninteractive:!1},s);super({pickableProperty:Bt}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!r.noninteractive&&hi(this,p=>r.facePressListener(null,p),r.faceBackgroundDragStartListener);const l=e.map(p=>p.start.viewCoordinates),c=r.useBackgroundOffsetStroke,a=r.backgroundOffsetDistance,n=Yt(l)>0?-a:a,d=p=>{const g=new ns;g.addShape(0,p),g.computeSimplifiedFaces(),g.computeFaceInclusion(E=>E[0]>0);const S=g.createFilledSubGraph(),C=S.facesToShape();return g.dispose(),S.dispose(),C},y=vt.getOffsetBackgroundShape(e,c,a),w=t.map(p=>{const g=p.map(C=>C.start.viewCoordinates),S=U.polygon(g);if(c)return d(S.getOffsetShape(n));{const E=S.getStrokedShape(new jt({lineWidth:2*a})).subpaths.map(v=>new U([v]));return d(ne.minBy(E,v=>v.getArea()))}});this.children=[new $(y,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...w.map(p=>new $(p,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const s=e.map(a=>a.start.viewCoordinates),r=U.polygon(s),c=Yt(s)>0?-o:o;if(t)return r.getOffsetShape(c).getSimplifiedAreaShape();{const a=r.getStrokedShape(new jt({lineWidth:2*o})),i=a.subpaths.map(n=>new U([n]));try{return a.bounds.width===9.718028227819117?U.bounds(a.bounds):ne.maxBy(i,n=>n.getArea()).getSimplifiedAreaShape()}catch{return U.bounds(a.bounds)}}}}class Ce extends H{static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,s=e.end.viewCoordinates,r=e.next.end.viewCoordinates,l=o.minus(s),c=r.minus(s),a=l.normalized(),n=c.normalized().minus(a).angle+Math.PI/2,d=e.face?e.face.viewCoordinates:oe.createPolar(t,n).plus(s),y=o.average(s),w=r.average(s);return U.polygon([y,s,w,d]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,s=e.end.viewCoordinates,r=e.next.end.viewCoordinates,l=o.minus(s),c=r.minus(s),a=l.normalized(),i=l.angle;let n=c.angle;return n<i&&(n+=2*Math.PI),new U().moveToPoint(s).lineToPoint(a.timesScalar(t).plus(s)).arcPoint(s,t,i,n,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===x.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===x.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===x.NOT_ONE?t.theme.sectorNotOneColorProperty:e===x.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}}f(Ce,"nameMap",new Map([[x.NONE,"Invalid"],[x.ONLY_ZERO,"No Lines"],[x.ONLY_ONE,"Only One Line"],[x.ONLY_TWO,"Both Lines"],[x.NOT_ZERO,"At Least One Line"],[x.NOT_ONE,"Zero or Two Lines"],[x.NOT_TWO,"Less Than Two Lines"],[x.ANY,"Any Lines"]]));class ui extends It{constructor(e,t){super(e.halfEdges,o=>Ce.getSectorBaseShape(o,t.backgroundOffsetDistance),t.sectorPressListener)}}const ao=[.02,.02],ke=.2,et=.02;class pi extends H{constructor(e,t,o){const s=new $(null,{lineWidth:.025,lineCap:"butt",stroke:Ce.getStrokeFromStyle(x.NOT_ZERO,o)}),r=new $(null,{lineWidth:.025,lineCap:"butt",stroke:Ce.getStrokeFromStyle(x.NOT_ONE,o)}),l=new $(null,{lineWidth:.025,lineCap:"butt",stroke:Ce.getStrokeFromStyle(x.NOT_TWO,o)}),c=new $(null,{lineWidth:.025,lineCap:"butt",stroke:Ce.getStrokeFromStyle(x.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[s,r,l,c]}),this.board=e;const a=e.halfEdges.map(d=>x.NONE),i=e.edges.map(d=>m.BLACK),n=Ee.multilink([t,o.sectorsVisibleProperty],(d,y)=>{if(y){let w=!1;for(let p=0;p<e.halfEdges.length;p++){const g=d.getSectorState(e.halfEdges[p]);g!==a[p]&&(w=!0,a[p]=g)}for(let p=0;p<e.edges.length;p++){const g=d.getEdgeState(e.edges[p]);g!==i[p]&&(w=!0,i[p]=g)}if(w){const p=new U,g=new U,S=new U,C=new U;for(let E=0;E<e.halfEdges.length;E++){const v=a[E];if(v!==x.NOT_ZERO&&v!==x.NOT_ONE&&v!==x.NOT_TWO&&v!==x.ONLY_ONE)continue;const L=e.halfEdges[E],N=d.getEdgeState(L.edge),P=d.getEdgeState(L.next.edge);if(N!==m.WHITE||P!==m.WHITE)continue;if(v===x.NOT_ONE){const ee=L.end.edges.filter(he=>d.getEdgeState(he)===m.BLACK),ae=L.end.edges.filter(he=>d.getEdgeState(he)===m.WHITE);if(ee.length===0&&ae.length===2)continue}const F=L.start.viewCoordinates,O=L.end.viewCoordinates,T=L.next.end.viewCoordinates,A=F.minus(O),M=T.minus(O),V=A.normalized(),I=A.angle;let R=M.angle;R<I&&(R+=2*Math.PI);const G=(ee,ae)=>(ee.moveToPoint(V.timesScalar(ae).add(O)),ee.arcPoint(O,ae,I,R,!0),ee);if(v===x.ONLY_ONE)G(C,ke);else if(v===x.NOT_ONE)G(g,ke-et),G(g,ke+et);else if(v===x.NOT_ZERO){const ee=new U;G(ee,ke-et),G(ee,ke+et);const ae=ee.getDashedShape(ao,0);p.subpaths.push(...ae.subpaths)}else if(v===x.NOT_TWO){const ee=new U;G(ee,ke);const ae=ee.getDashedShape(ao,0);S.subpaths.push(...ae.subpaths)}}s.shape=p.makeImmutable(),r.shape=g.makeImmutable(),l.shape=S.makeImmutable(),c.shape=C.makeImmutable()}}});this.disposeEmitter.addListener(()=>n.dispose())}}class gi extends H{constructor(e,t,o,s){let r=[];try{let l=new U;for(const a of e.faces)l.polygon(a.vertices.map(i=>i.viewCoordinates));if(e.faceColor.colorState===k.OUTSIDE)try{const a=U.polygon(t.outerBoundary.map(d=>d.start.viewCoordinates)),n=vt.getOffsetBackgroundShape(t.outerBoundary,s.useBackgroundOffsetStroke,s.backgroundOffsetDistance).shapeDifference(a);l=l.bounds.isValid()?l.shapeUnion(n):n}catch(a){console.error(a)}const c=new $(l.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});r.push(c)}catch(l){console.error(l)}super({children:r}),this.selectedFaceColorHighlight=e}}class fi extends H{constructor(e,t,o,s){const r=[],l=[],c=e.sector,a=e.currentState,i=Ce.getSectorArcShape(c,.5),n=new $(i.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});r.push(n);const d=[];if(a===x.ANY&&(d.push(x.NOT_ZERO),d.push(x.NOT_ONE),d.push(x.NOT_TWO)),a.one&&a!==x.ONLY_ONE&&d.push(x.ONLY_ONE),d.length){const y=d.map(g=>{const S=Ce.getStrokeFromStyle(g,o);return new ds({accessibleName:Ce.nameMap.get(g),content:new ls(0,0,25,25),listener:()=>{s.sectorSetListener&&s.sectorSetListener(c,g)},buttonAppearanceStrategy:ts,baseColor:S,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});l.push(...y);const w=new po(new uo({children:y,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});l.push(w);const p=.1;r.push(w),w.centerBottom=n.centerTop.plusXY(0,-.15),w.top<t.top+p&&(w.centerTop=n.centerBottom.plusXY(0,.15)),w.left<t.left+p&&(w.left=t.left+p),w.right>t.right-p&&(w.right=t.right-p)}super({children:r}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{l.forEach(y=>y.dispose())})}}class wi extends H{constructor(t,o,s){super({pickable:!1,visibleProperty:s.edgesVisibleProperty});f(this,"simpleRegionNodeMap",new Map);f(this,"regionIdMap",new Map);f(this,"weirdEdgeNodeMap",new Map);f(this,"regionContainer",new H);f(this,"weirdEdgeContainer",new H);f(this,"adjacentFacesMap",new Map);f(this,"weirdEdgeColorProperty");this.board=t,this.style=s,this.weirdEdgeColorProperty=new j([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,li],(c,a,i)=>i?c:a),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),t.faces.forEach(c=>{this.adjacentFacesMap.set(c,c.edges.map(a=>a.getOtherFace(c)).filter(a=>a!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(c=>this.addRegion(c)),o.value.getWeirdEdges().forEach(c=>this.addWeirdEdge(c)),this.updateHues();const r=(c,a)=>{const i=a.getSimpleRegions(),n=c.getSimpleRegions(),d=a.getWeirdEdges(),y=c.getWeirdEdges(),w=[],p=[];go(i,n,w,p,[]);const S=new Set(w);for(const C of p)if(this.regionIdMap.has(C.id)){const E=this.regionIdMap.get(C.id);this.replaceRegion(E,C),S.delete(E)}else this.addRegion(C);for(const C of S)this.removeRegion(C);for(const C of d)y.includes(C)||this.removeWeirdEdge(C);for(const C of y)d.includes(C)||this.addWeirdEdge(C);(p.length||w.length)&&this.updateHues()};o.lazyLink(r),this.disposeEmitter.addListener(()=>o.unlink(r)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const l=()=>this.updateHues();s.theme.simpleRegionHueLUTProperty.link(l),s.edgesHaveColorsProperty.lazyLink(l),this.disposeEmitter.addListener(()=>{s.theme.simpleRegionHueLUTProperty.unlink(l),s.edgesHaveColorsProperty.unlink(l)})}addRegion(t){const o=new Re(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){b()&&D(t.id===o.id);const s=this.simpleRegionNodeMap.get(t);s.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,s),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,s=t.end.viewCoordinates,r=new cs(o.x,o.y,s.x,s.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const l=c=>{r.lineCap=c};this.style.joinedLinesCapProperty.link(l),r.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(l))}this.weirdEdgeNodeMap.set(t,r),this.weirdEdgeContainer.addChild(r)}removeWeirdEdge(t){this.weirdEdgeNodeMap.get(t).dispose(),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new oe(0,0),s=()=>{for(const n of t)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},r=new Map,l=[];this.board.faces.forEach(n=>{r.set(n,[])});for(const n of t){const d=new Set;for(const w of n.simpleRegion.edges)for(const p of w.faces)d.add(p);const y=new Set;for(const w of d){y.add(w);for(const p of this.adjacentFacesMap.get(w))y.add(p)}for(const w of y){const p=r.get(w);if(p.length)for(const g of p){let S=!1;for(const C of l)if(C.a===g&&C.b===n){C.weight++,S=!0;break}S||l.push({a:g,b:n,weight:1})}p.push(n)}}const c=new Map;for(const n of t)c.set(n,oe.ZERO.copy());const a=(n,d,y)=>{const w=c.get(n),p=c.get(d),g=n.hueVector.dot(d.hueVector),S=o.set(d.hueVector).subtract(n.hueVector);if(S.magnitude>1e-9){S.normalize();const C=.3,E=y*((Math.max(C,g)-C)/(1-C))**3;S.multiplyScalar(E),w.subtract(S),p.add(S)}};let i=1;for(let n=0;n<100;n++){i*=.99;for(const d of t)c.get(d).setXY(0,0);for(const d of l){const y=d.a,w=d.b,p=d.weight;a(y,w,p)}if(t.length<8)for(let d=0;d<t.length;d++){const y=t[d];for(let w=d+1;w<t.length;w++)a(y,t[w],.2)}for(const d of t){const y=c.get(d);y.multiplyScalar(i/d.edgeCount),d.hueVector.add(y),c.get(d).setXY(0,0)}s()}for(const n of t)n.updateHue()}}class Re extends ${constructor(t,o){const s=oe.createPolar(1,st.nextDoubleBetween(0,2*Math.PI));super(Re.toShape(t),{stroke:Re.hueVectorToPaint(s,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});f(this,"hueVector");f(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=s,this.edgeCount=t.edges.length;const r=c=>{this.lineJoin=c};o.joinedLinesJoinProperty.link(r),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(r));const l=c=>{this.lineCap=c};o.joinedLinesCapProperty.link(l),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(l))}updateHue(){this.stroke=Re.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:oe.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=Re.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const s=o.theme.simpleRegionHueLUTProperty.value,r=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return b()&&D(r>=0&&r<s.length),o.edgesHaveColorsProperty.value?s[r]:o.theme.blackLineColorProperty}static toShape(t){const o=new U;let s=!0;for(const r of t.halfEdges)s&&(s=!1,o.moveToPoint(r.start.viewCoordinates)),o.lineToPoint(r.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class Si extends H{constructor(e,t,o){super({pickable:!1}),this.vertex=e;const s=.12,l=e.edges.map(w=>w.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(w=>w.times(s)),a=U.polygon(rs.grahamScan([oe.ZERO,...l],!1)).getOffsetShape(-.05),i=new $(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),n=new $(a,{translation:e.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[i,...l.map(w=>new ho({radius:.02,translation:w,fill:o.theme.vertexStatePointProperty}))]});let d=null;const y=Ee.multilink([t,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(w,p,g)=>{const S=()=>{this.children=[]};if(!p){S();return}const C=w.getVertexState(e);if(!g){let E=!1,v=!1;const L=new Set;for(const P of e.edges){const F=w.getEdgeState(P);E=E||F===m.BLACK,v=v||F===m.WHITE,F===m.WHITE&&L.add(P)}if(E||!v){S();return}if(dt.fromLookup(e,(P,F)=>L.has(P)&&L.has(F),!0).equals(C)){S();return}}if(!d||!d.equals(C)){d=C;const E=new U;for(const v of C.getAllowedPairs()){const L=N=>N.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(s);E.moveToPoint(L(v[0])),E.lineToPoint(L(v[1]))}C.allowsEmpty()&&(E.moveTo(.03,0),E.circle(oe.ZERO,.03),E.close()),E.makeImmutable(),i.shape=E}this.children=[n]});this.disposeEmitter.addListener(()=>y.dispose())}}class yi extends H{constructor(e,t,o,s){super({pickable:!1});const r=Ee.multilink([t,s.vertexStateVisibleProperty],(c,a)=>{this.children.forEach(i=>i.dispose()),this.children=[],a&&e.vertices.forEach(i=>{this.addChild(new Si(i,t,s))})});this.disposeEmitter.addListener(()=>r.dispose());const l=c=>{this.visible=!c};o.link(l),this.disposeEmitter.addListener(()=>{o.unlink(l),this.children.forEach(c=>c.dispose())})}}const Ci=.03,Ei=.05;class mi extends ${constructor(e,t,o,s){super(null,{pickable:!1,fill:s.theme.vertexColorProperty});const r=e.edges.map(i=>m.BLACK);let l=s.vertexStyleProperty.value,c=s.smallVertexProperty.value;const a=Ee.multilink([t,o,s.verticesVisibleProperty,s.vertexStyleProperty,s.smallVertexProperty],(i,n,d,y,w)=>{if(this.visible=!n&&d,this.visible){let p=!1;for(let g=0;g<e.edges.length;g++){const S=i.getEdgeState(e.edges[g]);S!==r[g]&&(p=!0,r[g]=S)}if(l!==y&&(l=y,p=!0),c!==w&&(c=w,p=!0),p){const g=new U;for(let S=0;S<e.vertices.length;S++){const C=e.vertices[S];if(C.edges.every(E=>i.getEdgeState(E)!==m.BLACK)){const E=C.viewCoordinates,v=w?Ci:Ei;y==="round"?(g.moveTo(E.x+v,E.y),g.arc(E.x,E.y,v,0,2*Math.PI,!1)):y==="square"?g.rect(E.x-v,E.y-v,2*v,2*v):b()&&D(!1,`unhandled vertex style: ${y}`)}}this.shape=g}}});this.disposeEmitter.addListener(()=>a.dispose())}}class no extends H{constructor(t,o){const s=Xe()({textOptions:{font:kt,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},onEdgeDragStart:()=>{},onEdgeDrag:()=>{},onEdgeDragEnd:()=>{},facePressListener:()=>{},faceBackgroundDragStartListener:F=>this.onFaceBackgroundDragStart(F),onFaceDragStart:()=>{},onFaceDrag:()=>{},onFaceDragEnd:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Ke(null),selectedSectorEditProperty:new Ke(null),style:te,noninteractive:!1,delayEdgeInteractionEmitter:new ye},o),r=s.style,l=new H({visibleProperty:r.faceColorsVisibleProperty}),c=new H({pickableProperty:Qr}),a=new H({pickableProperty:Zr}),i=new H({pickableProperty:Jr}),n=new H({pickableProperty:$r}),d=new H,y=new H({pickable:!1}),w=new H({pickable:!1}),p=new H({renderer:fs.chromium?"canvas":null,pickable:null}),g=new H({pickable:!1}),S=new H,C=new j([t.stateProperty],F=>{if(F.getWeirdEdges().length||F.hasInvalidFaceColors())return!1;const O=F.getSimpleRegions();return O.length===1&&O[0].isSolved});c.addChild(new di(t.board,t.stateProperty,r,s));let E=null;s.noninteractive||(E=new Ks(t.board,s),c.addChild(E)),w.addChild(new Us(t.board,t.stateProperty,C,r));const v=new vt(t.board.outerBoundary,t.board.innerBoundaries,r,s);n.addChild(new mi(t.board,t.stateProperty,C,r)),y.addChild(new yi(t.board,t.stateProperty,C,r)),i.addChild(new Ms(t.board,t.stateProperty,C,r)),s.noninteractive||i.addChild(new Bs(t.board,s.delayEdgeInteractionEmitter,s)),a.addChild(new pi(t.board,t.stateProperty,r)),s.noninteractive||a.addChild(new ui(t.board,s)),d.addChild(new wi(t.board,t.stateProperty,r));super(lo({children:[v,l,c,a,i,n,d,y,w,g,S,p]},s));f(this,"annotationContainer");f(this,"backgroundNode");f(this,"onFaceBackgroundDragStart");f(this,"faceColorViewNode",null);this.puzzle=t;const L=F=>{F?(this.faceColorViewNode=new Ws(t.board,t.stateProperty,r),l.addChild(this.faceColorViewNode)):this.faceColorViewNode&&(this.faceColorViewNode.dispose(),this.faceColorViewNode=null)};r.faceColorsVisibleProperty.link(L),E?this.onFaceBackgroundDragStart=F=>{var O;return(O=E.triggerDrag)==null?void 0:O.call(E,F)}:this.onFaceBackgroundDragStart=()=>{},this.annotationContainer=p;const N=F=>{g.children.forEach(O=>O.dispose()),F&&g.addChild(new gi(F,t.board,r,s))};s.selectedFaceColorHighlightProperty.link(N),this.disposeEmitter.addListener(()=>s.selectedFaceColorHighlightProperty.unlink(N));const P=F=>{S.children.forEach(O=>O.dispose()),F&&S.addChild(new fi(F,v,r,s))};s.selectedSectorEditProperty.link(P),this.disposeEmitter.addListener(()=>s.selectedSectorEditProperty.unlink(P)),this.disposeEmitter.addListener(()=>{r.faceColorsVisibleProperty.unlink(L),[l,c,i,n,d,y,w,a].forEach(O=>{O.children.forEach(T=>T.dispose()),O.dispose()}),C.dispose(),v.dispose()}),this.backgroundNode=v}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}getDualColorViews(){var t;return((t=this.faceColorViewNode)==null?void 0:t.getDualColorViews())??null}}class Ki extends H{constructor(e,t,o){const s=Xe()({style:te},o),r=t.getEmbeddedCompleteData(e.inputFeatureSet),l=t.getEmbeddedCompleteData(e.outputFeatureSet),c=new no(new qt(t.smallBoard,r),{noninteractive:!0,style:s.style}),a=new no(new qt(t.smallBoard,l),{noninteractive:!0,style:s.style}),i=c.getDualColorViews(),n=a.getDualColorViews();if(i&&n){const v=V=>V.faceCount>=s.style.faceColorThresholdProperty.value&&V.isUndecided(),L=V=>Math.min(...V.faces.map(I=>t.smallBoard.faces.indexOf(I))),N=ne.sortBy([...i].filter(v),L),P=ne.sortBy([...n].filter(v),L),F=new Map;for(const V of N)v(V)&&V.faces.forEach(I=>F.set(I,V));const O=[],T=new Map;for(const V of P){const I=V.faces.map(G=>F.get(G)).filter(ne.identity),R=ne.minBy(I,G=>G.faces.length*20+N.indexOf(G));R?T.set(V,R):(T.set(V,null),O.push(V))}const A=[...N,...ne.sortBy(O,L)],M=V=>{const I=A.indexOf(V);return b()&&D(I>=0,"view must be in the list"),console.log(I),oe.createPolar(1,5.5+2*Math.PI*I/A.length)};for(const V of N)V.overrideHueVector(M(V));for(const V of P){const I=T.get(V);I?V.overrideHueVector(M(I)):V.overrideHueVector(M(V))}}const d=e.highlander?new H({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(v=>new co("?",{font:kt,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?s.style.theme.faceValueColorProperty:s.style.theme.faceValueCompletedColorProperty,center:v.viewCoordinates}))}):new H,w=t.tightBounds.dilated(.5),p=.5,g=U.roundRectangle(w.x,w.y,w.width,w.height,p,p),S=new H({children:[c,d],clipArea:g,localBounds:w}),C=new H({children:[a,d],clipArea:g,localBounds:w}),E=new po(new uo({spacing:.2,children:[S,new Os(0,0,20,0,{fill:s.style.theme.uiForegroundColorProperty,stroke:s.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),C]}),{cornerRadius:p*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:s.style.theme.patternAnnotationBackgroundColorProperty});s.children=[E],super(s),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{c.dispose(),a.dispose()})}}const vi=(h,e)=>{at(So,h,e,!0)};class Ne{constructor(e,t,o,s,r,l,c,a,i,n){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=s,this.smallBoard=r,this.toSmallFaceMap=l,this.toSmallEdgeMap=c,this.toSmallSectorMap=a,this.tightBounds=i,this.expandedBounds=n}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const s=this.toSmallFaceMap.get(o);return b()&&D(s),s}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(s=>this.boardPatternBoard.getEdge(s)).map(s=>{const r=this.toSmallEdgeMap.get(s);return b()&&D(r),r})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),s=this.toSmallSectorMap.get(o);return b()&&D(s),s}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const s=this.mapFace(o);s&&t.add(s)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=Vs.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof As)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof bs)this.mapEdge(o.edge).forEach(s=>t.setEdgeState(s,m.BLACK));else if(o instanceof Ds)this.mapEdge(o.edge).forEach(s=>t.setEdgeState(s,m.RED));else if(o instanceof xs)t.setSectorState(this.mapSector(o.sector),x.NOT_ZERO);else if(o instanceof ks)t.setSectorState(this.mapSector(o.sector),x.NOT_ONE);else if(o instanceof Ns)t.setSectorState(this.mapSector(o.sector),x.NOT_TWO);else if(o instanceof Is)t.setSectorState(this.mapSector(o.sector),x.ONLY_ONE);else if(o instanceof Rs){const s=(l,c)=>{const a=this.mapFace(l),i=this.mapFace(c),n=a?t.getFaceColor(a):t.getOutsideColor(),d=i?t.getFaceColor(i):t.getOutsideColor();new We(q(t,n),q(t,d)).apply(t)},r=(l,c)=>{const a=this.mapFace(l),i=this.mapFace(c),n=a?t.getFaceColor(a):t.getOutsideColor(),d=i?t.getFaceColor(i):t.getOutsideColor();new ze(q(t,n),q(t,d)).apply(t)};for(let l=1;l<o.primaryFaces.length;l++)s(o.primaryFaces[l-1],o.primaryFaces[l]);for(let l=1;l<o.secondaryFaces.length;l++)s(o.secondaryFaces[l-1],o.secondaryFaces[l]);o.secondaryFaces.length&&r(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return vi(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o,s){const r=Pt.NOTHING.copy(),l=a=>{r.addPoint(t.getVertex(o.mapVertex(a)).viewCoordinates)};e.vertices.forEach(l);const c=a=>{if(s!=null&&s.sourceFaceFilter&&!s.sourceFaceFilter(a))return;const i=t.getFace(o.mapFace(a));i&&i.vertices.forEach(n=>r.addPoint(n.viewCoordinates))};return e.faces.forEach(c),e.edges.forEach(a=>{let i;if(a.isExit){if(s!=null&&s.sourceExitEdgeFilter&&!s.sourceExitEdgeFilter(a))return;i=o.mapExitEdges(a).map(n=>t.getEdge(n))}else i=[t.getEdge(o.mapNonExitEdge(a))];i.forEach(n=>{r.addPoint(n.start.viewCoordinates),r.addPoint(n.end.viewCoordinates)})}),r}static findBestEmbedding(e,t,o){const s=ws(e,t);if(s.length===0)return null;const r=Pt.NOTHING.copy();o.vertices.forEach(i=>r.addPoint(i.viewCoordinates));const l=r.center;let c=null,a=Number.POSITIVE_INFINITY;for(let i=0;i<s.length;i++){const n=s[i],y=Ne.getEmbeddingBounds(e,t,n).center,w=l.distance(y);w<a&&(a=w,c=n)}return c}static getDisplayEmbedding(e,t,o,s,r){const l=Ne.getEmbeddingBounds(e,t,s,r),c=l.dilated(.5),a=o.faces.filter(S=>{const C=Pt.NOTHING.copy();return S.vertices.forEach(E=>C.addPoint(E.viewCoordinates)),c.intersectsBounds(C)}),i=o.vertices.filter(S=>S.faces.some(C=>a.includes(C))),n=Ss({vertices:i.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates})),faces:a.map(S=>({logicalCoordinates:S.logicalCoordinates,vertices:S.vertices.map(C=>({logicalCoordinates:C.logicalCoordinates,viewCoordinates:C.viewCoordinates}))}))}),d=new ys(n),y=1e-6,w=new Map(a.map((S,C)=>{const E=d.faces.find(v=>v.viewCoordinates.equalsEpsilon(S.viewCoordinates,y));return b()&&D(E),[S,E]})),p=new Map(o.edges.map(S=>{const C=d.edges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,y)||E.start.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,y))??null;return C?[S,C]:null}).filter(S=>S!==null)),g=new Map(o.halfEdges.map(S=>{const C=d.halfEdges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,y))??null;return C?[S,C]:null}).filter(S=>S!==null));return b()&&D(s),new Ne(e,t,o,s,d,w,p,g,l,c)}static getOptionsForRule(e){const t=e.outputFeatureSet.getAffectedFaces(),o=e.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:s=>t.has(s),sourceExitEdgeFilter:s=>o.has(s)}}static getDisplayEmbeddingFromRule(e,t,o){return Ne.getDisplayEmbedding(e.patternBoard,t,t.board,o,Ne.getOptionsForRule(e))}}export{Hi as $,cr as A,dr as B,hr as C,ur as D,Ki as E,zs as F,pr as G,gr as H,fr as I,wr as J,Sr as K,yr as L,Cr as M,Er as N,mr as O,no as P,vr as Q,Pr as R,Fr as S,Vr as T,Hs as U,Si as V,$s as W,Qs as X,er as Y,ro as Z,io as _,ki as a,li as a0,Qe as a1,Dt as a2,Ni as a3,Ii as a4,Wi as a5,ni as a6,Je as a7,Or as a8,si as a9,vi as aa,_ as ab,z as ac,$e as ad,Po as ae,je as af,ri as ag,ue as ah,zi as ai,Mi as aj,hi as ak,te as al,Bi as am,Xr as an,Ne as ao,qs as ap,xr as b,kr as c,Nr as d,Br as e,Ui as f,Ir as g,To as h,Hr as i,zr as j,Ur as k,Kr as l,jr as m,Gr as n,Ar as o,qr as p,tr as q,or as r,Ri as s,sr as t,rr as u,Yr as v,ir as w,ar as x,nr as y,lr as z};
