var be=Object.defineProperty;var Fe=(w,h,i)=>h in w?be(w,h,{enumerable:!0,configurable:!0,writable:!0,value:i}):w[h]=i;var ne=(w,h,i)=>Fe(w,typeof h!="symbol"?h+"":h,i);import"./Vector2Property-mpypjo8N.js";import{N as _,P as re,R as Pe,L as ae,T as $,D as Be,V as ce,H as j,A as se}from"./PhetioControlledVisibilityProperty-C-W8fgEx.js";import{af as u,d as M,e as S,_ as k,ag as pe,P as xe,S as Q,ah as q,m as K,ai as Me,p as Se,H as Ge,Q as R,aj as le,R as qe,T as Le,V as Te,U as He,W as We}from"./patternBoards-59tNjMFd.js";import{l as ze,P as de,F as De,T as oe}from"./PatternBoardSolver-By-2anvW.js";import{f as je,e as ie,F as A,a as L,B as Re,R as H,S as Ae,g as Oe,h as ke}from"./PatternRule-DfusC3Hu.js";import{I as Je,B as Ue,c as ge}from"./BasicPuzzle-D1EmEwC1.js";import{d as ue,s as $e}from"./TPlanarMappedPatternBoard-BmAuuXVh.js";import{R as X}from"./Theme-D5xBVTq4.js";import{P as O}from"./PatternNode-BBc8vHgN.js";import{P as Y}from"./PlanarMappedPatternBoardNode-Cs64mmi8.js";import"./localStorage-B8VWGy9j.js";class P extends u{constructor(i,o){const t=new Set,n=new Set;o.forEach(e=>{e.vertices.forEach(g=>{t.add(g)}),e.edges.forEach(g=>{n.add(g)})});const r=Array.from(n),a=[],c=[];for(const e of t)e.faces.every(g=>o.includes(g))?c.push(e):a.push(e);const d=[...c,...a];super({numNonExitVertices:c.length,numExitVertices:a.length,type:"faces",vertexLists:o.map(e=>e.vertices.map(g=>d.indexOf(g)))});ne(this,"patternBoard");ne(this,"planarPatternMap");this.originalBoard=i,this.originalBoardFaces=o;const m=new Map(d.map((e,g)=>[this.vertices[g],e.viewCoordinates])),C=new Map;this.edges.forEach(e=>{if(!e.isExit){const g=d[e.vertices[0].index],l=d[e.vertices[1].index];C.set(e,[g.viewCoordinates,l.viewCoordinates])}});const f=new Map;this.sectors.forEach(e=>{M()&&S(e.edges.length===2);const g=d[e.edges[0].vertices[0].index],l=d[e.edges[0].vertices[1].index],V=d[e.edges[1].vertices[0].index],x=d[e.edges[1].vertices[1].index],b=r.find(T=>T.vertices.includes(g)&&T.vertices.includes(l)),B=r.find(T=>T.vertices.includes(V)&&T.vertices.includes(x));M()&&S(b&&B);const F=Je(b,B);M()&&S(F);const J=F.start.viewCoordinates,U=F.end.viewCoordinates,z=F.next.end.viewCoordinates;f.set(e,[J,U,z])});const p=new Map;this.faces.forEach(e=>{if(!e.isExit){const g=e.vertices.map(x=>d[x.index]),l=o.find(x=>x.vertices.every(b=>g.includes(b)));M()&&S(l);const V=l.vertices.map(x=>x.viewCoordinates);p.set(e,V)}}),this.faces.forEach(e=>{if(e.isExit){M()&&S(e.edges.length===1);const g=e.edges[0],l=d[g.vertices[0].index],V=d[g.vertices[1].index];M()&&S(l&&V);const x=r.find(F=>F.vertices.includes(l)&&F.vertices.includes(V));M()&&S(x);const b=o.includes(x.faces[0])?x.faces[1]:x.faces[0];M()&&S(b,"Did we hit null as in --- edge of board? can we expand the search pattern?");const B=[l.viewCoordinates,V.viewCoordinates,l.viewCoordinates.average(V.viewCoordinates).average(b.viewCoordinates)];p.set(e,B)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:m,edgeMap:C,sectorMap:f,faceMap:p}}static getSemiAdjacentFaces(i,o){const t=new Set;return o.vertices.forEach(n=>{n.faces.forEach(r=>{r!==o&&t.add(r)})}),t}static getFirstGeneration(i){const o=k.uniq(i.faces.map(n=>n.vertices.length)),t=i.vertices.map(n=>n.viewCoordinates).reduce((n,r)=>n.plus(r)).timesScalar(1/i.vertices.length);return o.map(n=>{const r=k.minBy(i.faces.filter(a=>a.vertices.length===n),a=>a.viewCoordinates.distanceSquared(t));return M()&&S(r),new P(i,[r])})}static getNextGeneration(i){const o=[];return i.forEach(t=>{const n=new Set;t.originalBoardFaces.forEach(r=>{P.getSemiAdjacentFaces(t.originalBoard,r).forEach(a=>{t.originalBoardFaces.includes(a)||n.add(a)})}),n.forEach(r=>{const a=[...t.originalBoardFaces,r],c=new P(t.originalBoard,a);o.some(d=>pe(d,c))||o.push(c)})}),o}static getFirstNGenerations(i,o){const n=[P.getFirstGeneration(i)];for(let r=0;r<o-1;r++)n.push(P.getNextGeneration(n[n.length-1]));return n}static getUniformTilingGenerations(i,o){const t=i.generate({width:15,height:15}),n=new xe(t,i.scale??1);return P.getFirstNGenerations(n,o)}}const Z=w=>{const h=new Map,i=je.get(w).connectedComponents,o=a=>i.findIndex(c=>c.includes(a)),t=(a,c)=>{const d=a.length>c.length||a.length===c.length&&a[0]<c[0],m=d?a:c,C=d?c:a,f=`${m.join(",")}-${C.join(",")}`;if(h.has(f))return h.get(f);{const p=ie.fromPrimarySecondaryFaces(a.map(e=>w.faces[e]),c.map(e=>w.faces[e]));return h.set(f,p),p}},n=w.faces.length,r=he(n).flatMap(a=>{const c=[];if(a.some(f=>{const p=f.map(e=>o(w.faces[e]));return p.some(e=>e!==p[0])}))return c;const d=a.map(f=>fe(f.length).map(p=>{const e=p[0].map(l=>f[l]),g=p[1].map(l=>f[l]);return t(e,g)})),m=[],C=f=>{if(f===d.length){c.push(m.slice());return}else for(let p=0;p<d[f].length;p++)m.push(d[f][p]),C(f+1),m.pop()};return C(0),c});return k.sortBy(r,a=>a.length*1e4+a.reduce((c,d)=>c+d.allFaces.size,0))},Qe=w=>{let h=[];const i=(o,t,n)=>{if(t===o.length){h.push(n.map(r=>r.slice()));return}i(o,t+1,n),i(o,t+1,[...n,[o[t]]]);for(let r=0;r<n.length;r++)n[r].push(o[t]),i(o,t+1,n),n[r].pop()};return i(Array.from({length:w},(o,t)=>t),0,[]),h},he=w=>Qe(w).filter(h=>h.every(i=>i.length>1)),fe=w=>{const h=[],i=(o,t,n)=>{if(o===w){(t.length===0||n.length===0||Math.min(...t)<Math.min(...n))&&t.length&&h.push([t.slice(),n.slice()]);return}t.push(o),i(o+1,t,n),t.pop(),n.push(o),i(o+1,t,n),n.pop()};return i(0,[],[]),h};class Ke extends _{constructor(h,i,o){super(),this.pattern=h,this.targetBoard=i,this.embedding=o;const t=new _({scale:30});this.addChild(t),i.board.faces.forEach(r=>{t.addChild(new re(Q.polygon(r.vertices.map(a=>a.viewCoordinates)),{stroke:"#888",lineWidth:.02}))});const n=t.localBounds;this.addChild(Pe.bounds(t.bounds.dilated(5)));for(const[r,a]of o.getExitEdgeMap()){const c=r.index;for(const d of a){const m=i.getEdge(d),C=new ae(m.vertices[0].viewCoordinates,m.vertices[1].viewCoordinates,{stroke:"#066",lineWidth:.03});t.addChild(C);const f=new $(c,{font:X,maxWidth:.4,maxHeight:.4,center:m.vertices[0].viewCoordinates.average(m.vertices[1].viewCoordinates),fill:"rgba(128,255,255,0.5)"});t.addChild(f)}}for(const[r,a]of o.getNonExitEdgeMap()){const c=i.getEdge(a),d=r.index,m=new ae(c.vertices[0].viewCoordinates,c.vertices[1].viewCoordinates,{stroke:"#f00",lineWidth:.03});t.addChild(m);const C=new $(d,{font:X,maxWidth:.4,maxHeight:.4,center:c.vertices[0].viewCoordinates.average(c.vertices[1].viewCoordinates),fill:"#fff"});t.addChild(C)}for(const[r,a]of o.getFaceMap()){const c=i.getFace(a),d=r.index,m=r.isExit,C=c?Q.polygon(c.vertices.map(p=>p.viewCoordinates)):Q.bounds(n.dilated(.13)).shapeDifference(Q.bounds(n)),f=new re(C,{fill:m?"rgba(0,0,0,0.2)":"rgba(50,0,0,0.5)"});if(t.addChild(f),c){const p=()=>{const g=i.getEdge(o.getNonExitEdgeMap().get(r.edges[0])).vertices.map(l=>l.viewCoordinates);return c.viewCoordinates.average(g[0].average(g[1]))},e=new $(d,{font:X,maxWidth:.4,maxHeight:.4,center:m?p():c.viewCoordinates,fill:m?"#f88":"#8f8"});t.addChild(e)}}for(const[r,a]of o.getVertexMap()){const c=i.getVertex(a),d=r.index,m=r.isExit,C=new $(d,{font:X,maxWidth:.4,maxHeight:.4,center:c.viewCoordinates,fill:m?"#0ff":"#88f"});t.addChild(C)}}}self.assertions.enableAssert();const I=new _,Xe=new _({renderer:"svg",children:[I]}),ee=new Be(Xe,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(ee.domElement);ee.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");(async()=>{const w=new De,h=new oe("a","a"),i=new oe("b","b"),o=new oe("c","c");w.addFormula(ze([h,i,o]));let t;do t=w.getNextSolution(),console.log(t);while(t!==null);const n=new u({numNonExitVertices:0,numExitVertices:0,type:"edge"});console.log("edgeBoard",n),console.log(q(n.descriptor));const r=new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3});console.log("nonExitVertexBoard",r),console.log(q(r.descriptor));const a=new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]});console.log("exitVertexBoard",a),console.log(q(a.descriptor));const c=new u({numNonExitVertices:0,numExitVertices:3,type:"faces",vertexLists:[[0,1,2]]});console.log("facesBoard",c),console.log(q(c.descriptor));const d=new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2],[0,1,3]]});console.log("facesBoard2",d),console.log(q(d.descriptor));const m=Ue.loadDefaultPuzzle(),C=new ge(m.board);console.log("boardPatternBoard",C),console.log(q(C.descriptor));const f=new K(2,3),p=new ge(f);console.log("simplePatternBoard",p),console.log(q(p.descriptor));const e=new ce({x:10,y:10,align:"left"});I.addChild(e);const g=V=>{e.addChild(new se(V,{margin:5}))},l=(V,x)=>{console.log("----------"),console.log(V),console.log("pattern",q(x.descriptor),x);const b=le(x,p);console.log("embeddings",b),e.addChild(new j({children:b.map(B=>new Ke(x,p,B))}))};l("edge pattern",new u({numNonExitVertices:0,numExitVertices:0,type:"edge"})),l("2-count exit-vertex no sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]})),l("2-count exit-vertex one sector",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]})),l("3-count exit-vertex two adjacent sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]})),l("4-count exit-vertex two opposite sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]})),l("4-count exit-vertex three-adjacent sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]})),l("2-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2})),l("3-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3})),l("4-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4})),l("square pattern",new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]})),l("2 adjacent squares pattern",new u({numNonExitVertices:0,numExitVertices:6,type:"faces",vertexLists:[[0,1,4,3],[1,2,5,4]]})),l("2 diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]})),l("L square pattern",new u({numNonExitVertices:0,numExitVertices:8,type:"faces",vertexLists:[[0,1,2,3],[0,3,4,5],[0,5,6,7]]})),l("4-square pattern",new u({numNonExitVertices:1,numExitVertices:8,type:"faces",vertexLists:[[0,1,2,3],[0,3,4,5],[0,5,6,7],[0,7,8,1]]})),l("3 diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:10,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6],[5,7,8,9]]})),l("3 semi-diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:10,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6],[4,7,8,9]]}));{g(new j({spacing:10,align:"origin",children:Me.map(V=>new Y({patternBoard:V,planarPatternMap:Se.get(V)}))}));{const V=s=>new se(new j({spacing:10,children:s.map(v=>new Y(v))}),{margin:5}),x=s=>new ce({spacing:10,align:"left",children:s.map(v=>V(v))}),b=s=>{const v=k.uniq(s.faces.map(y=>y.vertices.length)),E=s.vertices.map(y=>y.viewCoordinates).reduce((y,N)=>y.plus(N)).timesScalar(1/s.vertices.length);return v.map(y=>{const N=k.minBy(s.faces.filter(G=>G.vertices.length===y),G=>G.viewCoordinates.distanceSquared(E));return M()&&S(N),new P(s,[N])})},B=(s,v)=>{const y=[b(s)];for(let N=0;N<v-1;N++)y.push(P.getNextGeneration(y[y.length-1]));return y},F=(s,v)=>{const E=s.generate({width:15,height:15}),y=new xe(E,s.scale??1);return B(y,v)};console.log("---- square ----");const J=ue('{"patternBoard":"[0,9,\\"faces\\",[[0,1,2,3],[4,5,0,6],[1,7,8,2]]]","planarPatternMap":"[[[9,9],[10,9],[10,10],[9,10],[8,8],[9,8],[8,9],[11,9],[11,10]],[[0,1],[1,2],[2,3],[0,3],[4,5],[0,5],[0,6],[4,6],[1,7],[7,8],[2,8]],[[[9,9],[10,9],[10,10]],[[10,9],[10,10],[9,10]],[[10,10],[9,10],[9,9]],[[9,10],[9,9],[10,9]],[[8,8],[9,8],[9,9]],[[9,8],[9,9],[8,9]],[[9,9],[8,9],[8,8]],[[8,9],[8,8],[9,8]],[[10,9],[11,9],[11,10]],[[11,9],[11,10],[10,10]],[[11,10],[10,10],[10,9]],[[10,10],[10,9],[11,9]]],[[[9,9],[10,9],[10,10],[9,10]],[[8,8],[9,8],[9,9],[8,9]],[[10,9],[11,9],[11,10],[10,10]],[[9,9],[10,9],[9.5,8.75]],[[10,10],[9,10],[9.5,10.25]],[[9,9],[9,10],[8.75,9.5]],[[8,8],[9,8],[8.5,7.75]],[[9,9],[9,8],[9.25,8.5]],[[9,9],[8,9],[8.5,9.25]],[[8,8],[8,9],[7.75,8.5]],[[10,9],[11,9],[10.5,8.75]],[[11,9],[11,10],[11.25,9.5]],[[10,10],[11,10],[10.5,10.25]]]]"}'),U=ue('{"patternBoard":"[0,9,\\"faces\\",[[0,1,2,3],[4,5,0,6],[3,2,7,8]]]","planarPatternMap":"[[[9,9],[10,9],[10,10],[9,10],[8,8],[9,8],[8,9],[10,11],[9,11]],[[0,1],[1,2],[2,3],[0,3],[4,5],[0,5],[0,6],[4,6],[2,7],[7,8],[3,8]],[[[9,9],[10,9],[10,10]],[[10,9],[10,10],[9,10]],[[10,10],[9,10],[9,9]],[[9,10],[9,9],[10,9]],[[8,8],[9,8],[9,9]],[[9,8],[9,9],[8,9]],[[9,9],[8,9],[8,8]],[[8,9],[8,8],[9,8]],[[9,10],[10,10],[10,11]],[[10,10],[10,11],[9,11]],[[10,11],[9,11],[9,10]],[[9,11],[9,10],[10,10]]],[[[9,9],[10,9],[10,10],[9,10]],[[8,8],[9,8],[9,9],[8,9]],[[9,10],[10,10],[10,11],[9,11]],[[9,9],[10,9],[9.5,8.75]],[[10,9],[10,10],[10.25,9.5]],[[9,9],[9,10],[8.75,9.5]],[[8,8],[9,8],[8.5,7.75]],[[9,9],[9,8],[9.25,8.5]],[[9,9],[8,9],[8.5,9.25]],[[8,8],[8,9],[7.75,8.5]],[[10,10],[10,11],[10.25,10.5]],[[10,11],[9,11],[9.5,11.25]],[[9,10],[9,11],[8.75,10.5]]]]"}');e.addChild(new j({spacing:10,children:[new Y(J,{labels:!0}),new Y(U,{labels:!0})]})),console.log(pe(J.patternBoard,U.patternBoard));const z=B(new K(20,20),5);e.addChild(x(z)),z.forEach((s,v)=>{console.log(`-- ${v} --`),s.forEach(E=>{console.log(JSON.stringify($e(E)))})}),console.log("---- hex ----");const T=B(new Ge(5,1,!0),4);e.addChild(x(T)),console.log("---- rhombille ----");const me=F(R(qe,{width:8,height:8}),4);e.addChild(x(me)),console.log("---- cairo ----");const we=F(R(Le,{width:8,height:8,squareRegion:!0}),4);e.addChild(x(we)),console.log("---- triangular ----");const ve=F(R(Te,{width:6,height:5}),4);e.addChild(x(ve)),console.log("---- snub square ----");const Ee=F(R(He,{width:5,height:6,squareRegion:!0}),4);e.addChild(x(Ee)),console.log("---- trihexagonal ----");const Ce=F(R(We,{width:9,height:9}),4);e.addChild(x(Ce)),console.log(he(5).map(s=>JSON.stringify(s))),console.log(fe(5).map(s=>JSON.stringify(s))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]})).map(s=>s.map(v=>v.toCanonicalString()))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]}))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]})));const te=new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]}),Ve=le(te,te);console.log(Z(te).filter(s=>ie.areCanonicalWith(s,Ve)));{const s=b(new K(20,20))[0],v=P.getNextGeneration(P.getNextGeneration(P.getNextGeneration(b(new K(20,20)))))[0];e.addChild(new O(s,A.fromSolution(s,[s.edges[0],s.edges[1],s.edges[4]]),s.planarPatternMap)),[[],[new L(s.faces[0],2)],[new Re(s.edges[0])],[new H(s.edges[0])],[ie.fromPrimarySecondaryFaces([s.faces[0],s.faces[1]],[s.faces[2]])],[new Ae(s.sectors[3])]].forEach(N=>{const G=new de(s);N.forEach(W=>G.addFeature(W));const D=G.getRemainingSolutions();console.log(D),e.addChild(new se(new j({spacing:10,children:D.map(W=>new O(s,A.fromSolution(s,W),s.planarPatternMap))}),{margin:5}))}),g(new O(v,A.fromFeatures(v,[new L(v.faces[0],3),new L(v.faces[1],3),new H(v.edges.filter(N=>N.isExit)[1]),new H(v.edges.filter(N=>N.isExit)[3])]),v.planarPatternMap));const E=z[4][7],y=[new L(E.faces[0],null),new L(E.faces[1],null),new L(E.faces[2],2),new L(E.faces[3],null),new L(E.faces[4],null),new H(E.edges[1]),new H(E.edges[12]),new H(E.edges[17]),new H(E.edges[21])];g(new O(E,A.fromFeatures(E,y),E.planarPatternMap,{labels:!0})),g(new O(s,A.empty(s),s.planarPatternMap,{labels:!0}));{const N=new de(E),G=y;G.forEach(Ne=>N.addFeature(Ne));const D=N.getRemainingSolutions();console.log(D);const W=Oe(E,G);console.log(W);const ye=ke(D,W);console.log(ye)}}}}ee.setWidthHeight(Math.ceil(I.right+10),Math.ceil(I.bottom+10)),ee.updateDisplay()})();
