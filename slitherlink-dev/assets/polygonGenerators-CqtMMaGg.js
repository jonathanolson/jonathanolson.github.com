var A=Object.defineProperty;var N=(s,t,e)=>t in s?A(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var u=(s,t,e)=>(N(s,typeof t!="symbol"?t+"":t,e),e);import{N as $,F as H,P as M}from"./PhetioControlledVisibilityProperty-DLWPAyRL.js";import{g as v,h as R,R as x,V as p}from"./UnivariatePolynomial-B7u1WGdr.js";import{_ as V,S as D,L as O,e as E,f as F,G as z,I as G,J as L,K as U,M as J,N as X,O as n,Q as Y,R as Q,T as _,U as K,V as Z,W as j,X as ee,Y as te,Z as re,$ as ae,a0 as se,a1 as le,a2 as oe,a3 as ie,a4 as ce,a5 as de,a6 as ge,a7 as ne,a8 as he,a9 as ue,aa as pe}from"./patternBoards-DsO5TEFU.js";import{D as Se,E as fe,U as me}from"./DisplayEmbedding-Cthdqix5.js";import{c as we}from"./Theme-tmTDxZc0.js";import"./TextPushButton-jnVfkaQ5.js";import{E as Ce,h as I,C as Ee}from"./BasicPuzzle-DmOtz3tZ.js";import{I as C,G as Fe,S as Ve,H as ve,J as Te,K as ye,L as Re,M as xe,N as be,O as ke,P as Me,Q as De,R as Oe,V as Ie,T as We,U as Be,W as Pe,X as qe,Y as Ae,Z as Ne,_ as $e,$ as He,a0 as ze}from"./autoSolver-C98O43Em.js";import{S as T,g as W,s as B,M as P,b as Ge}from"./SATSolver-Ba-nmlKk.js";class ht extends ${constructor(t,e,a,c=null){let l;const h=r=>new D().moveToPoint(r.start.viewCoordinates).lineToPoint(r.end.viewCoordinates).getStrokedShape(new O({lineWidth:.2,lineCap:"round"})).getStrokedShape(new O({lineWidth:.02})),o=(r,i)=>new M(h(r),{fill:i}),S=[];if(e.type==="ForcedLine")l=[o(e.whiteEdge,"red"),o(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")l=[o(e.whiteEdge,"red"),...e.redEdges.map(r=>o(r,"blue"))];else if(e.type==="JointToRed")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.blackEdges.map(r=>o(r,"blue"))];else if(e.type==="FaceSatisfied")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.blackEdges.map(r=>o(r,"blue"))];else if(e.type==="FaceAntiSatisfied")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.redEdges.map(r=>o(r,"blue"))];else if(e.type==="ForcedSolveLoop")l=[...e.regionEdges.map(r=>o(r,"blue")),...e.pathEdges.map(r=>o(r,"red"))];else if(e.type==="PrematureForcedLoop")l=[...e.regionEdges.map(r=>o(r,"blue")),...e.pathEdges.map(r=>o(r,"red"))];else if(e.type==="CompletingEdgesAfterSolve")l=[...e.whiteEdges.map(r=>o(r,"red"))];else if(e.type==="FaceColoringBlackEdge")l=[o(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")l=[o(e.edge,"red")];else if(e.type==="FaceColorToBlack")l=[o(e.edge,"red")];else if(e.type==="FaceColorToRed")l=[o(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")l=[...e.face.edges.map(r=>o(r,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")l=[...e.balancedPairs.flatMap((r,i)=>{const d=["green","blue","black"][i%3],g=["magenta","orange","yellow"][i%3];return[...r[0].map(w=>o(w,d)),...r[1].map(w=>o(w,g))]})],e.type==="FaceColorMatchToRed"?l.push(...e.matchingEdges.map(r=>o(r,"red"))):e.type==="FaceColorMatchToBlack"?l.push(...e.matchingEdges.map(r=>o(r,"red"))):e.type==="FaceColorBalance"&&(l.push(...e.matchingEdges.map(r=>o(r,"orange"))),l.push(...e.oppositeEdges.map(r=>o(r,"red"))));else if(e.type==="DoubleMinusOneFaces")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")l=[e.sector.edge,e.sector.next.edge].map(r=>o(r,"red"));else if(e.type==="ForcedSector"){const r=[...e.toRedEdges,...e.toBlackEdges];l=[e.sector.edge,e.sector.next.edge].map(i=>o(i,r.includes(i)?"red":"blue"))}else if(e.type==="StaticFaceSectors")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="VertexState")l=e.vertex.edges.map(r=>o(r,"blue"));else if(e.type==="VertexStateToEdge")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="VertexStateToSector")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")l=V.uniq([...e.facesA,...e.facesB].flatMap(r=>r.edges)).map(r=>o(r,"red"));else if(e.type==="FaceState")l=e.face.edges.map(r=>o(r,"red"));else if(e.type==="FaceStateToEdge")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="FaceStateToSector")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const r=new Set([...e.facesA,...e.facesB].flatMap(d=>d.edges)),i=e.face.edges.filter(d=>!r.has(d));l=[...[...r].map(d=>o(d,"red")),...i.map(d=>o(d,"blue"))]}else if(e.type==="FaceStateToVertexState")l=e.face.edges.filter(i=>e.vertices.includes(i.start)||e.vertices.includes(i.end)).map(i=>o(i,"red"));else if(e.type==="Pattern"){if(l=[],c){const r=Se.getDisplayEmbedding(e.rule.patternBoard,e.boardPatternBoard,e.boardPatternBoard.board,e.embedding),i=.5+.05,d=.15,g=r.expandedBounds.top+d-(c.top+i),w=c.bottom-i-(r.expandedBounds.bottom-d),f=new fe(e.rule,r,{maxWidth:c.width-2*i,maxHeight:Math.max(g,w),inputListeners:[new H({fire:()=>{console.log(e.rule.getBinaryIdentifier());const m=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");m&&m.focus()}})],cursor:"pointer"});g>w?f.centerBottom=r.expandedBounds.centerTop.plusXY(0,-d):f.centerTop=r.expandedBounds.centerBottom.plusXY(0,d),f.left<c.left+i&&(f.left=c.left+i),f.right>c.right-i&&(f.right=c.right-i);{const m=r.tightBounds.dilated(.21),k=.1;l.push(new M(D.roundRectangle(m.x,m.y,m.width,m.height,k,k),{stroke:we.blackLineColorProperty,lineWidth:.13,pickable:!1}))}l.push(f)}}else l=[],console.log(`unknown type: ${e.type}`);super({children:l,pickable:e.type==="Pattern"?null:!1}),this.board=t,this.annotation=e,this.style=a,this.disposeEmitter.addListener(()=>S.forEach(r=>r()))}static getHintNode(t){return new me(t.type)}}class Le{constructor(t,e,a){u(this,"edgeStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(E()&&F(this.board.edges.includes(t)),e!==Ce.WHITE){const a=this.solvedState.getEdgeState(t);if(e!==a)throw new C(`Attempt to make edge ${e} when it should be ${a}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ue{constructor(t,e,a){u(this,"faceColorsChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,a,c,l){if(l)throw new C("invalid face color?");const h=new Set([...a.values(),...c.keys(),...a.values()]),o=new Map(this.currentState.getFaceColorMap());for(const i of a.keys())o.set(i,a.get(i));const S=i=>c.has(i)?c.get(i):[...t].includes(i)?this.currentState.getOppositeFaceColor(i):null,r=new Map;for(const i of o.keys()){const d=o.get(i);r.has(d)||r.set(d,new Set([i])),r.get(d).add(i)}for(const i of h){const d=r.get(i);if(!d)continue;const g=[...d];E()&&F(g.length>0);const w=this.solvedState.getFaceColor(g[0]);for(const m of g)if(this.solvedState.getFaceColor(m)!==w)throw new C("invalid face color");const f=S(i);if(f){let m;if(f.colorState===I.INSIDE?m=this.solvedState.getInsideColor():f.colorState===I.OUTSIDE?m=this.solvedState.getOutsideColor():m=this.solvedState.getFaceColor([...r.get(f)][0]),w===m)throw new C("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Je{constructor(t,e,a){u(this,"simpleRegionsChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,a,c){if([...a].length)throw new C("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Xe{constructor(t,e,a){u(this,"faceValueChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new C("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ye{constructor(t,e,a){u(this,"sectorStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){E()&&F(this.board.halfEdges.includes(t));const a=this.solvedState.getSectorState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make sector ${e} when it should be ${a}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Qe{constructor(t,e,a){u(this,"vertexStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){E()&&F(this.board.vertices.includes(t));const a=this.solvedState.getVertexState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make vertex ${e} when it should be ${a}`);const c=this.currentState.getVertexState(t);if(!e.isSubsetOf(c))throw new C("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class _e{constructor(t,e,a){u(this,"faceStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){E()&&F(this.board.faces.includes(t));const a=this.solvedState.getFaceState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make face ${e} when it should be ${a}`);const c=this.currentState.getFaceState(t);if(!e.isSubsetOf(c))throw new C("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class ut{constructor(t,e,a){u(this,"anyStateChangedEmitter",new v);u(this,"edgeStateValidator");u(this,"faceValueValidator");u(this,"simpleRegionDataValidator");u(this,"faceColorValidator");u(this,"sectorStateValidator");u(this,"vertexStateValidator");u(this,"faceStateValidator");E()&&F(t),E()&&F(a),this.edgeStateValidator=new Le(t,e,a),this.faceValueValidator=new Xe(t,e,a),this.simpleRegionDataValidator=new Je(t,e,a),this.faceColorValidator=new Ue(t,e,a),this.sectorStateValidator=new Ye(t,e,a),this.vertexStateValidator=new Qe(t,e,a),this.faceStateValidator=new _e(t,e,a)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,a,c){this.simpleRegionDataValidator.modifyRegions(t,e,a,c)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,a,c,l){this.faceColorValidator.modifyFaceColors(t,e,a,c,l)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const pt=(s,t,e)=>new Fe([new Ve(s,t),new ve(s,t),new Te(s,t),new ye(s,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Re(s,t,{solveToRed:!0,solveToBlack:!0}),new xe(s,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new be(s,t),new ke(s,t),new Me(s,t),new De(s,t),new Oe(s,t),new Ie(s,t,{solveToRed:!0,solveToBlack:!0}),new We(s,t),new Be(s,t,{solveToRed:!0,solveToBlack:!0}),new Pe(s,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new qe(s,t),new Ae(s,t),new Ne(s,t,{solveToRed:!0,solveToBlack:!0}),new $e(s,t),new He(s,t),new ze(s,t)]);let y=null,b=0;const St=()=>{if(y&&(b++,b>5)){const s=y;y=null,s(null)}},Ke=async function(s){return new Promise((t,e)=>{y=t,b=0,T.debugSleep&&console.log("sleep start"),setTimeout(()=>{T.debugSleep&&console.log("sleep end"),y===t&&(y=null,t(null)),T.debugSleep&&console.log("resolved")},s)})};class Ze extends Error{constructor(){super("Interrupted")}}const q=async function(s,t){if(await Ke(s),T.debugSleep&&console.log("after sleep before interrupt check"),t.value)throw new Ze},ft=async(s,t,e)=>{let a=0;for(;a++<100;){const c=Ee.fromFaces(s,()=>null),l=R.shuffle(s.faces);let h=-1,o=[];const S=r=>{try{return o=B(s,r,{maxIterations:1e4,failOnMultipleSolutions:!0}),o.length}catch(i){if(i instanceof P)return 2;if(i instanceof Ge)return 0;throw i}};for(const r of l){T.debugSleep&&console.log("going to sleep"),t&&await q(0,t),T.debugSleep&&console.log("finished sleep, generating next!");let i=R.shuffle(V.range(0,r.edges.length));i[0]===0&&(i=R.shuffle(i));for(const d of i){const g=c.createDelta();if(g.setFaceValue(r,d),h=S(g),h>=1){g.apply(c),e&&e.emit(s.faces.indexOf(r),d);break}}if(h===1)break}if(h===1)return W(s,c,o[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},mt=async(s,t=()=>!0,e,a)=>{const c=s.board,l=s.cleanState.clone(),h=R.shuffle(c.faces),o=S=>{try{return B(c,S,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(r){if(r instanceof P)return!0;throw r}};E()&&F(!o(l),"Initial state has multiple solutions"),E()&&F(t(c,l.clone()),"Initial state is not easy enough");for(const S of h){e&&await q(0,e);const r=l.getFaceValue(S);if(r===null){a&&a.emit(c.faces.indexOf(S),null);continue}const i=l.createDelta();i.setFaceValue(S,null),!o(i)&&t(c,i.clone())?(i.apply(l),a&&a.emit(c.faces.indexOf(S),null)):a&&a.emit(c.faces.indexOf(S),r)}return W(s.board,l,s.blackEdges)},je={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new x(2,50)},height:{label:"Height",type:"integer",range:new x(2,50)}},defaultParameterValues:{width:6,height:10},generate:s=>{const t=s.width,e=s.height;return V.range(0,e).flatMap(a=>V.range(0,t).map(c=>[new p(c,a),new p(c+1,a),new p(c+1,a+1),new p(c,a+1)]))}},et={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new x(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new x(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:s=>{const t=s.radius,e=s.isPointyTop,a=s.holeRadius;let c,l;e?(c=new p(Math.sqrt(3),0),l=new p(Math.sqrt(3)/2,3/2)):(c=new p(3/2,Math.sqrt(3)/2),l=new p(0,Math.sqrt(3)));const h=[new p(1,0),new p(1,-1),new p(0,-1),new p(-1,0),new p(-1,1),new p(0,1)],o=V.range(0,6).map(d=>h[d].plus(h[(d+1)%6])),S=d=>o.map(g=>g.plus(d.timesScalar(3))),r=(d,g)=>(Math.abs(d.x-g.x)+Math.abs(d.x+d.y-g.x-g.y)+Math.abs(d.y-g.y))/2,i=[];for(let d=-t;d<=t;d++)for(let g=Math.max(-t,-d-t);g<=Math.min(t,-d+t);g++){const w=new p(d,g);r(w,new p(0,0))>=a&&i.push(S(w).map(f=>c.timesScalar(f.x).plus(l.timesScalar(f.y)).timesScalar(1/3)))}return i}},tt={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:s=>{const t={6:z,10:G,11:L,13:U,14:J,20:X}[s.radius];E()&&F(t);const e=.01,a=t.thinShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(h=>h.timesScalar(e)));return[...t.thickShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(h=>h.timesScalar(e))),...a]}},wt=[je,n(Y,{width:8,height:8}),et,n(Q,{width:8,height:8,squareRegion:!0}),n(_,{width:5,height:6,squareRegion:!0}),n(K,{width:6,height:5}),n(Z,{width:9,height:9}),n(j,{width:9,height:9}),n(ee,{width:7,height:8}),n(te),n(re),n(ae),n(se,{squareRegion:!0}),n(le),n(oe),n(ie,{width:9,height:9}),n(ce),n(de,{width:9,height:9}),n(ge),n(ne),n(he,{width:6,height:8,squareRegion:!0}),n(ue),n(pe),tt];export{ht as A,ut as C,mt as a,Ke as b,ft as g,q as i,wt as p,pt as s,St as w};
