var $=Object.defineProperty;var z=(s,t,e)=>t in s?$(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var p=(s,t,e)=>(z(s,typeof t!="symbol"?t+"":t,e),e);import{N,F as H,P as k}from"./PhetioControlledVisibilityProperty-C4xreNPS.js";import{g as v,l as x,R as b,V as S}from"./UnivariatePolynomial-B1fo8xe7.js";import{_ as V,S as M,L as O,e as E,f as F,G,I as L,J,K as U,M as X,N as Y,O as n,Q,R as _,T as K,U as Z,V as j,W as ee,X as te,Y as re,Z as ae,$ as se,a0 as le,a1 as oe,a2 as ie,a3 as ce,a4 as de,a5 as ge,a6 as ne,a7 as he,a8 as ue,a9 as pe,aa as Se}from"./patternBoards-D316jvfQ.js";import{D as fe,E as me}from"./DisplayEmbedding-ChokjhCK.js";import{c as B}from"./Theme-D414G__S.js";import"./TextPushButton-gLDghw4s.js";import{E as we,h as I,C as Ce}from"./BasicPuzzle-qCypyw3t.js";import{I as C,G as Ee,S as Fe,H as Ve,J as ve,K as ye,L as Te,M as Re,N as xe,O as be,P as ke,Q as Me,R as De,V as Oe,T as Be,U as Ie,W as We,X as Pe,Y as qe,Z as Ae,_ as $e,$ as ze,a0 as Ne}from"./autoSolver-CHqufOu6.js";import{S as y,g as W,s as P,M as q,b as He}from"./SATSolver-DB4c3ov9.js";class nt extends N{constructor(t,e,a,c=null){let l;const u=r=>new M().moveToPoint(r.start.viewCoordinates).lineToPoint(r.end.viewCoordinates).getStrokedShape(new O({lineWidth:.2,lineCap:"round"})).getStrokedShape(new O({lineWidth:.02})),o=(r,i)=>new k(u(r),{fill:i}),f=[];if(e.type==="ForcedLine")l=[o(e.whiteEdge,"red"),o(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")l=[o(e.whiteEdge,"red"),...e.redEdges.map(r=>o(r,"blue"))];else if(e.type==="JointToRed")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.blackEdges.map(r=>o(r,"blue"))];else if(e.type==="FaceSatisfied")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.blackEdges.map(r=>o(r,"blue"))];else if(e.type==="FaceAntiSatisfied")l=[...e.whiteEdges.map(r=>o(r,"red")),...e.redEdges.map(r=>o(r,"blue"))];else if(e.type==="ForcedSolveLoop")l=[...e.regionEdges.map(r=>o(r,"blue")),...e.pathEdges.map(r=>o(r,"red"))];else if(e.type==="PrematureForcedLoop")l=[...e.regionEdges.map(r=>o(r,"blue")),...e.pathEdges.map(r=>o(r,"red"))];else if(e.type==="CompletingEdgesAfterSolve")l=[...e.whiteEdges.map(r=>o(r,"red"))];else if(e.type==="FaceColoringBlackEdge")l=[o(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")l=[o(e.edge,"red")];else if(e.type==="FaceColorToBlack")l=[o(e.edge,"red")];else if(e.type==="FaceColorToRed")l=[o(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")l=[...e.face.edges.map(r=>o(r,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")l=[...e.balancedPairs.flatMap((r,i)=>{const d=["green","blue","black"][i%3],g=["magenta","orange","yellow"][i%3];return[...r[0].map(w=>o(w,d)),...r[1].map(w=>o(w,g))]})],e.type==="FaceColorMatchToRed"?l.push(...e.matchingEdges.map(r=>o(r,"red"))):e.type==="FaceColorMatchToBlack"?l.push(...e.matchingEdges.map(r=>o(r,"red"))):e.type==="FaceColorBalance"&&(l.push(...e.matchingEdges.map(r=>o(r,"orange"))),l.push(...e.oppositeEdges.map(r=>o(r,"red"))));else if(e.type==="DoubleMinusOneFaces")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")l=[e.sector.edge,e.sector.next.edge].map(r=>o(r,"red"));else if(e.type==="ForcedSector"){const r=[...e.toRedEdges,...e.toBlackEdges];l=[e.sector.edge,e.sector.next.edge].map(i=>o(i,r.includes(i)?"red":"blue"))}else if(e.type==="StaticFaceSectors")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="VertexState")l=e.vertex.edges.map(r=>o(r,"blue"));else if(e.type==="VertexStateToEdge")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="VertexStateToSector")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")l=V.uniq([...e.facesA,...e.facesB].flatMap(r=>r.edges)).map(r=>o(r,"red"));else if(e.type==="FaceState")l=e.face.edges.map(r=>o(r,"red"));else if(e.type==="FaceStateToEdge")l=[...e.toBlackEdges.map(r=>o(r,"red")),...e.toRedEdges.map(r=>o(r,"red"))];else if(e.type==="FaceStateToSector")l=V.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>o(r,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const r=new Set([...e.facesA,...e.facesB].flatMap(d=>d.edges)),i=e.face.edges.filter(d=>!r.has(d));l=[...[...r].map(d=>o(d,"red")),...i.map(d=>o(d,"blue"))]}else if(e.type==="FaceStateToVertexState")l=e.face.edges.filter(i=>e.vertices.includes(i.start)||e.vertices.includes(i.end)).map(i=>o(i,"red"));else if(e.type==="Pattern"){if(l=[],c){const r=fe.getDisplayEmbedding(e.rule.patternBoard,e.boardPatternBoard,e.boardPatternBoard.board,e.embedding),i=.5+.05,d=.15,g=r.expandedBounds.top+d-(c.top+i),w=c.bottom-i-(r.expandedBounds.bottom-d),m=new me(e.rule,r,{maxWidth:c.width-2*i,maxHeight:Math.max(g,w),inputListeners:[new H({fire:()=>{console.log(e.rule.getBinaryIdentifier());const h=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");h&&h.focus()}})],cursor:"pointer"});g>w?m.centerBottom=r.expandedBounds.centerTop.plusXY(0,-d):m.centerTop=r.expandedBounds.centerBottom.plusXY(0,d),m.left<c.left+i&&(m.left=c.left+i),m.right>c.right-i&&(m.right=c.right-i);{const h=r.tightBounds.dilated(.21),R=.3;l.push(new k(M.roundRectangle(h.x,h.y,h.width,h.height,R,R),{stroke:B.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const h=r.tightBounds.dilated(.21),R=.3;l.push(new k(M.roundRectangle(h.x,h.y,h.width,h.height,R,R),{stroke:B.blackLineColorProperty,lineWidth:.13,pickable:!1}))}l.push(m)}}else l=[],console.log(`unknown type: ${e.type}`);super({children:l,pickable:e.type==="Pattern"?null:!1}),this.board=t,this.annotation=e,this.style=a,this.disposeEmitter.addListener(()=>f.forEach(r=>r()))}}class Ge{constructor(t,e,a){p(this,"edgeStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(E()&&F(this.board.edges.includes(t)),e!==we.WHITE){const a=this.solvedState.getEdgeState(t);if(e!==a)throw new C(`Attempt to make edge ${e} when it should be ${a}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Le{constructor(t,e,a){p(this,"faceColorsChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,a,c,l){if(l)throw new C("invalid face color?");const u=new Set([...a.values(),...c.keys(),...a.values()]),o=new Map(this.currentState.getFaceColorMap());for(const i of a.keys())o.set(i,a.get(i));const f=i=>c.has(i)?c.get(i):[...t].includes(i)?this.currentState.getOppositeFaceColor(i):null,r=new Map;for(const i of o.keys()){const d=o.get(i);r.has(d)||r.set(d,new Set([i])),r.get(d).add(i)}for(const i of u){const d=r.get(i);if(!d)continue;const g=[...d];E()&&F(g.length>0);const w=this.solvedState.getFaceColor(g[0]);for(const h of g)if(this.solvedState.getFaceColor(h)!==w)throw new C("invalid face color");const m=f(i);if(m){let h;if(m.colorState===I.INSIDE?h=this.solvedState.getInsideColor():m.colorState===I.OUTSIDE?h=this.solvedState.getOutsideColor():h=this.solvedState.getFaceColor([...r.get(m)][0]),w===h)throw new C("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Je{constructor(t,e,a){p(this,"simpleRegionsChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,a,c){if([...a].length)throw new C("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ue{constructor(t,e,a){p(this,"faceValueChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new C("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Xe{constructor(t,e,a){p(this,"sectorStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){E()&&F(this.board.halfEdges.includes(t));const a=this.solvedState.getSectorState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make sector ${e} when it should be ${a}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ye{constructor(t,e,a){p(this,"vertexStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){E()&&F(this.board.vertices.includes(t));const a=this.solvedState.getVertexState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make vertex ${e} when it should be ${a}`);const c=this.currentState.getVertexState(t);if(!e.isSubsetOf(c))throw new C("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Qe{constructor(t,e,a){p(this,"faceStateChangedEmitter",new v);this.board=t,this.currentState=e,this.solvedState=a}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){E()&&F(this.board.faces.includes(t));const a=this.solvedState.getFaceState(t);if(!a.isSubsetOf(e))throw new C(`Attempt to make face ${e} when it should be ${a}`);const c=this.currentState.getFaceState(t);if(!e.isSubsetOf(c))throw new C("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class ht{constructor(t,e,a){p(this,"anyStateChangedEmitter",new v);p(this,"edgeStateValidator");p(this,"faceValueValidator");p(this,"simpleRegionDataValidator");p(this,"faceColorValidator");p(this,"sectorStateValidator");p(this,"vertexStateValidator");p(this,"faceStateValidator");E()&&F(t),E()&&F(a),this.edgeStateValidator=new Ge(t,e,a),this.faceValueValidator=new Ue(t,e,a),this.simpleRegionDataValidator=new Je(t,e,a),this.faceColorValidator=new Le(t,e,a),this.sectorStateValidator=new Xe(t,e,a),this.vertexStateValidator=new Ye(t,e,a),this.faceStateValidator=new Qe(t,e,a)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,a,c){this.simpleRegionDataValidator.modifyRegions(t,e,a,c)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,a,c,l){this.faceColorValidator.modifyFaceColors(t,e,a,c,l)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const ut=(s,t,e)=>new Ee([new Fe(s,t),new Ve(s,t),new ve(s,t),new ye(s,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Te(s,t,{solveToRed:!0,solveToBlack:!0}),new Re(s,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new xe(s,t),new be(s,t),new ke(s,t),new Me(s,t),new De(s,t),new Oe(s,t,{solveToRed:!0,solveToBlack:!0}),new Be(s,t),new Ie(s,t,{solveToRed:!0,solveToBlack:!0}),new We(s,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new Pe(s,t),new qe(s,t),new Ae(s,t,{solveToRed:!0,solveToBlack:!0}),new $e(s,t),new ze(s,t),new Ne(s,t)]);let T=null,D=0;const pt=()=>{if(T&&(D++,D>5)){const s=T;T=null,s(null)}},_e=async function(s){return new Promise((t,e)=>{T=t,D=0,y.debugSleep&&console.log("sleep start"),setTimeout(()=>{y.debugSleep&&console.log("sleep end"),T===t&&(T=null,t(null)),y.debugSleep&&console.log("resolved")},s)})};class Ke extends Error{constructor(){super("Interrupted")}}const A=async function(s,t){if(await _e(s),y.debugSleep&&console.log("after sleep before interrupt check"),t.value)throw new Ke},St=async(s,t,e)=>{let a=0;for(;a++<100;){const c=Ce.fromFaces(s,()=>null),l=x.shuffle(s.faces);let u=-1,o=[];const f=r=>{try{return o=P(s,r,{maxIterations:1e4,failOnMultipleSolutions:!0}),o.length}catch(i){if(i instanceof q)return 2;if(i instanceof He)return 0;throw i}};for(const r of l){y.debugSleep&&console.log("going to sleep"),t&&await A(0,t),y.debugSleep&&console.log("finished sleep, generating next!");let i=x.shuffle(V.range(0,r.edges.length));i[0]===0&&(i=x.shuffle(i));for(const d of i){const g=c.createDelta();if(g.setFaceValue(r,d),u=f(g),u>=1){g.apply(c),e&&e.emit(s.faces.indexOf(r),d);break}}if(u===1)break}if(u===1)return W(s,c,o[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},ft=async(s,t=()=>!0,e,a)=>{const c=s.board,l=s.cleanState.clone(),u=x.shuffle(c.faces),o=f=>{try{return P(c,f,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(r){if(r instanceof q)return!0;throw r}};E()&&F(!o(l),"Initial state has multiple solutions"),E()&&F(t(c,l.clone()),"Initial state is not easy enough");for(const f of u){e&&await A(0,e);const r=l.getFaceValue(f);if(r===null){a&&a.emit(c.faces.indexOf(f),null);continue}const i=l.createDelta();i.setFaceValue(f,null),!o(i)&&t(c,i.clone())?(i.apply(l),a&&a.emit(c.faces.indexOf(f),null)):a&&a.emit(c.faces.indexOf(f),r)}return W(s.board,l,s.blackEdges)},Ze={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new b(2,50)},height:{label:"Height",type:"integer",range:new b(2,50)}},defaultParameterValues:{width:6,height:10},generate:s=>{const t=s.width,e=s.height;return V.range(0,e).flatMap(a=>V.range(0,t).map(c=>[new S(c,a),new S(c+1,a),new S(c+1,a+1),new S(c,a+1)]))}},je={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new b(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new b(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:s=>{const t=s.radius,e=s.isPointyTop,a=s.holeRadius;let c,l;e?(c=new S(Math.sqrt(3),0),l=new S(Math.sqrt(3)/2,3/2)):(c=new S(3/2,Math.sqrt(3)/2),l=new S(0,Math.sqrt(3)));const u=[new S(1,0),new S(1,-1),new S(0,-1),new S(-1,0),new S(-1,1),new S(0,1)],o=V.range(0,6).map(d=>u[d].plus(u[(d+1)%6])),f=d=>o.map(g=>g.plus(d.timesScalar(3))),r=(d,g)=>(Math.abs(d.x-g.x)+Math.abs(d.x+d.y-g.x-g.y)+Math.abs(d.y-g.y))/2,i=[];for(let d=-t;d<=t;d++)for(let g=Math.max(-t,-d-t);g<=Math.min(t,-d+t);g++){const w=new S(d,g);r(w,new S(0,0))>=a&&i.push(f(w).map(m=>c.timesScalar(m.x).plus(l.timesScalar(m.y)).timesScalar(1/3)))}return i}},et={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:s=>{const t={6:G,10:L,11:J,13:U,14:X,20:Y}[s.radius];E()&&F(t);const e=.01,a=t.thinShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(u=>u.timesScalar(e)));return[...t.thickShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(u=>u.timesScalar(e))),...a]}},mt=[Ze,n(Q,{width:8,height:8}),je,n(_,{width:8,height:8,squareRegion:!0}),n(K,{width:5,height:6,squareRegion:!0}),n(Z,{width:6,height:5}),n(j,{width:9,height:9}),n(ee,{width:9,height:9}),n(te,{width:7,height:8}),n(re),n(ae),n(se),n(le,{squareRegion:!0}),n(oe),n(ie),n(ce,{width:9,height:9}),n(de),n(ge,{width:9,height:9}),n(ne),n(he),n(ue,{width:6,height:8,squareRegion:!0}),n(pe),n(Se),et];export{nt as A,ht as C,ft as a,_e as b,St as g,A as i,mt as p,ut as s,pt as w};
