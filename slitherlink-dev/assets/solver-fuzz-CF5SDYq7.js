import"./UnivariatePolynomial-B1fo8xe7.js";import{N as E,D as x,B as F}from"./PhetioControlledVisibilityProperty-C4xreNPS.js";import{k as H,H as k,_ as h,e as D,f as W,P as L}from"./patternBoards-D316jvfQ.js";import{p as M,g as V,a as G,b as d,s as y,C as I,A as z}from"./polygonGenerators-CcAhf7v3.js";import{E as v,B as q,s as w}from"./BasicPuzzle-qCypyw3t.js";import{P as K,f as S}from"./DisplayEmbedding-ChokjhCK.js";import"./TextPushButton-gLDghw4s.js";import{F as O}from"./autoSolver-CHqufOu6.js";import"./Theme-D414G__S.js";import"./SATSolver-DB4c3ov9.js";import"./PatternBoardSolver-JIwhRtt1.js";import"./PatternRule-CbsljjHG.js";import"./SpinningIndicatorNode-DOFXt6Ex.js";self.assertions.enableAssert();const A=new E,R=new E({renderer:"svg",children:[A]}),c=new x(R,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(c.domElement);c.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");const T=e=>{const l=e.generate(e.defaultParameterValues);return new L(l,e.scale??1)},P=[new H(10,10),new k(4,1,!0),...M.map(T)];(async()=>{let e=null;const l=new F(!1);for(;;){console.log("board loaded");const t=P[Math.floor(Math.random()*P.length)],b=await V(t,l),p=await G(b,()=>!0,l),r=p.cleanState.clone();p.blackEdges.forEach(m=>r.setEdgeState(m,v.BLACK)),O(t,r);const f=q.fromSolvedPuzzle(p);e&&e.dispose(),e=new K(f,{scale:30,left:20,top:20}),A.addChild(e),c.updateDisplay(),await d(50);const o=f.stateProperty.value.clone(),g=y(t,o),u=()=>{f.stateProperty.value=o.clone(),c.updateDisplay()};let B=0;for(;!w(o);){if(e.clearAnnotationNodes(),B++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const m=o.clone(),N=g.clone(m),n=g.nextAction();if(n){console.log(n);const s=new I(t,o,r);e.addAnnotationNode(new z(t,n.annotation,S)),u(),await d(0);try{n.apply(s)}catch(i){console.error(i);debugger;const a=N.nextAction();a&&a.apply(s)}n.apply(o)}else if(!w(o)){const s=y(t,o),i=s.nextAction();if(i)throw e.addAnnotationNode(new z(t,i.annotation,S)),u(),await d(0),new Error("Fresh solver should not have any actions");s.dispose();const a=h.find(h.shuffle(t.edges),C=>o.getEdgeState(C)===v.WHITE);if(D()&&W(a),o.setEdgeState(a,r.getEdgeState(a)),console.log("setting white edge to red/black",a),!g.dirty)throw new Error("Solver should be dirty after setting edge state")}u(),await d(0)}if(!w(o))throw new Error("Solver did not solve the puzzle")}})();
