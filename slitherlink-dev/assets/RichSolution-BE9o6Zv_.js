var f=Object.defineProperty;var B=(g,t,e)=>t in g?f(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var l=(g,t,e)=>(B(g,typeof t!="symbol"?t+"":t,e),e);import{f as F,e as x,R as c,F as I,I as A,B as S,b as E,c as y,d as w}from"./PatternRule-CbsljjHG.js";import{e as u,f as o,_ as m}from"./patternBoards-D316jvfQ.js";import{G as N}from"./Highlander-XyUc4N_h.js";class d{constructor(t,e){this.numAttributes=t,this.data=e}or(t){u()&&o(this.numAttributes===t.numAttributes),this.data=this.data|t.data}and(t){u()&&o(this.numAttributes===t.numAttributes),this.data=this.data&t.data}not(){this.data=(1n<<BigInt(this.numAttributes))-1n-this.data}set(t){u()&&o(t<this.numAttributes&&t>=0),this.data|=1n<<BigInt(t)}clear(t){this.data&=~(1n<<BigInt(t))}isLessThan(t){return u()&&o(this.numAttributes===t.numAttributes),this.data<t.data}isLessThanOrEqual(t){return u()&&o(this.numAttributes===t.numAttributes),this.data<=t.data}isLessThanI(t,e){if(u()&&o(this.numAttributes===t.numAttributes),!t.hasAttribute(e)||this.hasAttribute(e))return!1;const s=~((1n<<BigInt(e+1))-1n),i=this.data&s,n=t.data&s;return i===n}union(t){return u()&&o(this.numAttributes===t.numAttributes),new d(this.numAttributes,this.data|t.data)}intersection(t){return u()&&o(this.numAttributes===t.numAttributes),new d(this.numAttributes,this.data&t.data)}complement(){return new d(this.numAttributes,(1n<<BigInt(this.numAttributes))-1n-this.data)}clone(){return new d(this.numAttributes,this.data)}equals(t){return this.data===t.data}isSubsetOf(t){return(this.data&t.data)===this.data}isProperSubsetOf(t){return this.isSubsetOf(t)&&!this.equals(t)}isEmpty(){return this.data===0n}getCardinality(){let t=0n,e=this.data;for(;e;)t+=e&1n,e>>=1n;return Number(t)}withAttribute(t){return new d(this.numAttributes,this.data|1n<<BigInt(t))}withLowestBitSet(t){return new d(this.numAttributes,this.data&~((1n<<BigInt(t))-1n)|1n<<BigInt(t))}hasAttribute(t){return(this.data&1n<<BigInt(t))!==0n}getAttributes(){const t=[];for(let e=0;e<this.numAttributes;e++)this.hasAttribute(e)&&t.push(e);return t}toString(){return`[${m.range(0,this.numAttributes).map(t=>this.hasAttribute(t)?"1":"0").join("")} (${this.getAttributes().join(",")}) #${this.numAttributes}]`}static getEmpty(t){return new d(t,0n)}static getFull(t){return new d(t,(1n<<BigInt(t))-1n)}static fromBinary(t,e){return u()&&o(e<1n<<BigInt(t)&&e>=0n),new d(t,e)}static fromCallback(t,e){let s=0n;for(let i=0;i<t;i++)e(i)&&(s|=1n<<BigInt(i));return new d(t,s)}}class p extends d{constructor(e,s,i){super(e,s);l(this,"optionalDataComplement");l(this,"withOptionalData");this.optionalData=i,this.optionalDataComplement=(1n<<BigInt(e))-1n-this.optionalData,this.withOptionalData=s|this.optionalData,u()&&o((s&i)===0n)}hasOptionalAttribute(e){return(this.optionalData&1n<<BigInt(e))!==0n}getOptionalAttributes(){const e=[];for(let s=0;s<this.numAttributes;s++)this.hasOptionalAttribute(s)&&e.push(s);return e}toString(){const e=`OPT: [${m.range(0,this.numAttributes).map(s=>this.hasOptionalAttribute(s)?"1":"0").join("")} (${this.getOptionalAttributes().join(",")})`;return`${super.toString()} ${e})`}static fromSolutionBinary(e,s,i){return new p(e,s,i)}static solutionClosure(e,s,i){let n=(1n<<BigInt(e))-1n;const r=s.length;for(let a=0;a<r;a++){const h=s[a];(i&h.withOptionalData)===i&&(n&=h.data|i&h.optionalData)}return n}}class v{constructor(t,e){l(this,"numAttributes");l(this,"numNonExitEdges");l(this,"sectorBaseIndex");l(this,"facePairBaseIndex");l(this,"extraPairs",[]);l(this,"primaryFeatures",[]);l(this,"allFeatures",[]);l(this,"empty",0n);l(this,"full");this.patternBoard=t;const s=F.get(t);let i=0,n=0;if(e.solveEdges)for(const r of t.edges)if(r.isExit){u()&&o(n===r.index+i),n++;const a=new c(r);this.primaryFeatures.push(a),this.allFeatures.push([a])}else{u()&&o(n===2*r.index),i++,n+=2;const a=new c(r),h=new S(r);this.primaryFeatures.push(a),this.primaryFeatures.push(h),this.allFeatures.push([a]),this.allFeatures.push([h])}if(this.sectorBaseIndex=n,e.solveSectors)for(const r of t.sectors){u()&&o(n===3*r.index+this.sectorBaseIndex),n+=3;const a=new E(r),h=new y(r),b=new w(r);this.primaryFeatures.push(a),this.primaryFeatures.push(h),this.primaryFeatures.push(b),this.allFeatures.push([a]),this.allFeatures.push([h]),this.allFeatures.push([b])}if(this.facePairBaseIndex=n,e.solveFaceColors)for(const r of s.connectedFacePairs){const a=x.fromPrimarySecondaryFaces([r.a,r.b],[]),h=x.fromPrimarySecondaryFaces([r.a],[r.b]);e.solveEdges&&r.shortestPath.length===1?(this.allFeatures[this.getNonExitRedIndex(r.shortestPath[0])].push(a),this.allFeatures[this.getNonExitBlackIndex(r.shortestPath[0])].push(h)):(this.extraPairs.push(r),n+=2,this.primaryFeatures.push(a),this.primaryFeatures.push(h),this.allFeatures.push([a]),this.allFeatures.push([h]))}this.numNonExitEdges=i,this.numAttributes=n,this.full=(1n<<BigInt(this.numAttributes))-1n}getSolutionAttributeSet(t){let e=0n,s=0n;const i=n=>t.has(n);for(let n=0;n<this.numAttributes;n++){const r=this.primaryFeatures[n];r instanceof c&&r.edge.isExit?r.edge.exitVertex.edges.every(a=>!i(a))?s|=1n<<BigInt(n):i(r.edge)||(e|=1n<<BigInt(n)):r.isPossibleWith(i)&&(e|=1n<<BigInt(n))}return p.fromSolutionBinary(this.numAttributes,e,s)}getFeatureSetBits(t){let e=0n;for(let s=0;s<this.numAttributes;s++){const i=this.primaryFeatures[s];t.impliesFeature(i)&&(e|=1n<<BigInt(s))}return e}bitsHaveIndex(t,e){return(t&1n<<BigInt(e))!==0n}getBitsIndices(t){const e=[];for(let s=0;s<this.numAttributes;s++)this.bitsHaveIndex(t,s)&&e.push(s);return e}getBitsPrimaryFeatures(t){const e=[];for(let s=0;s<this.numAttributes;s++)this.bitsHaveIndex(t,s)&&e.push(this.primaryFeatures[s]);return e}getBitsFeatureSet(t){if(t===this.full)return null;const e=I.empty(this.patternBoard);for(let s=0;s<this.numAttributes;s++)if(this.bitsHaveIndex(t,s)){const i=this.primaryFeatures[s];try{e.addFeature(i)}catch(n){if(n instanceof A)return null;throw n}}return e}getBinaryString(t){return m.range(0,this.numAttributes).map(e=>this.bitsHaveIndex(t,e)?"1":"0").join("")}getIndicesString(t){return this.getBitsIndices(t).join(",")}getFeaturesString(t){return this.getBitsPrimaryFeatures(t).map(e=>e.toCanonicalString()).join(", ")}getFeaturesSetString(t){const e=this.getBitsFeatureSet(t);return e?e.toCanonicalString():"null"}getNonExitRedIndex(t){return 2*t.index}getNonExitBlackIndex(t){return 2*t.index+1}getExitIndex(t){return this.numNonExitEdges+t.index}getSectorNotZeroIndex(t){return 3*t.index+this.sectorBaseIndex}getSectorNotOneIndex(t){return 3*t.index+this.sectorBaseIndex+1}getSectorNotTwoIndex(t){return 3*t.index+this.sectorBaseIndex+2}getNonExitEdgeRedMask(t){return 1n<<BigInt(2*t.index)}getNonExitEdgeBlackMask(t){return 1n<<BigInt(2*t.index+1)}getNonExitEdgeMask(t){return 3n<<BigInt(2*t.index)}getExitEdgeMask(t){return 1n<<BigInt(this.numNonExitEdges+t.index)}getEdgeMask(t){return t.isExit?this.getExitEdgeMask(t):this.getNonExitEdgeMask(t)}getSectorNotZeroMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex)}getSectorNotOneMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+1)}getSectorNotTwoMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+2)}getSectorMask(t){return 7n<<BigInt(3*t.index+this.sectorBaseIndex)}}class D extends N{constructor(e,s,i,n){u()&&o(e===s.patternBoard);super(e,i,n);l(this,"solutionAttributeSet");this.patternBoard=e,this.binaryFeatureMap=s,this.solution=i,this.solutionAttributeSet=s.getSolutionAttributeSet(this.solutionSet)}toDebugString(){return`[${this.binaryFeatureMap.getBinaryString(this.solutionAttributeSet.data)}] (${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.data)}) opt:(${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.optionalData)}) ${this.vertexConnectionKey??""}`}}export{v as B,D as R,p as S};
