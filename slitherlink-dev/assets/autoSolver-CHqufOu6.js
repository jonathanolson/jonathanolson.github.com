var Le=Object.defineProperty;var xe=(v,e,s)=>e in v?Le(v,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):v[e]=s;var C=(v,e,s)=>(xe(v,typeof e!="symbol"?e+"":e,s),s);import{l as Ae}from"./UnivariatePolynomial-B1fo8xe7.js";import{c as Ve}from"./PhetioControlledVisibilityProperty-C4xreNPS.js";import{L as b}from"./TextPushButton-gLDghw4s.js";import{E as f,A as L,a as B,j as z,h as K,b as Z,i as W,S as J,k as be,l as Re,F as Q,m as Te,n as Be,o as ve,p as Oe,q as Pe,V as _,r as M,t as ke,s as ze,u as De,v as Ie,w as He}from"./BasicPuzzle-qCypyw3t.js";import{e as P,f as k,_ as j}from"./patternBoards-D316jvfQ.js";class U{constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const s=e.nextAction();if(s)return s}return null}clone(e){return new U(this.solvers.map(s=>s.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class T extends Error{constructor(e){super(e)}}class ee{constructor(e,s,t,i){C(this,"dirtyEdges",new Set);C(this,"faceColorListener");this.board=e,this.state=s,this.options=t,i?this.dirtyEdges=new Set(i):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,c,a,l)=>{for(const o of l)for(const n of o.edges)this.dirtyEdges.add(n);for(const o of a){const n=this.state.getFacesWithColor(o);for(const h of n)for(const d of h.edges)this.dirtyEdges.add(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new T("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===f.WHITE){const t=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),i=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=t===i,c=this.state.getOppositeFaceColor(t)===i;if(this.options.solveToBlack&&c)return new L(new B(e,f.BLACK),{type:"FaceColorToBlack",edge:e},this.board);if(this.options.solveToRed&&r)return new L(new B(e,f.RED),{type:"FaceColorToRed",edge:e},this.board)}this.dirtyEdges.delete(e)}return null}clone(e){return new ee(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class te{constructor(e,s,t,i){C(this,"dirtyVertices",[]);C(this,"edgeListener");this.board=e,this.state=s,this.options=t,i?this.dirtyVertices.push(...i):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,c)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),s=e.edges;let t=0,i=0;if(s.forEach(r=>{const c=this.state.getEdgeState(r);return c===f.BLACK?t++:c===f.WHITE&&i++,c}),t>2)throw new T("Too many black edges on vertex");if(t===1&&i===0)throw new T("Nowhere for the single edge to go");if(i>0){if(this.options.solveJointToRed&&t===2){const r=s.filter(a=>this.state.getEdgeState(a)===f.WHITE),c=s.filter(a=>this.state.getEdgeState(a)===f.BLACK);return P()&&k(c.length===2),new L(new z(r.map(a=>new B(a,f.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:c},this.board)}else if(this.options.solveForcedLineToBlack&&t===1&&i===1){const r=s.find(a=>this.state.getEdgeState(a)===f.WHITE),c=s.find(a=>this.state.getEdgeState(a)===f.BLACK);return P()&&k(r),P()&&k(c),new L(new B(r,f.BLACK),{type:"ForcedLine",vertex:e,blackEdge:c,whiteEdge:r,redEdges:s.filter(a=>this.state.getEdgeState(a)===f.RED)},this.board)}else if(this.options.solveAlmostEmptyToRed&&t===0&&i===1){const r=s.find(c=>this.state.getEdgeState(c)===f.WHITE);return P()&&k(r),new L(new B(r,f.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:s.filter(c=>this.state.getEdgeState(c)===f.RED)},this.board)}}}return null}clone(e){return new te(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class se{constructor(e,s,t,i){C(this,"dirtyFaces",[]);C(this,"faceListener");C(this,"edgeListener");this.board=e,this.state=s,this.options=t,i?this.dirtyFaces.push(...i):this.dirtyFaces.push(...e.faces.filter(r=>s.getFaceValue(r)!==null)),this.faceListener=(r,c)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,c)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),s=this.state.getFaceValue(e);if(s!==null){const t=e.edges;let i=0,r=0,c=0;if(t.forEach(a=>{const l=this.state.getEdgeState(a);return l===f.BLACK?i++:l===f.RED?r++:c++,l}),i>s)throw new T("Too many black edges on face");if(r>e.edges.length-s)throw new T("Too many red edges on face");if(c>0){if(this.options.solveToRed&&i===s){const a=t.filter(o=>this.state.getEdgeState(o)===f.WHITE),l=t.filter(o=>this.state.getEdgeState(o)===f.BLACK);return new L(new z(a.map(o=>new B(o,f.RED))),{type:"FaceSatisfied",face:e,whiteEdges:a,blackEdges:l},this.board)}else if(this.options.solveToBlack&&r===e.edges.length-s){const a=t.filter(o=>this.state.getEdgeState(o)===f.WHITE),l=t.filter(o=>this.state.getEdgeState(o)===f.RED);return new L(new z(a.map(o=>new B(o,f.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:a,redEdges:l},this.board)}}}}return null}clone(e){return new se(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class oe{constructor(e,s,t,i){C(this,"dirtySimpleRegions");C(this,"hasDirtyWeirdEdges",!1);C(this,"simpleRegionListener");C(this,"edgeListener");this.board=e,this.state=s,this.options=t,i?this.dirtySimpleRegions=new Set(i):this.dirtySimpleRegions=new Set(s.getSimpleRegions()),this.simpleRegionListener=(r,c,a,l)=>{for(const o of c)this.dirtySimpleRegions.delete(o);for(const o of r)this.dirtySimpleRegions.add(o);this.hasDirtyWeirdEdges=s.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,c,a)=>{if(c===f.RED){const l=this.state.getSimpleRegions(),o=n=>{let h=n,d=null,g=0;do{if(g++>1e4)throw new Error("infinite loop detected");const S=h.edges.filter(F=>this.state.getEdgeState(F)===f.BLACK);if(S.length===1){for(const F of l)(F.a===h||F.b===h)&&this.dirtySimpleRegions.add(F);break}if(S.length!==0)break;const y=h.edges.filter(F=>this.state.getEdgeState(F)===f.WHITE);if(y.length!==2)break;const E=y[0].getOtherVertex(h)===d?y[1]:y[0];d=h,h=E.getOtherVertex(h)}while(h!==n)};o(r.start),o(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new T("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const s=e.values().next().value;if(!s.isSolved){const t=s.a,i=s.b,r=s.halfEdges[0].edge;for(const c of t.edges){if(c===r||this.state.getEdgeState(c)===f.RED)continue;const a=[c];let l=c,o=c.getOtherVertex(t);for(;o!==i;){let n=!1;const h=o.edges.filter(d=>{if(d===l)return!1;const g=this.state.getEdgeState(d);return g===f.BLACK&&(n=!0),g===f.WHITE});if(h.length!==1||n)break;l=h[0],a.push(l),o=l.getOtherVertex(o)}if(o===i){if(this.isSolvedWithAddedEdges(s,a)){if(this.options.solveToBlack)return new L(new z(a.map(n=>new B(n,f.BLACK))),{type:"ForcedSolveLoop",a:t,b:i,regionEdges:s.edges,pathEdges:a},this.board)}else if(this.options.solveToRed)return new L(new z(a.map(n=>new B(n,f.RED))),{type:"PrematureForcedLoop",a:t,b:i,regionEdges:s.edges,pathEdges:a},this.board)}}}e.delete(s)}return null}isSolvedWithAddedEdges(e,s){const t=new Set(e.edges);for(const i of s)t.add(i);for(const i of this.board.faces){const r=this.state.getFaceValue(i);if(r!==null&&i.edges.filter(a=>t.has(a)).length!==r)return!1}return!0}clone(e){return new oe(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const H=(v,e)=>{if(e.colorState===K.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===K.INSIDE)return{type:"absolute",isOutside:!1};{const s=[...v.getFacesWithColor(e)][0];return P()&&k(s),{type:"face",face:s}}};class ie{constructor(e,s,t,i){C(this,"dirtyFaces",new Set);C(this,"edgeListener");C(this,"faceColorListener");this.board=e,this.state=s,this.options=t,i?this.dirtyFaces=new Set(i):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,c,a,l)=>{const o=n=>{this.dirtyFaces.add(n);for(const h of n.edges){const d=h.getOtherFace(n);d&&this.dirtyFaces.add(d)}};for(const n of l)o(n);for(const n of[...r,...a]){const h=this.state.getFacesWithColor(n);for(const d of h)o(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,c)=>{for(const a of r.faces)this.dirtyFaces.add(a)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new T("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,s=i=>{const r=i.getOtherFace(e),c=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new We(c,i)},t=e.edges.filter(i=>this.state.getEdgeState(i)===f.WHITE).map(s);if(t.length){const i=this.state.getFaceValue(e);if(i===null){const r=t[0].color;if(e.edges.map(s).every(l=>l.color===r)&&this.options.solveToRed){const l=e.edges.map(n=>n.getOtherFace(e)).filter(n=>n!==null);if(this.board.faces.some(n=>n!==e&&this.state.getFaceValue(n)!==null&&!l.includes(n)))return new L(new z(t.map(n=>new B(n.edge,f.RED))),{type:"FaceColorNoTrivialLoop",face:e},this.board)}}else{const r=e.edges.filter(l=>this.state.getEdgeState(l)===f.BLACK).length,c=(l,o,n)=>{let h=[];for(const u of o){const A=u.color;let x=!1;for(const V of h)if(V.mainColor===A){V.mainColorSides.add(u),x=!0;break}else if(V.oppositeColor===A){V.oppositeColorSides.add(u),x=!0;break}if(!x){const V=this.state.getOppositeFaceColor(A),R=new Ne(A,V,0,0);h.push(R),R.mainColorSides.add(u)}}h=j.sortBy(h,u=>-u.size);const g=j.sortBy(h.flatMap(u=>{const A=[new Ce(u.mainColor,u.mainCount,u.mainColorSides)];return u.oppositeColor&&u.oppositeColorSides.size&&A.push(new Ce(u.oppositeColor,u.oppositeCount,u.oppositeColorSides)),A}),u=>-u.size)[0],S=g.size,y=l,E=o.length-y,F=Math.max(y,E),O=S>y,p=S>E,m=S===F;if(O&&p)throw new T("Too many adjacent faces with the same color");const w=()=>{const u=A=>[A[0].map(x=>x.edge),A[1].map(x=>x.edge)];return{face:e,remainingValue:l,availableSideCount:o.length,balancedPairs:n.map(u)}};if(O&&this.options.solveToRed)return new L(new z([...g.sides].map(u=>new B(u.edge,f.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...g.sides].map(u=>u.edge),...w()},this.board);if(p&&this.options.solveToBlack)return new L(new z([...g.sides].map(u=>new B(u.edge,f.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...g.sides].map(u=>u.edge),...w()},this.board);if(m&&this.options.solveColors){const u=g.color,A=o.filter(V=>V.color!==u),x=j.uniq(A.map(V=>V.color)).filter(V=>V!==this.state.getOppositeFaceColor(u));if(x.length)return P()&&k(x.every(V=>this.state.getFaceColors().includes(V))),new L(new z(x.map(V=>new Z(H(this.state,u),H(this.state,V)))),{type:"FaceColorBalance",matchingEdges:[...g.sides].map(V=>V.edge),oppositeEdges:[...A].map(V=>V.edge),...w()},this.board)}if(this.options.allowPartialReduction)for(const u of h){if(u.size<1)continue;const A=[...u.mainColorSides].slice(0,u.size),x=[...u.oppositeColorSides].slice(0,u.size),V=o.filter(R=>!A.includes(R)&&!x.includes(R));if(V.length){const R=c(y-u.size,V,n.concat([[A,x]]));if(R)return R}}return null},a=c(i-r,t,[]);if(a)return a}}this.dirtyFaces.delete(e)}return null}clone(e){return new ie(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class We{constructor(e,s){this.color=e,this.edge=s}}class Ne{constructor(e,s,t,i){C(this,"mainColorSides",new Set);C(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=s,this.mainCount=t,this.oppositeCount=i}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class Ce{constructor(e,s,t){this.color=e,this.count=s,this.sides=t}get size(){return this.sides.size}}const Me=(v,e)=>{let s=0;for(;v.dirty;){if(s++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const t=v.nextAction();t&&t.apply(e)}},Ke=(v,e)=>{try{Me(v,e)}finally{v.dispose()}},je=(v,e,s,t,i)=>{const r=v(e,s,i);t(),Ke(r,s)},qe=(v,e,s,t)=>{je(v,e,s,()=>{},t)},G=v=>{const e=[];for(const s of v.edges){const t=s.getOtherFace(v);t&&e.push(t)}return e},Ee=(v,e)=>v.start===e||v.end===e;class re{constructor(e,s,t){C(this,"dirtyFaces");C(this,"faceListener");this.board=e,this.state=s,t?this.dirtyFaces=new Set(t):this.dirtyFaces=new Set(e.faces),this.faceListener=(i,r)=>{this.dirtyFaces.add(i);for(const c of G(i))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,s=this.state.getFaceValue(e),t=e.edges.length;if(s===t-1)for(const i of e.edges){const r=i.getOtherFace(e);if(r){const c=this.state.getFaceValue(r),a=r.edges.length;if(c===a-1){const l=new Set([...G(e),...G(r)]);if(this.board.faces.some(o=>(this.state.getFaceValue(o)??0)>0&&!l.has(o))){const o=E=>!Ee(E,i.start)&&!Ee(E,i.end),n=e.edges.filter(o),h=r.edges.filter(o),d=E=>!E.faces.some(F=>F===e||F===r),g=[...i.start.edges.filter(d),...i.end.edges.filter(d)],S=[i,...n,...h].filter(E=>this.state.getEdgeState(E)!==f.BLACK),y=g.filter(E=>this.state.getEdgeState(E)!==f.RED);if(S.length||y.length)return new L(new z([...S.map(E=>new B(E,f.BLACK)),...y.map(E=>new B(E,f.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:S,toRedEdges:y},this.board)}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new re(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ae{constructor(e,s,t){C(this,"dirtySectors");C(this,"edgeListener");C(this,"sectorListener");this.board=e,this.state=s,t?this.dirtySectors=new Set(t):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(i,r,c)=>{this.dirtySectors.add(i.forwardHalf),this.dirtySectors.add(i.forwardHalf.previous),this.dirtySectors.add(i.reversedHalf),this.dirtySectors.add(i.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(i,r,c)=>{this.dirtySectors.add(i)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const s=e.edge,t=e.next.edge,i=this.state.getSectorState(e);if(i===W.NONE)throw new T(`invalid sector state: ${i}`);const r=this.state.getEdgeState(s),c=this.state.getEdgeState(t),a=(r===f.WHITE?1:0)+(c===f.WHITE?1:0),l=(r===f.BLACK?1:0)+(c===f.BLACK?1:0),o=(n,h)=>new L(new z([...n.map(d=>new B(d,f.BLACK)),...h.map(d=>new B(d,f.RED))]),{type:"ForcedSector",sector:e,sectorState:i,toRedEdges:h,toBlackEdges:n},this.board);if(a===0){if(!i.allows(l))throw new T(`invalid state: ${i} with ${l} black edges with no white`)}else if(a===1){const n=i.allows(l),h=i.allows(l+1);if(!n&&!h)throw new T(`invalid state: ${i} with ${l} black edges and 1 white`);if(n&&!h)return o([],[r===f.WHITE?s:t]);if(h&&!n)return o([r===f.WHITE?s:t],[])}else if(a===2){if(i===W.ONLY_ZERO)return o([],[s,t]);if(i===W.ONLY_TWO)return o([s,t],[])}else throw new T(`invalid white count: ${a}`)}return null}clone(e){return new ae(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class ne{constructor(e,s,t){C(this,"dirtyFaces");C(this,"faceListener");this.board=e,this.state=s,t?this.dirtyFaces=new Set(t):this.dirtyFaces=new Set(e.faces),this.faceListener=(i,r)=>{this.dirtyFaces.add(i);for(const c of G(i))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,s=this.state.getFaceValue(e),t=e.edges.length;let i=null;if(s===0?i=W.ONLY_ZERO:s===1?i=W.NOT_TWO:s===t-1?i=W.NOT_ZERO:s===t&&(i=W.ONLY_TWO),i){const r=e.halfEdges,c=[],a=[];for(const l of r){const o=this.state.getSectorState(l),n=o.and(i);if(n===W.NONE)throw new T(`invalid sector state: ${o}`);o!==n&&(c.push(new J(l,n)),a.push(l))}if(c.length)return new L(new z(c),{type:"StaticFaceSectors",face:e,sectors:a},this.board)}this.dirtyFaces.delete(e)}return null}clone(e){return new ne(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ce{constructor(e,s,t,i){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=s,this.options=t,i?this.dirtyVertices.push(...i):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),s=this.state.getVertexState(e);if(s.possibilityCount===0)throw new T("Vertex has no possibilities");const t=[],i=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const a=s.getFinalStatesOfEdge(r);if(a.size===1){const l=[...a][0];l===f.RED&&this.options.solveToRed&&t.push(r),l===f.BLACK&&this.options.solveToBlack&&i.push(r)}}if(t.length||i.length)return new L(new z([...t.map(r=>new B(r,f.RED)),...i.map(r=>new B(r,f.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:t,toBlackEdges:i},this.board)}return null}clone(e){return new ce(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class le{constructor(e,s,t){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=s,t?this.dirtyVertices.push(...t):this.dirtyVertices.push(...e.vertices),this.vertexListener=i=>{this.dirtyVertices.push(i)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),s=this.state.getVertexState(e);if(s.possibilityCount===0)throw new T("Vertex has no possibilities");const t=be(e),i=t.map(o=>this.state.getSectorState(o)),r=t.map(o=>W.NONE);for(const o of s.getAllowedPairs())for(let n=0;n<t.length;n++){const h=t[n],d=h.edge,g=h.next.edge,S=o[0],y=o[1],E=(d===S||d===y?1:0)+(g===S||g===y?1:0);r[n]=r[n].with(E)}if(s.allowsEmpty())for(let o=0;o<t.length;o++)r[o]=r[o].withZero(!0);for(let o=0;o<t.length;o++)r[o]=r[o].and(i[o]);for(const o of r)if(o===W.NONE)throw new T("Sector has no possibilities");const c=[],a=[],l=[];for(let o=0;o<t.length;o++)i[o]!==r[o]&&(c.push(t[o]),a.push(i[o]),l.push(r[o]));if(c.length)return new L(new z(c.map((o,n)=>new J(o,l[n]))),{type:"VertexStateToSector",vertex:e,sectors:c,beforeStates:a,afterStates:l},this.board)}return null}clone(e){return new le(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class de{constructor(e,s,t){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=s,t?this.dirtyVertices.push(...t):this.dirtyVertices.push(...e.vertices),this.vertexListener=i=>{this.dirtyVertices.push(i)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],s=this.state.getVertexState(e);if(s.possibilityCount===0)throw new T("Vertex has no possibilities");const i=Re(e).map(a=>a.face?this.state.getFaceColor(a.face):this.state.getOutsideColor()),r=new Set(i);if(r.size!==1){const a=new Map([...r].map(o=>[o,new Map([...r].map(n=>[n,!1]))])),l=new Map([...r].map(o=>[o,new Map([...r].map(n=>[n,!1]))]));for(const o of s.getAllowedPairs()){const n=e.edges.indexOf(o[0]),h=e.edges.indexOf(o[1]),d=Math.min(n,h),g=Math.max(n,h),S=i.slice(d,g),y=[...i.slice(g),...i.slice(0,d)],E=F=>{for(let O=0;O<F.length;O++)for(let p=O+1;p<F.length;p++)a.get(F[O]).set(F[p],!0),a.get(F[p]).set(F[O],!0)};E(S),E(y);for(const F of S)for(const O of y)F!==O&&(l.get(F).set(O,!0),l.get(O).set(F,!0))}for(const o of r)for(const n of r){if(o===n)continue;const h=s.allowsEmpty()||a.get(o).get(n),d=l.get(o).get(n);if(h&&!d)return new L(new Q(H(this.state,o),H(this.state,n)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===o),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===n)},this.board);if(d&&!h&&this.state.getOppositeFaceColor(o)!==n)return new L(new Z(H(this.state,o),H(this.state,n)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===o),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===n)},this.board)}}const c=this.dirtyVertices.pop();P()&&k(c===e)}return null}clone(e){return new de(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class ${constructor(e,s){this.face=e,this.state=s}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const s=e.getFaceState(this.face);return new $(this.face,s)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:Te(this.face),state:this.state.serialize()}}static deserializeAction(e,s){const t=Be(e,s.face);return new $(t,ve.deserialize(t,s.state))}}class Y{constructor(e,s,t){C(this,"dirtyFaces");C(this,"faceValueListener");C(this,"vertexStateListener");C(this,"faceColorListener");this.board=e,this.state=s,t?this.dirtyFaces=new Set(t):this.dirtyFaces=new Set(e.faces.filter(i=>s.getFaceValue(i)!==null)),this.faceValueListener=(i,r)=>{this.dirtyFaces.add(i)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=i=>{for(const r of i.faces)this.dirtyFaces.add(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(i,r,c,a)=>{const l=o=>{this.dirtyFaces.add(o);for(const n of o.edges){const h=n.getOtherFace(o);h&&this.dirtyFaces.add(h)}};for(const o of a)l(o);for(const o of[...i,...c]){const n=this.state.getFacesWithColor(o);for(const h of n)l(h)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const s=this.state.getFaceState(e),t=ve.fromVertexAndColorData(e,this.board,this.state).and(s);if(!s.equals(t))return new L(new $(e,t),{type:"FaceState",face:e,beforeState:s,afterState:t},this.board)}return null}clone(e){return new Y(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class he{constructor(e,s,t,i){C(this,"dirtyFaces",[]);C(this,"vertexListener");this.board=e,this.state=s,this.options=t,i?this.dirtyFaces.push(...i):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),s=this.state.getFaceState(e);if(s.possibilityCount===0)throw new T("Face has no possibilities");const t=[],i=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const a=s.getFinalStatesOfEdge(r);if(a.size===1){const l=[...a][0];l===f.RED&&this.options.solveToRed&&t.push(r),l===f.BLACK&&this.options.solveToBlack&&i.push(r)}}if(t.length||i.length)return new L(new z([...t.map(r=>new B(r,f.RED)),...i.map(r=>new B(r,f.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:t,toBlackEdges:i},this.board)}return null}clone(e){return new he(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class fe{constructor(e,s,t){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=s,t?this.dirtyFaces.push(...t):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),s=this.state.getFaceState(e);if(s.possibilityCount===0)throw new T("Face has no possibilities");const t=e.halfEdges,i=t.map(o=>this.state.getSectorState(o)),r=t.map(o=>W.NONE);for(const o of s.getAllowedCombinations())for(let n=0;n<t.length;n++){const h=t[n],d=h.edge,g=h.next.edge,S=(o.includes(d)?1:0)+(o.includes(g)?1:0);r[n]=r[n].with(S)}for(let o=0;o<t.length;o++)r[o]=r[o].and(i[o]);for(const o of r)if(o===W.NONE)throw new T("Sector has no possibilities");const c=[],a=[],l=[];for(let o=0;o<t.length;o++)i[o]!==r[o]&&(c.push(t[o]),a.push(i[o]),l.push(r[o]));if(c.length)return new L(new z(c.map((o,n)=>new J(o,l[n]))),{type:"FaceStateToSector",face:e,sectors:c,beforeStates:a,afterStates:l},this.board)}return null}clone(e){return new fe(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class ge{constructor(e,s,t){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=s,t?this.dirtyFaces.push(...t):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],s=this.state.getFaceState(e);if(s.possibilityCount===0)throw new T("Face has no possibilities");const t=new Map(e.edges.map(l=>{const o=l.getOtherFace(e);return[l,o?this.state.getFaceColor(o):this.state.getOutsideColor()]})),i=[e,...e.edges.map(l=>l.getOtherFace(e)).filter(j.identity)],r=this.state.getFaceColor(e),c=new Set([...t.values(),r]);if(c.size!==1){const l=new Map([...c].map(n=>[n,new Map([...c].map(h=>[h,!1]))])),o=new Map([...c].map(n=>[n,new Map([...c].map(h=>[h,!1]))]));for(const n of s.getAllowedCombinations()){const h=new Set([r]),d=new Set;for(const S of e.edges)n.includes(S)?d.add(t.get(S)):h.add(t.get(S));const g=S=>{for(let y=0;y<S.length;y++)for(let E=y+1;E<S.length;E++)l.get(S[y]).set(S[E],!0),l.get(S[E]).set(S[y],!0)};g([...h]),g([...d]);for(const S of h)for(const y of d)S!==y&&(o.get(S).set(y,!0),o.get(y).set(S,!0))}for(const n of c)for(const h of c){if(n===h)continue;const d=l.get(n).get(h),g=o.get(n).get(h);if(d&&!g)return new L(new Q(H(this.state,n),H(this.state,h)),{type:"FaceStateToSameFaceColor",face:e,facesA:i.filter(S=>this.state.getFaceColor(S)===n),facesB:i.filter(S=>this.state.getFaceColor(S)===h)},this.board);if(g&&!d&&this.state.getOppositeFaceColor(n)!==h)return new L(new Z(H(this.state,n),H(this.state,h)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:i.filter(S=>this.state.getFaceColor(S)===n),facesB:i.filter(S=>this.state.getFaceColor(S)===h)},this.board)}}const a=this.dirtyFaces.pop();P()&&k(a===e)}return null}clone(e){return new ge(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class q{constructor(e,s){this.vertex=e,this.state=s}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const s=e.getVertexState(this.vertex);return new q(this.vertex,s)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:Oe(this.vertex),state:this.state.serialize()}}static deserializeAction(e,s){const t=Pe(e,s.vertex);return new q(t,_.deserialize(t,s.state))}}class ue{constructor(e,s,t){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=s,t?this.dirtyFaces.push(...t):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),s=this.state.getFaceState(e);if(s.possibilityCount===0)throw new T("Face has no possibilities");const t=e.vertices.map(a=>this.state.getVertexState(a)),i=t.map(a=>{const l=a.vertex.edges.filter(o=>o.faces.includes(e));return P()&&k(l.length===2),{vertex:a.vertex,vertexState:a,edgeA:l[0],edgeB:l[1],...a.getBinaryCombinationsAllowed(l[0],l[1])}}),r=i.map(a=>({vertex:a.vertex,vertexState:a.vertexState,edgeA:a.edgeA,edgeB:a.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const a of s.getAllowedCombinations())for(const l of r){const o=a.includes(l.edgeA),n=a.includes(l.edgeB);o&&n&&(l.allowsBoth=!0),o&&!n&&(l.allowsAOnly=!0),!o&&n&&(l.allowsBOnly=!0),!o&&!n&&(l.allowsNone=!0)}const c=[];for(let a=0;a<r.length;a++){const l=i[a],o=r[a];if(o.allowsBoth&&(o.allowsBoth=l.allowsBoth),o.allowsAOnly&&(o.allowsAOnly=l.allowsAOnly),o.allowsBOnly&&(o.allowsBOnly=l.allowsBOnly),o.allowsNone&&(o.allowsNone=l.allowsNone),o.allowsBoth!==l.allowsBoth||o.allowsAOnly!==l.allowsAOnly||o.allowsBOnly!==l.allowsBOnly||o.allowsNone!==l.allowsNone){const n=l.vertexState,h=_.fromLookup(l.vertex,(d,g)=>{if(!n.allowsPair(d,g))return!1;const y=d===o.edgeA||g===o.edgeA,E=d===o.edgeB||g===o.edgeB;if(y&&E)return o.allowsBoth;if(y&&!E)return o.allowsAOnly;if(!y&&E)return o.allowsBOnly;if(!y&&!E)return o.allowsNone;throw new Error("Unreachable")},n.allowsEmpty()&&o.allowsNone);P()&&k(h.isSubsetOf(n)),n.equals(h)||c.push(h)}}if(c.length)return new L(new z(c.map(a=>new q(a.vertex,a))),{type:"FaceStateToVertexState",face:e,vertices:c.map(a=>a.vertex),beforeStates:c.map(a=>t.find(l=>l.vertex===a.vertex)),afterStates:c},this.board)}return null}clone(e){return new ue(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}const me=()=>Ae.nextInt(Number.MAX_SAFE_INTEGER);class N{constructor(e,s){C(this,"dirtyEdges",new Set);C(this,"edgeListener");this.board=e,this.state=s,e.edges.forEach(t=>{this.dirtyEdges.add(t)}),this.edgeListener=(t,i)=>{this.dirtyEdges.add(t)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),s=this.state.getWeirdEdges(),t=new Set,i=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===f.BLACK?t.add(d):i.add(d);const r=new Set,c=new Set,a=new Set(e),l=new Set,o=new Set,n=new Set(s);for(const d of i)n.has(d)&&(n.delete(d),o.add(d));for(const d of t)n.has(d)&&t.delete(d),[...a].some(g=>g.halfEdges.some(S=>S.edge===d))&&t.delete(d);for(const d of e)if(d.halfEdges.some(g=>i.has(g.edge))){const g=[];let S=[];for(const y of d.halfEdges)i.has(y.edge)?S.length>0&&(g.push(S),S=[]):S.push(y);if(S.length>0&&g.push(S),c.add(d),a.delete(d),g.length){if(d.isSolved&&g.length>1){const E=g[0][0],F=g[g.length-1][g[g.length-1].length-1];E.start===F.end&&g[0].unshift(...g.pop())}const y=j.maxBy(g,E=>E.length);for(const E of g){const F=new M(E===y?d.id:me(),E);r.add(F),a.add(F)}}}const h=d=>{const g=d.start,S=d.end,y=[...a].find(w=>w.a===g||w.b===g)||null,E=[...a].find(w=>w.a===S||w.b===S)||null,F=g.edges.filter(w=>this.state.getEdgeState(w)===f.BLACK).length,O=S.edges.filter(w=>this.state.getEdgeState(w)===f.BLACK).length;if(F>2||O>2)return!1;const p=w=>{a.add(w),r.add(w)},m=w=>{a.delete(w),r.has(w)?r.delete(w):c.add(w)};if(y&&E)if(y===E)if(N.isSolvedWithAddedEdge(this.board,this.state,y,d))m(y),p(new M(y.id,N.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]),!0));else return!1;else{const w=y.halfEdges.length>=E.halfEdges.length?y:E,u=w===y?E:y,A=new M(w.id,N.combineHalfEdgeArrays(w.halfEdges,[d.forwardHalf],u.halfEdges));m(w),m(u),p(A)}else if(y){const w=new M(y.id,N.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]));m(y),p(w)}else if(E){const w=new M(E.id,N.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]));m(E),p(w)}else{const w=new M(me(),[d.forwardHalf]);p(w)}return!0};for(const d of n)h(d)&&(o.add(d),n.delete(d));for(const d of t)h(d)||(l.add(d),n.add(d));return this.dirtyEdges.clear(),r.size||c.size||l.size||o.size?new L(new ke(this.board,r,c,l,o),{type:"SimpleRegions"},this.board):null}clone(e){return new N(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,s,t,i){if(i.start!==t.a&&i.start!==t.b||i.end!==t.a&&i.end!==t.b)return!1;const r=new Set(t.edges);r.add(i);for(const c of e.faces){const a=s.getFaceValue(c);if(a!==null&&c.edges.filter(o=>r.has(o)).length!==a)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let s=[...e[0]];for(let t=1;t<e.length;t++){const i=e[t];if(i.length!==0)if(s[0].start===i[0].start)s=[...i.map(r=>r.reversed).reverse(),...s];else if(s[0].start===i[i.length-1].end)s=[...i,...s];else if(s[s.length-1].end===i[0].start)s=[...s,...i];else if(s[s.length-1].end===i[i.length-1].end)s=[...s,...i.map(r=>r.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return s}}class pe{constructor(e,s){C(this,"hasDirtySimpleRegions",!0);C(this,"simpleRegionListener");this.board=e,this.state=s,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(ze(this.state)){const e=this.board.edges.filter(s=>this.state.getEdgeState(s)===f.WHITE);if(e.length)return new L(new z(e.map(s=>new B(s,f.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e},this.board)}return this.hasDirtySimpleRegions=!1,null}clone(e){return new pe(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}class Ue{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,s){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Se{constructor(e,s){C(this,"hadEdgeAdjusted",!1);C(this,"dirtyEdges",new Set);C(this,"edgeListener");this.board=e,this.state=s,e.edges.forEach(t=>this.dirtyEdges.add(t)),this.edgeListener=(t,i,r)=>{this.dirtyEdges.add(t),this.hadEdgeAdjusted=this.hadEdgeAdjusted||r!==f.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var s;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const t=new Map,i=new X(K.OUTSIDE,new Set),r=new X(K.INSIDE,new Set);i.opposite=r,r.opposite=i;const c=new Set([i,r,...this.board.faces.map(p=>{const m=new X(K.UNDECIDED,new Set([p]));return t.set(p,m),m})]);let a=!1;const l=p=>{if(p===null)return i;const m=t.get(p);return P()&&k(m),m},o=(p,m)=>{if(m===i||m===r)return o(m,p);P()&&k(p!==m);for(const w of m.faces)p.faces.add(w),t.set(w,p);return m.faces.clear(),c.delete(m),p},n=(p,m)=>{if(P()&&k(c.has(p)&&c.has(m)),p===m)return;const w=p.opposite,u=m.opposite;if(w&&w===m){a=!0;return}if(u&&u===p){a=!0;return}const A=o(p,m),x=w&&u?o(w,u):w||u;A.opposite=x,x&&(x.opposite=A)},h=(p,m)=>{if(P()&&k(c.has(p)&&c.has(m)),p===m){a=!0;return}if(p.opposite&&p.opposite===m)return;const w=p.opposite,u=m.opposite;if(w&&w===u){a=!0;return}const A=u?o(p,u):p,x=w?o(m,w):m;A.opposite=x,x.opposite=A};for(const p of this.board.edges){if(a)break;const m=this.state.getEdgeState(p);if(m!==f.WHITE){const w=l(p.forwardFace),u=l(p.reversedFace);m===f.BLACK?h(w,u):m===f.RED&&n(w,u)}}if(P()){const p=new Set(this.board.faces);for(const m of c)for(const w of m.faces)p.delete(w);k(p.size===0)}if(a)return new L(new Ue,{type:"InvalidFaceColoring"},this.board);const d=new Set(this.state.getFaceColors()),g=new Set,S=new Map,y=(p,m)=>{P()&&k(d.has(p)),P()&&k(m.faceColor===null),d.delete(p),m.faceColor=p};y(this.state.getOutsideColor(),i),y(this.state.getInsideColor(),r);for(const p of c){if(!p.faceColor){const w=new Set([...p.faces].map(x=>this.state.getFaceColor(x)));let u=null,A=0;for(const x of w){if(!d.has(x))continue;const V=this.state.getFacesWithColor(x);V.some(R=>!p.faces.has(R))||V.length>A&&(u=x,A=V.length)}if(u)y(u,p);else{const x=new De(Ie(),K.UNDECIDED);g.add(x),p.faceColor=x}}const m=p.faceColor;P()&&k(m),p.faces.forEach(w=>{this.state.getFaceColor(w)!==m&&S.set(w,m)})}const E=new Set(d),F=new Map;for(const p of c){const m=p.faceColor,w=((s=p.opposite)==null?void 0:s.faceColor)??null;let u=g.has(m);u||(u=this.state.getOppositeFaceColor(m)!==w),u&&F.set(m,w)}return g.size>0||E.size>0||S.size>0||F.size>0||this.state.hasInvalidFaceColors()?new L(new He(this.board,g,E,S,F,!1),{type:"GeneralFaceColoring"},this.board):null}else for(;this.dirtyEdges.size;){const t=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(t);const i=this.state.getEdgeState(t);if(i!==f.WHITE){const r=t.forwardFace?this.state.getFaceColor(t.forwardFace):this.state.getOutsideColor(),c=t.reversedFace?this.state.getFaceColor(t.reversedFace):this.state.getOutsideColor();if(i===f.BLACK){if(this.state.getOppositeFaceColor(r)!==c)return new L(new Z(H(this.state,r),H(this.state,c)),{type:"FaceColoringBlackEdge",edge:t},this.board)}else if(i===f.RED&&r!==c)return new L(new Q(H(this.state,r),H(this.state,c)),{type:"FaceColoringRedEdge",edge:t},this.board)}}return null}clone(e){return new Se(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class X{constructor(e,s){C(this,"opposite",null);C(this,"faceColor",null);this.colorState=e,this.faces=s}}class we{constructor(e,s){C(this,"dirtySectors",new Set);C(this,"edgeListener");this.board=e,this.state=s,e.halfEdges.forEach(t=>this.dirtySectors.add(t)),this.edgeListener=(t,i,r)=>{this.dirtySectors.add(t.forwardHalf),this.dirtySectors.add(t.forwardHalf.previous),this.dirtySectors.add(t.reversedHalf),this.dirtySectors.add(t.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const s=e.edge,t=e.next.edge,i=this.state.getEdgeState(s),r=this.state.getEdgeState(t),c=this.state.getSectorState(e);let a=c;const l=(i===f.WHITE?1:0)+(r===f.WHITE?1:0),o=(i===f.BLACK?1:0)+(r===f.BLACK?1:0),n=(i===f.RED?1:0)+(r===f.RED?1:0);if(l===0?a=W.getOnly(o):l===1&&(o&&a.zero&&(a=a.withDisallowZero()),n&&a.two&&(a=a.withDisallowTwo())),a!==c)return new L(new J(e,a),{type:l===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:c,afterState:a},this.board)}return null}clone(e){return new we(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class ye{constructor(e,s){C(this,"dirtyVertices",new Set);C(this,"edgeListener");C(this,"sectorListener");C(this,"faceColorListener");this.board=e,this.state=s,e.vertices.forEach(t=>this.dirtyVertices.add(t)),this.edgeListener=(t,i,r)=>{this.dirtyVertices.add(t.start),this.dirtyVertices.add(t.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(t,i,r)=>{this.dirtyVertices.add(t.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(t,i,r,c)=>{for(const a of c)for(const l of a.vertices)this.dirtyVertices.add(l);for(const a of r){const l=this.state.getFacesWithColor(a);for(const o of l)for(const n of o.vertices)this.dirtyVertices.add(n)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const s=this.state.getVertexState(e),t=_.fromEdgeColorSectorData(e,this.state).and(s);if(!s.equals(t))return new L(new q(e,t),{type:"VertexState",vertex:e,beforeState:s,afterState:t},this.board)}return null}clone(e){return new ye(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}const Fe=(v,e,s)=>new U([new N(v,e),new pe(v,e),new Se(v,e),new we(v,e),new ye(v,e)]),xt=new b("autoSolveEnabledProperty",!0),At=new b("autoSolveToBlackProperty",!1),Vt=new b("autoSolveSimpleLoopsProperty",!1),Ge=new b("autoSolveSimpleVertexJointToRedProperty",!0),$e=new b("autoSolveSimpleVertexForcedLineToBlackProperty",!0),Ze=new b("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),Je=new b("autoSolveSimpleFaceToRedProperty",!0),Ye=new b("autoSolveSimpleFaceToBlackProperty",!0),Xe=new b("autoSolveSimpleLoopToRedProperty",!0),Qe=new b("autoSolveSimpleLoopToBlackProperty",!1),_e=new b("autoSolveDoubleMinusOneFacesProperty",!1),et=new b("autoSolveStaticFaceSectorProperty",!0),tt=new b("autoSolveSimpleSectorProperty",!1),st=new b("autoSolveVertexToRedEdgeProperty",!1),ot=new b("autoSolveVertexToBlackEdgeProperty",!1),it=new b("autoSolveVertexToSectorsProperty",!1),rt=new b("autoSolveVertexToFaceColorProperty",!1),at=new b("autoSolveFaceColorToRedProperty",!1),nt=new b("autoSolveFaceColorToBlackProperty",!1),ct=new b("autoSolveFaceColorParityToRedProperty",!1),lt=new b("autoSolveFaceColorParityToBlackProperty",!1),dt=new b("autoSolveFaceColorParityColorsProperty",!1),ht=new b("autoSolveFaceColorParityPartialReductionProperty",!1),ft=new b("autoSolveVertexColorToFaceProperty",!1),gt=new b("autoSolveFaceToRedProperty",!1),ut=new b("autoSolveFaceToBlackProperty",!1),pt=new b("autoSolveFaceToSectorsProperty",!1),St=new b("autoSolveFaceToFaceColorsProperty",!1),wt=new b("autoSolveFaceToVertexProperty",!1),yt=(v,e,s)=>new U([Fe(v,e),new Y(v,e)]),bt=(v,e)=>{qe(yt,v,e,!0)},Rt=new Ve([Ge,$e,Ze,Je,Ye,Xe,Qe,_e,et,tt,st,ot,it,rt,at,nt,ct,lt,dt,ht,ft,gt,ut,pt,St,wt],(v,e,s,t,i,r,c,a,l,o,n,h,d,g,S,y,E,F,O,p,m,w,u,A,x,V)=>(R,D,I)=>new U([...v||e||s?[new te(R,D,{solveJointToRed:v,solveForcedLineToBlack:e,solveAlmostEmptyToRed:s},I?void 0:[])]:[],...t||i?[new se(R,D,{solveToRed:t,solveToBlack:i},I?void 0:[])]:[],...a?[new re(R,D,I?void 0:[])]:[],Fe(R,D),...l?[new ne(R,D,I?void 0:[])]:[],...o?[new ae(R,D,I?void 0:[])]:[],...r||c?[new oe(R,D,{solveToRed:r,solveToBlack:c,resolveAllRegions:!1},I?void 0:[])]:[],...n||h?[new ce(R,D,{solveToRed:n,solveToBlack:h},I?void 0:[])]:[],...d?[new le(R,D,I?void 0:[])]:[],...S||y?[new ee(R,D,{solveToRed:S,solveToBlack:y},I?void 0:[])]:[],...E||F||O?[new ie(R,D,{solveToRed:E,solveToBlack:F,solveColors:O,allowPartialReduction:p},I?void 0:[])]:[],...g?[new de(R,D,I?void 0:[])]:[],...m?[new Y(R,D,I?void 0:[])]:[],...w||u?[new he(R,D,{solveToRed:w,solveToBlack:u},I?void 0:[])]:[],...A?[new fe(R,D,I?void 0:[])]:[],...x?[new ge(R,D,I?void 0:[])]:[],...V?[new ue(R,D,I?void 0:[])]:[]]));export{ge as $,ut as A,pt as B,St as C,At as D,Vt as E,bt as F,U as G,pe as H,T as I,Se as J,te as K,se as L,oe as M,re as N,we as O,ne as P,ae as Q,ye as R,N as S,le as T,ee as U,ce as V,ie as W,de as X,Y,he as Z,fe as _,xt as a,ue as a0,Rt as a1,Fe as a2,Ge as b,$e as c,Ze as d,Je as e,Ye as f,H as g,Xe as h,qe as i,Qe as j,_e as k,et as l,tt as m,st as n,ot as o,it as p,rt as q,at as r,nt as s,ct as t,lt as u,dt as v,je as w,ht as x,ft as y,gt as z};
