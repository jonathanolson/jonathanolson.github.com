var z=Object.defineProperty;var T=(g,t,e)=>t in g?z(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var S=(g,t,e)=>(T(g,typeof t!="symbol"?t+"":t,e),e);import{g as W,P as $,k as A,l as b,m as M,s as q,i as v}from"./PatternRule-CDRs6Hn3.js";import{a as N,b as U}from"./compression-L63-wCoo.js";import{e as F,f as y,_ as E,ah as P}from"./patternBoards-DsO5TEFU.js";import{G as L,H as G}from"./Highlander-iuAp_GQQ.js";import{P as O}from"./PatternBoardSolver-BpeZ3tu0.js";const k=new WeakMap,V=(g,t=!1)=>{F()&&y(g);let e=k.get(g)??null;return e||(e=O.getSolutions(g,[]),t&&k.set(g,e)),e},H=new WeakMap,j=(g,t=!1)=>{F()&&y(g);let e=H.get(g)??null;return e||(e=V(g).map(s=>new L(g,s,!0),t),t&&H.set(g,e)),e};class J{constructor(t,e,s){S(this,"exitEdgeIndices");S(this,"solutionAttributeSetLists");this.initialFeatureSet=t,this.binaryFeatureMap=e,this.richSolutions=s;const n=t.patternBoard,a=n.edges.filter(o=>o.isExit);this.exitEdgeIndices=a.map(o=>e.getExitIndex(o)),this.solutionAttributeSetLists=new Array(1<<a.length).fill([]);const r=W(n,t.getFeaturesArray()),i=(o,l,d)=>{if(o===a.length){const c=G.filterWithInfo(s,r,d).map(h=>h.solutionAttributeSet);this.solutionAttributeSetLists[l]=c}else i(o+1,l,d),i(o+1,l|1<<o,[...d,a[o]])};i(0,0,[])}getSolutionAttributeSets(t){let e=0;for(let s=0;s<this.exitEdgeIndices.length;s++){const n=this.exitEdgeIndices[s];(t&1n<<BigInt(n))!==0n&&(e|=1<<s)}return this.solutionAttributeSetLists[e]}}const K=(g,t,e)=>{const s=g.inputFeatureSet.getFeaturesArray(),n=g.outputFeatureSet.getFeaturesArray();let a=e??j(g.patternBoard);t&&(a=J.filterWithFeatureSet(a,g.inputFeatureSet)),a=a.filter(r=>s.every(i=>i.isPossibleWith(r.isEdgeBlack)));for(const r of a)if(!n.every(i=>i.isPossibleWith(r.isEdgeBlack)))return!1;return!0};class R{constructor(t,e,s,n,a){if(this.patternBoards=t,this.data=e,this.ruleIndices=s,this.nextRuleIndex=n,this.highlander=a,F())for(let r=0;r<s.length;r++)y(e[s[r]]<t.length,"pattern board index")}clone(){return new R(this.patternBoards.slice(),new Uint8Array(this.data),this.ruleIndices.slice(),this.nextRuleIndex,this.highlander)}addRule(t){this.patternBoards.includes(t.patternBoard)||this.patternBoards.push(t.patternBoard);const e=t.getBinary(this.patternBoards);this.nextRuleIndex+e.length>this.data.length&&this.allocateMoreSpace(e.length),this.highlander||(this.highlander=t.highlander),this.data.set(e,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=e.length}addRuleSuffixBytes(t,e,s){this.patternBoards.includes(t)||this.patternBoards.push(t);const n=[this.patternBoards.indexOf(t),...e];this.nextRuleIndex+n.length>this.data.length&&this.allocateMoreSpace(n.length),this.highlander||(this.highlander=s),this.data.set(n,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=n.length}getRules(){const t=[];return this.forEachRule(e=>t.push(e)),t}get size(){return this.ruleIndices.length}allocateMoreSpace(t){const e=Math.max(this.data.length*2,this.data.length+t),s=new Uint8Array(e);s.set(this.data,0),this.data=s}getRule(t,e){return $.fromBinary(this.patternBoards,this.data,this.ruleIndices[t],e===void 0?this.highlander:e)}getRuleBytes(t,e){const s=this.ruleIndices[t],n=t+1<this.ruleIndices.length?this.ruleIndices[t+1]:this.nextRuleIndex,a=[];for(let r=e?s:s+1;r<n;r++)a.push(this.data[r]);return a}getRulePatternBoard(t){return this.patternBoards[this.data[this.ruleIndices[t]]]}forEachRule(t){for(let e=0;e<this.ruleIndices.length;e++)t(this.getRule(e))}withPatternBoardFilter(t){const e=this.patternBoards.map(t),s=this.patternBoards.filter((i,o)=>e[o]),n=[],a=[];let r=0;for(let i=0;i<this.ruleIndices.length;i++){const o=this.ruleIndices[i],l=this.data[o];if(F()&&y(l<this.patternBoards.length,"pattern board index"),e[l]){const d=s.indexOf(this.patternBoards[l]);F()&&y(d!==-1,"pattern board index");const c=i+1<this.ruleIndices.length?this.ruleIndices[i+1]:this.data.length;n.push(d,...this.data.slice(o+1,c)),a.push(r),F()&&y(n[r]===d,"pattern board index"),r=n.length}}return new R(s,new Uint8Array(n),a,r,this.highlander)}withRules(t){const e=this.highlander||t.some(i=>i.highlander),s=E.uniq([...this.patternBoards,...t.map(i=>i.patternBoard)]),n=[...this.data],a=[...this.ruleIndices];let r=this.nextRuleIndex;for(const i of t)n.push(...i.getBinary(s)),a.push(r),r=n.length;return new R(s,new Uint8Array(n),a,r,e)}withCollection(t){const e=this.clone();return t.forEachRule(s=>{e.addRule(s)}),e}withCollectionNonequal(t){const e=this.clone();let s=0;const n=this.getRules();return t.forEachRule(a=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,n.every(r=>!a.equals(r))&&e.addRule(a)}),e}withCollectionNonredundant(t){const e=this.clone();let s=0;return t.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,e.isRuleRedundant(n)||e.addRule(n)}),e}withoutCollectionNonequal(t){const e=R.empty();let s=0;const n=t.getRules();return this.forEachRule(a=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,n.every(r=>!a.equals(r))&&e.addRule(a)}),e}withoutCollectionNonredundant(t){const e=R.empty();let s=0;return this.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,t.isRuleRedundant(n)||e.addRule(n)}),e}withRulesApplied(t,e=()=>!1){const s=t.clone();for(;;){const n=s.clone();let a=null,r=[];for(let i=0;i<this.ruleIndices.length;i++){const o=this.ruleIndices[i],l=this.data[o],d=this.patternBoards[l];d!==a&&(a=d,r=P(d,t.patternBoard));const c=r;for(const h of c)if(this.isActionableEmbeddingFromFeatureSet(s,i,h)){const f=this.getRule(i).embedded(s.patternBoard,h);if(F()){self.isPatternRuleValid=K;const p=f.getMatchState(s);if(p===A.INCOMPATIBLE||p===A.DORMANT){debugger;throw new Error("Why would this happen")}}f.apply(s)}}if(e(s)||n.equals(s))break}return s}isRuleRedundant(t){return t.isTrivial()?!0:t.outputFeatureSet.isSubsetOf(this.withRulesApplied(t.inputFeatureSet,e=>t.outputFeatureSet.isSubsetOf(e)))}findNextActionableEmbeddedRuleFromData(t,e,s=0,n){let a=0;for(let r=s;r<this.ruleIndices.length;r++){a%1e3===0&&console.log("search",a),a++;const i=this.ruleIndices[r],o=this.data[i],l=this.patternBoards[o],d=P(l,t);for(const c of d)if(this.isActionableEmbeddingFromData(t,e,r,c)){const h=n?this.getRule(r,n(r)):this.getRule(r),u=h.embedded(t,c);if(F()&&(y(h.inputFeatureSet.getBoardMatchState(e,c,!0)===b.MATCH),y(h.outputFeatureSet.getBoardMatchState(e,c,!0)!==b.MATCH),y(!u||!!h.inputFeatureSet.embedded(l,c))),u)return{rule:h,embeddedRule:u,embedding:c,ruleIndex:r};debugger;throw new Error("Why would this happen")}}return null}isActionableEmbeddingFromData(t,e,s,n){let a=this.ruleIndices[s];const r=this.data[a++],i=this.patternBoards[r];F()&&y(i,"pattern board");const o=M(i);for(;;){const l=this.data[a++];if(l===255)break;if(l===254){const d=this.data[a++];for(F()&&y(d<128);;){const c=this.data[a++];if(c===255||c===254){a--;break}if(c&128){const h=c&127,u=e.oppositeFaceColors[n.mapFace(i.faces[d]).index],f=e.faceColors[n.mapFace(i.faces[h]).index];if(u!==f)return!1}else{const h=c,u=e.faceColors[n.mapFace(i.faces[d]).index],f=e.faceColors[n.mapFace(i.faces[h]).index];if(u!==f)return!1}}}else{const d=o.featureMatchers[l];if(d(e,n)!==b.MATCH)return!1}}for(;;){const l=this.data[a++];if(l===255)break;if(l===254){const d=this.data[a++];for(F()&&y(d<128);;){const c=this.data[a++];if(c===255||c===254){a--;break}if(c&128){const h=c&127,u=e.oppositeFaceColors[n.mapFace(i.faces[d]).index],f=e.faceColors[n.mapFace(i.faces[h]).index];if(u!==f)return!0}else{const h=c,u=e.faceColors[n.mapFace(i.faces[d]).index],f=e.faceColors[n.mapFace(i.faces[h]).index];if(u!==f)return!0}}}else{const d=o.featureMatchers[l];if(d(e,n)!==b.MATCH)return!0}}return!1}isActionableEmbeddingFromFeatureSet(t,e,s){let n=this.ruleIndices[e];const a=this.data[n++],r=this.patternBoards[a];F()&&y(r,"pattern board");const i=M(r);for(;;){const o=this.data[n++];if(o===255)break;if(o===254){const l=this.data[n++];F()&&y(l<128);const d=s.mapFace(r.faces[l]),c=t.getFaceColorDualFromFace(d);if(!c)return!1;const h=c.secondaryFaces.includes(d);F()&&y(h||c.primaryFaces.includes(d));const u=h?c.secondaryFaces:c.primaryFaces,f=h?c.primaryFaces:c.secondaryFaces;for(;;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const m=p&127,x=s.mapFace(r.faces[m]);if(!f.includes(x))return!1}else{const m=p,x=s.mapFace(r.faces[m]);if(!u.includes(x))return!1}}}else{const l=i.featureSetMatchers[o];if(l(t,s)!==b.MATCH)return!1}}for(;;){const o=this.data[n++];if(o===255)break;if(o===254){const l=this.data[n++];F()&&y(l<128);const d=s.mapFace(r.faces[l]),c=t.getFaceColorDualFromFace(d);if(!c)return!0;const h=c.secondaryFaces.includes(d);F()&&y(h||c.primaryFaces.includes(d));const u=h?c.secondaryFaces:c.primaryFaces,f=h?c.primaryFaces:c.secondaryFaces;for(;;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const m=p&127,x=s.mapFace(r.faces[m]);if(!f.includes(x))return!0}else{const m=p,x=s.mapFace(r.faces[m]);if(!u.includes(x))return!0}}}else{const l=i.featureSetMatchers[o];if(l(t,s)!==b.MATCH)return!0}}return!1}getActionableEmbeddingsFromData(t,e,s){let n=this.ruleIndices[s];const a=this.data[n++],r=this.patternBoards[a];F()&&y(r,"pattern board");const i=M(r);let o=P(r,t),l=o.slice();for(;;){const h=this.data[n++];let u=0;if(h===255)break;if(h===254){const f=this.data[n++];for(F()&&y(f<128);;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const x=p&127;for(let I=0;I<o.length;I++){const B=o[I],w=e.oppositeFaceColors[B.mapFace(r.faces[f]).index],C=e.faceColors[B.mapFace(r.faces[x]).index];w===C&&(l[u++]=B)}}else{const x=p;for(let I=0;I<o.length;I++){const B=o[I],w=e.faceColors[B.mapFace(r.faces[f]).index],C=e.faceColors[B.mapFace(r.faces[x]).index];w===C&&(l[u++]=B)}}if(l.length=u,u===0)return l;const m=o;o=l,l=m,u=0}}else{const f=i.featureMatchers[h];for(let m=0;m<o.length;m++){const x=o[m];f(e,x)===b.MATCH&&(l[u++]=x)}if(l.length=u,u===0)return l;const p=o;o=l,l=p,u=0}}const d=o.map(()=>!1);let c=0;for(;;){const h=this.data[n++];if(h===255)break;if(h===254){const u=this.data[n++];for(F()&&y(u<128);;){const f=this.data[n++];if(f===255||f===254){n--;break}if(f&128){const p=f&127;for(let m=0;m<o.length;m++)if(!d[m]){const x=o[m],I=e.oppositeFaceColors[x.mapFace(r.faces[u]).index],B=e.faceColors[x.mapFace(r.faces[p]).index];I!==B&&(d[m]=!0,c++)}}else{const p=f;for(let m=0;m<o.length;m++)if(!d[m]){const x=o[m],I=e.faceColors[x.mapFace(r.faces[u]).index],B=e.faceColors[x.mapFace(r.faces[p]).index];I!==B&&(d[m]=!0,c++)}}}}else{const u=i.featureMatchers[h];for(let f=0;f<o.length;f++)if(!d[f]){const p=o[f];u(e,p)!==b.MATCH&&(d[f]=!0,c++)}}}return c?o.filter((h,u)=>d[u]):[]}serialize(){return{patternBoards:this.patternBoards.map(q),rules:N(this.data.subarray(0,this.nextRuleIndex)),highlander:this.highlander}}static deserialize(t){const e=U(t.rules);if(!e)throw new Error("Failed to decompress rules!");let s=0;const n=[];for(;s<e.length;){n.push(s),F()&&y(e[s]!==254);let a=0;for(;a<2;)F()&&y(s<e.length,"Unexpected end of data"),e[s++]===255&&a++}return new R(t.patternBoards.map(v),e,n,e.length,t.highlander)}static empty(){return new R([],new Uint8Array(0),[],0,!1)}static fromRules(t){const e=t.some(i=>i.highlander),s=E.uniq(t.map(i=>i.patternBoard)),n=[];let a=0;const r=[];for(const i of t)n.push(...i.getBinary(s)),r.push(a),a=n.length;return new R(s,new Uint8Array(n),r,a,e)}}export{R as B,J as H,j as g,K as i};
