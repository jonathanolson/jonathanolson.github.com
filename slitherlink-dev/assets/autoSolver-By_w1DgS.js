var Le=Object.defineProperty;var xe=(v,e,t)=>e in v?Le(v,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):v[e]=t;var E=(v,e,t)=>(xe(v,typeof e!="symbol"?e+"":e,t),t);import{h as Ae}from"./UnivariatePolynomial-B7u1WGdr.js";import{c as Ve}from"./PhetioControlledVisibilityProperty-DLWPAyRL.js";import{L as b}from"./TextPushButton-jnVfkaQ5.js";import{E as f,A as L,a as B,i as k,h as j,b as J,S as H,j as be,k as Re,l as Te,m as Be,F as Q,n as Oe,o as Pe,p as ve,q as ze,r as ke,V as _,t as K,u as De,s as Ie,v as He,w as We,x as Ne}from"./BasicPuzzle-A0tzNytz.js";import{e as P,f as z,_ as U}from"./patternBoards-DsO5TEFU.js";class G{constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const t=e.nextAction();if(t)return t}return null}clone(e){return new G(this.solvers.map(t=>t.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class T extends Error{constructor(e){super(e)}}class ee{constructor(e,t,s,i){E(this,"dirtyEdges",new Set);E(this,"faceColorListener");this.board=e,this.state=t,this.options=s,i?this.dirtyEdges=new Set(i):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,c,a,l)=>{for(const o of l)for(const n of o.edges)this.dirtyEdges.add(n);for(const o of a){const n=this.state.getFacesWithColor(o);for(const h of n)for(const d of h.edges)this.dirtyEdges.add(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new T("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===f.WHITE){const s=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),i=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=s===i,c=this.state.getOppositeFaceColor(s)===i;if(this.options.solveToBlack&&c)return new L(new B(e,f.BLACK),{type:"FaceColorToBlack",edge:e},this.board);if(this.options.solveToRed&&r)return new L(new B(e,f.RED),{type:"FaceColorToRed",edge:e},this.board)}this.dirtyEdges.delete(e)}return null}clone(e){return new ee(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class te{constructor(e,t,s,i){E(this,"dirtyVertices",[]);E(this,"edgeListener");this.board=e,this.state=t,this.options=s,i?this.dirtyVertices.push(...i):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,c)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=e.edges;let s=0,i=0;if(t.forEach(r=>{const c=this.state.getEdgeState(r);return c===f.BLACK?s++:c===f.WHITE&&i++,c}),s>2)throw new T("Too many black edges on vertex");if(s===1&&i===0)throw new T("Nowhere for the single edge to go");if(i>0){if(this.options.solveJointToRed&&s===2){const r=t.filter(a=>this.state.getEdgeState(a)===f.WHITE),c=t.filter(a=>this.state.getEdgeState(a)===f.BLACK);return P()&&z(c.length===2),new L(new k(r.map(a=>new B(a,f.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:c},this.board)}else if(this.options.solveForcedLineToBlack&&s===1&&i===1){const r=t.find(a=>this.state.getEdgeState(a)===f.WHITE),c=t.find(a=>this.state.getEdgeState(a)===f.BLACK);return P()&&z(r),P()&&z(c),new L(new B(r,f.BLACK),{type:"ForcedLine",vertex:e,blackEdge:c,whiteEdge:r,redEdges:t.filter(a=>this.state.getEdgeState(a)===f.RED)},this.board)}else if(this.options.solveAlmostEmptyToRed&&s===0&&i===1){const r=t.find(c=>this.state.getEdgeState(c)===f.WHITE);return P()&&z(r),new L(new B(r,f.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:t.filter(c=>this.state.getEdgeState(c)===f.RED)},this.board)}}}return null}clone(e){return new te(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class se{constructor(e,t,s,i){E(this,"dirtyFaces",[]);E(this,"faceListener");E(this,"edgeListener");this.board=e,this.state=t,this.options=s,i?this.dirtyFaces.push(...i):this.dirtyFaces.push(...e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceListener=(r,c)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,c)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceValue(e);if(t!==null){const s=e.edges;let i=0,r=0,c=0;if(s.forEach(a=>{const l=this.state.getEdgeState(a);return l===f.BLACK?i++:l===f.RED?r++:c++,l}),i>t)throw new T("Too many black edges on face");if(r>e.edges.length-t)throw new T("Too many red edges on face");if(c>0){if(this.options.solveToRed&&i===t){const a=s.filter(o=>this.state.getEdgeState(o)===f.WHITE),l=s.filter(o=>this.state.getEdgeState(o)===f.BLACK);return new L(new k(a.map(o=>new B(o,f.RED))),{type:"FaceSatisfied",face:e,whiteEdges:a,blackEdges:l},this.board)}else if(this.options.solveToBlack&&r===e.edges.length-t){const a=s.filter(o=>this.state.getEdgeState(o)===f.WHITE),l=s.filter(o=>this.state.getEdgeState(o)===f.RED);return new L(new k(a.map(o=>new B(o,f.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:a,redEdges:l},this.board)}}}}return null}clone(e){return new se(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class oe{constructor(e,t,s,i){E(this,"dirtySimpleRegions");E(this,"hasDirtyWeirdEdges",!1);E(this,"simpleRegionListener");E(this,"edgeListener");this.board=e,this.state=t,this.options=s,i?this.dirtySimpleRegions=new Set(i):this.dirtySimpleRegions=new Set(t.getSimpleRegions()),this.simpleRegionListener=(r,c,a,l)=>{for(const o of c)this.dirtySimpleRegions.delete(o);for(const o of r)this.dirtySimpleRegions.add(o);this.hasDirtyWeirdEdges=t.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,c,a)=>{if(c===f.RED){const l=this.state.getSimpleRegions(),o=n=>{let h=n,d=null,g=0;do{if(g++>1e4)throw new Error("infinite loop detected");const S=h.edges.filter(F=>this.state.getEdgeState(F)===f.BLACK);if(S.length===1){for(const F of l)(F.a===h||F.b===h)&&this.dirtySimpleRegions.add(F);break}if(S.length!==0)break;const y=h.edges.filter(F=>this.state.getEdgeState(F)===f.WHITE);if(y.length!==2)break;const C=y[0].getOtherVertex(h)===d?y[1]:y[0];d=h,h=C.getOtherVertex(h)}while(h!==n)};o(r.start),o(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new T("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const t=e.values().next().value;if(!t.isSolved){const s=t.a,i=t.b,r=t.halfEdges[0].edge;for(const c of s.edges){if(c===r||this.state.getEdgeState(c)===f.RED)continue;const a=[c];let l=c,o=c.getOtherVertex(s);for(;o!==i;){let n=!1;const h=o.edges.filter(d=>{if(d===l)return!1;const g=this.state.getEdgeState(d);return g===f.BLACK&&(n=!0),g===f.WHITE});if(h.length!==1||n)break;l=h[0],a.push(l),o=l.getOtherVertex(o)}if(o===i){if(this.isSolvedWithAddedEdges(t,a)){if(this.options.solveToBlack)return new L(new k(a.map(n=>new B(n,f.BLACK))),{type:"ForcedSolveLoop",a:s,b:i,regionEdges:t.edges,pathEdges:a},this.board)}else if(this.options.solveToRed)return new L(new k(a.map(n=>new B(n,f.RED))),{type:"PrematureForcedLoop",a:s,b:i,regionEdges:t.edges,pathEdges:a},this.board)}}}e.delete(t)}return null}isSolvedWithAddedEdges(e,t){const s=new Set(e.edges);for(const i of t)s.add(i);for(const i of this.board.faces){const r=this.state.getFaceValue(i);if(r!==null&&i.edges.filter(a=>s.has(a)).length!==r)return!1}return!0}clone(e){return new oe(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const W=(v,e)=>{if(e.colorState===j.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===j.INSIDE)return{type:"absolute",isOutside:!1};{const t=[...v.getFacesWithColor(e)][0];return P()&&z(t),{type:"face",face:t}}};class ie{constructor(e,t,s,i){E(this,"dirtyFaces",new Set);E(this,"edgeListener");E(this,"faceColorListener");this.board=e,this.state=t,this.options=s,i?this.dirtyFaces=new Set(i):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,c,a,l)=>{const o=n=>{this.dirtyFaces.add(n);for(const h of n.edges){const d=h.getOtherFace(n);d&&this.dirtyFaces.add(d)}};for(const n of l)o(n);for(const n of[...r,...a]){const h=this.state.getFacesWithColor(n);for(const d of h)o(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,c)=>{for(const a of r.faces)this.dirtyFaces.add(a)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new T("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,t=i=>{const r=i.getOtherFace(e),c=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new Me(c,i)},s=e.edges.filter(i=>this.state.getEdgeState(i)===f.WHITE).map(t);if(s.length){const i=this.state.getFaceValue(e);if(i===null){const r=s[0].color;if(e.edges.map(t).every(l=>l.color===r)&&this.options.solveToRed){const l=e.edges.map(n=>n.getOtherFace(e)).filter(n=>n!==null);if(this.board.faces.some(n=>n!==e&&this.state.getFaceValue(n)!==null&&!l.includes(n)))return new L(new k(s.map(n=>new B(n.edge,f.RED))),{type:"FaceColorNoTrivialLoop",face:e},this.board)}}else{const r=e.edges.filter(l=>this.state.getEdgeState(l)===f.BLACK).length,c=(l,o,n)=>{let h=[];for(const u of o){const A=u.color;let x=!1;for(const V of h)if(V.mainColor===A){V.mainColorSides.add(u),x=!0;break}else if(V.oppositeColor===A){V.oppositeColorSides.add(u),x=!0;break}if(!x){const V=this.state.getOppositeFaceColor(A),R=new Ke(A,V,0,0);h.push(R),R.mainColorSides.add(u)}}h=U.sortBy(h,u=>-u.size);const g=U.sortBy(h.flatMap(u=>{const A=[new Ee(u.mainColor,u.mainCount,u.mainColorSides)];return u.oppositeColor&&u.oppositeColorSides.size&&A.push(new Ee(u.oppositeColor,u.oppositeCount,u.oppositeColorSides)),A}),u=>-u.size)[0],S=g.size,y=l,C=o.length-y,F=Math.max(y,C),O=S>y,p=S>C,m=S===F;if(O&&p)throw new T("Too many adjacent faces with the same color");const w=()=>{const u=A=>[A[0].map(x=>x.edge),A[1].map(x=>x.edge)];return{face:e,remainingValue:l,availableSideCount:o.length,balancedPairs:n.map(u)}};if(O&&this.options.solveToRed)return new L(new k([...g.sides].map(u=>new B(u.edge,f.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...g.sides].map(u=>u.edge),...w()},this.board);if(p&&this.options.solveToBlack)return new L(new k([...g.sides].map(u=>new B(u.edge,f.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...g.sides].map(u=>u.edge),...w()},this.board);if(m&&this.options.solveColors){const u=g.color,A=o.filter(V=>V.color!==u),x=U.uniq(A.map(V=>V.color)).filter(V=>V!==this.state.getOppositeFaceColor(u));if(x.length)return P()&&z(x.every(V=>this.state.getFaceColors().includes(V))),new L(new k(x.map(V=>new J(W(this.state,u),W(this.state,V)))),{type:"FaceColorBalance",matchingEdges:[...g.sides].map(V=>V.edge),oppositeEdges:[...A].map(V=>V.edge),...w()},this.board)}if(this.options.allowPartialReduction)for(const u of h){if(u.size<1)continue;const A=[...u.mainColorSides].slice(0,u.size),x=[...u.oppositeColorSides].slice(0,u.size),V=o.filter(R=>!A.includes(R)&&!x.includes(R));if(V.length){const R=c(y-u.size,V,n.concat([[A,x]]));if(R)return R}}return null},a=c(i-r,s,[]);if(a)return a}}this.dirtyFaces.delete(e)}return null}clone(e){return new ie(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Me{constructor(e,t){this.color=e,this.edge=t}}class Ke{constructor(e,t,s,i){E(this,"mainColorSides",new Set);E(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=t,this.mainCount=s,this.oppositeCount=i}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class Ee{constructor(e,t,s){this.color=e,this.count=t,this.sides=s}get size(){return this.sides.size}}const je=(v,e)=>{let t=0;for(;v.dirty;){if(t++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const s=v.nextAction();s&&s.apply(e)}},Ue=(v,e)=>{try{je(v,e)}finally{v.dispose()}},qe=(v,e,t,s,i)=>{const r=v(e,t,i);s(),Ue(r,t)},Ge=(v,e,t,s)=>{qe(v,e,t,()=>{},s)},$=v=>{const e=[];for(const t of v.edges){const s=t.getOtherFace(v);s&&e.push(s)}return e},Ce=(v,e)=>v.start===e||v.end===e;class re{constructor(e,t,s){E(this,"dirtyFaces");E(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(i,r)=>{this.dirtyFaces.add(i);for(const c of $(i))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;if(t===s-1)for(const i of e.edges){const r=i.getOtherFace(e);if(r){const c=this.state.getFaceValue(r),a=r.edges.length;if(c===a-1){const l=new Set([...$(e),...$(r)]);if(this.board.faces.some(o=>(this.state.getFaceValue(o)??0)>0&&!l.has(o))){const o=C=>!Ce(C,i.start)&&!Ce(C,i.end),n=e.edges.filter(o),h=r.edges.filter(o),d=C=>!C.faces.some(F=>F===e||F===r),g=[...i.start.edges.filter(d),...i.end.edges.filter(d)],S=[i,...n,...h].filter(C=>this.state.getEdgeState(C)!==f.BLACK),y=g.filter(C=>this.state.getEdgeState(C)!==f.RED);if(S.length||y.length)return new L(new k([...S.map(C=>new B(C,f.BLACK)),...y.map(C=>new B(C,f.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:S,toRedEdges:y},this.board)}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new re(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ae{constructor(e,t,s){E(this,"dirtySectors");E(this,"edgeListener");E(this,"sectorListener");this.board=e,this.state=t,s?this.dirtySectors=new Set(s):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(i,r,c)=>{this.dirtySectors.add(i.forwardHalf),this.dirtySectors.add(i.forwardHalf.previous),this.dirtySectors.add(i.reversedHalf),this.dirtySectors.add(i.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(i,r,c)=>{this.dirtySectors.add(i)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,i=this.state.getSectorState(e);if(i===H.NONE)throw new T(`invalid sector state: ${i}`);const r=this.state.getEdgeState(t),c=this.state.getEdgeState(s),a=(r===f.WHITE?1:0)+(c===f.WHITE?1:0),l=(r===f.BLACK?1:0)+(c===f.BLACK?1:0),o=(n,h)=>new L(new k([...n.map(d=>new B(d,f.BLACK)),...h.map(d=>new B(d,f.RED))]),{type:"ForcedSector",sector:e,sectorState:i,toRedEdges:h,toBlackEdges:n},this.board);if(a===0){if(!i.allows(l))throw new T(`invalid state: ${i} with ${l} black edges with no white`)}else if(a===1){const n=i.allows(l),h=i.allows(l+1);if(!n&&!h)throw new T(`invalid state: ${i} with ${l} black edges and 1 white`);if(n&&!h)return o([],[r===f.WHITE?t:s]);if(h&&!n)return o([r===f.WHITE?t:s],[])}else if(a===2){if(i===H.ONLY_ZERO)return o([],[t,s]);if(i===H.ONLY_TWO)return o([t,s],[])}else throw new T(`invalid white count: ${a}`)}return null}clone(e){return new ae(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class M{constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new M(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:be(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new M(Re(e,t.sector),H.deserialize(t.state))}}class ne{constructor(e,t,s){E(this,"dirtyFaces");E(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(i,r)=>{this.dirtyFaces.add(i);for(const c of $(i))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;let i=null;if(t===0?i=H.ONLY_ZERO:t===1?i=H.NOT_TWO:t===s-1?i=H.NOT_ZERO:t===s&&(i=H.ONLY_TWO),i){const r=e.halfEdges,c=[],a=[];for(const l of r){const o=this.state.getSectorState(l),n=o.and(i);if(n===H.NONE)throw new T(`invalid sector state: ${o}`);o!==n&&(c.push(new M(l,n)),a.push(l))}if(c.length)return new L(new k(c),{type:"StaticFaceSectors",face:e,sectors:a},this.board)}this.dirtyFaces.delete(e)}return null}clone(e){return new ne(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ce{constructor(e,t,s,i){E(this,"dirtyVertices",[]);E(this,"vertexListener");this.board=e,this.state=t,this.options=s,i?this.dirtyVertices.push(...i):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new T("Vertex has no possibilities");const s=[],i=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const a=t.getFinalStatesOfEdge(r);if(a.size===1){const l=[...a][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&i.push(r)}}if(s.length||i.length)return new L(new k([...s.map(r=>new B(r,f.RED)),...i.map(r=>new B(r,f.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:s,toBlackEdges:i},this.board)}return null}clone(e){return new ce(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class le{constructor(e,t,s){E(this,"dirtyVertices",[]);E(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=i=>{this.dirtyVertices.push(i)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new T("Vertex has no possibilities");const s=Te(e),i=s.map(o=>this.state.getSectorState(o)),r=s.map(o=>H.NONE);for(const o of t.getAllowedPairs())for(let n=0;n<s.length;n++){const h=s[n],d=h.edge,g=h.next.edge,S=o[0],y=o[1],C=(d===S||d===y?1:0)+(g===S||g===y?1:0);r[n]=r[n].with(C)}if(t.allowsEmpty())for(let o=0;o<s.length;o++)r[o]=r[o].withZero(!0);for(let o=0;o<s.length;o++)r[o]=r[o].and(i[o]);for(const o of r)if(o===H.NONE)throw new T("Sector has no possibilities");const c=[],a=[],l=[];for(let o=0;o<s.length;o++)i[o]!==r[o]&&(c.push(s[o]),a.push(i[o]),l.push(r[o]));if(c.length)return new L(new k(c.map((o,n)=>new M(o,l[n]))),{type:"VertexStateToSector",vertex:e,sectors:c,beforeStates:a,afterStates:l},this.board)}return null}clone(e){return new le(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class de{constructor(e,t,s){E(this,"dirtyVertices",[]);E(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=i=>{this.dirtyVertices.push(i)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new T("Vertex has no possibilities");const i=Be(e).map(a=>a.face?this.state.getFaceColor(a.face):this.state.getOutsideColor()),r=new Set(i);if(r.size!==1){const a=new Map([...r].map(o=>[o,new Map([...r].map(n=>[n,!1]))])),l=new Map([...r].map(o=>[o,new Map([...r].map(n=>[n,!1]))]));for(const o of t.getAllowedPairs()){const n=e.edges.indexOf(o[0]),h=e.edges.indexOf(o[1]),d=Math.min(n,h),g=Math.max(n,h),S=i.slice(d,g),y=[...i.slice(g),...i.slice(0,d)],C=F=>{for(let O=0;O<F.length;O++)for(let p=O+1;p<F.length;p++)a.get(F[O]).set(F[p],!0),a.get(F[p]).set(F[O],!0)};C(S),C(y);for(const F of S)for(const O of y)F!==O&&(l.get(F).set(O,!0),l.get(O).set(F,!0))}for(const o of r)for(const n of r){if(o===n)continue;const h=t.allowsEmpty()||a.get(o).get(n),d=l.get(o).get(n);if(h&&!d)return new L(new Q(W(this.state,o),W(this.state,n)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===o),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===n)},this.board);if(d&&!h&&this.state.getOppositeFaceColor(o)!==n)return new L(new J(W(this.state,o),W(this.state,n)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===o),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===n)},this.board)}}const c=this.dirtyVertices.pop();P()&&z(c===e)}return null}clone(e){return new de(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Z{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const t=e.getFaceState(this.face);return new Z(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:Oe(this.face),state:this.state.serialize()}}static deserializeAction(e,t){const s=Pe(e,t.face);return new Z(s,ve.deserialize(s,t.state))}}class Y{constructor(e,t,s){E(this,"dirtyFaces");E(this,"faceValueListener");E(this,"vertexStateListener");E(this,"faceColorListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces.filter(i=>t.getFaceValue(i)!==null)),this.faceValueListener=(i,r)=>{this.dirtyFaces.add(i)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=i=>{for(const r of i.faces)this.dirtyFaces.add(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(i,r,c,a)=>{const l=o=>{this.dirtyFaces.add(o);for(const n of o.edges){const h=n.getOtherFace(o);h&&this.dirtyFaces.add(h)}};for(const o of a)l(o);for(const o of[...i,...c]){const n=this.state.getFacesWithColor(o);for(const h of n)l(h)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const t=this.state.getFaceState(e),s=ve.fromVertexAndColorData(e,this.board,this.state).and(t);if(!t.equals(s))return new L(new Z(e,s),{type:"FaceState",face:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new Y(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class he{constructor(e,t,s,i){E(this,"dirtyFaces",[]);E(this,"vertexListener");this.board=e,this.state=t,this.options=s,i?this.dirtyFaces.push(...i):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new T("Face has no possibilities");const s=[],i=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const a=t.getFinalStatesOfEdge(r);if(a.size===1){const l=[...a][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&i.push(r)}}if(s.length||i.length)return new L(new k([...s.map(r=>new B(r,f.RED)),...i.map(r=>new B(r,f.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:s,toBlackEdges:i},this.board)}return null}clone(e){return new he(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class fe{constructor(e,t,s){E(this,"dirtyFaces",[]);E(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new T("Face has no possibilities");const s=e.halfEdges,i=s.map(o=>this.state.getSectorState(o)),r=s.map(o=>H.NONE);for(const o of t.getAllowedCombinations())for(let n=0;n<s.length;n++){const h=s[n],d=h.edge,g=h.next.edge,S=(o.includes(d)?1:0)+(o.includes(g)?1:0);r[n]=r[n].with(S)}for(let o=0;o<s.length;o++)r[o]=r[o].and(i[o]);for(const o of r)if(o===H.NONE)throw new T("Sector has no possibilities");const c=[],a=[],l=[];for(let o=0;o<s.length;o++)i[o]!==r[o]&&(c.push(s[o]),a.push(i[o]),l.push(r[o]));if(c.length)return new L(new k(c.map((o,n)=>new M(o,l[n]))),{type:"FaceStateToSector",face:e,sectors:c,beforeStates:a,afterStates:l},this.board)}return null}clone(e){return new fe(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class ge{constructor(e,t,s){E(this,"dirtyFaces",[]);E(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new T("Face has no possibilities");const s=new Map(e.edges.map(l=>{const o=l.getOtherFace(e);return[l,o?this.state.getFaceColor(o):this.state.getOutsideColor()]})),i=[e,...e.edges.map(l=>l.getOtherFace(e)).filter(U.identity)],r=this.state.getFaceColor(e),c=new Set([...s.values(),r]);if(c.size!==1){const l=new Map([...c].map(n=>[n,new Map([...c].map(h=>[h,!1]))])),o=new Map([...c].map(n=>[n,new Map([...c].map(h=>[h,!1]))]));for(const n of t.getAllowedCombinations()){const h=new Set([r]),d=new Set;for(const S of e.edges)n.includes(S)?d.add(s.get(S)):h.add(s.get(S));const g=S=>{for(let y=0;y<S.length;y++)for(let C=y+1;C<S.length;C++)l.get(S[y]).set(S[C],!0),l.get(S[C]).set(S[y],!0)};g([...h]),g([...d]);for(const S of h)for(const y of d)S!==y&&(o.get(S).set(y,!0),o.get(y).set(S,!0))}for(const n of c)for(const h of c){if(n===h)continue;const d=l.get(n).get(h),g=o.get(n).get(h);if(d&&!g)return new L(new Q(W(this.state,n),W(this.state,h)),{type:"FaceStateToSameFaceColor",face:e,facesA:i.filter(S=>this.state.getFaceColor(S)===n),facesB:i.filter(S=>this.state.getFaceColor(S)===h)},this.board);if(g&&!d&&this.state.getOppositeFaceColor(n)!==h)return new L(new J(W(this.state,n),W(this.state,h)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:i.filter(S=>this.state.getFaceColor(S)===n),facesB:i.filter(S=>this.state.getFaceColor(S)===h)},this.board)}}const a=this.dirtyFaces.pop();P()&&z(a===e)}return null}clone(e){return new ge(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class q{constructor(e,t){this.vertex=e,this.state=t}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const t=e.getVertexState(this.vertex);return new q(this.vertex,t)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:ze(this.vertex),state:this.state.serialize()}}static deserializeAction(e,t){const s=ke(e,t.vertex);return new q(s,_.deserialize(s,t.state))}}class ue{constructor(e,t,s){E(this,"dirtyFaces",[]);E(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new T("Face has no possibilities");const s=e.vertices.map(a=>this.state.getVertexState(a)),i=s.map(a=>{const l=a.vertex.edges.filter(o=>o.faces.includes(e));return P()&&z(l.length===2),{vertex:a.vertex,vertexState:a,edgeA:l[0],edgeB:l[1],...a.getBinaryCombinationsAllowed(l[0],l[1])}}),r=i.map(a=>({vertex:a.vertex,vertexState:a.vertexState,edgeA:a.edgeA,edgeB:a.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const a of t.getAllowedCombinations())for(const l of r){const o=a.includes(l.edgeA),n=a.includes(l.edgeB);o&&n&&(l.allowsBoth=!0),o&&!n&&(l.allowsAOnly=!0),!o&&n&&(l.allowsBOnly=!0),!o&&!n&&(l.allowsNone=!0)}const c=[];for(let a=0;a<r.length;a++){const l=i[a],o=r[a];if(o.allowsBoth&&(o.allowsBoth=l.allowsBoth),o.allowsAOnly&&(o.allowsAOnly=l.allowsAOnly),o.allowsBOnly&&(o.allowsBOnly=l.allowsBOnly),o.allowsNone&&(o.allowsNone=l.allowsNone),o.allowsBoth!==l.allowsBoth||o.allowsAOnly!==l.allowsAOnly||o.allowsBOnly!==l.allowsBOnly||o.allowsNone!==l.allowsNone){const n=l.vertexState,h=_.fromLookup(l.vertex,(d,g)=>{if(!n.allowsPair(d,g))return!1;const y=d===o.edgeA||g===o.edgeA,C=d===o.edgeB||g===o.edgeB;if(y&&C)return o.allowsBoth;if(y&&!C)return o.allowsAOnly;if(!y&&C)return o.allowsBOnly;if(!y&&!C)return o.allowsNone;throw new Error("Unreachable")},n.allowsEmpty()&&o.allowsNone);P()&&z(h.isSubsetOf(n)),n.equals(h)||c.push(h)}}if(c.length)return new L(new k(c.map(a=>new q(a.vertex,a))),{type:"FaceStateToVertexState",face:e,vertices:c.map(a=>a.vertex),beforeStates:c.map(a=>s.find(l=>l.vertex===a.vertex)),afterStates:c},this.board)}return null}clone(e){return new ue(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}const me=()=>Ae.nextInt(Number.MAX_SAFE_INTEGER);class N{constructor(e,t){E(this,"dirtyEdges",new Set);E(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>{this.dirtyEdges.add(s)}),this.edgeListener=(s,i)=>{this.dirtyEdges.add(s)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),t=this.state.getWeirdEdges(),s=new Set,i=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===f.BLACK?s.add(d):i.add(d);const r=new Set,c=new Set,a=new Set(e),l=new Set,o=new Set,n=new Set(t);for(const d of i)n.has(d)&&(n.delete(d),o.add(d));for(const d of s)n.has(d)&&s.delete(d),[...a].some(g=>g.halfEdges.some(S=>S.edge===d))&&s.delete(d);for(const d of e)if(d.halfEdges.some(g=>i.has(g.edge))){const g=[];let S=[];for(const y of d.halfEdges)i.has(y.edge)?S.length>0&&(g.push(S),S=[]):S.push(y);if(S.length>0&&g.push(S),c.add(d),a.delete(d),g.length){if(d.isSolved&&g.length>1){const C=g[0][0],F=g[g.length-1][g[g.length-1].length-1];C.start===F.end&&g[0].unshift(...g.pop())}const y=U.maxBy(g,C=>C.length);for(const C of g){const F=new K(C===y?d.id:me(),C);r.add(F),a.add(F)}}}const h=d=>{const g=d.start,S=d.end,y=[...a].find(w=>w.a===g||w.b===g)||null,C=[...a].find(w=>w.a===S||w.b===S)||null,F=g.edges.filter(w=>this.state.getEdgeState(w)===f.BLACK).length,O=S.edges.filter(w=>this.state.getEdgeState(w)===f.BLACK).length;if(F>2||O>2)return!1;const p=w=>{a.add(w),r.add(w)},m=w=>{a.delete(w),r.has(w)?r.delete(w):c.add(w)};if(y&&C)if(y===C)if(N.isSolvedWithAddedEdge(this.board,this.state,y,d))m(y),p(new K(y.id,N.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]),!0));else return!1;else{const w=y.halfEdges.length>=C.halfEdges.length?y:C,u=w===y?C:y,A=new K(w.id,N.combineHalfEdgeArrays(w.halfEdges,[d.forwardHalf],u.halfEdges));m(w),m(u),p(A)}else if(y){const w=new K(y.id,N.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]));m(y),p(w)}else if(C){const w=new K(C.id,N.combineHalfEdgeArrays(C.halfEdges,[d.forwardHalf]));m(C),p(w)}else{const w=new K(me(),[d.forwardHalf]);p(w)}return!0};for(const d of n)h(d)&&(o.add(d),n.delete(d));for(const d of s)h(d)||(l.add(d),n.add(d));return this.dirtyEdges.clear(),r.size||c.size||l.size||o.size?new L(new De(this.board,r,c,l,o),{type:"SimpleRegions"},this.board):null}clone(e){return new N(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,t,s,i){if(i.start!==s.a&&i.start!==s.b||i.end!==s.a&&i.end!==s.b)return!1;const r=new Set(s.edges);r.add(i);for(const c of e.faces){const a=t.getFaceValue(c);if(a!==null&&c.edges.filter(o=>r.has(o)).length!==a)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let t=[...e[0]];for(let s=1;s<e.length;s++){const i=e[s];if(i.length!==0)if(t[0].start===i[0].start)t=[...i.map(r=>r.reversed).reverse(),...t];else if(t[0].start===i[i.length-1].end)t=[...i,...t];else if(t[t.length-1].end===i[0].start)t=[...t,...i];else if(t[t.length-1].end===i[i.length-1].end)t=[...t,...i.map(r=>r.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return t}}class pe{constructor(e,t){E(this,"hasDirtySimpleRegions",!0);E(this,"simpleRegionListener");this.board=e,this.state=t,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(Ie(this.state)){const e=this.board.edges.filter(t=>this.state.getEdgeState(t)===f.WHITE);if(e.length)return new L(new k(e.map(t=>new B(t,f.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e},this.board)}return this.hasDirtySimpleRegions=!1,null}clone(e){return new pe(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}class $e{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Se{constructor(e,t){E(this,"hadEdgeAdjusted",!1);E(this,"dirtyEdges",new Set);E(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>this.dirtyEdges.add(s)),this.edgeListener=(s,i,r)=>{this.dirtyEdges.add(s),this.hadEdgeAdjusted=this.hadEdgeAdjusted||r!==f.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var t;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const s=new Map,i=new X(j.OUTSIDE,new Set),r=new X(j.INSIDE,new Set);i.opposite=r,r.opposite=i;const c=new Set([i,r,...this.board.faces.map(p=>{const m=new X(j.UNDECIDED,new Set([p]));return s.set(p,m),m})]);let a=!1;const l=p=>{if(p===null)return i;const m=s.get(p);return P()&&z(m),m},o=(p,m)=>{if(m===i||m===r)return o(m,p);P()&&z(p!==m);for(const w of m.faces)p.faces.add(w),s.set(w,p);return m.faces.clear(),c.delete(m),p},n=(p,m)=>{if(P()&&z(c.has(p)&&c.has(m)),p===m)return;const w=p.opposite,u=m.opposite;if(w&&w===m){a=!0;return}if(u&&u===p){a=!0;return}const A=o(p,m),x=w&&u?o(w,u):w||u;A.opposite=x,x&&(x.opposite=A)},h=(p,m)=>{if(P()&&z(c.has(p)&&c.has(m)),p===m){a=!0;return}if(p.opposite&&p.opposite===m)return;const w=p.opposite,u=m.opposite;if(w&&w===u){a=!0;return}const A=u?o(p,u):p,x=w?o(m,w):m;A.opposite=x,x.opposite=A};for(const p of this.board.edges){if(a)break;const m=this.state.getEdgeState(p);if(m!==f.WHITE){const w=l(p.forwardFace),u=l(p.reversedFace);m===f.BLACK?h(w,u):m===f.RED&&n(w,u)}}if(P()){const p=new Set(this.board.faces);for(const m of c)for(const w of m.faces)p.delete(w);z(p.size===0)}if(a)return new L(new $e,{type:"InvalidFaceColoring"},this.board);const d=new Set(this.state.getFaceColors()),g=new Set,S=new Map,y=(p,m)=>{P()&&z(d.has(p)),P()&&z(m.faceColor===null),d.delete(p),m.faceColor=p};y(this.state.getOutsideColor(),i),y(this.state.getInsideColor(),r);for(const p of c){if(!p.faceColor){const w=new Set([...p.faces].map(x=>this.state.getFaceColor(x)));let u=null,A=0;for(const x of w){if(!d.has(x))continue;const V=this.state.getFacesWithColor(x);V.some(R=>!p.faces.has(R))||V.length>A&&(u=x,A=V.length)}if(u)y(u,p);else{const x=new He(We(),j.UNDECIDED);g.add(x),p.faceColor=x}}const m=p.faceColor;P()&&z(m),p.faces.forEach(w=>{this.state.getFaceColor(w)!==m&&S.set(w,m)})}const C=new Set(d),F=new Map;for(const p of c){const m=p.faceColor,w=((t=p.opposite)==null?void 0:t.faceColor)??null;let u=g.has(m);u||(u=this.state.getOppositeFaceColor(m)!==w),u&&F.set(m,w)}return g.size>0||C.size>0||S.size>0||F.size>0||this.state.hasInvalidFaceColors()?new L(new Ne(this.board,g,C,S,F,!1),{type:"GeneralFaceColoring"},this.board):null}else for(;this.dirtyEdges.size;){const s=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(s);const i=this.state.getEdgeState(s);if(i!==f.WHITE){const r=s.forwardFace?this.state.getFaceColor(s.forwardFace):this.state.getOutsideColor(),c=s.reversedFace?this.state.getFaceColor(s.reversedFace):this.state.getOutsideColor();if(i===f.BLACK){if(this.state.getOppositeFaceColor(r)!==c)return new L(new J(W(this.state,r),W(this.state,c)),{type:"FaceColoringBlackEdge",edge:s},this.board)}else if(i===f.RED&&r!==c)return new L(new Q(W(this.state,r),W(this.state,c)),{type:"FaceColoringRedEdge",edge:s},this.board)}}return null}clone(e){return new Se(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class X{constructor(e,t){E(this,"opposite",null);E(this,"faceColor",null);this.colorState=e,this.faces=t}}class we{constructor(e,t){E(this,"dirtySectors",new Set);E(this,"edgeListener");this.board=e,this.state=t,e.halfEdges.forEach(s=>this.dirtySectors.add(s)),this.edgeListener=(s,i,r)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,i=this.state.getEdgeState(t),r=this.state.getEdgeState(s),c=this.state.getSectorState(e);let a=c;const l=(i===f.WHITE?1:0)+(r===f.WHITE?1:0),o=(i===f.BLACK?1:0)+(r===f.BLACK?1:0),n=(i===f.RED?1:0)+(r===f.RED?1:0);if(l===0?a=H.getOnly(o):l===1&&(o&&a.zero&&(a=a.withDisallowZero()),n&&a.two&&(a=a.withDisallowTwo())),a!==c)return new L(new M(e,a),{type:l===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:c,afterState:a},this.board)}return null}clone(e){return new we(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class ye{constructor(e,t){E(this,"dirtyVertices",new Set);E(this,"edgeListener");E(this,"sectorListener");E(this,"faceColorListener");this.board=e,this.state=t,e.vertices.forEach(s=>this.dirtyVertices.add(s)),this.edgeListener=(s,i,r)=>{this.dirtyVertices.add(s.start),this.dirtyVertices.add(s.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,i,r)=>{this.dirtyVertices.add(s.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(s,i,r,c)=>{for(const a of c)for(const l of a.vertices)this.dirtyVertices.add(l);for(const a of r){const l=this.state.getFacesWithColor(a);for(const o of l)for(const n of o.vertices)this.dirtyVertices.add(n)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const t=this.state.getVertexState(e),s=_.fromEdgeColorSectorData(e,this.state).and(t);if(!t.equals(s))return new L(new q(e,s),{type:"VertexState",vertex:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new ye(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}const Fe=(v,e,t)=>new G([new N(v,e),new pe(v,e),new Se(v,e),new we(v,e),new ye(v,e)]),Vt=new b("autoSolveEnabledProperty",!0),bt=new b("autoSolveToBlackProperty",!1),Rt=new b("autoSolveSimpleLoopsProperty",!1),Ze=new b("autoSolveSimpleVertexJointToRedProperty",!0),Je=new b("autoSolveSimpleVertexForcedLineToBlackProperty",!0),Ye=new b("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),Xe=new b("autoSolveSimpleFaceToRedProperty",!0),Qe=new b("autoSolveSimpleFaceToBlackProperty",!0),_e=new b("autoSolveSimpleLoopToRedProperty",!0),et=new b("autoSolveSimpleLoopToBlackProperty",!1),tt=new b("autoSolveDoubleMinusOneFacesProperty",!1),st=new b("autoSolveStaticFaceSectorProperty",!0),ot=new b("autoSolveSimpleSectorProperty",!1),it=new b("autoSolveVertexToRedEdgeProperty",!1),rt=new b("autoSolveVertexToBlackEdgeProperty",!1),at=new b("autoSolveVertexToSectorsProperty",!1),nt=new b("autoSolveVertexToFaceColorProperty",!1),ct=new b("autoSolveFaceColorToRedProperty",!1),lt=new b("autoSolveFaceColorToBlackProperty",!1),dt=new b("autoSolveFaceColorParityToRedProperty",!1),ht=new b("autoSolveFaceColorParityToBlackProperty",!1),ft=new b("autoSolveFaceColorParityColorsProperty",!1),gt=new b("autoSolveFaceColorParityPartialReductionProperty",!1),ut=new b("autoSolveVertexColorToFaceProperty",!1),pt=new b("autoSolveFaceToRedProperty",!1),St=new b("autoSolveFaceToBlackProperty",!1),wt=new b("autoSolveFaceToSectorsProperty",!1),yt=new b("autoSolveFaceToFaceColorsProperty",!1),Et=new b("autoSolveFaceToVertexProperty",!1),Ct=(v,e,t)=>new G([Fe(v,e),new Y(v,e)]),Tt=(v,e)=>{Ge(Ct,v,e,!0)},Bt=new Ve([Ze,Je,Ye,Xe,Qe,_e,et,tt,st,ot,it,rt,at,nt,ct,lt,dt,ht,ft,gt,ut,pt,St,wt,yt,Et],(v,e,t,s,i,r,c,a,l,o,n,h,d,g,S,y,C,F,O,p,m,w,u,A,x,V)=>(R,D,I)=>new G([...v||e||t?[new te(R,D,{solveJointToRed:v,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},I?void 0:[])]:[],...s||i?[new se(R,D,{solveToRed:s,solveToBlack:i},I?void 0:[])]:[],...a?[new re(R,D,I?void 0:[])]:[],Fe(R,D),...l?[new ne(R,D,I?void 0:[])]:[],...o?[new ae(R,D,I?void 0:[])]:[],...r||c?[new oe(R,D,{solveToRed:r,solveToBlack:c,resolveAllRegions:!1},I?void 0:[])]:[],...n||h?[new ce(R,D,{solveToRed:n,solveToBlack:h},I?void 0:[])]:[],...d?[new le(R,D,I?void 0:[])]:[],...S||y?[new ee(R,D,{solveToRed:S,solveToBlack:y},I?void 0:[])]:[],...C||F||O?[new ie(R,D,{solveToRed:C,solveToBlack:F,solveColors:O,allowPartialReduction:p},I?void 0:[])]:[],...g?[new de(R,D,I?void 0:[])]:[],...m?[new Y(R,D,I?void 0:[])]:[],...w||u?[new he(R,D,{solveToRed:w,solveToBlack:u},I?void 0:[])]:[],...A?[new fe(R,D,I?void 0:[])]:[],...x?[new ge(R,D,I?void 0:[])]:[],...V?[new ue(R,D,I?void 0:[])]:[]]));export{fe as $,St as A,wt as B,yt as C,bt as D,Rt as E,Tt as F,G,N as H,T as I,pe as J,Se as K,te as L,se as M,oe as N,re as O,we as P,ne as Q,ae as R,M as S,ye as T,le as U,ce as V,ee as W,ie as X,de as Y,Y as Z,he as _,Vt as a,ge as a0,ue as a1,Bt as a2,Fe as a3,Ze as b,Je as c,Ye as d,Xe as e,Qe as f,W as g,_e as h,Ge as i,et as j,tt as k,st as l,ot as m,it as n,rt as o,at as p,nt as q,ct as r,lt as s,dt as t,ht as u,ft as v,qe as w,gt as x,ut as y,pt as z};
