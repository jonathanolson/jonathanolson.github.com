var co=Object.defineProperty;var ho=(a,t,e)=>t in a?co(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var g=(a,t,e)=>ho(a,typeof t!="symbol"?t+"":t,e);import{u as uo,c as de,R as it,S as po,T as go,U as fo,V as So,f as wo,g as yo,h as pt,J as Co,s as gt,i as Eo,j as mo,v as ft,k as Po,m as St,w as vo,n as he,o as Fo,q as Vo,x as To,y as Do,I as ue,G as Oo,E as Ao,A as bo,C as No,W as Io,r as Lo}from"./Theme-D5xBVTq4.js";import{E as we,a as ye,d as ko,V as J,k as Ge,o as We,b as pe,T as h,P as Re,l as xo,c as Bt,C as Ro,B as Qe}from"./Vector2Property-mpypjo8N.js";import{a as z,N as k,F as Le,q as wt,P as K,M as Se,r as yt,T as Wt,G as Mo,C as Ut,h as W,B as be,g as Bo,R as Wo,H as Ht,L as Uo}from"./PhetioControlledVisibilityProperty-C-W8fgEx.js";import{a as nt,b as Ho,L as ge,f as zo,c as Yo,P as zt}from"./localStorage-B8VWGy9j.js";import{S as M,d as A,e as b,_ as je,ac as Yt,m as Go,H as jo,ad as Ko,h as Ct,L as Et,ae as Xo,k as _o,o as qo,l as Jo,i as Zo}from"./patternBoards-59tNjMFd.js";import{E as v,F as T,S as N,V as lt,d as Gt,e as jt,f as Kt,g as mt,h as Pt,i as rt,j as st,k as $o,l as Qo,m as Ke,n as ct,U as et,o as vt,p as er,q as Ft,r as tr,s as or,t as Vt,u as rr,B as Tt,C as sr}from"./BasicPuzzle-D1EmEwC1.js";import{I as ee,D as Xe,J as Fe,S as Xt,K as _t,L as qt,N as Jt,O as Zt,P as $t,Q as ar,R as Qt,T as eo,U as ir,V as to,W as nr,X as lr,Y as Ze,Z as cr,_ as dr,$ as oo,a0 as hr,a1 as ur,a2 as pr,a3 as gr,a4 as fr,B as Sr,C as wr,a5 as oe,A as yr,a6 as Dt,F as Cr,a7 as Er}from"./SATSolver-I2LwIpNX.js";import{A as mr}from"./SpinningIndicatorNode-BFgzh9_P.js";import{a as Pr,B as vr,R as Fr,b as Vr,c as Tr,d as Dr,S as Or,e as Ar}from"./PatternRule-DfusC3Hu.js";const Pe=class Pe extends we{};g(Pe,"PAN_ONLY",new Pe),g(Pe,"DRAG_ONLY",new Pe),g(Pe,"enumeration",new ye(Pe));let _e=Pe;const br=new nt("panDragModeProperty",_e.PAN_ONLY),ro=new z([br],a=>a===_e.DRAG_ONLY);class dt extends k{constructor(t,e,o,r){super();const s=new Set;if(r!=null&&r.delayInteractionEmitter){const f=r==null?void 0:r.delayInteractionEmitter,p=S=>{s.add(S),setTimeout(()=>{s.delete(S)},700)};f.addListener(p),this.disposeEmitter.addListener(()=>f.removeListener(p))}const c=new M,d=t.map(f=>{const p=e(f);return p.makeImmutable(),c.subpaths.push(...p.subpaths),p});this.mouseArea=this.touchArea=c.makeImmutable();const i=f=>{const p=f.trail.globalToLocalPoint(f.pointer.point);for(let S=0;S<d.length;S++){const w=d[S];if(w.bounds.containsPoint(p)&&w.containsPoint(p)){const C=t[S];if(!s.has(C))return C}}return null},n=(f,p)=>{const S=i(f);S&&o(S,p)};this.cursor="pointer";const l=new Le({mouseButton:0,fire:f=>{var p;return n(f,(p=f.domEvent)!=null&&p.shiftKey?2:0)}}),u=new Le({mouseButton:2,fire:f=>{var p;return n(f,(p=f.domEvent)!=null&&p.shiftKey?0:2)}}),y=new Le({mouseButton:1,fire:f=>n(f,1)});if(this.disposeEmitter.addListener(()=>{l.dispose(),u.dispose(),y.dispose()}),r!=null&&r.isDragModeProperty){const f=r.isDragModeProperty,p=(V,F)=>{var I,L;const D=i(V);D?(I=r.onDragStart)==null||I.call(r,D,F):r.noItemItem!==void 0&&((L=r.onDragStart)==null||L.call(r,r.noItemItem,F))},S=V=>{var I,L;const F=V.trail.globalToLocalPoint(V.pointer.point),D=i(V);D?(I=r.onDrag)==null||I.call(r,D,F):r.noItemItem!==void 0&&((L=r.onDrag)==null||L.call(r,r.noItemItem,F))},w=()=>{var V;(V=r.onDragEnd)==null||V.call(r)},C=V=>V?!!i(V):!1,E=new wt({mouseButton:0,start:V=>{var F;return p(V,(F=V.domEvent)!=null&&F.shiftKey?2:0)},drag:S,end:w,canStartPress:C}),m=new wt({mouseButton:2,start:V=>{var F;return p(V,(F=V.domEvent)!=null&&F.shiftKey?0:2)},drag:S,end:w,canStartPress:C});this.disposeEmitter.addListener(()=>{E.dispose(),m.dispose()});const P=V=>{this.inputListeners=V?[E,m]:[l,u,y]};f.link(P),this.disposeEmitter.addListener(()=>f.unlink(P))}else this.addInputListener(l),this.addInputListener(u),this.addInputListener(y)}}class Nr extends dt{constructor(t,e,o){super(t.edges,r=>{const s=r.start.viewCoordinates,c=r.end.viewCoordinates,d=new M;let i;if(r.faces.length===2)i=[s,r.faces[0].viewCoordinates,c,r.faces[1].viewCoordinates];else{A()&&b(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const n=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;A()&&b(n.previous.face===null),A()&&b(n.next.face===null);const l=n.start.viewCoordinates,u=n.end.viewCoordinates,y=n.previous.start.viewCoordinates,f=n.next.end.viewCoordinates,p=(C,E,m)=>{const P=E.minus(C).normalized(),V=m.minus(E).normalized();let F=P.minus(V);return F.getMagnitude()<1e-6?F=P.getPerpendicular():F=F.normalized(),ko.triangleAreaSigned(C,E,E.plus(F))<0&&(F=F.negated()),F},S=p(y,l,u),w=p(l,u,f);i=[l,r.faces[0].viewCoordinates,u,u.plus(w.times(o.backgroundOffsetDistance)),l.plus(S.times(o.backgroundOffsetDistance))]}return d.polygon(i),d.makeImmutable(),d},o.edgePressListener,{delayInteractionEmitter:e,isDragModeProperty:ro,onDragStart:o.onEdgeDragStart,onDrag:o.onEdgeDrag,onDragEnd:o.onEdgeDragEnd})}}class Ir extends k{constructor(t,e,o,r){const s=new K(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),c=new K(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),d=new K(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,c,d],pickable:!1});const i=t.edges.map(S=>v.BLACK);let n=!1,l=!1,u=!1,y=!1,f=null;const p=Se.multilink([e,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(S,w,C,E,m,P,V)=>{if(this.visible=!w,s.visible=C,c.visible=E,d.visible=P,this.visible){let F=!1;for(let D=0;D<t.edges.length;D++){const I=S.getEdgeState(t.edges[D]);I!==i[D]&&(F=!0,i[D]=I)}if(n!==m&&(F=!0,n=m),l!==C&&(F=!0,l=C),u!==E&&(F=!0,u=E),y!==P&&(F=!0,y=P),f!==V&&(F=!0,f=V),F){const D=new M,I=new M,L=new M;for(let U=0;U<t.edges.length;U++){const q=i[U];if(C&&q===v.WHITE){const R=t.edges[U];D.moveTo(R.start.viewCoordinates.x,R.start.viewCoordinates.y),D.lineTo(R.end.viewCoordinates.x,R.end.viewCoordinates.y)}if(q===v.RED){if(E){const R=t.edges[U],B=.07;let O=R.start.viewCoordinates.blend(R.end.viewCoordinates,.5);if(m){const Y=R.end.viewCoordinates.minus(R.start.viewCoordinates).getAngle(),X=new J(-B,-B).rotate(Y).add(O),te=new J(B,B).rotate(Y).add(O),ie=new J(-B,B).rotate(Y).add(O),Ve=new J(B,-B).rotate(Y).add(O);I.moveTo(X.x,X.y),I.lineTo(te.x,te.y),I.moveTo(ie.x,ie.y),I.lineTo(Ve.x,Ve.y)}else I.moveTo(O.x-B,O.y-B),I.lineTo(O.x+B,O.y+B),I.moveTo(O.x-B,O.y+B),I.lineTo(O.x+B,O.y-B)}if(P){const R=t.edges[U],B=.4,O=.017,Y=R.start.viewCoordinates.blend(R.end.viewCoordinates,.5),X=Y.blend(R.start.viewCoordinates,B),te=Y.blend(R.end.viewCoordinates,B);for(let ie=0;ie<5;ie++){const Ve=X.blend(te,ie/4);L.moveTo(Ve.x+O,Ve.y),L.arc(Ve.x,Ve.y,O,0,2*Math.PI,!1)}}}}D.makeImmutable(),I.makeImmutable(),L.makeImmutable(),s.shape=D,c.shape=I,d.shape=L}}});this.disposeEmitter.addListener(()=>p.dispose())}}class Lr extends k{constructor(e,o,r){const s=new k;super({pickable:!1,children:[s]});g(this,"faceColorNodeMap",new Map);g(this,"faceColorIdMap",new Map);g(this,"adjacentFacesMap",new Map);g(this,"faceColorNodeContainer");g(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,e.faces.forEach(n=>{this.adjacentFacesMap.set(n,n.edges.map(l=>l.getOtherFace(n)).filter(l=>l!==null))});{const n=o.value.getFaceColors();for(const l of n)this.addFaceColor(l,o.value.getFacesWithColor(l));this.addDualColorViews(o.value,n)}this.updateHues();let c=o.value.clone();const d=n=>{const l=c;c=n.clone();const u=l.getFaceColors(),y=n.getFaceColors(),f=[],p=[],S=[];Yt(u,y,f,p,S);const w=new Set(f),C=this.removeInvalidDualColorViews(n),E=[...C];for(const m of p)if(C.add(m),this.faceColorIdMap.has(m.id)){const P=this.faceColorIdMap.get(m.id);this.replaceFaceColor(P,m,n.getFacesWithColor(m)),w.delete(P)}else this.addFaceColor(m,n.getFacesWithColor(m));for(const m of S)this.updateFaceColor(m,n.getFacesWithColor(m));for(const m of w)C.delete(m),this.removeFaceColor(m);this.addDualColorViews(n,[...C]),(p.length||f.length||E.length)&&this.updateHues()};o.lazyLink(d),this.disposeEmitter.addListener(()=>o.unlink(d)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const i=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(i),r.theme.faceColorLightHueLUTProperty.lazyLink(i),r.theme.faceColorDarkHueLUTProperty.lazyLink(i),r.theme.faceColorInsideColorProperty.lazyLink(i),r.theme.faceColorOutsideColorProperty.lazyLink(i),r.theme.faceColorDefaultColorProperty.lazyLink(i),r.faceColorThresholdProperty.lazyLink(i),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(i),r.theme.faceColorLightHueLUTProperty.unlink(i),r.theme.faceColorDarkHueLUTProperty.unlink(i),r.theme.faceColorInsideColorProperty.unlink(i),r.theme.faceColorOutsideColorProperty.unlink(i),r.theme.faceColorDefaultColorProperty.unlink(i),r.faceColorThresholdProperty.unlink(i)})}addFaceColor(e,o){const r=new xe(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){A()&&b(e.id===o.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let s=r.faces.length!==o.length;if(!s)for(let c=0;c<o.length;c++){const d=r.faces[c],i=o[c];if(d!==i){s=!0;break}}s&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const c=this.faceColorNodeMap.get(s);A()&&b(c);const d=e.getOppositeFaceColor(s);if(d){A()&&b(r.has(d)),r.delete(d);const i=this.faceColorNodeMap.get(d);A()&&b(i),this.dualColorViews.add(new Ot([c,i],this.style))}else this.dualColorViews.add(new Ot([c],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const c of s.colorNodes)o.add(c.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==T.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new J(0,0),r=()=>{for(const l of e)l.hueVector.getMagnitude()>1e-6?l.hueVector.normalize():l.hueVector.setXY(Ge.nextDouble()-.5,Ge.nextDouble()-.5).normalize()},s=new Map,c=[];this.board.faces.forEach(l=>{s.set(l,[])});for(const l of e){const u=new Set;for(const f of l.faces)u.add(f);const y=new Set;for(const f of u){y.add(f);for(const p of this.adjacentFacesMap.get(f))y.add(p)}for(const f of y){const p=s.get(f);if(p){if(p.length)for(const S of p){let w=!1;for(const C of c)if(C.a===S&&C.b===l){C.weight++,w=!0;break}w||c.push({a:S,b:l,weight:1})}p.push(l)}}}const d=new Map;for(const l of e)d.set(l,J.ZERO.copy());const i=(l,u,y)=>{const f=d.get(l),p=d.get(u),S=l.hueVector.dot(u.hueVector),w=o.set(u.hueVector).subtract(l.hueVector);w.magnitudeSquared>1e-11&&w.normalize();const C=.2,E=Math.abs(S),m=y*((Math.max(C,E)-C)/(1-C))**3;w.multiplyScalar(m),f.subtract(w),p.add(w)};let n=1;for(let l=0;l<100;l++){n*=.99;for(const u of e)d.get(u).setXY(0,0);for(const u of c){const y=u.a,f=u.b,p=u.weight;i(y,f,p)}if(e.length<8)for(let u=0;u<e.length;u++){const y=e[u];for(let f=u+1;f<e.length;f++)i(y,e[f],.2)}for(const u of e){const y=d.get(u);y.multiplyScalar(n/u.faceCount),u.hueVector.add(y),d.get(u).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const le=class le extends we{};g(le,"BASIC",new le),g(le,"PRIMARY",new le),g(le,"SECONDARY",new le),g(le,"enumeration",new ye(le));let se=le;class Ot{constructor(t,e){g(this,"hueVector");g(this,"faceCount");if(this.colorNodes=t,this.style=e,A()&&b(t.length===1||t.length===2),this.faceCount=je.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=se.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let s;o.type===se.PRIMARY?s=o:r.type===se.PRIMARY||o.type===se.SECONDARY?s=r:(r.type,se.SECONDARY,s=o);const c=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=se.PRIMARY,c.type=se.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class xe extends K{constructor(e,o,r){const s=J.createPolar(1,Ge.nextDoubleBetween(0,2*Math.PI));super(xe.toShape(o));g(this,"hueVector");g(this,"faceCount");g(this,"dualColorView",null);g(this,"type",se.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==T.UNDECIDED?this.fill=xe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=xe.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,s){const c=r===se.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===se.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,d=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&b(d>=0&&d<c.length);const i=c[d];if(o===T.UNDECIDED)return i;{const l=(o===T.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,u=l.alpha,y=new yt(i);return new yt((1-u)*y.red+u*l.red,(1-u)*y.green+u*l.green,(1-u)*y.blue+u*l.blue).toCSS()}}static toShape(e){const o=new M;for(const r of e)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class kr extends Wt{constructor(t,e){const o=We()({font:uo,fill:de.uiForegroundColorProperty},e);super(t,o)}}class xr extends k{constructor(t,e,o){super({translation:t.viewCoordinates}),this.face=t;const s=e.value.getFaceState(t),c=s.possibilityCount===0||s.possibilityCount>9;let d;const i=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(c)d=new kr(s.possibilityCount,{font:it,maxWidth:.4,maxHeight:.4});else{const n=new Set(t.vertices);d=new Mo({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(l=>{const u=new k,y=new Set(l.map(S=>S.start)),f=new Set(l.map(S=>S.end)),p=S=>S.minus(t.viewCoordinates);if(u.addChild(new K(M.polygon(t.vertices.map(S=>p(S.viewCoordinates))),{stroke:i,lineWidth:.03,opacity:.2})),y.size){const S=new M;if(l.length===t.edges.length)S.polygon(t.vertices.map(w=>p(w.viewCoordinates)));else{const w=new Set(l);for(;w.size;){const C=[...n].find(P=>[...w].filter(V=>V.start===P||V.end===P).length===1);A()&&b(C);let E=C,m=[...w].find(P=>P.start===E||P.end===E)??null;for(S.moveToPoint(p(E.viewCoordinates));m;)w.delete(m),E=m.getOtherVertex(E),S.lineToPoint(p(E.viewCoordinates)),m=[...w].find(P=>P.start===E||P.end===E)??null}}u.addChild(new K(S,{stroke:i,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const S of t.vertices)!y.has(S)&&!f.has(S)&&u.addChild(new Ut(.1,{fill:i,translation:p(S.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}d.center=J.ZERO,this.addChild(d)}}class Rr extends k{constructor(t,e,o,r){super({pickable:!1});const s=Se.multilink([e,r.faceStateVisibleProperty],(d,i)=>{this.children.forEach(n=>n.dispose()),this.children=[],i&&t.faces.forEach(n=>{this.addChild(new xr(n,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const c=d=>{this.visible=!d};o.link(c),this.disposeEmitter.addListener(()=>{o.unlink(c),this.children.forEach(d=>d.dispose())})}}class Mr extends dt{constructor(t,e){super(t.faces,o=>o?M.polygon(o.vertices.map(r=>r.viewCoordinates)):new M,e.facePressListener,{isDragModeProperty:ro,onDragStart:e.onFaceDragStart,onDrag:e.onFaceDrag,onDragEnd:e.onFaceDragEnd,noItemItem:null})}}const Ie=class Ie{constructor(t,e){this.incorrectEdges=t,this.incorrectFaces=e}isCorrect(){return this.incorrectEdges.size===0&&this.incorrectFaces.size===0}with(t){return this.isCorrect()?t:t.isCorrect()?this:new Ie(new Set([...this.incorrectEdges,...t.incorrectEdges]),new Set([...this.incorrectFaces,...t.incorrectFaces]))}static with(t){return t.reduce((e,o)=>e.with(o),Ie.CORRECT)}};g(Ie,"CORRECT",new Ie(new Set,new Set));let ke=Ie;class At{constructor(t,e,o){g(this,"edgeStateChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(A()&&b(this.board.edges.includes(t)),e!==v.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new ee(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}static getCorrectnessState(t,e,o){const r=new Set;for(const s of t.edges){const c=e.getEdgeState(s);c!==v.WHITE&&c!==o.getEdgeState(s)&&r.add(s)}return new ke(r,new Set)}}class bt{constructor(t,e,o){g(this,"faceColorsChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){if(s)throw new ee("invalid face color?");const c=new Set([...o.values(),...r.keys(),...o.values()]),d=new Map(this.currentState.getFaceColorMap());for(const l of o.keys())d.set(l,o.get(l));const i=l=>r.has(l)?r.get(l):[...t].includes(l)?this.currentState.getOppositeFaceColor(l):null,n=new Map;for(const l of d.keys()){const u=d.get(l);n.has(u)||n.set(u,new Set([l])),n.get(u).add(l)}for(const l of c){const u=n.get(l);if(!u)continue;const y=[...u];A()&&b(y.length>0);const f=this.solvedState.getFaceColor(y[0]);for(const S of y)if(this.solvedState.getFaceColor(S)!==f)throw new ee("invalid face color");const p=i(l);if(p){let S;if(p.colorState===T.INSIDE?S=this.solvedState.getInsideColor():p.colorState===T.OUTSIDE?S=this.solvedState.getOutsideColor():S=this.solvedState.getFaceColor([...n.get(p)][0]),f===S)throw new ee("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}static getCorrectnessState(t,e,o){const r=new Set,s=new Set,c=e.getOutsideColor(),d=e.getInsideColor(),i=o.getOutsideColor(),n=o.getInsideColor();for(const l of e.getFaceColors()){if(s.has(l))continue;const u=e.getOppositeFaceColor(l);s.add(l),u&&s.add(u);const y=e.getFacesWithColor(l),f=u?e.getFacesWithColor(u):[],p=(S,w)=>{o.getFaceColor(S)!==w&&r.add(S)};if(l===c)y.forEach(S=>p(S,i)),f.forEach(S=>p(S,n));else if(l===d)y.forEach(S=>p(S,n)),f.forEach(S=>p(S,i));else if(y.length){let S=y.filter(C=>o.getFaceColor(C)===i).length+f.filter(C=>o.getFaceColor(C)===n).length,w=y.length+f.length;if(S>0&&S<w){const C=S>w/2,E=C?i:n,m=C?n:i;y.forEach(P=>p(P,E)),f.forEach(P=>p(P,m))}}}return new ke(new Set,r)}}class Br{constructor(t,e,o){g(this,"faceStateChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){A()&&b(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new ee(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new ee("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Wr{constructor(t,e,o){g(this,"faceValueChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new ee("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Nt{constructor(t,e,o){g(this,"sectorStateChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){A()&&b(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new ee(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}static getCorrectnessState(t,e,o){const r=new Set;for(const s of t.halfEdges){const c=s.edge,d=s.next.edge,i=e.getSectorState(s),n=(o.getEdgeState(c)===v.BLACK?1:0)+(o.getEdgeState(d)===v.BLACK?1:0);i.allows(n)||(r.add(c),r.add(d))}return new ke(r,new Set)}}class Ur{constructor(t,e,o){g(this,"simpleRegionsChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new ee("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Hr{constructor(t,e,o){g(this,"vertexStateChangedEmitter",new pe);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){A()&&b(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new ee(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new ee("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class zr{constructor(t,e,o){g(this,"anyStateChangedEmitter",new pe);g(this,"edgeStateValidator");g(this,"faceValueValidator");g(this,"simpleRegionDataValidator");g(this,"faceColorValidator");g(this,"sectorStateValidator");g(this,"vertexStateValidator");g(this,"faceStateValidator");A()&&b(t),A()&&b(o),this.edgeStateValidator=new At(t,e,o),this.faceValueValidator=new Wr(t,e,o),this.simpleRegionDataValidator=new Ur(t,e,o),this.faceColorValidator=new bt(t,e,o),this.sectorStateValidator=new Nt(t,e,o),this.vertexStateValidator=new Hr(t,e,o),this.faceStateValidator=new Br(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){this.faceColorValidator.modifyFaceColors(t,e,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}static getCorrectnessState(t,e,o){return ke.with([At.getCorrectnessState(t,e,o),bt.getCorrectnessState(t,e,o),Nt.getCorrectnessState(t,e,o)])}}const Yr=a=>[a.forwardHalf,a.reversedHalf,a.forwardHalf.previous,a.reversedHalf.previous];class Me{constructor(t){this.edge=t,A()&&b(t)}apply(t){t.getEdgeState(this.edge)!==v.WHITE&&t.setEdgeState(this.edge,v.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=t.getOutsideColor(),c=t.getInsideColor(),d=o?t.getFaceColor(o):s,i=r?t.getFaceColor(r):s,n=t.getOppositeFaceColor(d);if(d===i||n===i){const l=[...t.getFacesWithColor(d),...d===s?[null]:[]],u=n?[...t.getFacesWithColor(n),...n===s?[null]:[]]:[],y=[...l,...u],f=S=>{const w=new Set,C=new Set([S]);for(;C.size>0;){const E=C.values().next().value;if(C.delete(E),w.add(E),E){for(const m of E.edges)if(t.getEdgeState(m)!==v.WHITE){const P=m.getOtherFace(E),V=P?t.getFaceColor(P):s;(V===d||V===n)&&!w.has(P)&&C.add(P)}}else for(const m of y)if(m&&!w.has(m))for(const P of m.edges)P.getOtherFace(m)===null&&t.getEdgeState(P)!==v.WHITE&&C.add(m)}return w},p=f(o);if(!p.has(r)){const S=f(r);A()&&b(p.size>0&&S.size>0),A()&&b([...p].every(L=>!S.has(L)));const w=y.filter(L=>!p.has(L)&&!S.has(L)),C=[],E=[],m=new Map,P=new Map,V=(L,U,q)=>{const R=L.filter(O=>(O?t.getFaceColor(O):s)===d),B=L.filter(O=>(O?t.getFaceColor(O):s)===n);if(U!==null)U!==s&&U!==c&&(R.length||E.push(U),q&&!B.length&&E.push(q));else if(A()&&b(L.every(O=>O)),U=new mt(Pt(),T.UNDECIDED),C.push(U),R.length&&B.length){q=new mt(Pt(),T.UNDECIDED),C.push(q),P.set(U,q),P.set(q,U);for(const O of R)A()&&b(O),m.set(O,U);for(const O of B)A()&&b(O),m.set(O,q)}else{const O=R.length?R:B;A()&&b(O.length);for(const Y of O)A()&&b(Y),m.set(Y,U)}},F=[...p],D=[...S],I=je.sortBy([...w.length?[w]:[],F,D],L=>-L.length+(L.some(U=>!U)?-1e7:0));for(let L=0;L<I.length;L++)V(I[L],L===0?d:null,L===0?n:null);t.modifyFaceColors(C,E,m,P,!1)}}for(const l of Yr(this.edge))t.setSectorState(l,N.ANY);for(const l of this.edge.vertices)t.setVertexState(l,lt.any(l));for(const l of this.edge.faces)t.setFaceState(l,Gt.any(l,t.getFaceValue(l)))}getUndo(t){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:jt(this.edge)}}static deserializeAction(t,e){const o=Kt(t,e.edge);return new Me(o)}}class Be{constructor(t){this.face=t,A()&&b(t)}apply(t){this.face.edges.forEach(e=>{new Me(e).apply(t)})}getUndo(t){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:rt(this.face)}}static deserializeAction(t,e){const o=st(t,e.face);return new Be(o)}}class ht{constructor(t){this.sector=t,A()&&b(t)}apply(t){t.setSectorState(this.sector,N.ANY);const e=this.sector.end;t.setVertexState(e,lt.any(e));const o=this.sector.face;o&&t.setFaceState(o,Gt.any(o,t.getFaceValue(o)))}getUndo(t){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:$o(this.sector)}}static deserializeAction(t,e){const o=Qo(t,e.sector);return new ht(o)}}class tt extends Error{constructor(t){super(t)}}const It=(a,t,e)=>{Xe(e,a,t,!0)},Gr=(a,t,e)=>new Fe([new Xt(a,t),new _t(a,t),new qt(a,t),new Jt(a,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Zt(a,t,{solveToRed:!0,solveToBlack:!0}),new $t(a,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new ar(a,t),new Qt(a,t),new eo(a,t),new ir(a,t),new to(a,t),new nr(a,t,{solveToRed:!0,solveToBlack:!0}),new lr(a,t),new Ze(a,t,{solveToRed:!0,solveToBlack:!0}),new cr(a,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new dr(a,t),new oo(a,t),new hr(a,t,{solveToRed:!0,solveToBlack:!0}),new ur(a,t),new pr(a,t),new gr(a,t)]),so=(a,t,e,o)=>(r,s,c)=>{const d=[new Xt(r,s),new _t(r,s)];return(a||t||e||o)&&(d.push(new qt(r,s)),(t||e||o)&&(d.push(new Qt(r,s)),(e||o)&&(d.push(new to(r,s)),o&&d.push(new oo(r,s))))),new Fe(d)},jr={allowEdgeEditProperty:po,allowAbsoluteFaceColorEditProperty:go,allowFaceColorEditProperty:fo,allowSectorEditProperty:So,edgesVisibleProperty:wo,edgesHaveColorsProperty:yo,faceColorsVisibleProperty:pt,faceColorThresholdProperty:Co,sectorsVisibleProperty:gt,sectorsNextToEdgesVisibleProperty:Eo,sectorsTrivialVisibleProperty:mo,vertexStateVisibleProperty:ft,allVertexStateVisibleProperty:Po,faceStateVisibleProperty:St,whiteLineVisibleProperty:vo,redLineVisibleProperty:he,verticesVisibleProperty:Fo,smallVertexProperty:Vo,redXsVisibleProperty:To,redXsAlignedProperty:Do,faceValueStyleProperty:ue,redLineStyleProperty:Oo,vertexStyleProperty:Ao,joinedLinesJoinProperty:bo,joinedLinesCapProperty:No,safeSolverFactoryProperty:new z([pt,gt,ft,St],(a,t,e,o)=>so(a,t,e,o)),autoSolverFactoryProperty:fr,theme:de},Ce=(a,t,e,o,r)=>{const s=so(a,t,e,o);return{faceColorsVisibleProperty:new be(a),sectorsVisibleProperty:new be(t),vertexStateVisibleProperty:new be(e),faceStateVisibleProperty:new be(o),safeSolverFactoryProperty:new Re(s),autoSolverFactoryProperty:r?new z([r],c=>(d,i,n)=>new Fe([s(d,i,n),c(d,i,n)])):new Re(s)}},Te=new z([Sr,wr],(a,t)=>(e,o,r)=>new Fe([new Jt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:a,solveAlmostEmptyToRed:!0},r?void 0:[]),new Zt(e,o,{solveToRed:!0,solveToBlack:a},r?void 0:[]),...t?[new $t(e,o,{solveToRed:!0,solveToBlack:a,resolveAllRegions:!1},r?void 0:[])]:[]])),Kr=new z([Te],a=>(t,e,o)=>new Fe([a(t,e,o),new Ze(t,e,{solveToRed:!0,solveToBlack:!0})])),ao=new z([Te],a=>(t,e,o)=>new Fe([a(t,e,o),new eo(t,e,o?void 0:[])])),Xr=new z([ao],a=>(t,e,o)=>new Fe([a(t,e,o),new Ze(t,e,{solveToRed:!0,solveToBlack:!0})])),_r=a=>({...Ce(!0,!1,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),qr=a=>({...Ce(!0,!1,!1,!1,Kr),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Jr=a=>({...Ce(!0,!1,!1,!1,new Re((t,e,o)=>new Fe([new Ze(t,e,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:a,allowEdgeEditProperty:new h(!1),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!1),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Zr=a=>({...Ce(!1,!1,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),qs=a=>({...Ce(!1,!0,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),$r=a=>({...Ce(!0,!0,!1,!1,ao),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Qr=a=>({...Ce(!0,!0,!1,!1,Xr),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),es=a=>({...Ce(!0,!1,!0,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),ts=a=>({...Ce(!0,!1,!1,!0,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),os=_r(de),rs=qr(de),ss=Jr(de),io=Zr(de),as=$r(de),is=Qr(de),ns=es(de),ls=ts(de),ot={basicLines:os,basicFaceColoring:rs,pureFaceColor:ss,classic:io,basicSectors:as,sectorsWithColors:is,vertexState:ns,faceState:ls,custom:jr},Lt=io,cs=a=>({allowEdgeEditProperty:new W(a,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new W(a,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new W(a,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new W(a,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new W(a,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new W(a,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new W(a,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new W(a,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new W(a,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new W(a,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new W(a,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new W(a,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new W(a,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new W(a,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new W(a,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new W(a,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new W(a,{derive:"verticesVisibleProperty"}),smallVertexProperty:new W(a,{derive:"smallVertexProperty"}),redXsVisibleProperty:new W(a,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new W(a,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new W(a,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new W(a,{derive:"redLineStyleProperty"}),vertexStyleProperty:new W(a,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new W(a,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new W(a,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new W(a,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new W(a,{derive:"autoSolverFactoryProperty"}),theme:Io(new z([a],t=>t.theme))}),ds=new Ho("puzzleStyle",{serialize:a=>Object.keys(ot).find(t=>ot[t]===a),deserialize:a=>a?ot[a]??Lt:Lt}),_=cs(ds),Js=new ge("showPuzzleStyleProperty",!0),Zs=new ge("showPuzzleTimerProperty",!1),$s=new ge("showSectorViewModesProperty",!1),H=class H extends we{constructor(t){super(),this.isEnabledProperty=t}};g(H,"EDGE_STATE",new H(_.allowEdgeEditProperty)),g(H,"EDGE_STATE_REVERSED",new H(_.allowEdgeEditProperty)),g(H,"FACE_COLOR_INSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),g(H,"FACE_COLOR_OUTSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),g(H,"FACE_COLOR_MATCH",new H(_.allowFaceColorEditProperty)),g(H,"FACE_COLOR_OPPOSITE",new H(_.allowFaceColorEditProperty)),g(H,"SECTOR_STATE",new H(_.allowSectorEditProperty)),g(H,"VERTEX_STATE",new H(_.vertexStateVisibleProperty)),g(H,"FACE_STATE",new H(_.faceStateVisibleProperty)),g(H,"FACE_VALUE",new H(new be(!1))),g(H,"DELETE_FACE",new H(new be(!1))),g(H,"enumeration",new ye(H));let x=H;const G=new nt("editModeProperty",x.EDGE_STATE);x.enumeration.values.forEach(a=>{a.isEnabledProperty.lazyLink(t=>{if(!G.value.isEnabledProperty.value){const e=x.enumeration.values.find(o=>o.isEnabledProperty.value)??null;e&&(G.value=e)}})});const Ue=new ge("eraserEnabledProperty",!1),Qs=a=>{a.isEnabledProperty.value&&(G.value=a)},hs=new z([G],a=>a===x.EDGE_STATE||a===x.EDGE_STATE_REVERSED),ut=new z([G],a=>a===x.FACE_COLOR_MATCH||a===x.FACE_COLOR_OPPOSITE),ea=ut,us=new z([G],a=>a===x.FACE_COLOR_OUTSIDE||a===x.FACE_COLOR_INSIDE),ps=new z([G],a=>a===x.SECTOR_STATE),gs=new z([G],a=>a===x.VERTEX_STATE),fs=new z([G,ut,us],(a,t,e)=>t||e||a===x.FACE_STATE||a===x.FACE_VALUE||a===x.DELETE_FACE),re=class re extends we{};g(re,"NONE",new re),g(re,"ABSOLUTE_PAINT",new re),g(re,"MAKE_SAME",new re),g(re,"MAKE_OPPOSITE",new re),g(re,"enumeration",new ye(re));let Z=re;class Ss{constructor(t){g(this,"paintFaceSet",new Set);g(this,"paintFaceOppositeSet",new Set);g(this,"absolutePaintState",T.INSIDE);g(this,"lastFace",null);g(this,"faceDragStateProperty",new h(Z.NONE));g(this,"dragIndex",0);this.board=t}isNoOpSingleFace(){return(this.faceDragStateProperty.value===Z.MAKE_SAME||this.faceDragStateProperty.value===Z.MAKE_OPPOSITE)&&this.paintFaceSet.size===1&&this.paintFaceOppositeSet.size===0}onAbsolutePaintStart(t,e){this.faceDragStateProperty.value=Z.ABSOLUTE_PAINT,this.paintFaceSet.clear(),this.paintFaceSet.add(t),this.paintFaceOppositeSet.clear(),this.absolutePaintState=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeSameStart(t){this.faceDragStateProperty.value=Z.MAKE_SAME,this.paintFaceSet.clear(),this.paintFaceSet.add(t),this.paintFaceOppositeSet.clear(),this.absolutePaintState=T.UNDECIDED,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeOppositeStart(t){this.faceDragStateProperty.value=Z.MAKE_OPPOSITE,this.paintFaceSet.clear(),this.paintFaceSet.add(t),this.paintFaceOppositeSet.clear(),this.absolutePaintState=T.UNDECIDED,this.lastFace=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(t,e){if(t){const r=t.viewCoordinates.distance(e),s=t.vertices.map(c=>c.viewCoordinates.distance(e)).reduce((c,d)=>Math.min(c,d),Number.POSITIVE_INFINITY);if(r>.3&&s/r<.7)return!1}const o=this.lastFace;return this.lastFace=t,!this.paintFaceSet.has(t)&&!this.paintFaceOppositeSet.has(t)?(this.faceDragStateProperty.value===Z.MAKE_OPPOSITE&&o&&this.paintFaceSet.has(o)?(A()&&b(!this.paintFaceSet.has(t)),this.paintFaceOppositeSet.add(t)):(A()&&b(!this.paintFaceOppositeSet.has(t)),this.paintFaceSet.add(t)),!0):!1}onDragEnd(){this.faceDragStateProperty.value=Z.NONE}}const $=class $ extends we{};g($,"DEFAULT",new $),g($,"LOADING",new $),g($,"SEARCHING",new $),g($,"FOUND",new $),g($,"NOT_FOUND",new $),g($,"enumeration",new ye($));let ne=$;const ce=class ce extends we{};g(ce,"NONE",new ce),g(ce,"LINE_DRAG",new ce),g(ce,"EDGE_PAINT",new ce),g(ce,"enumeration",new ye(ce));let ae=ce;class ws{constructor(t){g(this,"edgeStack",[]);g(this,"vertexStack",[]);g(this,"paintEdgeSet",new Set);g(this,"paintEdgeState",v.WHITE);g(this,"lineDragStateProperty",new h(ae.NONE));g(this,"dragIndex",0);this.board=t}onLineDragStart(t){this.lineDragStateProperty.value=ae.LINE_DRAG,this.edgeStack.length=0,this.edgeStack.push(t),this.vertexStack.length=0,this.dragIndex=Math.ceil(Math.random()*1e10)}onPaintDragStart(t,e){this.lineDragStateProperty.value=ae.EDGE_PAINT,this.paintEdgeSet.clear(),this.paintEdgeSet.add(t),this.paintEdgeState=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(t,e){if(this.lineDragStateProperty.value===ae.LINE_DRAG){const o=this.edgeStack[this.edgeStack.length-1],r=this.edgeStack.length>1?this.edgeStack[this.edgeStack.length-2]:null;if(t===o)return!1;if(t===r)return this.edgeStack.pop(),this.vertexStack.pop(),!0;if(this.edgeStack.includes(t))return!1;if(this.vertexStack.length===0){const s=o.vertices.find(c=>t.vertices.includes(c))??null;return s?(this.edgeStack.push(t),this.vertexStack.push(s),!0):!1}else{const s=this.vertexStack[this.vertexStack.length-1];if(t.vertices.includes(s)){const c=t.getOtherVertex(s);return this.edgeStack.push(t),this.vertexStack.push(c),!0}else return!1}}else if(this.lineDragStateProperty.value===ae.EDGE_PAINT){const o=t.start.viewCoordinates.distance(t.end.viewCoordinates);if(Math.min(...t.vertices.map(s=>s.viewCoordinates.distance(e)))/o<.2)return!1;if(!this.paintEdgeSet.has(t))return this.paintEdgeSet.add(t),!0}return!1}onDragEnd(){this.lineDragStateProperty.value=ae.NONE}}const j=class j extends we{constructor(t,e,o){super(),this.fromWhite=t,this.fromBlack=e,this.fromRed=o}apply(t){return t===v.WHITE?this.fromWhite:t===v.BLACK?this.fromBlack:this.fromRed}};g(j,"CYCLE",new j(v.BLACK,v.RED,v.WHITE)),g(j,"REVERSE_CYCLE",new j(v.RED,v.WHITE,v.BLACK)),g(j,"BLACK_TOGGLE",new j(v.BLACK,v.WHITE,v.BLACK)),g(j,"RED_TOGGLE",new j(v.RED,v.RED,v.WHITE)),g(j,"WHITE_SET",new j(v.WHITE,v.WHITE,v.WHITE)),g(j,"BLACK_SET",new j(v.BLACK,v.BLACK,v.BLACK)),g(j,"RED_SET",new j(v.RED,v.RED,v.RED)),g(j,"enumeration",new ye(j));let Ee=j;const Q=class Q extends we{constructor(t,e,o){super(),this.fromUndecided=t,this.fromInside=e,this.fromOutside=o}apply(t){return t===T.UNDECIDED?this.fromUndecided:t===T.OUTSIDE?this.fromOutside:this.fromInside}};g(Q,"CYCLE",new Q(T.INSIDE,T.OUTSIDE,T.UNDECIDED)),g(Q,"REVERSE_CYCLE",new Q(T.OUTSIDE,T.UNDECIDED,T.INSIDE)),g(Q,"INSIDE_TOGGLE",new Q(T.INSIDE,T.UNDECIDED,T.INSIDE)),g(Q,"OUTSIDE_TOGGLE",new Q(T.OUTSIDE,T.OUTSIDE,T.UNDECIDED)),g(Q,"UNDECIDED_SET",new Q(T.UNDECIDED,T.UNDECIDED,T.UNDECIDED)),g(Q,"enumeration",new ye(Q));let me=Q;const ve=class ve extends we{constructor(t,e){super(),this.edgePressStyles=t,this.faceColorPressStyles=e}};g(ve,"CYCLIC",new ve([Ee.CYCLE,Ee.WHITE_SET,Ee.REVERSE_CYCLE],[me.CYCLE,me.UNDECIDED_SET,me.REVERSE_CYCLE])),g(ve,"TOGGLE",new ve([Ee.BLACK_TOGGLE,Ee.WHITE_SET,Ee.RED_TOGGLE],[me.INSIDE_TOGGLE,me.UNDECIDED_SET,me.OUTSIDE_TOGGLE])),g(ve,"enumeration",new ye(ve));let at=ve;const He=new nt("stateTransitionModeProperty",at.CYCLIC);class qe{constructor(t,e,o){this.edges=t,this.state=e,this.dragIndex=o}apply(t){for(const e of this.edges)t.setEdgeState(e,this.state)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.edges.length===0}serializeAction(){return{type:"UserEdgeDragAction",edges:this.edges.map(t=>jt(t)),state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(t,e){return new qe(e.edges.map(o=>Kt(t,o)),v.enumeration.getValue(e.state),e.dragIndex)}}class Je{constructor(t,e,o,r,s){this.primaryFaces=t,this.secondaryFaces=e,this.isAbsolute=o,this.state=r,this.dragIndex=s}apply(t){if(console.log(this.state,this.primaryFaces,this.secondaryFaces),this.state!==T.UNDECIDED){const e=this.state===T.OUTSIDE;console.log("absolute",e?"outside":"inside");const o=e?t.getOutsideColor():t.getInsideColor();for(const r of this.primaryFaces){const s=r?t.getFaceColor(r):t.getOutsideColor();o!==s&&new Ke(oe(t,s),{type:"absolute",isOutside:e}).apply(t)}}else if(this.isAbsolute){console.log("absolute erase");for(const e of this.primaryFaces)e&&new Be(e).apply(t)}else{console.log("normal");const e=o=>{for(let r=1;r<o.length;r++){const s=o[r-1],c=o[r],d=s?t.getFaceColor(s):t.getOutsideColor(),i=c?t.getFaceColor(c):t.getOutsideColor();d!==i&&new Ke(oe(t,d),oe(t,i)).apply(t)}};if(e(this.primaryFaces),e(this.secondaryFaces),this.primaryFaces.length&&this.secondaryFaces.length){const o=this.primaryFaces[0],r=this.secondaryFaces[0],s=o?t.getFaceColor(o):t.getOutsideColor(),c=r?t.getFaceColor(r):t.getOutsideColor();new ct(oe(t,s),oe(t,c)).apply(t)}}}getUndo(t){throw new Error("unimplemented")}isEmpty(){return(this.primaryFaces.length===0||this.state===T.UNDECIDED&&this.primaryFaces.length===1)&&this.secondaryFaces.length===0}serializeAction(){return{type:"UserFaceDragAction",primaryFaces:this.primaryFaces.map(t=>t?rt(t):null),secondaryFaces:this.secondaryFaces.map(t=>t?rt(t):null),isAbsolute:this.isAbsolute,state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(t,e){return new Je(e.primaryFaces.map(o=>o?st(t,o):null),e.secondaryFaces.map(o=>o?st(t,o):null),e.isAbsolute,T.enumeration.getValue(e.state),e.dragIndex)}}class ys{constructor(t){this.hintAction=t}get annotation(){return this.hintAction.annotation}apply(t){this.hintAction.apply(t)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(t,e){throw new Error("unimplemented")}}const Cs=a=>a instanceof Go?{type:"SquareBoard",width:a.width,height:a.height}:a instanceof jo?{type:"HexagonalBoard",radius:a.radius,scale:a.scale,isPointyTop:a.isPointyTop,holeRadius:a.holeRadius}:{type:"BaseBoard",vertices:a.vertices.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vx:t.viewCoordinates.x,vy:t.viewCoordinates.y})),faces:a.faces.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vertices:t.vertices.map(e=>a.vertices.indexOf(e))}))},no=a=>({version:1,board:Cs(a.board),state:a.stateProperty.value.serializeState(a.board)}),Es=a=>{const t=no(a);return Ko(JSON.stringify(t))},ms=a=>{const t=no(a),e=a.solution.cleanState.serializeState(a.board),o=a.solution.solvedState.serializeState(a.board),r=[...a.solution.blackEdges].map(s=>a.board.edges.indexOf(s));return{puzzle:t,cleanState:e,solvedState:o,blackEdges:r}};function Ps(a){return new Worker(""+new URL("hintWorker-C0UQluhd.js",import.meta.url).href,{name:a==null?void 0:a.name})}let De=null;const Ye=new h(!1),lo=()=>(De||(De=new Ps,De==null||De.addEventListener("message",a=>{a.data.type==="hint-worker-loaded"&&(Ye.value=!0)})),De);lo();const vs=new ge("uiHintUsesBuiltInSolve",!1),ta=new ge("showUndoRedoAllProperty",!1),kt=new ge("dimCompletedNumbersProperty",!0),xt=new ge("highlightIncorrectNumbersProperty",!0),oa=new ge("highlightIncorrectMovesProperty",!0),Fs=new ge("highlightIntersectionsProperty",!0),ra=new zo("highlightIncorrectMovesDelayProperty",.7);class sa extends xo{constructor(e,o){const r=We()({style:_,initialTimeElapsed:0},o),s=r.style;super();g(this,"timeElapsedProperty",new h(0));g(this,"hintStateProperty",new h(ne.DEFAULT));g(this,"edgeAutoSolvedEmitter",new pe);g(this,"stack");g(this,"stackLengthProperty",new h(0));g(this,"stackPositionProperty",new h(0));g(this,"undoPossibleProperty");g(this,"redoPossibleProperty");g(this,"currentSnapshotProperty");g(this,"hasErrorProperty");g(this,"correctnessStateProperty");g(this,"isSolvedProperty");g(this,"hintWorkerMessageID",0);g(this,"addedHintListener",!1);g(this,"pendingHintActionProperty",new h(null));g(this,"displayedAnnotationProperty");g(this,"pendingActionFaceColorProperty",new h(null));g(this,"pendingActionSectorProperty",new h(null));g(this,"selectedFaceColorHighlightProperty");g(this,"selectedSectorEditProperty");g(this,"autoSolverFactoryProperty");g(this,"style");g(this,"lineDrag");g(this,"faceDrag");this.puzzle=e,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.lineDrag=new ws(e.board),this.faceDrag=new Ss(e.board),this.autoSolverFactoryProperty=new z([yr,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(i,n,l)=>i?l:n),this.displayedAnnotationProperty=new z([this.pendingHintActionProperty],i=>i?i.annotation:null);const c=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(c),G.lazyLink(c),this.disposeEmitter.addListener(()=>G.unlink(c)),this.selectedFaceColorHighlightProperty=new z([e.stateProperty,G,this.pendingActionFaceColorProperty],(i,n,l)=>{if((n===x.FACE_COLOR_MATCH||n===x.FACE_COLOR_OPPOSITE)&&l){const u=i.getFacesWithColor(l.color);return{faceColor:l.color,face:l.face,faces:u}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new z([e.stateProperty,G,this.pendingActionSectorProperty],(i,n,l)=>n===x.SECTOR_STATE&&l?{sector:l,currentState:i.getSectorState(l)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const i=e.stateProperty.value.clone();It(e.board,i,this.style.safeSolverFactoryProperty.value),e.stateProperty.value=i}this.stack=[this.getSnapshot(null,e.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new z([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new z([this.currentSnapshotProperty],i=>!i.correctnessState.isCorrect()),this.correctnessStateProperty=new z([this.currentSnapshotProperty],i=>i.correctnessState),this.isSolvedProperty=new z([this.currentSnapshotProperty],i=>{if(i.state.getWeirdEdges().length||i.state.hasInvalidFaceColors())return!1;const n=i.state.getSimpleRegions();return n.length===1&&n[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new z([this.stackPositionProperty],i=>i>0),this.redoPossibleProperty=new z([this.stackPositionProperty,this.stackLengthProperty],(i,n)=>i<n-1);const d=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(d),this.style.safeSolverFactoryProperty.lazyLink(d),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(d),this.style.safeSolverFactoryProperty.unlink(d)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(e){this.isSolvedProperty.value||(this.timeElapsedProperty.value+=Math.min(e,5),localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value)))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Es(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(e){this.wipeStackTop(),this.stack.push(e),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(e,o){const r=(o==null?void 0:o.forceDirty)||e instanceof et;let c=this.stack[this.stackPositionProperty.value].state;o!=null&&o.erase&&(c=c.clone(),o.erase(c));let d=new Set;const i=u=>{d.add(u)};let n=c.createDelta();try{if(n.edgeStateChangedEmitter.addListener(i),Dt(this.autoSolverFactoryProperty.value,this.puzzle.board,n,()=>{e.apply(n)},r),n.edgeStateChangedEmitter.removeListener(i),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(n)))throw new tt("Auto-solver did not respect user action")}catch(u){if(d=new Set,u instanceof ee||u instanceof tt)u instanceof ee?console.log("error"):u instanceof tt&&console.log("skipping autosolve due to undo"),n=c.createDelta(),n.edgeStateChangedEmitter.addListener(i),Dt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,n,()=>{e.apply(n)},r),n.edgeStateChangedEmitter.removeListener(i);else throw u}const l=c.clone();n.apply(l),this.pushTransitionAtCurrentPosition(this.getSnapshot(e,l));for(const u of d)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(u))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(u))}computeCorrectnessState(e=this.puzzle.stateProperty.value){return zr.getCorrectnessState(this.puzzle.board,e,this.puzzle.solution.solvedState)}getSnapshot(e,o){return new Vs(this.puzzle.board,e,o,this.computeCorrectnessState(o))}addAutoSolveDelta(){const e=this.puzzle.stateProperty.value.createDelta();try{if(Xe(this.autoSolverFactoryProperty.value,this.puzzle.board,e,!0),!e.isEmpty()){const o=this.puzzle.stateProperty.value.clone();e.apply(o),this.pushTransitionAtCurrentPosition(this.getSnapshot(new et,o))}}catch(o){if(!(o instanceof ee))throw o}}onAutoSolveChange(){const e=this.stack[this.stackPositionProperty.value];e.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(e.action||new et,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(e,o,r){r&&(o=2-o);const s=He.value.edgePressStyles[o];return console.log(He.value,s,o,e),s.apply(e)}getNewFaceColorState(e,o,r){r&&(o=2-o);const s=He.value.faceColorPressStyles[o];return console.log(He.value,s,o,e),s.apply(e)}getNextEdgeState(e,o){const r=Ue.value,s=this.puzzle.stateProperty.value.getEdgeState(e);return r?v.WHITE:this.getNewEdgeState(s,o,G.value===x.EDGE_STATE_REVERSED)}getNextFaceColorState(e,o){const r=this.puzzle.stateProperty.value.getOutsideColor(),s=this.puzzle.stateProperty.value.getInsideColor(),c=this.puzzle.stateProperty.value.getFaceColor(e),d=c===r?T.OUTSIDE:c===s?T.INSIDE:T.UNDECIDED;return this.getNewFaceColorState(d,o,G.value===x.FACE_COLOR_OUTSIDE)}onUserEdgePress(e,o){const r=this.puzzle.stateProperty.value.getEdgeState(e),s=this.getNextEdgeState(e,o);if(r!==s){const c=this.stack[this.stackPositionProperty.value];c.action&&c.action instanceof vt&&c.action.edge===e&&this.stackPositionProperty.value--;let d;r!==v.WHITE&&(d=n=>{new Me(e).apply(n)});const i=new vt(e,s);this.applyUserActionToStack(i,{erase:d,checkAutoSolve:n=>n.getEdgeState(e)===s,excludedEdges:new Set([e])}),this.updateState()}}onUserEdgeDragStart(e,o){if(this.lineDrag.lineDragStateProperty.value!==ae.NONE)return;const r=this.getNextEdgeState(e,o);r===v.BLACK?this.lineDrag.onLineDragStart(e):this.lineDrag.onPaintDragStart(e,r),this.updateEdgeDrag()}onUserEdgeDrag(e,o){this.lineDrag.onDrag(e,o)&&this.updateEdgeDrag()}onUserEdgeDragEnd(){this.lineDrag.onDragEnd()}updateEdgeDrag(){const e=this.stack[this.stackPositionProperty.value];e.action&&e.action instanceof qe&&e.action.dragIndex===this.lineDrag.dragIndex&&this.stackPositionProperty.value--,A()&&b(this.lineDrag.lineDragStateProperty.value!==ae.NONE,"line drag state should not be NONE");const o=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?this.lineDrag.edgeStack.slice():Array.from(this.lineDrag.paintEdgeSet),r=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?v.BLACK:this.lineDrag.paintEdgeState,s=o.filter(i=>this.puzzle.stateProperty.value.getEdgeState(i)!==v.WHITE),c=new er(s.map(i=>new Me(i))),d=new qe(o,r,this.lineDrag.dragIndex);this.applyUserActionToStack(d,{erase:i=>c.apply(i),checkAutoSolve:i=>o.every(n=>i.getEdgeState(n)===r),excludedEdges:new Set(o)}),this.updateState()}onUserFacePress(e,o){const r=Ue.value,s=G.value;if(r){if(e){const c=new Be(e);this.applyUserActionToStack(c,{erase:d=>c.apply(d)}),this.updateState()}}else if(s===x.FACE_COLOR_MATCH||s===x.FACE_COLOR_OPPOSITE){let c=G.value===x.FACE_COLOR_MATCH;o===2&&(c=!c);const d=e?this.puzzle.stateProperty.value.getFaceColor(e):this.puzzle.stateProperty.value.getOutsideColor(),i=this.pendingActionFaceColorProperty.value;if(i){if(e!==i.face){const n=i.color;n!==d&&(c?this.applyUserActionToStack(new Ke(oe(this.puzzle.stateProperty.value,d),oe(this.puzzle.stateProperty.value,n))):this.applyUserActionToStack(new ct(oe(this.puzzle.stateProperty.value,d),oe(this.puzzle.stateProperty.value,n))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:e,color:d}}else if((s===x.FACE_COLOR_OUTSIDE||s===x.FACE_COLOR_INSIDE)&&e){const c=this.puzzle.stateProperty.value.getOutsideColor(),d=this.puzzle.stateProperty.value.getInsideColor(),i=this.puzzle.stateProperty.value.getFaceColor(e),n=i===c?T.OUTSIDE:i===d?T.INSIDE:T.UNDECIDED,l=this.getNewFaceColorState(n,o,s===x.FACE_COLOR_OUTSIDE);if(n!==l){const u=this.stack[this.stackPositionProperty.value];u.action&&u.action instanceof Ft&&u.action.face===e&&this.stackPositionProperty.value--;let y;const f=new Be(e);n!==T.UNDECIDED&&(y=p=>{f.apply(p)}),l===T.UNDECIDED?this.applyUserActionToStack(f,{erase:y}):this.applyUserActionToStack(new Ft(e,l===T.INSIDE),{erase:y}),this.updateState()}}}onUserFaceDragStart(e,o){if(this.faceDrag.faceDragStateProperty.value!==Z.NONE)return;const r=G.value;if(Ue.value)this.faceDrag.onAbsolutePaintStart(e,T.UNDECIDED);else if(r===x.FACE_COLOR_MATCH||r===x.FACE_COLOR_OPPOSITE)r===x.FACE_COLOR_MATCH==(o===0)?this.faceDrag.onMakeSameStart(e):this.faceDrag.onMakeOppositeStart(e);else if(r===x.FACE_COLOR_INSIDE||r===x.FACE_COLOR_OUTSIDE){const s=e?this.getNextFaceColorState(e,o):x.FACE_COLOR_OUTSIDE;this.faceDrag.onAbsolutePaintStart(e,s)}this.updateFaceDrag()}onUserFaceDrag(e,o){this.faceDrag.onDrag(e,o)&&this.updateFaceDrag()}onUserFaceDragEnd(){if(this.faceDrag.isNoOpSingleFace()){const e=G.value===x.FACE_COLOR_MATCH==(this.faceDrag.faceDragStateProperty.value===Z.MAKE_SAME);this.onUserFacePress([...this.faceDrag.paintFaceSet][0],e?0:2)}this.faceDrag.onDragEnd()}updateFaceDrag(){const e=this.stack[this.stackPositionProperty.value];e.action&&e.action instanceof Je&&e.action.dragIndex===this.faceDrag.dragIndex&&this.stackPositionProperty.value--;const o=this.faceDrag.faceDragStateProperty.value;if(A()&&b(o!==Z.NONE,"line drag state should not be NONE"),this.faceDrag.isNoOpSingleFace())return;const r=[...this.faceDrag.paintFaceSet],s=o===Z.MAKE_OPPOSITE?[...this.faceDrag.paintFaceOppositeSet]:[],c=this.faceDrag.absolutePaintState,d=o===Z.ABSOLUTE_PAINT,i=new Je(r,s,d,c,this.faceDrag.dragIndex);this.applyUserActionToStack(i,{checkAutoSolve:n=>{if(r.length){const l=r[0]?n.getFaceColor(r[0]):n.getOutsideColor();if(r.some(u=>(u?n.getFaceColor(u):n.getOutsideColor())!==l))return!1;if(s.length){const u=s[0]?n.getFaceColor(s[0]):n.getOutsideColor();if(s.some(y=>(y?n.getFaceColor(y):n.getOutsideColor())!==u)||n.getOppositeFaceColor(l)!==u)return!1}}return!0}}),this.updateState()}onUserSectorPress(e,o){if(Ue.value){const s=new ht(e);this.applyUserActionToStack(s,{erase:c=>s.apply(c)}),this.updateState()}else this.pendingActionSectorProperty.value=e}onUserSectorSet(e,o){this.applyUserActionToStack(new tr(e,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const e=this.puzzle.stateProperty.value;if(!or(e))if(vs.value){const o=e.clone();Xe(Gr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Vt,o)),this.updateState()}else{const o=Cr(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,v.BLACK)}),It(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Vt,r)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ne.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(e){this.hintStateProperty.value=e?ne.FOUND:ne.NOT_FOUND,e&&(this.pendingHintActionProperty.value=e)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const e=_.allowEdgeEditProperty.value,o=_.allowFaceColorEditProperty.value,r=_.allowSectorEditProperty.value,s=_.vertexStateVisibleProperty.value,c=_.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const d=lo();if(!this.addedHintListener){this.addedHintListener=!0;const i=n=>{if(n.data.type==="hint-response"&&n.data.id===this.hintWorkerMessageID){const l=n.data.action?rr(this.puzzle.board,n.data.action):null;this.onHintReceived(l)}};d.addEventListener("message",i),this.disposeEmitter.addListener(()=>self.removeEventListener("message",i))}if(d.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:e,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:c,serializedSolvablePuzzle:ms(this.puzzle)}),Ye.value)this.hintStateProperty.value=ne.SEARCHING;else{this.hintStateProperty.value=ne.LOADING;const i=n=>{n&&(this.hintStateProperty.value===ne.LOADING&&(this.hintStateProperty.value=ne.SEARCHING),Ye.unlink(i))};Ye.link(i)}}onUserApplyHint(){const e=this.pendingHintActionProperty.value;e&&(this.clearPendingHint(),this.applyUserActionToStack(new ys(e)),this.updateState())}}class Vs{constructor(t,e,o,r){this.board=t,this.action=e,this.state=o,this.correctnessState=r}}class Ts extends k{constructor(t,e,o,r){super({pickable:!1}),this.board=t;const s=t.faces.map(n=>null),c=()=>{const n=[],l=o.faceValueStyleProperty.value,u=o.theme.faceValueColorProperty.value,y=o.theme.faceValueCompletedColorProperty.value,f=o.theme.faceValueErrorColorProperty.value,p=o.theme.faceValueRatioColorProperty.value,S=o.faceStateVisibleProperty.value,w=kt.value,C=xt.value;this.visible=!S;for(let E=0;E<t.faces.length;E++){const m=s[E];if(m!==null){const P=t.faces[E],V=new Bo("",Bt({subScale:.7},r==null?void 0:r.textOptions)),F=Se.multilink([e],D=>{let I,L,U=!1,q=!1;if(m===null)I="",L=null;else{let R=0,B=0;for(const O of P.edges){const Y=D.getEdgeState(O);Y===v.BLACK?R++:Y===v.WHITE&&B++}if(l==="static"||m===0)I=`${m}`;else if(l==="remaining")I=`${m-R}`,U=R>0;else if(l==="ratio")m-R===0?I="0":(I=`${m-R}<sub style="color: ${p.toCSS()};">/<sub>${B}</sub></sub>`,q=!0),U=R>0;else throw new Error(`unhandled faceValueStyle: ${l}`);R>m&&C?L=f:R===m&&w?L=y:L=u}V.string=I,V.fill=L,V.maxWidth=q?.8:.9,V.maxHeight=q?.8:.9,V.center=P.viewCoordinates});V.disposeEmitter.addListener(()=>F.dispose()),n.push(V)}}this.children.forEach(E=>E.dispose()),this.children=n},d=Se.multilink([e],n=>{let l=!1;for(let u=0;u<t.faces.length;u++){const y=n.getFaceValue(t.faces[u]);y!==s[u]&&(l=!0,s[u]=y)}l&&c()}),i=Se.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,kt,xt],c);this.disposeEmitter.addListener(()=>{d.dispose(),i.dispose(),this.children.forEach(n=>n.dispose())})}}const Ds=(a,t,e)=>{const o=new Le({mouseButton:0,fire:c=>{var d;return e&&e(a,(d=c.domEvent)!=null&&d.shiftKey?2:0)}}),r=new Le({mouseButton:2,fire:c=>{var d;return e&&e(a,(d=c.domEvent)!=null&&d.shiftKey?0:2)}}),s=new Le({mouseButton:1,fire:c=>e&&e(a,1)});t.addInputListener(o),t.addInputListener(r),t.addInputListener(s),t.cursor="pointer",t.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class $e extends k{constructor(t,e,o,r){const s=We()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},noninteractive:!1},r);super({pickableProperty:ut}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,!s.noninteractive&&Ds(null,this,s.facePressListener);const c=t.map(p=>p.start.viewCoordinates),d=s.useBackgroundOffsetStroke,i=s.backgroundOffsetDistance,l=Ct(c)>0?-i:i,u=p=>{const S=new Xo;S.addShape(0,p),S.computeSimplifiedFaces(),S.computeFaceInclusion(E=>E[0]>0);const w=S.createFilledSubGraph(),C=w.facesToShape();return S.dispose(),w.dispose(),C},y=$e.getOffsetBackgroundShape(t,d,i),f=e.map(p=>{const S=p.map(C=>C.start.viewCoordinates),w=M.polygon(S);if(d)return u(w.getOffsetShape(l));{const E=w.getStrokedShape(new Et({lineWidth:2*i})).subpaths.map(m=>new M([m]));return u(je.minBy(E,m=>m.getArea()))}});this.children=[new K(y,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...f.map(p=>new K(p,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(i=>i.start.viewCoordinates),s=M.polygon(r),d=Ct(r)>0?-o:o;if(e)return s.getOffsetShape(d).getSimplifiedAreaShape();{const i=s.getStrokedShape(new Et({lineWidth:2*o})),n=i.subpaths.map(l=>new M([l]));try{return i.bounds.width===9.718028227819117?M.bounds(i.bounds):je.maxBy(n,l=>l.getArea()).getSimplifiedAreaShape()}catch{return M.bounds(i.bounds)}}}}class fe extends k{static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,c=o.minus(r),d=s.minus(r),i=c.normalized(),l=d.normalized().minus(i).angle+Math.PI/2,u=t.face?t.face.viewCoordinates:J.createPolar(e,l).plus(r),y=o.average(r),f=s.average(r);return M.polygon([y,r,f,u]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,c=o.minus(r),d=s.minus(r),i=c.normalized(),n=c.angle;let l=d.angle;return l<n&&(l+=2*Math.PI),new M().moveToPoint(r).lineToPoint(i.timesScalar(e).plus(r)).arcPoint(r,e,n,l,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===N.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===N.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===N.NOT_ONE?e.theme.sectorNotOneColorProperty:t===N.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}}g(fe,"nameMap",new Map([[N.NONE,"Invalid"],[N.ONLY_ZERO,"No Lines"],[N.ONLY_ONE,"Only One Line"],[N.ONLY_TWO,"Both Lines"],[N.NOT_ZERO,"At Least One Line"],[N.NOT_ONE,"Zero or Two Lines"],[N.NOT_TWO,"Less Than Two Lines"],[N.ANY,"Any Lines"]]));class Os extends dt{constructor(t,e){super(t.halfEdges,o=>fe.getSectorBaseShape(o,e.backgroundOffsetDistance),e.sectorPressListener)}}const Rt=[.02,.02],Oe=.2,ze=.02;class As extends k{constructor(t,e,o){const r=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ZERO,o)}),s=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ONE,o)}),c=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_TWO,o)}),d=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,c,d]}),this.board=t;const i=t.halfEdges.map(u=>N.NONE),n=t.edges.map(u=>v.BLACK),l=Se.multilink([e,o.sectorsVisibleProperty],(u,y)=>{if(y){let f=!1;for(let p=0;p<t.halfEdges.length;p++){const S=u.getSectorState(t.halfEdges[p]);S!==i[p]&&(f=!0,i[p]=S)}for(let p=0;p<t.edges.length;p++){const S=u.getEdgeState(t.edges[p]);S!==n[p]&&(f=!0,n[p]=S)}if(f){const p=new M,S=new M,w=new M,C=new M;for(let E=0;E<t.halfEdges.length;E++){const m=i[E];if(m!==N.NOT_ZERO&&m!==N.NOT_ONE&&m!==N.NOT_TWO&&m!==N.ONLY_ONE)continue;const P=t.halfEdges[E],V=u.getEdgeState(P.edge),F=u.getEdgeState(P.next.edge);if(V!==v.WHITE||F!==v.WHITE)continue;if(m===N.NOT_ONE){const X=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.BLACK),te=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.WHITE);if(X.length===0&&te.length===2)continue}const D=P.start.viewCoordinates,I=P.end.viewCoordinates,L=P.next.end.viewCoordinates,U=D.minus(I),q=L.minus(I),R=U.normalized(),B=U.angle;let O=q.angle;O<B&&(O+=2*Math.PI);const Y=(X,te)=>(X.moveToPoint(R.timesScalar(te).add(I)),X.arcPoint(I,te,B,O,!0),X);if(m===N.ONLY_ONE)Y(C,Oe);else if(m===N.NOT_ONE)Y(S,Oe-ze),Y(S,Oe+ze);else if(m===N.NOT_ZERO){const X=new M;Y(X,Oe-ze),Y(X,Oe+ze);const te=X.getDashedShape(Rt,0);p.subpaths.push(...te.subpaths)}else if(m===N.NOT_TWO){const X=new M;Y(X,Oe);const te=X.getDashedShape(Rt,0);w.subpaths.push(...te.subpaths)}}r.shape=p.makeImmutable(),s.shape=S.makeImmutable(),c.shape=w.makeImmutable(),d.shape=C.makeImmutable()}}});this.disposeEmitter.addListener(()=>l.dispose())}}class bs extends k{constructor(t,e,o,r){let s=[];try{let c=new M;for(const i of t.faces)c.polygon(i.vertices.map(n=>n.viewCoordinates));if(t.faceColor.colorState===T.OUTSIDE)try{const i=M.polygon(e.outerBoundary.map(u=>u.start.viewCoordinates)),l=$e.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(i);c=c.bounds.isValid()?c.shapeUnion(l):l}catch(i){console.error(i)}const d=new K(c.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(d)}catch(c){console.error(c)}super({children:s}),this.selectedFaceColorHighlight=t}}class Ns extends k{constructor(t,e,o,r){const s=[],c=[],d=t.sector,i=t.currentState,n=fe.getSectorArcShape(d,.5),l=new K(n.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(l);const u=[];if(i===N.ANY&&(u.push(N.NOT_ZERO),u.push(N.NOT_ONE),u.push(N.NOT_TWO)),i.one&&i!==N.ONLY_ONE&&u.push(N.ONLY_ONE),u.length){const y=u.map(S=>{const w=fe.getStrokeFromStyle(S,o);return new Yo({accessibleName:fe.nameMap.get(S),content:new Wo(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(d,S)},buttonAppearanceStrategy:Lo,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});c.push(...y);const f=new zt(new Ht({children:y,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});c.push(f);const p=.1;s.push(f),f.centerBottom=l.centerTop.plusXY(0,-.15),f.top<e.top+p&&(f.centerTop=l.centerBottom.plusXY(0,.15)),f.left<e.left+p&&(f.left=e.left+p),f.right>e.right-p&&(f.right=e.right-p)}super({children:s}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{c.forEach(y=>y.dispose())})}}class Is extends k{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});g(this,"simpleRegionNodeMap",new Map);g(this,"regionIdMap",new Map);g(this,"weirdEdgeNodeMap",new Map);g(this,"regionContainer",new k);g(this,"weirdEdgeContainer",new k);g(this,"adjacentFacesMap",new Map);g(this,"weirdEdgeColorProperty");this.board=e,this.style=r,this.weirdEdgeColorProperty=new z([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,Fs],(d,i,n)=>n?d:i),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),e.faces.forEach(d=>{this.adjacentFacesMap.set(d,d.edges.map(i=>i.getOtherFace(d)).filter(i=>i!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(d=>this.addRegion(d)),o.value.getWeirdEdges().forEach(d=>this.addWeirdEdge(d)),this.updateHues();const s=(d,i)=>{const n=i.getSimpleRegions(),l=d.getSimpleRegions(),u=i.getWeirdEdges(),y=d.getWeirdEdges(),f=[],p=[];Yt(n,l,f,p,[]);const w=new Set(f);for(const C of p)if(this.regionIdMap.has(C.id)){const E=this.regionIdMap.get(C.id);this.replaceRegion(E,C),w.delete(E)}else this.addRegion(C);for(const C of w)this.removeRegion(C);for(const C of u)y.includes(C)||this.removeWeirdEdge(C);for(const C of y)u.includes(C)||this.addWeirdEdge(C);(p.length||f.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const c=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(c),r.edgesHaveColorsProperty.lazyLink(c),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(c),r.edgesHaveColorsProperty.unlink(c)})}addRegion(e){const o=new Ne(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){A()&&b(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=new Uo(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const c=d=>{s.lineCap=d};this.style.joinedLinesCapProperty.link(c),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(c))}this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){this.weirdEdgeNodeMap.get(e).dispose(),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new J(0,0),r=()=>{for(const l of e)l.hueVector.getMagnitude()>1e-6?l.hueVector.normalize():l.hueVector.setXY(1,0)},s=new Map,c=[];this.board.faces.forEach(l=>{s.set(l,[])});for(const l of e){const u=new Set;for(const f of l.simpleRegion.edges)for(const p of f.faces)u.add(p);const y=new Set;for(const f of u){y.add(f);for(const p of this.adjacentFacesMap.get(f))y.add(p)}for(const f of y){const p=s.get(f);if(p.length)for(const S of p){let w=!1;for(const C of c)if(C.a===S&&C.b===l){C.weight++,w=!0;break}w||c.push({a:S,b:l,weight:1})}p.push(l)}}const d=new Map;for(const l of e)d.set(l,J.ZERO.copy());const i=(l,u,y)=>{const f=d.get(l),p=d.get(u),S=l.hueVector.dot(u.hueVector),w=o.set(u.hueVector).subtract(l.hueVector);if(w.magnitude>1e-9){w.normalize();const C=.3,E=y*((Math.max(C,S)-C)/(1-C))**3;w.multiplyScalar(E),f.subtract(w),p.add(w)}};let n=1;for(let l=0;l<100;l++){n*=.99;for(const u of e)d.get(u).setXY(0,0);for(const u of c){const y=u.a,f=u.b,p=u.weight;i(y,f,p)}if(e.length<8)for(let u=0;u<e.length;u++){const y=e[u];for(let f=u+1;f<e.length;f++)i(y,e[f],.2)}for(const u of e){const y=d.get(u);y.multiplyScalar(n/u.edgeCount),u.hueVector.add(y),d.get(u).setXY(0,0)}r()}for(const l of e)l.updateHue()}}class Ne extends K{constructor(e,o){const r=J.createPolar(1,Ge.nextDoubleBetween(0,2*Math.PI));super(Ne.toShape(e),{stroke:Ne.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});g(this,"hueVector");g(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const s=d=>{this.lineJoin=d};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const c=d=>{this.lineCap=d};o.joinedLinesCapProperty.link(c),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(c))}updateHue(){this.stroke=Ne.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=Ne.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&b(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(e){const o=new M;let r=!0;for(const s of e.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class Ls extends k{constructor(t,e,o){super({pickable:!1}),this.vertex=t;const r=.12,c=t.edges.map(f=>f.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(f=>f.times(r)),i=M.polygon(Ro.grahamScan([J.ZERO,...c],!1)).getOffsetShape(-.05),n=new K(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),l=new K(i,{translation:t.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[n,...c.map(f=>new Ut({radius:.02,translation:f,fill:o.theme.vertexStatePointProperty}))]});let u=null;const y=Se.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(f,p,S)=>{const w=()=>{this.children=[]};if(!p){w();return}const C=f.getVertexState(t);if(!S){let E=!1,m=!1;const P=new Set;for(const F of t.edges){const D=f.getEdgeState(F);E=E||D===v.BLACK,m=m||D===v.WHITE,D===v.WHITE&&P.add(F)}if(E||!m){w();return}if(lt.fromLookup(t,(F,D)=>P.has(F)&&P.has(D),!0).equals(C)){w();return}}if(!u||!u.equals(C)){u=C;const E=new M;for(const m of C.getAllowedPairs()){const P=V=>V.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);E.moveToPoint(P(m[0])),E.lineToPoint(P(m[1]))}C.allowsEmpty()&&(E.moveTo(.03,0),E.circle(J.ZERO,.03),E.close()),E.makeImmutable(),n.shape=E}this.children=[l]});this.disposeEmitter.addListener(()=>y.dispose())}}class ks extends k{constructor(t,e,o,r){super({pickable:!1});const s=Se.multilink([e,r.vertexStateVisibleProperty],(d,i)=>{this.children.forEach(n=>n.dispose()),this.children=[],i&&t.vertices.forEach(n=>{this.addChild(new Ls(n,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const c=d=>{this.visible=!d};o.link(c),this.disposeEmitter.addListener(()=>{o.unlink(c),this.children.forEach(d=>d.dispose())})}}const xs=.03,Rs=.05;class Ms extends K{constructor(t,e,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=t.edges.map(n=>v.BLACK);let c=r.vertexStyleProperty.value,d=r.smallVertexProperty.value;const i=Se.multilink([e,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(n,l,u,y,f)=>{if(this.visible=!l&&u,this.visible){let p=!1;for(let S=0;S<t.edges.length;S++){const w=n.getEdgeState(t.edges[S]);w!==s[S]&&(p=!0,s[S]=w)}if(c!==y&&(c=y,p=!0),d!==f&&(d=f,p=!0),p){const S=new M;for(let w=0;w<t.vertices.length;w++){const C=t.vertices[w];if(C.edges.every(E=>n.getEdgeState(E)!==v.BLACK)){const E=C.viewCoordinates,m=f?xs:Rs;y==="round"?(S.moveTo(E.x+m,E.y),S.arc(E.x,E.y,m,0,2*Math.PI,!1)):y==="square"?S.rect(E.x-m,E.y-m,2*m,2*m):A()&&b(!1,`unhandled vertex style: ${y}`)}}this.shape=S}}});this.disposeEmitter.addListener(()=>i.dispose())}}class Mt extends k{constructor(e,o){const r=We()({textOptions:{font:it,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},onEdgeDragStart:()=>{},onEdgeDrag:()=>{},onEdgeDragEnd:()=>{},facePressListener:()=>{},onFaceDragStart:()=>{},onFaceDrag:()=>{},onFaceDragEnd:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Re(null),selectedSectorEditProperty:new Re(null),style:_,noninteractive:!1,delayEdgeInteractionEmitter:new pe},o),s=r.style,c=new k({visibleProperty:s.faceColorsVisibleProperty}),d=new k({pickableProperty:fs}),i=new k({pickableProperty:ps}),n=new k({pickableProperty:hs}),l=new k({pickableProperty:gs}),u=new k,y=new k({pickable:!1}),f=new k({pickable:!1}),p=new k({renderer:_o.chromium?"canvas":null,pickable:null}),S=new k({pickable:!1}),w=new k,C=new z([e.stateProperty],F=>{if(F.getWeirdEdges().length||F.hasInvalidFaceColors())return!1;const D=F.getSimpleRegions();return D.length===1&&D[0].isSolved}),E=F=>{F?c.addChild(new Lr(e.board,e.stateProperty,s)):c.children.forEach(D=>D.dispose())};s.faceColorsVisibleProperty.link(E),d.addChild(new Ts(e.board,e.stateProperty,s,r)),r.noninteractive||d.addChild(new Mr(e.board,r)),f.addChild(new Rr(e.board,e.stateProperty,C,s));const m=new $e(e.board.outerBoundary,e.board.innerBoundaries,s,r);l.addChild(new Ms(e.board,e.stateProperty,C,s)),y.addChild(new ks(e.board,e.stateProperty,C,s)),n.addChild(new Ir(e.board,e.stateProperty,C,s)),r.noninteractive||n.addChild(new Nr(e.board,r.delayEdgeInteractionEmitter,r)),i.addChild(new As(e.board,e.stateProperty,s)),r.noninteractive||i.addChild(new Os(e.board,r)),u.addChild(new Is(e.board,e.stateProperty,s));super(Bt({children:[m,c,d,i,n,l,u,y,f,S,w,p]},r));g(this,"annotationContainer");g(this,"backgroundNode");this.puzzle=e,this.annotationContainer=p;const P=F=>{S.children.forEach(D=>D.dispose()),F&&S.addChild(new bs(F,e.board,s,r))};r.selectedFaceColorHighlightProperty.link(P),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(P));const V=F=>{w.children.forEach(D=>D.dispose()),F&&w.addChild(new Ns(F,m,s,r))};r.selectedSectorEditProperty.link(V),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(V)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(E),[c,d,n,l,u,y,f,i].forEach(D=>{D.children.forEach(I=>I.dispose()),D.dispose()}),C.dispose(),m.dispose()}),this.backgroundNode=m}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class aa extends k{constructor(t,e,o){const r=We()({style:_},o),s=e.getEmbeddedCompleteData(t.inputFeatureSet),c=e.getEmbeddedCompleteData(t.outputFeatureSet),d=new Mt(new Tt(e.smallBoard,s),{noninteractive:!0,style:r.style}),i=new Mt(new Tt(e.smallBoard,c),{noninteractive:!0,style:r.style}),n=t.highlander?new k({children:e.getEmbeddedQuestionFaces(t.inputFeatureSet).map(C=>new Wt("?",{font:it,maxWidth:.9,maxHeight:.9,opacity:.5,fill:t.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:C.viewCoordinates}))}):new k,u=e.tightBounds.dilated(.5),y=.5,f=M.roundRectangle(u.x,u.y,u.width,u.height,y,y),p=new k({children:[d,n],clipArea:f,localBounds:u}),S=new k({children:[i,n],clipArea:f,localBounds:u}),w=new zt(new Ht({spacing:.2,children:[p,new mr(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),S]}),{cornerRadius:y*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[w],super(r),this.rule=t,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{d.dispose(),i.dispose()})}}const Bs=(a,t)=>{Xe(Er,a,t,!0)};class Ae{constructor(t,e,o,r,s,c,d,i,n,l){this.sourcePatternBoard=t,this.boardPatternBoard=e,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=c,this.toSmallEdgeMap=d,this.toSmallSectorMap=i,this.tightBounds=n,this.expandedBounds=l}mapFace(t){const e=this.embedding.mapFace(t),o=this.boardPatternBoard.getFace(e);if(o){const r=this.toSmallFaceMap.get(o);return A()&&b(r),r}else return null}mapEdge(t){return(t.isExit?this.embedding.mapExitEdges(t):[this.embedding.mapNonExitEdge(t)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return A()&&b(s),s})}mapSector(t){const e=this.embedding.mapSector(t),o=this.boardPatternBoard.getSector(e),r=this.toSmallSectorMap.get(o);return A()&&b(r),r}getEmbeddedQuestionFaces(t){const e=new Set;for(const o of t.patternBoard.faces)if(t.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&e.add(r)}return this.smallBoard.faces.filter(o=>!e.has(o))}getEmbeddedCompleteData(t){const e=sr.empty(this.smallBoard);for(const o of t.getFeaturesArray())if(o instanceof Pr)o.value!==null&&e.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof vr)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.BLACK));else if(o instanceof Fr)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.RED));else if(o instanceof Vr)e.setSectorState(this.mapSector(o.sector),N.NOT_ZERO);else if(o instanceof Tr)e.setSectorState(this.mapSector(o.sector),N.NOT_ONE);else if(o instanceof Dr)e.setSectorState(this.mapSector(o.sector),N.NOT_TWO);else if(o instanceof Or)e.setSectorState(this.mapSector(o.sector),N.ONLY_ONE);else if(o instanceof Ar){const r=(c,d)=>{const i=this.mapFace(c),n=this.mapFace(d),l=i?e.getFaceColor(i):e.getOutsideColor(),u=n?e.getFaceColor(n):e.getOutsideColor();new Ke(oe(e,l),oe(e,u)).apply(e)},s=(c,d)=>{const i=this.mapFace(c),n=this.mapFace(d),l=i?e.getFaceColor(i):e.getOutsideColor(),u=n?e.getFaceColor(n):e.getOutsideColor();new ct(oe(e,l),oe(e,u)).apply(e)};for(let c=1;c<o.primaryFaces.length;c++)r(o.primaryFaces[c-1],o.primaryFaces[c]);for(let c=1;c<o.secondaryFaces.length;c++)r(o.secondaryFaces[c-1],o.secondaryFaces[c]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return Bs(this.smallBoard,e),e}static getEmbeddingBounds(t,e,o,r){const s=Qe.NOTHING.copy(),c=i=>{s.addPoint(e.getVertex(o.mapVertex(i)).viewCoordinates)};t.vertices.forEach(c);const d=i=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(i))return;const n=e.getFace(o.mapFace(i));n&&n.vertices.forEach(l=>s.addPoint(l.viewCoordinates))};return t.faces.forEach(d),t.edges.forEach(i=>{let n;if(i.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(i))return;n=o.mapExitEdges(i).map(l=>e.getEdge(l))}else n=[e.getEdge(o.mapNonExitEdge(i))];n.forEach(l=>{s.addPoint(l.start.viewCoordinates),s.addPoint(l.end.viewCoordinates)})}),s}static findBestEmbedding(t,e,o){const r=qo(t,e);if(r.length===0)return null;const s=Qe.NOTHING.copy();o.vertices.forEach(n=>s.addPoint(n.viewCoordinates));const c=s.center;let d=null,i=Number.POSITIVE_INFINITY;for(let n=0;n<r.length;n++){const l=r[n],y=Ae.getEmbeddingBounds(t,e,l).center,f=c.distance(y);f<i&&(i=f,d=l)}return d}static getDisplayEmbedding(t,e,o,r,s){const c=Ae.getEmbeddingBounds(t,e,r,s),d=c.dilated(.5),i=o.faces.filter(w=>{const C=Qe.NOTHING.copy();return w.vertices.forEach(E=>C.addPoint(E.viewCoordinates)),d.intersectsBounds(C)}),n=o.vertices.filter(w=>w.faces.some(C=>i.includes(C))),l=Jo({vertices:n.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates})),faces:i.map(w=>({logicalCoordinates:w.logicalCoordinates,vertices:w.vertices.map(C=>({logicalCoordinates:C.logicalCoordinates,viewCoordinates:C.viewCoordinates}))}))}),u=new Zo(l),y=1e-6,f=new Map(i.map((w,C)=>{const E=u.faces.find(m=>m.viewCoordinates.equalsEpsilon(w.viewCoordinates,y));return A()&&b(E),[w,E]})),p=new Map(o.edges.map(w=>{const C=u.edges.find(E=>E.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)||E.start.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y))??null;return C?[w,C]:null}).filter(w=>w!==null)),S=new Map(o.halfEdges.map(w=>{const C=u.halfEdges.find(E=>E.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&E.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y))??null;return C?[w,C]:null}).filter(w=>w!==null));return A()&&b(r),new Ae(t,e,o,r,u,f,p,S,c,d)}static getOptionsForRule(t){const e=t.outputFeatureSet.getAffectedFaces(),o=t.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>e.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(t,e,o){return Ae.getDisplayEmbedding(t.patternBoard,e,e.board,o,Ae.getOptionsForRule(t))}}export{vs as A,Gr as B,Bs as C,G as D,aa as E,xr as F,x as G,Ue as H,br as I,_e as J,Es as K,ne as L,ra as M,ea as N,Ds as O,Mt as P,_ as Q,Qs as R,at as S,cs as T,kr as U,Ls as V,Ae as W,zr as X,qs as a,_r as b,qr as c,Jr as d,Qr as e,sa as f,Zr as g,io as h,os as i,rs as j,ss as k,as as l,is as m,ls as n,jr as o,ds as p,kt as q,xt as r,$s as s,oa as t,Fs as u,ns as v,He as w,Js as x,Zs as y,ta as z};
