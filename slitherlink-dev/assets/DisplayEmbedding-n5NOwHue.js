var Wt=Object.defineProperty;var Ht=(i,t,e)=>t in i?Wt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var m=(i,t,e)=>(Ht(i,typeof t!="symbol"?t+"":t,e),e);import{d as z,h as W,B as Ce,F as Pe,N as T,P as Y,L as Mt,o as Ke,R as zt,H as gt,M as le,T as wt,G as Ut,C as yt,p as jt}from"./PhetioControlledVisibilityProperty-Bd0APyjs.js";import{E as v,F as ce,S as b,V as je,d as St,e as Yt,f as Xt,g as Je,h as Ze,i as _t,j as qt,k as Gt,l as Kt,U as He,m as $e,n as Ct,o as mt,p as Jt,q as Zt,s as $t,r as Qe,t as Qt,B as et,C as eo}from"./BasicPuzzle-BtlNDbsV.js";import{T as a,P as Fe,E as xe,e as Ie,o as be,f as re,l as to,V as K,k as ke,D as oo,c as Pt,C as ro,B as Me}from"./UnivariatePolynomial-CzQEP6td.js";import{b as so,L as de,a as Re,c as io,P as Et}from"./TextPushButton-BK9sQTIP.js";import{i as tt,S as N,L as ot,_ as Oe,ac as ao,e as L,f as A,m as no,H as lo,ad as co,ae as vt,k as ho,o as uo,l as po,d as fo}from"./patternBoards-DKw4bfen.js";import{Q as go,R as wo,S as yo,T as So,f as Co,g as mo,h as rt,K as Po,s as st,i as Eo,j as vo,v as it,k as Fo,m as at,w as Vo,n as se,q as bo,x as To,y as Lo,z as Ao,J as ie,H as ko,F as Oo,B as No,D as xo,c as ae,U as Io,r as Ro,u as Do,V as Ye}from"./Theme-DJ20V18i.js";import{S as Ft,J as Vt,K as bt,L as Tt,N as Lt,V as At,O as pe,P as Bo,A as Wo,B as Ho,Q as kt,R as Ot,T as Nt,U as De,W as xt,I as Z,X as Mo,Y as zo,Z as Uo,_ as jo,$ as Yo,a0 as Xo,a1 as _o,a2 as qo,a3 as Go,a4 as Ko,C as Ne,z as Jo,a5 as nt,a6 as ue,F as Zo,a7 as $o}from"./SATSolver-CQcvF3VG.js";import{A as Qo}from"./SpinningIndicatorNode-D6AHUmrG.js";import{a as er,B as tr,R as or,b as rr,c as sr,d as ir,S as ar,e as nr}from"./PatternRule-BPSy1pyf.js";const It=(i,t,e,o)=>(r,s,u)=>{const l=[new Ft(r,s),new Vt(r,s)];return(i||t||e||o)&&(l.push(new bt(r,s)),(t||e||o)&&(l.push(new Tt(r,s)),(e||o)&&(l.push(new Lt(r,s)),o&&l.push(new At(r,s))))),new pe(l)},lr={allowEdgeEditProperty:go,allowAbsoluteFaceColorEditProperty:wo,allowFaceColorEditProperty:yo,allowSectorEditProperty:So,edgesVisibleProperty:Co,edgesHaveColorsProperty:mo,faceColorsVisibleProperty:rt,faceColorThresholdProperty:Po,sectorsVisibleProperty:st,sectorsNextToEdgesVisibleProperty:Eo,sectorsTrivialVisibleProperty:vo,vertexStateVisibleProperty:it,allVertexStateVisibleProperty:Fo,faceStateVisibleProperty:at,whiteLineVisibleProperty:Vo,redLineVisibleProperty:se,verticesVisibleProperty:bo,smallVertexProperty:To,redXsVisibleProperty:Lo,redXsAlignedProperty:Ao,faceValueStyleProperty:ie,redLineStyleProperty:ko,vertexStyleProperty:Oo,joinedLinesJoinProperty:No,joinedLinesCapProperty:xo,safeSolverFactoryProperty:new z([rt,st,it,at],(i,t,e,o)=>It(i,t,e,o)),autoSolverFactoryProperty:Bo,theme:ae},he=(i,t,e,o,r)=>{const s=It(i,t,e,o);return{faceColorsVisibleProperty:new Ce(i),sectorsVisibleProperty:new Ce(t),vertexStateVisibleProperty:new Ce(e),faceStateVisibleProperty:new Ce(o),safeSolverFactoryProperty:new Fe(s),autoSolverFactoryProperty:r?new z([r],u=>(l,c,d)=>new pe([s(l,c,d),u(l,c,d)])):new Fe(s)}},ge=new z([Wo,Ho],(i,t)=>(e,o,r)=>new pe([new kt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:i,solveAlmostEmptyToRed:!0},r?void 0:[]),new Ot(e,o,{solveToRed:!0,solveToBlack:i},r?void 0:[]),...t?[new Nt(e,o,{solveToRed:!0,solveToBlack:i,resolveAllRegions:!1},r?void 0:[])]:[]])),cr=new z([ge],i=>(t,e,o)=>new pe([i(t,e,o),new De(t,e,{solveToRed:!0,solveToBlack:!0})])),Rt=new z([ge],i=>(t,e,o)=>new pe([i(t,e,o),new xt(t,e,o?void 0:[])])),dr=new z([Rt],i=>(t,e,o)=>new pe([i(t,e,o),new De(t,e,{solveToRed:!0,solveToBlack:!0})])),hr=i=>({...he(!0,!1,!1,!1,ge),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!0),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),ur=i=>({...he(!0,!1,!1,!1,cr),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),pr=i=>({...he(!0,!1,!1,!1,new Fe((t,e,o)=>new pe([new De(t,e,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:i,allowEdgeEditProperty:new a(!1),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!1),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),fr=i=>({...he(!1,!1,!1,!1,ge),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:se,verticesVisibleProperty:new a(!0),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!0),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("square"),joinedLinesJoinProperty:new a("miter"),joinedLinesCapProperty:new a("square")}),Os=i=>({...he(!1,!0,!1,!1,ge),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:se,verticesVisibleProperty:new a(!0),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!0),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("square"),joinedLinesJoinProperty:new a("miter"),joinedLinesCapProperty:new a("square")}),gr=i=>({...he(!0,!0,!1,!1,Rt),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!0),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),wr=i=>({...he(!0,!0,!1,!1,dr),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),yr=i=>({...he(!0,!1,!0,!1,ge),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),Sr=i=>({...he(!0,!1,!1,!0,ge),theme:i,allowEdgeEditProperty:new a(!0),allowAbsoluteFaceColorEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:se,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:ie,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),Cr=hr(ae),mr=ur(ae),Pr=pr(ae),Dt=fr(ae),Er=gr(ae),vr=wr(ae),Fr=yr(ae),Vr=Sr(ae),ze={basicLines:Cr,basicFaceColoring:mr,pureFaceColor:Pr,classic:Dt,basicSectors:Er,sectorsWithColors:vr,vertexState:Fr,faceState:Vr,custom:lr},lt=Dt,br=i=>({allowEdgeEditProperty:new W(i,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new W(i,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new W(i,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new W(i,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new W(i,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new W(i,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new W(i,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new W(i,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new W(i,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new W(i,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new W(i,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new W(i,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new W(i,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new W(i,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new W(i,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new W(i,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new W(i,{derive:"verticesVisibleProperty"}),smallVertexProperty:new W(i,{derive:"smallVertexProperty"}),redXsVisibleProperty:new W(i,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new W(i,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new W(i,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new W(i,{derive:"redLineStyleProperty"}),vertexStyleProperty:new W(i,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new W(i,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new W(i,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new W(i,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new W(i,{derive:"autoSolverFactoryProperty"}),theme:Io(new z([i],t=>t.theme))}),Tr=new so("puzzleStyle",{serialize:i=>Object.keys(ze).find(t=>ze[t]===i),deserialize:i=>i?ze[i]??lt:lt}),_=br(Tr),Ns=new de("showPuzzleStyleProperty",!0),xs=new de("showPuzzleTimerProperty",!1),M=class M extends xe{constructor(t){super(),this.isEnabledProperty=t}};m(M,"EDGE_STATE",new M(_.allowEdgeEditProperty)),m(M,"EDGE_STATE_REVERSED",new M(_.allowEdgeEditProperty)),m(M,"FACE_COLOR_OUTSIDE",new M(_.allowAbsoluteFaceColorEditProperty)),m(M,"FACE_COLOR_INSIDE",new M(_.allowAbsoluteFaceColorEditProperty)),m(M,"FACE_COLOR_MATCH",new M(_.allowFaceColorEditProperty)),m(M,"FACE_COLOR_OPPOSITE",new M(_.allowFaceColorEditProperty)),m(M,"SECTOR_STATE",new M(_.allowSectorEditProperty)),m(M,"VERTEX_STATE",new M(_.vertexStateVisibleProperty)),m(M,"FACE_STATE",new M(_.faceStateVisibleProperty)),m(M,"FACE_VALUE",new M(new Ce(!1))),m(M,"DELETE_FACE",new M(new Ce(!1))),m(M,"enumeration",new Ie(M));let B=M;const G=new Re("editModeProperty",B.EDGE_STATE);B.enumeration.values.forEach(i=>{i.isEnabledProperty.lazyLink(t=>{if(!G.value.isEnabledProperty.value){const e=B.enumeration.values.find(o=>o.isEnabledProperty.value)??null;e&&(G.value=e)}})});const Ue=new de("eraserEnabledProperty",!1),Is=i=>{i.isEnabledProperty.value&&(G.value=i)},Lr=new z([G],i=>i===B.EDGE_STATE||i===B.EDGE_STATE_REVERSED),Xe=new z([G],i=>i===B.FACE_COLOR_MATCH||i===B.FACE_COLOR_OPPOSITE),Rs=Xe,Ar=new z([G],i=>i===B.FACE_COLOR_OUTSIDE||i===B.FACE_COLOR_INSIDE),kr=new z([G],i=>i===B.SECTOR_STATE),Or=new z([G],i=>i===B.VERTEX_STATE),Nr=new z([G,Xe,Ar],(i,t,e)=>t||e||i===B.FACE_STATE||i===B.FACE_VALUE||i===B.DELETE_FACE),xr=(i,t,e)=>{const o=new Pe({mouseButton:0,fire:u=>{var l;return e&&e(i,(l=u.domEvent)!=null&&l.shiftKey?2:0)}}),r=new Pe({mouseButton:2,fire:u=>{var l;return e&&e(i,(l=u.domEvent)!=null&&l.shiftKey?0:2)}}),s=new Pe({mouseButton:1,fire:u=>e&&e(i,1)});t.addInputListener(o),t.addInputListener(r),t.addInputListener(s),t.cursor="pointer",t.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class Be extends T{constructor(t,e,o,r){const s=be()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},noninteractive:!1},r);super({pickableProperty:Xe}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,!s.noninteractive&&xr(null,this,s.facePressListener);const u=t.map(f=>f.start.viewCoordinates),l=s.useBackgroundOffsetStroke,c=s.backgroundOffsetDistance,n=tt(u)>0?-c:c,h=f=>{const g=new ao;g.addShape(0,f),g.computeSimplifiedFaces(),g.computeFaceInclusion(C=>C[0]>0);const w=g.createFilledSubGraph(),y=w.facesToShape();return g.dispose(),w.dispose(),y},S=Be.getOffsetBackgroundShape(t,l,c),p=e.map(f=>{const g=f.map(y=>y.start.viewCoordinates),w=N.polygon(g);if(l)return h(w.getOffsetShape(n));{const C=w.getStrokedShape(new ot({lineWidth:2*c})).subpaths.map(P=>new N([P]));return h(Oe.minBy(C,P=>P.getArea()))}});this.children=[new Y(S,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...p.map(f=>new Y(f,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(c=>c.start.viewCoordinates),s=N.polygon(r),l=tt(r)>0?-o:o;if(e)return s.getOffsetShape(l).getSimplifiedAreaShape();{const c=s.getStrokedShape(new ot({lineWidth:2*o})),d=c.subpaths.map(n=>new N([n]));try{return c.bounds.width===9.718028227819117?N.bounds(c.bounds):Oe.maxBy(d,n=>n.getArea()).getSimplifiedAreaShape()}catch{return N.bounds(c.bounds)}}}}class Ir{constructor(t,e,o){m(this,"edgeStateChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(L()&&A(this.board.edges.includes(t)),e!==v.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new Z(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Rr{constructor(t,e,o){m(this,"faceColorsChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){if(s)throw new Z("invalid face color?");const u=new Set([...o.values(),...r.keys(),...o.values()]),l=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())l.set(n,o.get(n));const c=n=>r.has(n)?r.get(n):[...t].includes(n)?this.currentState.getOppositeFaceColor(n):null,d=new Map;for(const n of l.keys()){const h=l.get(n);d.has(h)||d.set(h,new Set([n])),d.get(h).add(n)}for(const n of u){const h=d.get(n);if(!h)continue;const S=[...h];L()&&A(S.length>0);const p=this.solvedState.getFaceColor(S[0]);for(const g of S)if(this.solvedState.getFaceColor(g)!==p)throw new Z("invalid face color");const f=c(n);if(f){let g;if(f.colorState===ce.INSIDE?g=this.solvedState.getInsideColor():f.colorState===ce.OUTSIDE?g=this.solvedState.getOutsideColor():g=this.solvedState.getFaceColor([...d.get(f)][0]),p===g)throw new Z("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Dr{constructor(t,e,o){m(this,"simpleRegionsChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new Z("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Br{constructor(t,e,o){m(this,"faceValueChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new Z("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Wr{constructor(t,e,o){m(this,"sectorStateChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){L()&&A(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Hr{constructor(t,e,o){m(this,"vertexStateChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){L()&&A(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new Z("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Mr{constructor(t,e,o){m(this,"faceStateChangedEmitter",new re);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){L()&&A(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new Z("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class zr{constructor(t,e,o){m(this,"anyStateChangedEmitter",new re);m(this,"edgeStateValidator");m(this,"faceValueValidator");m(this,"simpleRegionDataValidator");m(this,"faceColorValidator");m(this,"sectorStateValidator");m(this,"vertexStateValidator");m(this,"faceStateValidator");L()&&A(t),L()&&A(o),this.edgeStateValidator=new Ir(t,e,o),this.faceValueValidator=new Br(t,e,o),this.simpleRegionDataValidator=new Dr(t,e,o),this.faceColorValidator=new Rr(t,e,o),this.sectorStateValidator=new Wr(t,e,o),this.vertexStateValidator=new Hr(t,e,o),this.faceStateValidator=new Mr(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){this.faceColorValidator.modifyFaceColors(t,e,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const j=class j extends xe{constructor(t,e,o){super(),this.fromWhite=t,this.fromBlack=e,this.fromRed=o}apply(t){return t===v.WHITE?this.fromWhite:t===v.BLACK?this.fromBlack:this.fromRed}};m(j,"CYCLE",new j(v.BLACK,v.RED,v.WHITE)),m(j,"REVERSE_CYCLE",new j(v.RED,v.WHITE,v.BLACK)),m(j,"WHITE_SET",new j(v.WHITE,v.WHITE,v.WHITE)),m(j,"BLACK_SET",new j(v.BLACK,v.BLACK,v.BLACK)),m(j,"RED_SET",new j(v.RED,v.RED,v.RED)),m(j,"BLACK_TOGGLE",new j(v.BLACK,v.WHITE,v.BLACK)),m(j,"RED_TOGGLE",new j(v.RED,v.RED,v.WHITE)),m(j,"enumeration",new Ie(j));let Ve=j;const Ur=new Re("pressStyle0",Ve.CYCLE),jr=new Re("pressStyle1",Ve.WHITE_SET),Yr=new Re("pressStyle2",Ve.REVERSE_CYCLE),Xr=i=>{switch(i){case 0:return Ur.value;case 1:return jr.value;case 2:return Yr.value}},_r=(i,t,e)=>new pe([new Ft(i,t),new Vt(i,t),new bt(i,t),new kt(i,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Ot(i,t,{solveToRed:!0,solveToBlack:!0}),new Nt(i,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new Mo(i,t),new Tt(i,t),new xt(i,t),new zo(i,t),new Lt(i,t),new Uo(i,t,{solveToRed:!0,solveToBlack:!0}),new jo(i,t),new De(i,t,{solveToRed:!0,solveToBlack:!0}),new Yo(i,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new Xo(i,t),new At(i,t),new _o(i,t,{solveToRed:!0,solveToBlack:!0}),new qo(i,t),new Go(i,t),new Ko(i,t)]),ct=(i,t,e)=>{Ne(e,i,t,!0)};class qr{constructor(t){this.hintAction=t}get annotation(){return this.hintAction.annotation}apply(t){this.hintAction.apply(t)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(t,e){throw new Error("unimplemented")}}const Gr=i=>i instanceof no?{type:"SquareBoard",width:i.width,height:i.height}:i instanceof lo?{type:"HexagonalBoard",radius:i.radius,scale:i.scale,isPointyTop:i.isPointyTop,holeRadius:i.holeRadius}:{type:"BaseBoard",vertices:i.vertices.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vx:t.viewCoordinates.x,vy:t.viewCoordinates.y})),faces:i.faces.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vertices:t.vertices.map(e=>i.vertices.indexOf(e))}))},Bt=i=>({version:1,board:Gr(i.board),state:i.stateProperty.value.serializeState(i.board)}),Kr=i=>{const t=Bt(i);return co(JSON.stringify(t))};function Jr(i){return new Worker(""+new URL("hintWorker-3McetjA7.js",import.meta.url).href,{name:i==null?void 0:i.name})}let we=null;const Ae=new a(!1),Zr=()=>(we||(we=new Jr,we==null||we.addEventListener("message",i=>{i.data.type==="hint-worker-loaded"&&(Ae.value=!0)})),we),$r=i=>{const t=Bt(i),e=i.solution.cleanState.serializeState(i.board),o=i.solution.solvedState.serializeState(i.board),r=[...i.solution.blackEdges].map(s=>i.board.edges.indexOf(s));return{puzzle:t,cleanState:e,solvedState:o,blackEdges:r}},J=class J extends xe{};m(J,"DEFAULT",new J),m(J,"LOADING",new J),m(J,"SEARCHING",new J),m(J,"FOUND",new J),m(J,"NOT_FOUND",new J),m(J,"enumeration",new Ie(J));let te=J;const Qr=i=>[i.forwardHalf,i.reversedHalf,i.forwardHalf.previous,i.reversedHalf.previous];class We{constructor(t){this.edge=t,L()&&A(t)}apply(t){t.getEdgeState(this.edge)!==v.WHITE&&t.setEdgeState(this.edge,v.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=t.getOutsideColor(),u=t.getInsideColor(),l=o?t.getFaceColor(o):s,c=r?t.getFaceColor(r):s,d=t.getOppositeFaceColor(l);if(l===c||d===c){const n=[...t.getFacesWithColor(l),...l===s?[null]:[]],h=d?[...t.getFacesWithColor(d),...d===s?[null]:[]]:[],S=[...n,...h],p=g=>{const w=new Set,y=new Set([g]);for(;y.size>0;){const C=y.values().next().value;if(y.delete(C),w.add(C),C){for(const P of C.edges)if(t.getEdgeState(P)!==v.WHITE){const E=P.getOtherFace(C),D=E?t.getFaceColor(E):s;(D===l||D===d)&&!w.has(E)&&y.add(E)}}else for(const P of S)if(P&&!w.has(P))for(const E of P.edges)E.getOtherFace(P)===null&&t.getEdgeState(E)!==v.WHITE&&y.add(P)}return w},f=p(o);if(!f.has(r)){const g=p(r);L()&&A(f.size>0&&g.size>0),L()&&A([...f].every(I=>!g.has(I)));const w=S.filter(I=>!f.has(I)&&!g.has(I)),y=[],C=[],P=new Map,E=new Map,D=(I,H,q)=>{const O=I.filter(V=>(V?t.getFaceColor(V):s)===l),R=I.filter(V=>(V?t.getFaceColor(V):s)===d);if(H!==null)H!==s&&H!==u&&(O.length||C.push(H),q&&!R.length&&C.push(q));else if(L()&&A(I.every(V=>V)),H=new Je(Ze(),ce.UNDECIDED),y.push(H),O.length&&R.length){q=new Je(Ze(),ce.UNDECIDED),y.push(q),E.set(H,q),E.set(q,H);for(const V of O)L()&&A(V),P.set(V,H);for(const V of R)L()&&A(V),P.set(V,q)}else{const V=O.length?O:R;L()&&A(V.length);for(const U of V)L()&&A(U),P.set(U,H)}},F=[...f],k=[...g],x=Oe.sortBy([...w.length?[w]:[],F,k],I=>-I.length+(I.some(H=>!H)?-1e7:0));for(let I=0;I<x.length;I++)D(x[I],I===0?l:null,I===0?d:null);t.modifyFaceColors(y,C,P,E,!1)}}for(const n of Qr(this.edge))t.setSectorState(n,b.ANY);for(const n of this.edge.vertices)t.setVertexState(n,je.any(n));for(const n of this.edge.faces)t.setFaceState(n,St.any(n,t.getFaceValue(n)))}getUndo(t){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:Yt(this.edge)}}static deserializeAction(t,e){const o=Xt(t,e.edge);return new We(o)}}class Te extends Error{constructor(t){super(t)}}class _e{constructor(t){this.face=t,L()&&A(t)}apply(t){this.face.edges.forEach(e=>{new We(e).apply(t)})}getUndo(t){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:_t(this.face)}}static deserializeAction(t,e){const o=qt(t,e.face);return new _e(o)}}class qe{constructor(t){this.sector=t,L()&&A(t)}apply(t){t.setSectorState(this.sector,b.ANY);const e=this.sector.end;t.setVertexState(e,je.any(e));const o=this.sector.face;o&&t.setFaceState(o,St.any(o,t.getFaceValue(o)))}getUndo(t){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:Gt(this.sector)}}static deserializeAction(t,e){const o=Kt(t,e.sector);return new qe(o)}}const es=new de("uiHintUsesBuiltInSolve",!1),Ds=new de("showUndoRedoAllProperty",!1),dt=new de("dimCompletedNumbersProperty",!0),ht=new de("highlightIncorrectNumbersProperty",!0),Bs=new de("highlightIncorrectMovesProperty",!0),ts=new de("highlightIntersectionsProperty",!0);class Ws extends to{constructor(e,o){const r=be()({style:_,initialTimeElapsed:0},o),s=r.style;super();m(this,"timeElapsedProperty",new a(0));m(this,"hintStateProperty",new a(te.DEFAULT));m(this,"edgeAutoSolvedEmitter",new re);m(this,"stack");m(this,"stackLengthProperty",new a(0));m(this,"stackPositionProperty",new a(0));m(this,"undoPossibleProperty");m(this,"redoPossibleProperty");m(this,"currentSnapshotProperty");m(this,"hasErrorProperty");m(this,"isSolvedProperty");m(this,"hintWorkerMessageID",0);m(this,"addedHintListener",!1);m(this,"pendingHintActionProperty",new a(null));m(this,"displayedAnnotationProperty");m(this,"pendingActionFaceColorProperty",new a(null));m(this,"pendingActionSectorProperty",new a(null));m(this,"selectedFaceColorHighlightProperty");m(this,"selectedSectorEditProperty");m(this,"autoSolverFactoryProperty");m(this,"style");this.puzzle=e,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.autoSolverFactoryProperty=new z([Jo,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(c,d,n)=>c?n:d),this.displayedAnnotationProperty=new z([this.pendingHintActionProperty],c=>c?c.annotation:null);const u=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(u),G.lazyLink(u),this.disposeEmitter.addListener(()=>G.unlink(u)),this.selectedFaceColorHighlightProperty=new z([e.stateProperty,G,this.pendingActionFaceColorProperty],(c,d,n)=>{if((d===B.FACE_COLOR_MATCH||d===B.FACE_COLOR_OPPOSITE)&&n){const h=c.getFacesWithColor(n.color);return{faceColor:n.color,face:n.face,faces:h}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new z([e.stateProperty,G,this.pendingActionSectorProperty],(c,d,n)=>d===B.SECTOR_STATE&&n?{sector:n,currentState:c.getSectorState(n)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const c=e.stateProperty.value.clone();ct(e.board,c,this.style.safeSolverFactoryProperty.value),e.stateProperty.value=c}this.stack=[new Ee(this.puzzle.board,null,e.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new z([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new z([this.currentSnapshotProperty],c=>c.errorDetected),this.isSolvedProperty=new z([this.currentSnapshotProperty],c=>{if(c.state.getWeirdEdges().length||c.state.hasInvalidFaceColors())return!1;const d=c.state.getSimpleRegions();return d.length===1&&d[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new z([this.stackPositionProperty],c=>c>0),this.redoPossibleProperty=new z([this.stackPositionProperty,this.stackLengthProperty],(c,d)=>c<d-1);const l=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(l),this.style.safeSolverFactoryProperty.lazyLink(l),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(l),this.style.safeSolverFactoryProperty.unlink(l)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(e){this.timeElapsedProperty.value+=e,localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Kr(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(e){this.wipeStackTop(),this.stack.push(e),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(e,o){const r=(o==null?void 0:o.forceDirty)||e instanceof He,s=this.stack[this.stackPositionProperty.value];let u=!1,l=s.state;o!=null&&o.erase&&(l=l.clone(),o.erase(l));const c=new zr(this.puzzle.board,l,this.puzzle.solution.solvedState);try{e.apply(c)}catch{u=!0}let d=new Set;const n=p=>{d.add(p)};let h=l.createDelta();try{if(h.edgeStateChangedEmitter.addListener(n),nt(this.autoSolverFactoryProperty.value,this.puzzle.board,h,()=>{e.apply(h)},r),h.edgeStateChangedEmitter.removeListener(n),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(h)))throw new Te("Auto-solver did not respect user action")}catch(p){if(u=!(p instanceof Te),d=new Set,p instanceof Z||p instanceof Te)p instanceof Z?console.log("error"):p instanceof Te&&console.log("skipping autosolve due to undo"),h=l.createDelta(),h.edgeStateChangedEmitter.addListener(n),nt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,h,()=>{e.apply(h)},r),h.edgeStateChangedEmitter.removeListener(n);else throw p}const S=l.clone();h.apply(S),this.pushTransitionAtCurrentPosition(new Ee(this.puzzle.board,e,S,u));for(const p of d)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(p))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(p))}addAutoSolveDelta(){const e=this.puzzle.stateProperty.value.createDelta();try{if(Ne(this.autoSolverFactoryProperty.value,this.puzzle.board,e,!0),!e.isEmpty()){const o=this.puzzle.stateProperty.value.clone();e.apply(o),this.pushTransitionAtCurrentPosition(new Ee(this.puzzle.board,new He,o))}}catch(o){if(!(o instanceof Z))throw o}}onAutoSolveChange(){const e=this.stack[this.stackPositionProperty.value];e.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(e.action||new He,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(e,o){const r=G.value===B.EDGE_STATE_REVERSED;return Xr(r?2-o:o).apply(e)}onUserEdgePress(e,o){const r=Ue.value,s=this.puzzle.stateProperty.value.getEdgeState(e),u=r?v.WHITE:this.getNewEdgeState(s,o);let l;if(s!==u){const c=this.stack[this.stackPositionProperty.value];c.action&&c.action instanceof $e&&c.action.edge===e?this.stackPositionProperty.value--:s!==v.WHITE&&(l=n=>{new We(e).apply(n)});const d=new $e(e,u);this.applyUserActionToStack(d,{erase:l,checkAutoSolve:n=>n.getEdgeState(e)===u,excludedEdges:new Set([e])}),this.updateState()}}onUserFacePress(e,o){const r=Ue.value,s=G.value;if(r){if(e){const u=new _e(e);this.applyUserActionToStack(u,{erase:l=>u.apply(l)}),this.updateState()}}else if(s===B.FACE_COLOR_MATCH||s===B.FACE_COLOR_OPPOSITE){let u=G.value===B.FACE_COLOR_MATCH;o===2&&(u=!u);const l=e?this.puzzle.stateProperty.value.getFaceColor(e):this.puzzle.stateProperty.value.getOutsideColor(),c=this.pendingActionFaceColorProperty.value;if(c){if(e!==c.face){const d=c.color;d!==l&&(u?this.applyUserActionToStack(new Ct(ue(this.puzzle.stateProperty.value,l),ue(this.puzzle.stateProperty.value,d))):this.applyUserActionToStack(new mt(ue(this.puzzle.stateProperty.value,l),ue(this.puzzle.stateProperty.value,d))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:e,color:l}}else if((s===B.FACE_COLOR_OUTSIDE||s===B.FACE_COLOR_INSIDE)&&e){const u=this.puzzle.stateProperty.value.getFaceColor(e),l=s===B.FACE_COLOR_OUTSIDE?this.puzzle.stateProperty.value.getOutsideColor():this.puzzle.stateProperty.value.getInsideColor();s===B.FACE_COLOR_OUTSIDE?this.puzzle.stateProperty.value.getInsideColor():this.puzzle.stateProperty.value.getOutsideColor(),u!==l&&(this.applyUserActionToStack(new Jt(e,s===B.FACE_COLOR_INSIDE)),this.updateState())}}onUserSectorPress(e,o){if(Ue.value){const s=new qe(e);this.applyUserActionToStack(s,{erase:u=>s.apply(u)}),this.updateState()}else this.pendingActionSectorProperty.value=e}onUserSectorSet(e,o){this.applyUserActionToStack(new Zt(e,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const e=this.puzzle.stateProperty.value;if(!$t(e))if(es.value){const o=e.clone();Ne(_r,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(new Ee(this.puzzle.board,new Qe,o,!1)),this.updateState()}else{const o=Zo(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,v.BLACK)}),ct(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(new Ee(this.puzzle.board,new Qe,r,!1)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=te.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(e){this.hintStateProperty.value=e?te.FOUND:te.NOT_FOUND,e&&(this.pendingHintActionProperty.value=e)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const e=_.allowEdgeEditProperty.value,o=_.allowFaceColorEditProperty.value,r=_.allowSectorEditProperty.value,s=_.vertexStateVisibleProperty.value,u=_.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const l=Zr();if(!this.addedHintListener){this.addedHintListener=!0;const c=d=>{if(d.data.type==="hint-response"&&d.data.id===this.hintWorkerMessageID){const n=d.data.action?Qt(this.puzzle.board,d.data.action):null;this.onHintReceived(n)}};l.addEventListener("message",c),this.disposeEmitter.addListener(()=>self.removeEventListener("message",c))}if(l.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:e,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:u,serializedSolvablePuzzle:$r(this.puzzle)}),Ae.value)this.hintStateProperty.value=te.SEARCHING;else{this.hintStateProperty.value=te.LOADING;const c=d=>{d&&(this.hintStateProperty.value===te.LOADING&&(this.hintStateProperty.value=te.SEARCHING),Ae.unlink(c))};Ae.link(c)}}onUserApplyHint(){const e=this.pendingHintActionProperty.value;e&&(this.clearPendingHint(),this.applyUserActionToStack(new qr(e)),this.updateState())}}class Ee{constructor(t,e,o,r=!1){this.board=t,this.action=e,this.state=o,this.errorDetected=r}}class os extends T{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});m(this,"simpleRegionNodeMap",new Map);m(this,"regionIdMap",new Map);m(this,"weirdEdgeNodeMap",new Map);m(this,"regionContainer",new T);m(this,"weirdEdgeContainer",new T);m(this,"adjacentFacesMap",new Map);m(this,"weirdEdgeColorProperty");this.board=e,this.style=r,this.weirdEdgeColorProperty=new z([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,ts],(l,c,d)=>d?l:c),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),e.faces.forEach(l=>{this.adjacentFacesMap.set(l,l.edges.map(c=>c.getOtherFace(l)).filter(c=>c!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(l=>this.addRegion(l)),o.value.getWeirdEdges().forEach(l=>this.addWeirdEdge(l)),this.updateHues();const s=(l,c)=>{const d=c.getSimpleRegions(),n=l.getSimpleRegions(),h=c.getWeirdEdges(),S=l.getWeirdEdges(),p=[],f=[];vt(d,n,p,f,[]);const w=new Set(p);for(const y of f)if(this.regionIdMap.has(y.id)){const C=this.regionIdMap.get(y.id);this.replaceRegion(C,y),w.delete(C)}else this.addRegion(y);for(const y of w)this.removeRegion(y);for(const y of h)S.includes(y)||this.removeWeirdEdge(y);for(const y of S)h.includes(y)||this.addWeirdEdge(y);(f.length||p.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const u=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(u),r.edgesHaveColorsProperty.lazyLink(u),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(u),r.edgesHaveColorsProperty.unlink(u)})}addRegion(e){const o=new me(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){L()&&A(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=new Mt(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const u=l=>{s.lineCap=l};this.style.joinedLinesCapProperty.link(u),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(u))}this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){this.weirdEdgeNodeMap.get(e).dispose(),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new K(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},s=new Map,u=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of e){const h=new Set;for(const p of n.simpleRegion.edges)for(const f of p.faces)h.add(f);const S=new Set;for(const p of h){S.add(p);for(const f of this.adjacentFacesMap.get(p))S.add(f)}for(const p of S){const f=s.get(p);if(f.length)for(const g of f){let w=!1;for(const y of u)if(y.a===g&&y.b===n){y.weight++,w=!0;break}w||u.push({a:g,b:n,weight:1})}f.push(n)}}const l=new Map;for(const n of e)l.set(n,K.ZERO.copy());const c=(n,h,S)=>{const p=l.get(n),f=l.get(h),g=n.hueVector.dot(h.hueVector),w=o.set(h.hueVector).subtract(n.hueVector);if(w.magnitude>1e-9){w.normalize();const y=.3,C=S*((Math.max(y,g)-y)/(1-y))**3;w.multiplyScalar(C),p.subtract(w),f.add(w)}};let d=1;for(let n=0;n<100;n++){d*=.99;for(const h of e)l.get(h).setXY(0,0);for(const h of u){const S=h.a,p=h.b,f=h.weight;c(S,p,f)}if(e.length<8)for(let h=0;h<e.length;h++){const S=e[h];for(let p=h+1;p<e.length;p++)c(S,e[p],.2)}for(const h of e){const S=l.get(h);S.multiplyScalar(d/h.edgeCount),h.hueVector.add(S),l.get(h).setXY(0,0)}r()}for(const n of e)n.updateHue()}}class me extends Y{constructor(e,o){const r=K.createPolar(1,ke.nextDoubleBetween(0,2*Math.PI));super(me.toShape(e),{stroke:me.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});m(this,"hueVector");m(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const s=l=>{this.lineJoin=l};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const u=l=>{this.lineCap=l};o.joinedLinesCapProperty.link(u),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(u))}updateHue(){this.stroke=me.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:K.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=me.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return L()&&A(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(e){const o=new N;let r=!0;for(const s of e.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class rs extends T{constructor(e,o,r){const s=new T;super({pickable:!1,children:[s]});m(this,"faceColorNodeMap",new Map);m(this,"faceColorIdMap",new Map);m(this,"adjacentFacesMap",new Map);m(this,"faceColorNodeContainer");m(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,e.faces.forEach(d=>{this.adjacentFacesMap.set(d,d.edges.map(n=>n.getOtherFace(d)).filter(n=>n!==null))});{const d=o.value.getFaceColors();for(const n of d)this.addFaceColor(n,o.value.getFacesWithColor(n));this.addDualColorViews(o.value,d)}this.updateHues();let u=o.value.clone();const l=d=>{const n=u;u=d.clone();const h=n.getFaceColors(),S=d.getFaceColors(),p=[],f=[],g=[];vt(h,S,p,f,g);const w=new Set(p),y=this.removeInvalidDualColorViews(d),C=[...y];for(const P of f)if(y.add(P),this.faceColorIdMap.has(P.id)){const E=this.faceColorIdMap.get(P.id);this.replaceFaceColor(E,P,d.getFacesWithColor(P)),w.delete(E)}else this.addFaceColor(P,d.getFacesWithColor(P));for(const P of g)this.updateFaceColor(P,d.getFacesWithColor(P));for(const P of w)y.delete(P),this.removeFaceColor(P);this.addDualColorViews(d,[...y]),(f.length||p.length||C.length)&&this.updateHues()};o.lazyLink(l),this.disposeEmitter.addListener(()=>o.unlink(l)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const c=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(c),r.theme.faceColorLightHueLUTProperty.lazyLink(c),r.theme.faceColorDarkHueLUTProperty.lazyLink(c),r.theme.faceColorInsideColorProperty.lazyLink(c),r.theme.faceColorOutsideColorProperty.lazyLink(c),r.theme.faceColorDefaultColorProperty.lazyLink(c),r.faceColorThresholdProperty.lazyLink(c),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(c),r.theme.faceColorLightHueLUTProperty.unlink(c),r.theme.faceColorDarkHueLUTProperty.unlink(c),r.theme.faceColorInsideColorProperty.unlink(c),r.theme.faceColorOutsideColorProperty.unlink(c),r.theme.faceColorDefaultColorProperty.unlink(c),r.faceColorThresholdProperty.unlink(c)})}addFaceColor(e,o){const r=new ve(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){L()&&A(e.id===o.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let s=r.faces.length!==o.length;if(!s)for(let u=0;u<o.length;u++){const l=r.faces[u],c=o[u];if(l!==c){s=!0;break}}s&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const u=this.faceColorNodeMap.get(s);L()&&A(u);const l=e.getOppositeFaceColor(s);if(l){L()&&A(r.has(l)),r.delete(l);const c=this.faceColorNodeMap.get(l);L()&&A(c),this.dualColorViews.add(new ut([u,c],this.style))}else this.dualColorViews.add(new ut([u],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const u of s.colorNodes)o.add(u.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==ce.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new K(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(ke.nextDouble()-.5,ke.nextDouble()-.5).normalize()},s=new Map,u=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of e){const h=new Set;for(const p of n.faces)h.add(p);const S=new Set;for(const p of h){S.add(p);for(const f of this.adjacentFacesMap.get(p))S.add(f)}for(const p of S){const f=s.get(p);if(f){if(f.length)for(const g of f){let w=!1;for(const y of u)if(y.a===g&&y.b===n){y.weight++,w=!0;break}w||u.push({a:g,b:n,weight:1})}f.push(n)}}}const l=new Map;for(const n of e)l.set(n,K.ZERO.copy());const c=(n,h,S)=>{const p=l.get(n),f=l.get(h),g=n.hueVector.dot(h.hueVector),w=o.set(h.hueVector).subtract(n.hueVector);w.magnitudeSquared>1e-11&&w.normalize();const y=.2,C=Math.abs(g),P=S*((Math.max(y,C)-y)/(1-y))**3;w.multiplyScalar(P),p.subtract(w),f.add(w)};let d=1;for(let n=0;n<100;n++){d*=.99;for(const h of e)l.get(h).setXY(0,0);for(const h of u){const S=h.a,p=h.b,f=h.weight;c(S,p,f)}if(e.length<8)for(let h=0;h<e.length;h++){const S=e[h];for(let p=h+1;p<e.length;p++)c(S,e[p],.2)}for(const h of e){const S=l.get(h);S.multiplyScalar(d/h.faceCount),h.hueVector.add(S),l.get(h).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const oe=class oe extends xe{};m(oe,"BASIC",new oe),m(oe,"PRIMARY",new oe),m(oe,"SECONDARY",new oe),m(oe,"enumeration",new Ie(oe));let Q=oe;class ut{constructor(t,e){m(this,"hueVector");m(this,"faceCount");if(this.colorNodes=t,this.style=e,L()&&A(t.length===1||t.length===2),this.faceCount=Oe.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=Q.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let s;o.type===Q.PRIMARY?s=o:r.type===Q.PRIMARY||o.type===Q.SECONDARY?s=r:(r.type,Q.SECONDARY,s=o);const u=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=Q.PRIMARY,u.type=Q.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class ve extends Y{constructor(e,o,r){const s=K.createPolar(1,ke.nextDoubleBetween(0,2*Math.PI));super(ve.toShape(o));m(this,"hueVector");m(this,"faceCount");m(this,"dualColorView",null);m(this,"type",Q.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==ce.UNDECIDED?this.fill=ve.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:K.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=ve.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,s){const u=r===Q.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===Q.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,l=(Math.round(e.getAngle()*180/Math.PI)+360)%360;L()&&A(l>=0&&l<u.length);const c=u[l];if(o===ce.UNDECIDED)return c;{const n=(o===ce.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,h=n.alpha,S=new Ke(c);return new Ke((1-h)*S.red+h*n.red,(1-h)*S.green+h*n.green,(1-h)*S.blue+h*n.blue).toCSS()}}static toShape(e){const o=new N;for(const r of e)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class ss extends T{constructor(t,e,o,r){let s=[];try{let u=new N;for(const c of t.faces)u.polygon(c.vertices.map(d=>d.viewCoordinates));if(t.faceColor.colorState===ce.OUTSIDE)try{const c=N.polygon(e.outerBoundary.map(h=>h.start.viewCoordinates)),n=Be.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(c);u=u.bounds.isValid()?u.shapeUnion(n):n}catch(c){console.error(c)}const l=new Y(u.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(l)}catch(u){console.error(u)}super({children:s}),this.selectedFaceColorHighlight=t}}class ne extends T{static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,u=o.minus(r),l=s.minus(r),c=u.normalized(),n=l.normalized().minus(c).angle+Math.PI/2,h=t.face?t.face.viewCoordinates:K.createPolar(e,n).plus(r),S=o.average(r),p=s.average(r);return N.polygon([S,r,p,h]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,u=o.minus(r),l=s.minus(r),c=u.normalized(),d=u.angle;let n=l.angle;return n<d&&(n+=2*Math.PI),new N().moveToPoint(r).lineToPoint(c.timesScalar(e).plus(r)).arcPoint(r,e,d,n,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===b.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===b.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===b.NOT_ONE?e.theme.sectorNotOneColorProperty:t===b.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}}m(ne,"nameMap",new Map([[b.NONE,"Invalid"],[b.ONLY_ZERO,"No Lines"],[b.ONLY_ONE,"Only One Line"],[b.ONLY_TWO,"Both Lines"],[b.NOT_ZERO,"At Least One Line"],[b.NOT_ONE,"Zero or Two Lines"],[b.NOT_TWO,"Less Than Two Lines"],[b.ANY,"Any Lines"]]));class is extends T{constructor(t,e,o,r){const s=[],u=[],l=t.sector,c=t.currentState,d=ne.getSectorArcShape(l,.5),n=new Y(d.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(n);const h=[];if(c===b.ANY&&(h.push(b.NOT_ZERO),h.push(b.NOT_ONE),h.push(b.NOT_TWO)),c.one&&c!==b.ONLY_ONE&&h.push(b.ONLY_ONE),h.length){const S=h.map(g=>{const w=ne.getStrokeFromStyle(g,o);return new io({accessibleName:ne.nameMap.get(g),content:new zt(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(l,g)},buttonAppearanceStrategy:Ro,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});u.push(...S);const p=new Et(new gt({children:S,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});u.push(p);const f=.1;s.push(p),p.centerBottom=n.centerTop.plusXY(0,-.15),p.top<e.top+f&&(p.centerTop=n.centerBottom.plusXY(0,.15)),p.left<e.left+f&&(p.left=e.left+f),p.right>e.right-f&&(p.right=e.right-f)}super({children:s}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{u.forEach(S=>S.dispose())})}}class as extends T{constructor(t,e,o,r){const s=new Y(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),u=new Y(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),l=new Y(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,u,l],pickable:!1});const c=t.edges.map(g=>v.BLACK);let d=!1,n=!1,h=!1,S=!1,p=null;const f=le.multilink([e,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(g,w,y,C,P,E,D)=>{if(this.visible=!w,s.visible=y,u.visible=C,l.visible=E,this.visible){let F=!1;for(let k=0;k<t.edges.length;k++){const x=g.getEdgeState(t.edges[k]);x!==c[k]&&(F=!0,c[k]=x)}if(d!==P&&(F=!0,d=P),n!==y&&(F=!0,n=y),h!==C&&(F=!0,h=C),S!==E&&(F=!0,S=E),p!==D&&(F=!0,p=D),F){const k=new N,x=new N,I=new N;for(let H=0;H<t.edges.length;H++){const q=c[H];if(y&&q===v.WHITE){const O=t.edges[H];k.moveTo(O.start.viewCoordinates.x,O.start.viewCoordinates.y),k.lineTo(O.end.viewCoordinates.x,O.end.viewCoordinates.y)}if(q===v.RED){if(C){const O=t.edges[H],R=.07;let V=O.start.viewCoordinates.blend(O.end.viewCoordinates,.5);if(P){const U=O.end.viewCoordinates.minus(O.start.viewCoordinates).getAngle(),X=new K(-R,-R).rotate(U).add(V),$=new K(R,R).rotate(U).add(V),ee=new K(-R,R).rotate(U).add(V),fe=new K(R,-R).rotate(U).add(V);x.moveTo(X.x,X.y),x.lineTo($.x,$.y),x.moveTo(ee.x,ee.y),x.lineTo(fe.x,fe.y)}else x.moveTo(V.x-R,V.y-R),x.lineTo(V.x+R,V.y+R),x.moveTo(V.x-R,V.y+R),x.lineTo(V.x+R,V.y-R)}if(E){const O=t.edges[H],R=.4,V=.017,U=O.start.viewCoordinates.blend(O.end.viewCoordinates,.5),X=U.blend(O.start.viewCoordinates,R),$=U.blend(O.end.viewCoordinates,R);for(let ee=0;ee<5;ee++){const fe=X.blend($,ee/4);I.moveTo(fe.x+V,fe.y),I.arc(fe.x,fe.y,V,0,2*Math.PI,!1)}}}}k.makeImmutable(),x.makeImmutable(),I.makeImmutable(),s.shape=k,u.shape=x,l.shape=I}}});this.disposeEmitter.addListener(()=>f.dispose())}}class Ge extends T{constructor(t,e,o,r){super();const s=new Set;if(r!=null&&r.delayInteractionEmitter){const p=r==null?void 0:r.delayInteractionEmitter,f=g=>{s.add(g),setTimeout(()=>{s.delete(g)},700)};p.addListener(f),this.disposeEmitter.addListener(()=>p.removeListener(f))}const u=new N,l=t.map(p=>{const f=e(p);return f.makeImmutable(),u.subpaths.push(...f.subpaths),f});this.mouseArea=this.touchArea=u.makeImmutable();const c=p=>{const f=p.trail.globalToLocalPoint(p.pointer.point);for(let g=0;g<l.length;g++){const w=l[g];if(w.bounds.containsPoint(f)&&w.containsPoint(f)){const y=t[g];if(!s.has(y))return y}}return null},d=(p,f)=>{const g=c(p);g&&o(g,f)},n=new Pe({mouseButton:0,fire:p=>{var f;return d(p,(f=p.domEvent)!=null&&f.shiftKey?2:0)}}),h=new Pe({mouseButton:2,fire:p=>{var f;return d(p,(f=p.domEvent)!=null&&f.shiftKey?0:2)}}),S=new Pe({mouseButton:1,fire:p=>d(p,1)});this.addInputListener(n),this.addInputListener(h),this.addInputListener(S),this.cursor="pointer",this.disposeEmitter.addListener(()=>{n.dispose(),h.dispose(),S.dispose()})}}class ns extends Ge{constructor(t,e,o){super(t.edges,r=>{const s=r.start.viewCoordinates,u=r.end.viewCoordinates,l=new N;let c;if(r.faces.length===2)c=[s,r.faces[0].viewCoordinates,u,r.faces[1].viewCoordinates];else{L()&&A(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const d=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;L()&&A(d.previous.face===null),L()&&A(d.next.face===null);const n=d.start.viewCoordinates,h=d.end.viewCoordinates,S=d.previous.start.viewCoordinates,p=d.next.end.viewCoordinates,f=(y,C,P)=>{const E=C.minus(y).normalized(),D=P.minus(C).normalized();let F=E.minus(D);return F.getMagnitude()<1e-6?F=E.getPerpendicular():F=F.normalized(),oo.triangleAreaSigned(y,C,C.plus(F))<0&&(F=F.negated()),F},g=f(S,n,h),w=f(n,h,p);c=[n,r.faces[0].viewCoordinates,h,h.plus(w.times(o.backgroundOffsetDistance)),n.plus(g.times(o.backgroundOffsetDistance))]}return l.polygon(c),l.makeImmutable(),l},o.edgePressListener,{delayInteractionEmitter:e})}}const pt=[.02,.02],ye=.2,Le=.02;class ls extends T{constructor(t,e,o){const r=new Y(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(b.NOT_ZERO,o)}),s=new Y(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(b.NOT_ONE,o)}),u=new Y(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(b.NOT_TWO,o)}),l=new Y(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(b.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,u,l]}),this.board=t;const c=t.halfEdges.map(h=>b.NONE),d=t.edges.map(h=>v.BLACK),n=le.multilink([e,o.sectorsVisibleProperty],(h,S)=>{if(S){let p=!1;for(let f=0;f<t.halfEdges.length;f++){const g=h.getSectorState(t.halfEdges[f]);g!==c[f]&&(p=!0,c[f]=g)}for(let f=0;f<t.edges.length;f++){const g=h.getEdgeState(t.edges[f]);g!==d[f]&&(p=!0,d[f]=g)}if(p){const f=new N,g=new N,w=new N,y=new N;for(let C=0;C<t.halfEdges.length;C++){const P=c[C];if(P!==b.NOT_ZERO&&P!==b.NOT_ONE&&P!==b.NOT_TWO&&P!==b.ONLY_ONE)continue;const E=t.halfEdges[C],D=h.getEdgeState(E.edge),F=h.getEdgeState(E.next.edge);if(D!==v.WHITE||F!==v.WHITE)continue;if(P===b.NOT_ONE){const X=E.end.edges.filter(ee=>h.getEdgeState(ee)===v.BLACK),$=E.end.edges.filter(ee=>h.getEdgeState(ee)===v.WHITE);if(X.length===0&&$.length===2)continue}const k=E.start.viewCoordinates,x=E.end.viewCoordinates,I=E.next.end.viewCoordinates,H=k.minus(x),q=I.minus(x),O=H.normalized(),R=H.angle;let V=q.angle;V<R&&(V+=2*Math.PI);const U=(X,$)=>(X.moveToPoint(O.timesScalar($).add(x)),X.arcPoint(x,$,R,V,!0),X);if(P===b.ONLY_ONE)U(y,ye);else if(P===b.NOT_ONE)U(g,ye-Le),U(g,ye+Le);else if(P===b.NOT_ZERO){const X=new N;U(X,ye-Le),U(X,ye+Le);const $=X.getDashedShape(pt,0);f.subpaths.push(...$.subpaths)}else if(P===b.NOT_TWO){const X=new N;U(X,ye);const $=X.getDashedShape(pt,0);w.subpaths.push(...$.subpaths)}}r.shape=f.makeImmutable(),s.shape=g.makeImmutable(),u.shape=w.makeImmutable(),l.shape=y.makeImmutable()}}});this.disposeEmitter.addListener(()=>n.dispose())}}class cs extends Ge{constructor(t,e){super(t.halfEdges,o=>ne.getSectorBaseShape(o,e.backgroundOffsetDistance),e.sectorPressListener)}}class ds extends wt{constructor(t,e){const o=be()({font:Do,fill:ae.uiForegroundColorProperty},e);super(t,o)}}class hs extends T{constructor(t,e,o){super({translation:t.viewCoordinates}),this.face=t;const s=e.value.getFaceState(t),u=s.possibilityCount===0||s.possibilityCount>9;let l;const c=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(u)l=new ds(s.possibilityCount,{font:Ye,maxWidth:.4,maxHeight:.4});else{const d=new Set(t.vertices);l=new Ut({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(n=>{const h=new T,S=new Set(n.map(g=>g.start)),p=new Set(n.map(g=>g.end)),f=g=>g.minus(t.viewCoordinates);if(h.addChild(new Y(N.polygon(t.vertices.map(g=>f(g.viewCoordinates))),{stroke:c,lineWidth:.03,opacity:.2})),S.size){const g=new N;if(n.length===t.edges.length)g.polygon(t.vertices.map(w=>f(w.viewCoordinates)));else{const w=new Set(n);for(;w.size;){const y=[...d].find(E=>[...w].filter(D=>D.start===E||D.end===E).length===1);L()&&A(y);let C=y,P=[...w].find(E=>E.start===C||E.end===C)??null;for(g.moveToPoint(f(C.viewCoordinates));P;)w.delete(P),C=P.getOtherVertex(C),g.lineToPoint(f(C.viewCoordinates)),P=[...w].find(E=>E.start===C||E.end===C)??null}}h.addChild(new Y(g,{stroke:c,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of t.vertices)!S.has(g)&&!p.has(g)&&h.addChild(new yt(.1,{fill:c,translation:f(g.viewCoordinates)}));return h}),maxWidth:.6,maxHeight:.6})}l.center=K.ZERO,this.addChild(l)}}class us extends T{constructor(t,e,o,r){super({pickable:!1});const s=le.multilink([e,r.faceStateVisibleProperty],(l,c)=>{this.children.forEach(d=>d.dispose()),this.children=[],c&&t.faces.forEach(d=>{this.addChild(new hs(d,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const u=l=>{this.visible=!l};o.link(u),this.disposeEmitter.addListener(()=>{o.unlink(u),this.children.forEach(l=>l.dispose())})}}class ps extends Ge{constructor(t,e){super(t.faces,o=>o?N.polygon(o.vertices.map(r=>r.viewCoordinates)):new N,e.facePressListener)}}class fs extends T{constructor(t,e,o,r){super({pickable:!1}),this.board=t;const s=t.faces.map(d=>null),u=()=>{const d=[],n=o.faceValueStyleProperty.value,h=o.theme.faceValueColorProperty.value,S=o.theme.faceValueCompletedColorProperty.value,p=o.theme.faceValueErrorColorProperty.value,f=o.theme.faceValueRatioColorProperty.value,g=o.faceStateVisibleProperty.value,w=dt.value,y=ht.value;this.visible=!g;for(let C=0;C<t.faces.length;C++){const P=s[C];if(P!==null){const E=t.faces[C],D=new jt("",Pt({subScale:.7},r==null?void 0:r.textOptions)),F=le.multilink([e],k=>{let x,I,H=!1,q=!1;if(P===null)x="",I=null;else{let O=0,R=0;for(const V of E.edges){const U=k.getEdgeState(V);U===v.BLACK?O++:U===v.WHITE&&R++}if(n==="static"||P===0)x=`${P}`;else if(n==="remaining")x=`${P-O}`,H=O>0;else if(n==="ratio")P-O===0?x="0":(x=`${P-O}<sub style="color: ${f.toCSS()};">/<sub>${R}</sub></sub>`,q=!0),H=O>0;else throw new Error(`unhandled faceValueStyle: ${n}`);O>P&&y?I=p:O===P&&w?I=S:I=h}D.string=x,D.fill=I,D.maxWidth=q?.8:.9,D.maxHeight=q?.8:.9,D.center=E.viewCoordinates});D.disposeEmitter.addListener(()=>F.dispose()),d.push(D)}}this.children.forEach(C=>C.dispose()),this.children=d},l=le.multilink([e],d=>{let n=!1;for(let h=0;h<t.faces.length;h++){const S=d.getFaceValue(t.faces[h]);S!==s[h]&&(n=!0,s[h]=S)}n&&u()}),c=le.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,dt,ht],u);this.disposeEmitter.addListener(()=>{l.dispose(),c.dispose(),this.children.forEach(d=>d.dispose())})}}class gs extends T{constructor(t,e,o){super({pickable:!1}),this.vertex=t;const r=.12,u=t.edges.map(p=>p.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(p=>p.times(r)),c=N.polygon(ro.grahamScan([K.ZERO,...u],!1)).getOffsetShape(-.05),d=new Y(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),n=new Y(c,{translation:t.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[d,...u.map(p=>new yt({radius:.02,translation:p,fill:o.theme.vertexStatePointProperty}))]});let h=null;const S=le.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(p,f,g)=>{const w=()=>{this.children=[]};if(!f){w();return}const y=p.getVertexState(t);if(!g){let C=!1,P=!1;const E=new Set;for(const F of t.edges){const k=p.getEdgeState(F);C=C||k===v.BLACK,P=P||k===v.WHITE,k===v.WHITE&&E.add(F)}if(C||!P){w();return}if(je.fromLookup(t,(F,k)=>E.has(F)&&E.has(k),!0).equals(y)){w();return}}if(!h||!h.equals(y)){h=y;const C=new N;for(const P of y.getAllowedPairs()){const E=D=>D.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);C.moveToPoint(E(P[0])),C.lineToPoint(E(P[1]))}y.allowsEmpty()&&(C.moveTo(.03,0),C.circle(K.ZERO,.03),C.close()),C.makeImmutable(),d.shape=C}this.children=[n]});this.disposeEmitter.addListener(()=>S.dispose())}}class ws extends T{constructor(t,e,o,r){super({pickable:!1});const s=le.multilink([e,r.vertexStateVisibleProperty],(l,c)=>{this.children.forEach(d=>d.dispose()),this.children=[],c&&t.vertices.forEach(d=>{this.addChild(new gs(d,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const u=l=>{this.visible=!l};o.link(u),this.disposeEmitter.addListener(()=>{o.unlink(u),this.children.forEach(l=>l.dispose())})}}const ys=.03,Ss=.05;class Cs extends Y{constructor(t,e,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=t.edges.map(d=>v.BLACK);let u=r.vertexStyleProperty.value,l=r.smallVertexProperty.value;const c=le.multilink([e,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(d,n,h,S,p)=>{if(this.visible=!n&&h,this.visible){let f=!1;for(let g=0;g<t.edges.length;g++){const w=d.getEdgeState(t.edges[g]);w!==s[g]&&(f=!0,s[g]=w)}if(u!==S&&(u=S,f=!0),l!==p&&(l=p,f=!0),f){const g=new N;for(let w=0;w<t.vertices.length;w++){const y=t.vertices[w];if(y.edges.every(C=>d.getEdgeState(C)!==v.BLACK)){const C=y.viewCoordinates,P=p?ys:Ss;S==="round"?(g.moveTo(C.x+P,C.y),g.arc(C.x,C.y,P,0,2*Math.PI,!1)):S==="square"?g.rect(C.x-P,C.y-P,2*P,2*P):L()&&A(!1,`unhandled vertex style: ${S}`)}}this.shape=g}}});this.disposeEmitter.addListener(()=>c.dispose())}}class ft extends T{constructor(e,o){const r=be()({textOptions:{font:Ye,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},facePressListener:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Fe(null),selectedSectorEditProperty:new Fe(null),style:_,noninteractive:!1,delayEdgeInteractionEmitter:new re},o),s=r.style,u=new T({visibleProperty:s.faceColorsVisibleProperty}),l=new T({pickableProperty:Nr}),c=new T({pickableProperty:kr}),d=new T({pickableProperty:Lr}),n=new T({pickableProperty:Or}),h=new T,S=new T({pickable:!1}),p=new T({pickable:!1}),f=new T({renderer:ho.chromium?"canvas":null,pickable:null}),g=new T({pickable:!1}),w=new T,y=new z([e.stateProperty],F=>{if(F.getWeirdEdges().length||F.hasInvalidFaceColors())return!1;const k=F.getSimpleRegions();return k.length===1&&k[0].isSolved}),C=F=>{F?u.addChild(new rs(e.board,e.stateProperty,s)):u.children.forEach(k=>k.dispose())};s.faceColorsVisibleProperty.link(C),l.addChild(new fs(e.board,e.stateProperty,s,r)),r.noninteractive||l.addChild(new ps(e.board,r)),p.addChild(new us(e.board,e.stateProperty,y,s));const P=new Be(e.board.outerBoundary,e.board.innerBoundaries,s,r);n.addChild(new Cs(e.board,e.stateProperty,y,s)),S.addChild(new ws(e.board,e.stateProperty,y,s)),d.addChild(new as(e.board,e.stateProperty,y,s)),r.noninteractive||d.addChild(new ns(e.board,r.delayEdgeInteractionEmitter,r)),c.addChild(new ls(e.board,e.stateProperty,s)),r.noninteractive||c.addChild(new cs(e.board,r)),h.addChild(new os(e.board,e.stateProperty,s));super(Pt({children:[P,u,l,c,d,n,h,S,p,g,w,f]},r));m(this,"annotationContainer");m(this,"backgroundNode");this.puzzle=e,this.annotationContainer=f;const E=F=>{g.children.forEach(k=>k.dispose()),F&&g.addChild(new ss(F,e.board,s,r))};r.selectedFaceColorHighlightProperty.link(E),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(E));const D=F=>{w.children.forEach(k=>k.dispose()),F&&w.addChild(new is(F,P,s,r))};r.selectedSectorEditProperty.link(D),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(D)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(C),[u,l,d,n,h,S,p,c].forEach(k=>{k.children.forEach(x=>x.dispose()),k.dispose()}),y.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class Hs extends T{constructor(t,e,o){const r=be()({style:_},o),s=e.getEmbeddedCompleteData(t.inputFeatureSet),u=e.getEmbeddedCompleteData(t.outputFeatureSet),l=new ft(new et(e.smallBoard,s),{noninteractive:!0,style:r.style}),c=new ft(new et(e.smallBoard,u),{noninteractive:!0,style:r.style}),d=t.highlander?new T({children:e.getEmbeddedQuestionFaces(t.inputFeatureSet).map(y=>new wt("?",{font:Ye,maxWidth:.9,maxHeight:.9,opacity:.5,fill:t.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:y.viewCoordinates}))}):new T,h=e.tightBounds.dilated(.5),S=.5,p=N.roundRectangle(h.x,h.y,h.width,h.height,S,S),f=new T({children:[l,d],clipArea:p,localBounds:h}),g=new T({children:[c,d],clipArea:p,localBounds:h}),w=new Et(new gt({spacing:.2,children:[f,new Qo(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),g]}),{cornerRadius:S*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[w],super(r),this.rule=t,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{l.dispose(),c.dispose()})}}const ms=(i,t)=>{Ne($o,i,t,!0)};class Se{constructor(t,e,o,r,s,u,l,c,d,n){this.sourcePatternBoard=t,this.boardPatternBoard=e,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=u,this.toSmallEdgeMap=l,this.toSmallSectorMap=c,this.tightBounds=d,this.expandedBounds=n}mapFace(t){const e=this.embedding.mapFace(t),o=this.boardPatternBoard.getFace(e);if(o){const r=this.toSmallFaceMap.get(o);return L()&&A(r),r}else return null}mapEdge(t){return(t.isExit?this.embedding.mapExitEdges(t):[this.embedding.mapNonExitEdge(t)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return L()&&A(s),s})}mapSector(t){const e=this.embedding.mapSector(t),o=this.boardPatternBoard.getSector(e),r=this.toSmallSectorMap.get(o);return L()&&A(r),r}getEmbeddedQuestionFaces(t){const e=new Set;for(const o of t.patternBoard.faces)if(t.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&e.add(r)}return this.smallBoard.faces.filter(o=>!e.has(o))}getEmbeddedCompleteData(t){const e=eo.empty(this.smallBoard);for(const o of t.getFeaturesArray())if(o instanceof er)o.value!==null&&e.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof tr)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.BLACK));else if(o instanceof or)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.RED));else if(o instanceof rr)e.setSectorState(this.mapSector(o.sector),b.NOT_ZERO);else if(o instanceof sr)e.setSectorState(this.mapSector(o.sector),b.NOT_ONE);else if(o instanceof ir)e.setSectorState(this.mapSector(o.sector),b.NOT_TWO);else if(o instanceof ar)e.setSectorState(this.mapSector(o.sector),b.ONLY_ONE);else if(o instanceof nr){const r=(u,l)=>{const c=this.mapFace(u),d=this.mapFace(l),n=c?e.getFaceColor(c):e.getOutsideColor(),h=d?e.getFaceColor(d):e.getOutsideColor();new Ct(ue(e,n),ue(e,h)).apply(e)},s=(u,l)=>{const c=this.mapFace(u),d=this.mapFace(l),n=c?e.getFaceColor(c):e.getOutsideColor(),h=d?e.getFaceColor(d):e.getOutsideColor();new mt(ue(e,n),ue(e,h)).apply(e)};for(let u=1;u<o.primaryFaces.length;u++)r(o.primaryFaces[u-1],o.primaryFaces[u]);for(let u=1;u<o.secondaryFaces.length;u++)r(o.secondaryFaces[u-1],o.secondaryFaces[u]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return ms(this.smallBoard,e),e}static getEmbeddingBounds(t,e,o,r){const s=Me.NOTHING.copy(),u=c=>{s.addPoint(e.getVertex(o.mapVertex(c)).viewCoordinates)};t.vertices.forEach(u);const l=c=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(c))return;const d=e.getFace(o.mapFace(c));d&&d.vertices.forEach(n=>s.addPoint(n.viewCoordinates))};return t.faces.forEach(l),t.edges.forEach(c=>{let d;if(c.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(c))return;d=o.mapExitEdges(c).map(n=>e.getEdge(n))}else d=[e.getEdge(o.mapNonExitEdge(c))];d.forEach(n=>{s.addPoint(n.start.viewCoordinates),s.addPoint(n.end.viewCoordinates)})}),s}static findBestEmbedding(t,e,o){const r=uo(t,e);if(r.length===0)return null;const s=Me.NOTHING.copy();o.vertices.forEach(d=>s.addPoint(d.viewCoordinates));const u=s.center;let l=null,c=Number.POSITIVE_INFINITY;for(let d=0;d<r.length;d++){const n=r[d],S=Se.getEmbeddingBounds(t,e,n).center,p=u.distance(S);p<c&&(c=p,l=n)}return l}static getDisplayEmbedding(t,e,o,r,s){const u=Se.getEmbeddingBounds(t,e,r,s),l=u.dilated(.5),c=o.faces.filter(w=>{const y=Me.NOTHING.copy();return w.vertices.forEach(C=>y.addPoint(C.viewCoordinates)),l.intersectsBounds(y)}),d=o.vertices.filter(w=>w.faces.some(y=>c.includes(y))),n=po({vertices:d.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates})),faces:c.map(w=>({logicalCoordinates:w.logicalCoordinates,vertices:w.vertices.map(y=>({logicalCoordinates:y.logicalCoordinates,viewCoordinates:y.viewCoordinates}))}))}),h=new fo(n),S=1e-6,p=new Map(c.map((w,y)=>{const C=h.faces.find(P=>P.viewCoordinates.equalsEpsilon(w.viewCoordinates,S));return L()&&A(C),[w,C]})),f=new Map(o.edges.map(w=>{const y=h.edges.find(C=>C.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,S)&&C.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,S)||C.start.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,S)&&C.end.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,S))??null;return y?[w,y]:null}).filter(w=>w!==null)),g=new Map(o.halfEdges.map(w=>{const y=h.halfEdges.find(C=>C.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,S)&&C.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,S))??null;return y?[w,y]:null}).filter(w=>w!==null));return L()&&A(r),new Se(t,e,o,r,h,p,f,g,u,l)}static getOptionsForRule(t){const e=t.outputFeatureSet.getAffectedFaces(),o=t.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>e.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(t,e,o){return Se.getDisplayEmbedding(t.patternBoard,e,e.board,o,Se.getOptionsForRule(t))}}export{Ds as A,es as B,Kr as C,_r as D,Hs as E,hs as F,Ws as G,te as H,G as I,B as J,Ue as K,Is as L,br as M,Se as N,zr as O,ft as P,ds as U,gs as V,Os as a,hr as b,ur as c,pr as d,wr as e,_ as f,fr as g,xr as h,Rs as i,Dt as j,Cr as k,mr as l,Pr as m,Er as n,vr as o,Tr as p,Vr as q,lr as r,ms as s,dt as t,ht as u,Fr as v,Bs as w,ts as x,Ns as y,xs as z};
