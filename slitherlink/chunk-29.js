var le=Object.defineProperty;var ce=(l,e,t)=>e in l?le(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var L=(l,e,t)=>ce(l,typeof e!="symbol"?e+"":e,t);import{g as k,o as de,p as he,j as re,A as D,y as fe,z as ge,V as ie,E,m as ue,n as pe,D as Ee,b as we,F as Se,i as Ce,S as me,H as T,I as ye,s as X,C as ve,a as Le}from"./chunk-28.js";import{d as x,e as V,_ as Fe}from"./chunk-20.js";import{k as Ae,P as ee,m as te}from"./chunk-16.js";import{L as H}from"./chunk-27.js";import"./chunk-17.js";import"./chunk-18.js";class qe extends Error{constructor(e){super(e)}}const q=(l,e)=>{if(e.colorState===k.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===k.INSIDE)return{type:"absolute",isOutside:!1};{const t=[...l.getFacesWithColor(e)][0];return x()&&V(t),{type:"face",face:t}}},xe=(l,e)=>{let t=0;for(;l.dirty;){if(t++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const s=l.nextAction();s&&s.apply(e)}},Ve=(l,e)=>{try{xe(l,e)}finally{l.dispose()}},ze=(l,e,t,s,r)=>{const c=l(e,t,r);s(),Ve(c,t)},be=(l,e,t,s)=>{ze(l,e,t,()=>{},s)};class G{constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const t=e.nextAction();if(t)return t}return null}clone(e){return new G(this.solvers.map(t=>t.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class P{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const t=e.getFaceState(this.face);return new P(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:de(this.face),state:this.state.serialize()}}static deserializeAction(e,t){const s=he(e,t.face);return new P(s,re.deserialize(s,t.state))}}class Z{constructor(e,t,s){L(this,"dirtyFaces");L(this,"faceValueListener");L(this,"vertexStateListener");L(this,"faceColorListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceValueListener=(r,c)=>{this.dirtyFaces.add(r)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=r=>{for(const c of r.faces)this.dirtyFaces.add(c)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(r,c,g,h)=>{const w=p=>{this.dirtyFaces.add(p);for(const y of p.edges){const z=y.getOtherFace(p);z&&this.dirtyFaces.add(z)}};for(const p of h)w(p);for(const p of[...r,...g]){const y=this.state.getFacesWithColor(p);for(const z of y)w(z)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const t=this.state.getFaceState(e),s=re.fromVertexAndColorData(e,this.board,this.state).and(t);if(!t.equals(s))return new D(new P(e,s),{type:"FaceState",face:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new Z(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class j{constructor(e,t){this.vertex=e,this.state=t}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const t=e.getVertexState(this.vertex);return new j(this.vertex,t)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:fe(this.vertex),state:this.state.serialize()}}static deserializeAction(e,t){const s=ge(e,t.vertex);return new j(s,ie.deserialize(s,t.state))}}class J{constructor(e,t){L(this,"dirtyVertices",new Set);L(this,"edgeListener");L(this,"sectorListener");L(this,"faceColorListener");this.board=e,this.state=t,e.vertices.forEach(s=>this.dirtyVertices.add(s)),this.edgeListener=(s,r,c)=>{this.dirtyVertices.add(s.start),this.dirtyVertices.add(s.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,r,c)=>{this.dirtyVertices.add(s.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(s,r,c,g)=>{for(const h of g)for(const w of h.vertices)this.dirtyVertices.add(w);for(const h of c){const w=this.state.getFacesWithColor(h);for(const p of w)for(const y of p.vertices)this.dirtyVertices.add(y)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const t=this.state.getVertexState(e),s=ie.fromEdgeColorSectorData(e,this.state).and(t);if(!t.equals(s))return new D(new j(e,s),{type:"VertexState",vertex:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new J(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class Ie{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Q{constructor(e,t){L(this,"hadEdgeAdjusted",!1);L(this,"dirtyEdges",new Set);L(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>this.dirtyEdges.add(s)),this.edgeListener=(s,r,c)=>{this.dirtyEdges.add(s),this.hadEdgeAdjusted=this.hadEdgeAdjusted||c!==E.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var t;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const s=new Map,r=new $(k.OUTSIDE,new Set),c=new $(k.INSIDE,new Set);r.opposite=c,c.opposite=r;const g=new Set([r,c,...this.board.faces.map(n=>{const a=new $(k.UNDECIDED,new Set([n]));return s.set(n,a),a})]);let h=!1;const w=n=>{if(n===null)return r;const a=s.get(n);return x()&&V(a),a},p=(n,a)=>{if(a===r||a===c)return p(a,n);x()&&V(n!==a);for(const i of a.faces)n.faces.add(i),s.set(i,n);return a.faces.clear(),g.delete(a),n},y=(n,a)=>{if(x()&&V(g.has(n)&&g.has(a)),n===a)return;const i=n.opposite,C=a.opposite;if(i&&i===a){h=!0;return}if(C&&C===n){h=!0;return}const A=p(n,a),o=i&&C?p(i,C):i||C;A.opposite=o,o&&(o.opposite=A)},z=(n,a)=>{if(x()&&V(g.has(n)&&g.has(a)),n===a){h=!0;return}if(n.opposite&&n.opposite===a)return;const i=n.opposite,C=a.opposite;if(i&&i===C){h=!0;return}const A=C?p(n,C):n,o=i?p(a,i):a;A.opposite=o,o.opposite=A};for(const n of this.board.edges){if(h)break;const a=this.state.getEdgeState(n);if(a!==E.WHITE){const i=w(n.forwardFace),C=w(n.reversedFace);a===E.BLACK?z(i,C):a===E.RED&&y(i,C)}}if(x()){const n=new Set(this.board.faces);for(const a of g)for(const i of a.faces)n.delete(i);V(n.size===0)}if(h)return new D(new Ie,{type:"InvalidFaceColoring"},this.board);const d=new Set(this.state.getFaceColors()),u=new Set,F=new Map,S=(n,a)=>{x()&&V(d.has(n)),x()&&V(a.faceColor===null),d.delete(n),a.faceColor=n};S(this.state.getOutsideColor(),r),S(this.state.getInsideColor(),c);for(const n of g){if(!n.faceColor){const i=new Set([...n.faces].map(o=>this.state.getFaceColor(o)));let C=null,A=0;for(const o of i){if(!d.has(o))continue;const f=this.state.getFacesWithColor(o);f.some(v=>!n.faces.has(v))||f.length>A&&(C=o,A=f.length)}if(C)S(C,n);else{const o=new ue(pe(),k.UNDECIDED);u.add(o),n.faceColor=o}}const a=n.faceColor;x()&&V(a),n.faces.forEach(i=>{this.state.getFaceColor(i)!==a&&F.set(i,a)})}const m=new Set(d),b=new Map;for(const n of g){const a=n.faceColor,i=((t=n.opposite)==null?void 0:t.faceColor)??null;let C=u.has(a);C||(C=this.state.getOppositeFaceColor(a)!==i),C&&b.set(a,i)}return u.size>0||m.size>0||F.size>0||b.size>0||this.state.hasInvalidFaceColors()?new D(new Ee(this.board,u,m,F,b,!1),{type:"GeneralFaceColoring"},this.board):null}else for(;this.dirtyEdges.size;){const s=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(s);const r=this.state.getEdgeState(s);if(r!==E.WHITE){const c=s.forwardFace?this.state.getFaceColor(s.forwardFace):this.state.getOutsideColor(),g=s.reversedFace?this.state.getFaceColor(s.reversedFace):this.state.getOutsideColor();if(r===E.BLACK){if(this.state.getOppositeFaceColor(c)!==g)return new D(new we(q(this.state,c),q(this.state,g)),{type:"FaceColoringBlackEdge",edge:s},this.board)}else if(r===E.RED&&c!==g)return new D(new Se(q(this.state,c),q(this.state,g)),{type:"FaceColoringRedEdge",edge:s},this.board)}}return null}clone(e){return new Q(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class ${constructor(e,t){L(this,"opposite",null);L(this,"faceColor",null);this.colorState=e,this.faces=t}}class Y{constructor(e,t){L(this,"dirtySectors",new Set);L(this,"edgeListener");this.board=e,this.state=t,e.halfEdges.forEach(s=>this.dirtySectors.add(s)),this.edgeListener=(s,r,c)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,r=this.state.getEdgeState(t),c=this.state.getEdgeState(s),g=this.state.getSectorState(e);let h=g;const w=(r===E.WHITE?1:0)+(c===E.WHITE?1:0),p=(r===E.BLACK?1:0)+(c===E.BLACK?1:0),y=(r===E.RED?1:0)+(c===E.RED?1:0);if(w===0?h=Ce.getOnly(p):w===1&&(p&&h.zero&&(h=h.withDisallowZero()),y&&h.two&&(h=h.withDisallowTwo())),h!==g)return new D(new me(e,h),{type:w===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:g,afterState:h},this.board)}return null}clone(e){return new Y(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const se=()=>Ae.nextInt(Number.MAX_SAFE_INTEGER);class M{constructor(e,t){L(this,"dirtyEdges",new Set);L(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>{this.dirtyEdges.add(s)}),this.edgeListener=(s,r)=>{this.dirtyEdges.add(s)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),t=this.state.getWeirdEdges(),s=new Set,r=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===E.BLACK?s.add(d):r.add(d);const c=new Set,g=new Set,h=new Set(e),w=new Set,p=new Set,y=new Set(t);for(const d of r)y.has(d)&&(y.delete(d),p.add(d));for(const d of s)y.has(d)&&s.delete(d),[...h].some(u=>u.halfEdges.some(F=>F.edge===d))&&s.delete(d);for(const d of e)if(d.halfEdges.some(u=>r.has(u.edge))){const u=[];let F=[];for(const S of d.halfEdges)r.has(S.edge)?F.length>0&&(u.push(F),F=[]):F.push(S);if(F.length>0&&u.push(F),g.add(d),h.delete(d),u.length){if(d.isSolved&&u.length>1){const m=u[0][0],b=u[u.length-1][u[u.length-1].length-1];m.start===b.end&&u[0].unshift(...u.pop())}const S=Fe.maxBy(u,m=>m.length);for(const m of u){const b=new T(m===S?d.id:se(),m);c.add(b),h.add(b)}}}const z=d=>{const u=d.start,F=d.end,S=[...h].find(i=>i.a===u||i.b===u)||null,m=[...h].find(i=>i.a===F||i.b===F)||null,b=u.edges.filter(i=>this.state.getEdgeState(i)===E.BLACK).length,N=F.edges.filter(i=>this.state.getEdgeState(i)===E.BLACK).length;if(b>2||N>2)return!1;const n=i=>{h.add(i),c.add(i)},a=i=>{h.delete(i),c.has(i)?c.delete(i):g.add(i)};if(S&&m)if(S===m)if(M.isSolvedWithAddedEdge(this.board,this.state,S,d))a(S),n(new T(S.id,M.combineHalfEdgeArrays(S.halfEdges,[d.forwardHalf]),!0));else return!1;else{const i=S.halfEdges.length>=m.halfEdges.length?S:m,C=i===S?m:S,A=new T(i.id,M.combineHalfEdgeArrays(i.halfEdges,[d.forwardHalf],C.halfEdges));a(i),a(C),n(A)}else if(S){const i=new T(S.id,M.combineHalfEdgeArrays(S.halfEdges,[d.forwardHalf]));a(S),n(i)}else if(m){const i=new T(m.id,M.combineHalfEdgeArrays(m.halfEdges,[d.forwardHalf]));a(m),n(i)}else{const i=new T(se(),[d.forwardHalf]);n(i)}return!0};for(const d of y)z(d)&&(p.add(d),y.delete(d));for(const d of s)z(d)||(w.add(d),y.add(d));return this.dirtyEdges.clear(),c.size||g.size||w.size||p.size?new D(new ye(this.board,c,g,w,p),{type:"SimpleRegions"},this.board):null}clone(e){return new M(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,t,s,r){if(r.start!==s.a&&r.start!==s.b||r.end!==s.a&&r.end!==s.b)return!1;const c=new Set(s.edges);c.add(r);for(const g of e.faces){const h=t.getFaceValue(g);if(h!==null&&g.edges.filter(p=>c.has(p)).length!==h)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let t=[...e[0]];for(let s=1;s<e.length;s++){const r=e[s];if(r.length!==0)if(t[0].start===r[0].start)t=[...r.map(c=>c.reversed).reverse(),...t];else if(t[0].start===r[r.length-1].end)t=[...r,...t];else if(t[t.length-1].end===r[0].start)t=[...t,...r];else if(t[t.length-1].end===r[r.length-1].end)t=[...t,...r.map(c=>c.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return t}}class _{constructor(e,t){L(this,"hasDirtySimpleRegions",!0);L(this,"simpleRegionListener");this.board=e,this.state=t,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(X(this.state)){const e=this.board.edges.filter(t=>this.state.getEdgeState(t)===E.WHITE);if(e.length)return new D(new ve(e.map(t=>new Le(t,E.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e},this.board)}return this.hasDirtySimpleRegions=!1,null}clone(e){return new _(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}const Re=(l,e,t)=>new G([new M(l,e),new _(l,e),new Q(l,e),new Y(l,e),new J(l,e)]),Oe=(l,e,t)=>new G([Re(l,e),new Z(l,e)]),ne=(l,e)=>{be(Oe,l,e,!0)},oe=(l,e,t)=>{const s=e.clone();for(const r of t)s.setEdgeState(r,E.BLACK);return ne(l,s),{board:l,cleanState:e,solvedState:s,blackEdges:new Set(t)}};class He extends Error{constructor(){super("Too many iterations!")}}class ae extends Error{constructor(e){super("Multiple solutions found"),this.solutionEdges=e}}const Pe=(l,e)=>{try{if(X(e))return{board:l,stateProperty:new ee(e),solution:oe(l,e,[])};const t=e.clone();for(const g of l.edges)t.setEdgeState(g,E.WHITE);const s=De(l,t,{maxIterations:1e4,failOnMultipleSolutions:!0});if(s.length!==1)return null;const r=s[0],c=t.clone();for(const g of r)c.setEdgeState(g,E.BLACK);return ne(l,c),x()&&V(X(c)),{board:l,stateProperty:new ee(e),solution:oe(l,e,r)}}catch(t){if(t instanceof ae)return null;throw t}},De=(l,e,t)=>{const s=l.edges.filter(o=>e.getEdgeState(o)===E.BLACK),r=l.edges.filter(o=>e.getEdgeState(o)===E.WHITE);x()&&V(r.length,"Need to have at least some undefined edges to use solver");const c=new Set(r),g=new Map(r.map((o,f)=>[o,`edge${f+1}`])),h=new Map(r.map((o,f)=>[`edge${f+1}`,o])),w=new H.Solver,p=o=>{const f=g.get(o);return x()&&V(f!==void 0,"Edge not found!"),f},y=o=>`-${p(o)}`,z=o=>{for(const f of o)w.require(H.not(p(f)))},d=o=>{w.require(H.or(...o.map(p)))},u=o=>{w.require(H.or(...o.map(y)))},F=(o,f)=>{f>0&&(d(o),te.forEachCombination(o,v=>{v.length===o.length-f+1&&w.require(H.not(H.and(...v.map(y))))}))},S=(o,f)=>{te.forEachCombination(o,v=>{v.length===f+1&&w.require(H.or(...v.map(y)))})},m=o=>{w.require(H.not(H.exactlyOne(...o.map(p))))},b=o=>{S(o,2),m(o)},N=(o,f)=>{f===0?z(o):(F(o,f),S(o,f))};d(r);for(const o of l.vertices){let f=0,v=0,I=[];for(const B of o.edges){const R=e.getEdgeState(B);R===E.BLACK?f++:R===E.WHITE&&(v++,I.push(B))}v!==0&&(f===0?b(I):f===1?N(I,1):z(I))}let n=!1;for(const o of l.faces){const f=e.getFaceValue(o);if(f===null)continue;n=!0;let v=0,I=0,B=[];for(const W of o.edges){const O=e.getEdgeState(W);O===E.BLACK?v++:O===E.WHITE&&(I++,B.push(W))}if(I===0)continue;const R=Math.max(f-v,0);N(B,R)}x()&&V(n,"No faces with values!");const a=()=>{let o=null;return H.disablingAssertions(()=>{o=w.solve()}),o?o.getTrueVars().map(v=>h.get(v)):null};let i=0;const C=()=>{const o=a();if(o===null)return{touchingValueLoops:[],nonTouchingValueLoops:[]};const f=new Set([...o,...s]),v=[],I=[];for(;f.size;){const B=f.values().next().value,R=[];let W=B.end,O=B,U=!1;for(;O;)f.delete(O),R.push(O),U=U||O.faces.some(K=>e.getFaceValue(K)!==null),O=W.edges.find(K=>f.has(K))??null,O&&(W=O.getOtherVertex(W));x()&&V(R[0].vertices.some(K=>R[R.length-1].vertices.includes(K)),"Loop is not a loop!"),(U?v:I).push(R)}return{touchingValueLoops:v,nonTouchingValueLoops:I}},A=[];for(;;){const o=C();if(!o.touchingValueLoops.length)break;if(o.touchingValueLoops.length===1&&(A.push(o.touchingValueLoops[0]),A.length>1&&t.failOnMultipleSolutions))throw new ae(A);const f=[...o.touchingValueLoops,...o.nonTouchingValueLoops];for(const v of f)u(v.filter(I=>c.has(I)));if(i++,i>t.maxIterations)throw new He}return A};export{G as C,qe as I,ae as M,M as S,j as V,q as a,_ as b,Q as c,oe as d,He as e,ne as f,Pe as g,Re as h,be as i,Z as j,Y as k,J as l,De as s,ze as w};
