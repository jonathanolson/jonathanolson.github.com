var B=Object.defineProperty;var z=(e,l,t)=>l in e?B(e,l,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[l]=t;var F=(e,l,t)=>z(e,typeof l!="symbol"?l+"":l,t);import{T as V,a as C}from"./chunk-16.js";import{N as I,D as x}from"./chunk-17.js";import{d as b,e as D,s as q,ad as R,K as P,P as M,_}from"./chunk-18.js";import{C as g,F as k,B as A}from"./chunk-36.js";import{g as O,a as G,i as L,I as Y}from"./chunk-43.js";import{j as W,S as J,b as H,c as j,d as U,e as K,V as $}from"./chunk-30.js";import{g as Q,a as X,b as Z,c as ee,B as le}from"./chunk-38.js";import{B as s}from"./chunk-39.js";import{B as S}from"./chunk-48.js";import{s as te,i as m}from"./chunk-20.js";import{S as re,b as oe,f as se,d as ce,e as ie,V as ae,g as ne,h as ue,F as fe,i as de,j as Se,k as ge,l as ye,m as ve,s as me}from"./chunk-31.js";import{B as Fe,s as T}from"./chunk-28.js";import{g as Ce}from"./chunk-41.js";import"./chunk-22.js";import"./chunk-27.js";import"./chunk-40.js";import"./chunk-42.js";import"./chunk-47.js";const pe=e=>{const l=e.cleanState.clone();for(const t of e.board.faces)l.getFaceValue(t)===null&&l.setFaceValue(t,t.edges.filter(r=>e.blackEdges.has(r)).length);return W(e.board,l,e.blackEdges)},Te=async(e,l,t,r,o,f)=>{try{const n=l.canSolve,a=async()=>await O(e,t,r),c=async()=>{let u=await a();if(l===g.NO_LIMIT)return u;{const h=e.faces.filter(y=>u.cleanState.getFaceValue(y)===null),p=pe(u);return h.forEach(y=>{r.emit(e.faces.indexOf(y),p.cleanState.getFaceValue(y))}),p}};let i=await c();for(;i.board.faces.some(u=>i.solvedState.getFaceValue(u)===u.edges.length)||!n(i.board,i.cleanState.clone());)f.emit(),i=await c();const d=await G(i,n,t,o);return L(17,t),d}catch(n){if(n instanceof Y)return null;throw n}},w=e=>{if(e.type==="SimpleRegions"||e.type==="CompletingEdgesAfterSolve"||e.type==="GeneralFaceColoring"||e.type==="InvalidFaceColoring"||e.type==="FaceColoringBlackEdge"||e.type==="FaceColoringRedEdge"||e.type==="JointToRed"||e.type==="ForcedLine"||e.type==="AlmostEmptyToRed"||e.type==="FaceSatisfied"||e.type==="FaceAntiSatisfied"||e.type==="FaceColorToBlack"||e.type==="FaceColorToRed"||e.type==="StaticFaceSectors")return 0;if(e.type==="Pattern")return Math.max(0,e.rule.getInputDifficultyScoreB());if(e.type==="ForcedSolveLoop"||e.type==="PrematureForcedLoop")return 5;if(e.type==="DoubleMinusOneFaces")return 5;if(e.type==="FaceColorDisconnection")return 6;if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")return 6;if(e.type==="ForcedSector")return 7;if(e.type==="FaceColorNoTrivialLoop")return 7;if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack")return 9;if(e.type==="FaceColorBalance")return 11;if(e.type==="VertexState"||e.type==="VertexStateToEdge")return 12;if(e.type==="VertexStateToSector"||e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")return 15;if(e.type==="FaceState"||e.type==="FaceStateToEdge"||e.type==="FaceStateToSector"||e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"||e.type==="FaceStateToVertexState")return 20;throw new Error(`unknown annotation type: ${e.type}`)};class Ie{constructor(l,t,r){F(this,"_dirty",!0);F(this,"_action",null);const o=Fe.get(l),f=[...r.solveEdges&&r.solveFaceColors&&r.solveSectors?[Q]:[],...r.solveEdges&&r.solveSectors?[X]:[],...r.solveEdges&&r.solveFaceColors?[Z]:[],...r.solveFaceColors&&!r.solveEdges?[Ce]:[],...r.solveEdges?[ee]:[]],n=[()=>new J(l,t),()=>new H(l,t),...r.solveFaceColors?[()=>new j(l,t)]:[],()=>new re(l,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),()=>new oe(l,t,{solveToRed:!0,solveToBlack:!0}),()=>new se(l,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),...r.solveSectors?[()=>new U(l,t),()=>new ce(l,t),()=>new ie(l,t)]:[],...r.solveVertexState?[()=>new K(l,t),...r.solveEdges?[()=>new ae(l,t,{solveToRed:!0,solveToBlack:!0})]:[],...r.solveSectors?[()=>new ne(l,t)]:[]]:[],...r.solveFaceColors?[()=>new ue(l,t,{solveToRed:!0,solveToBlack:!0}),()=>new fe(l,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),()=>new k(l,t),...r.solveVertexState?[()=>new de(l,t)]:[]]:[],...r.solveFaceState?[...r.solveVertexState||r.solveFaceColors?[()=>new $(l,t)]:[],...r.solveEdges?[()=>new Se(l,t,{solveToRed:!0,solveToBlack:!0})]:[],...r.solveSectors?[()=>new ge(l,t)]:[],...r.solveFaceColors?[()=>new ye(l,t)]:[],...r.solveVertexState?[()=>new ve(l,t)]:[]]:[],...f.map(c=>i=>{const d=c.getRuleCountWithDifficulty(Math.min(r.cutoffDifficulty,i));return console.log("size",d,"of",c.size,"for maxDifficulty",i),A.fromGroup(l,o,t,c,d)})];let a=Number.POSITIVE_INFINITY;for(const c of n){const i=c(a),d=i.nextAction();if(i.dispose(),d){const u=w(d.annotation);if(u<a&&(a=u,this._action=d),a===0)break}}}get dirty(){return this._dirty}nextAction(){return this._dirty?(this._dirty=!1,this._action):null}clone(l){throw new Error("unimplemented")}dispose(){}}const E=16,we=e=>Math.log(e)/Math.log(E),Ee=e=>Math.pow(E,e),v=(e,l,t)=>{l=l.clone();let r=0,o=0;const f=()=>we(r/Math.sqrt(o)+1);for(;;){if(f()>t.cutoffDifficulty)return Number.POSITIVE_INFINITY;const n=new Ie(e,l,t),a=n.nextAction();if(n.dispose(),a){a.apply(l);const c=w(a.annotation);console.log("difficulty",c,a.annotation.type),c>0&&(r+=Ee(c)-1,o+=1)}else break;if(T(l))break}return T(l)?f():Number.POSITIVE_INFINITY},Ne=(e,l)=>e.faces.map(t=>{const r=l.getFaceValue(t);return b()&&D(r===null||r>=0&&r<10,"Invalid face value: "+r),r===null?".":r.toString()}).join(""),he=e=>{const l=v(e.board,e.cleanState,{solveEdges:!0,solveSectors:!0,solveFaceColors:!0,solveVertexState:!0,solveFaceState:!0,cutoffDifficulty:Number.POSITIVE_INFINITY}),t=isFinite(l)?v(e.board,e.cleanState,{solveEdges:!0,solveSectors:!0,solveFaceColors:!0,solveVertexState:!1,solveFaceState:!1,cutoffDifficulty:Number.POSITIVE_INFINITY}):Number.POSITIVE_INFINITY,r=isFinite(t)?v(e.board,e.cleanState,{solveEdges:!0,solveSectors:!1,solveFaceColors:!0,solveVertexState:!1,solveFaceState:!1,cutoffDifficulty:Number.POSITIVE_INFINITY}):Number.POSITIVE_INFINITY,o=isFinite(r)?v(e.board,e.cleanState,{solveEdges:!0,solveSectors:!1,solveFaceColors:!1,solveVertexState:!1,solveFaceState:!1,cutoffDifficulty:Number.POSITIVE_INFINITY}):Number.POSITIVE_INFINITY;return{board:me(e.board),faceData:Ne(e.board,e.cleanState),edgeDifficulty:o,edgeColorDifficulty:r,edgeColorSectorDifficulty:t,fullDifficulty:l}},Be=new I,ze=new I({renderer:"svg",children:[Be]}),N=new x(ze,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(N.domElement);N.setWidthHeight(self.innerWidth,self.innerHeight);self.standardSquareBoardGenerations=q;self.getSerializedPatternBoardLibraryJS=()=>{const e=R();return JSON.stringify(P(JSON.stringify(e)))};self.getSequenceName=e=>S.getName(e);self.getEmptySequence=e=>S.empty(e).serialize();self.getSequenceStatus=e=>S.deserialize(e).getStatusString();self.getNextBoardInSequence=e=>{const t=S.deserialize(e).getNextBoard();return t?te(t):null};self.getSequenceWithProcessingBoard=(e,l)=>{const t=S.deserialize(e),r=m(l);return t.addProcessingBoard(r),t.serialize()};self.getSequenceWithoutProcessingBoard=(e,l)=>{const t=S.deserialize(e),r=m(l);return t.removeProcessingBoard(r),t.serialize()};self.getSequenceWithCollection=(e,l,t)=>{const r=S.deserialize(e),o=m(l),f=s.deserialize(t);return r.addProcessedBoardCollection(o,f),r.serialize()};self.getCollectionForSequence=(e,l)=>{const t=S.deserialize(e),r=m(l);return t.getCollectionForBoard(r).serialize()};self.withCollection=(e,l)=>{const t=s.deserialize(e),r=s.deserialize(l);return t.withCollection(r).serialize()};self.withCollectionNonequal=(e,l)=>{const t=s.deserialize(e),r=s.deserialize(l);return t.withCollectionNonequal(r).serialize()};self.withCollectionNonredundant=(e,l)=>{const t=s.deserialize(e),r=s.deserialize(l);return t.withCollectionNonredundant(r).serialize()};self.withoutCollectionNonequal=(e,l)=>{const t=s.deserialize(e),r=s.deserialize(l);return t.withoutCollectionNonequal(r).serialize()};self.withoutCollectionNonredundant=(e,l)=>{const t=s.deserialize(e),r=s.deserialize(l);return t.withoutCollectionNonredundant(r).serialize()};self.collectionsToSortedMixedGroup=(e,l)=>{const t=e?s.deserialize(e):null,r=l?s.deserialize(l):null;console.log("main count",t?t.size:0),console.log("highlander count",r?r.size:0);const o=le.fromCollections(t,r);return console.log("rule count",o.size),o.sortedDefault().serialize()};self.getMinimizedRatedPuzzle=async e=>{const l=M.fromShortName(e);let t=null;const r=_.sample([g.EASY,g.MEDIUM,g.HARD,g.VERY_HARD,g.NO_LIMIT]);try{for(;!t;)t=await Te(l,r,new V(!1),new C,new C,new C);return he(t)}catch{return null}};
