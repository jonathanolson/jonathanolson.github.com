var Y=Object.defineProperty;var _=(e,t,s)=>t in e?Y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var P=(e,t,s)=>(_(e,typeof t!="symbol"?t+"":t,s),s);import{e as w,f as v,_ as V,j as ee,H as te}from"./getCoordinateClusteredMap-Bd_wM-c0.js";import{V as E}from"./UnivariatePolynomial-1rLpyqfN.js";import{c as se,P as z,g as C,t as ne,h as re,r as ae,s as ie,i as oe,k as ce,l as de,q as ge,x as le,z as ue,A as xe}from"./getPeriodicTilingGenerator-zRiID_iR.js";const I=new WeakMap,b=(e,t)=>{w()&&v(e),w()&&v(t);let s=I.get(e)??null;s||(s=new WeakMap,I.set(e,s));let i=s.get(t)??null;return i||(i=se(e,t),s.set(t,i)),i},he=(e,t)=>{if(e.numNonExitVertices!==t.numNonExitVertices||e.numExitVertices!==t.numExitVertices||e.type!==t.type)return!1;if(e.type==="faces"&&t.type==="faces"){if(e.vertexLists.length!==t.vertexLists.length)return!1;for(let s=0;s<e.vertexLists.length;s++){if(e.vertexLists[s].length!==t.vertexLists[s].length)return!1;for(let i=0;i<e.vertexLists[s].length;i++)if(e.vertexLists[s][i]!==t.vertexLists[s][i])return!1}}if(e.type==="non-exit-vertex"&&t.type==="non-exit-vertex"&&e.edgeCount!==t.edgeCount)return!1;if(e.type==="exit-vertex"&&t.type==="exit-vertex"){if(e.edgeCount!==t.edgeCount||e.spans.length!==t.spans.length)return!1;for(let s=0;s<e.spans.length;s++)if(e.spans[s]!==t.spans[s])return!1}return!0},fe=e=>{const t=[];t.push(e.numNonExitVertices),t.push(e.numExitVertices),t.push(e.type),e.type==="faces"?t.push(e.vertexLists):(e.type==="non-exit-vertex"||e.type==="exit-vertex")&&(t.push(e.edgeCount),e.type==="exit-vertex"&&t.push(e.spans));const s=JSON.stringify(t);return w()&&v(he(J(s),e)),s},J=e=>{const t=JSON.parse(e),s=t.shift(),i=t.shift(),g=t.shift();return g==="faces"?{numNonExitVertices:s,numExitVertices:i,type:g,vertexLists:t.shift()}:g==="non-exit-vertex"?{numNonExitVertices:s,numExitVertices:i,type:g,edgeCount:t.shift()}:g==="exit-vertex"?{numNonExitVertices:s,numExitVertices:i,type:g,edgeCount:t.shift(),spans:t.shift()}:{numNonExitVertices:s,numExitVertices:i,type:g}};class j{constructor(t,s){P(this,"exitEdge",null);P(this,"edges",[]);P(this,"sectors",[]);P(this,"faces",[]);this.index=t,this.isExit=s}}class q{constructor(t,s,i=null){P(this,"vertices");P(this,"sectors",[]);P(this,"faces",[]);this.index=t,this.isExit=s,this.exitVertex=i,this.vertices=i?[i]:[]}}class R{constructor(t,s,i){P(this,"face");this.index=t,this.vertex=s,this.edges=i}}class G{constructor(t,s,i,g,u){this.index=t,this.isExit=s,this.vertices=i,this.edges=g,this.sectors=u}}class M{constructor(t,s){P(this,"name");P(this,"vertices");P(this,"edges");P(this,"sectors");P(this,"faces");this.descriptor=t;const i=[...V.range(0,t.numNonExitVertices).map(r=>new j(r,!1)),...V.range(0,t.numExitVertices).map(r=>new j(r+t.numNonExitVertices,!0))];let g=[],u=[],l=[];if(t.type==="faces"){for(const r of t.vertexLists){const n=r.map(d=>i[d]),a=n.map((d,f)=>{const o=n[(f+1)%n.length],x=d.edges.find(p=>p.vertices.includes(o));if(x)return x;{const p=new q(g.length,!1),N=d.index<o.index?d:o,y=d.index<o.index?o:d;return p.vertices.push(N),p.vertices.push(y),g.push(p),d.edges.push(p),o.edges.push(p),p}}),c=a.map((d,f)=>{const o=a[(f+1)%a.length],x=d.vertices.find(N=>o.vertices.includes(N));w()&&v(x);const p=new R(u.length,x,[d,o]);return u.push(p),d.sectors.push(p),o.sectors.push(p),x.sectors.push(p),p}),h=new G(l.length,!1,n,a,c);l.push(h),n.forEach(d=>{d.faces.push(h)}),c.forEach(d=>{d.face=h}),a.forEach(d=>{d.faces.push(h)})}g.forEach(r=>{if(r.faces.length<2){w()&&v(r.faces.length===1);const n=new G(l.length,!0,r.vertices,[r],[]);l.push(n),r.faces.push(n),r.vertices.forEach(a=>{a.faces.push(n)})}}),i.forEach(r=>{if(r.isExit){const n=new q(g.length,!0,r);g.push(n),r.edges.push(n),r.exitEdge=n}})}else if(t.type==="edge"){w()&&v(i.length===0);const r=new q(0,!1,null);g.push(r);const n=new G(0,!0,[],[r],[]);l.push(n);const a=new G(1,!0,[],[r],[]);l.push(a),r.faces.push(n),r.faces.push(a)}else if(t.type==="non-exit-vertex"){w()&&v(i.length===1&&!i[0].isExit);const r=i[0];g.push(...V.range(0,t.edgeCount).map(n=>{const a=new q(n,!1);return r.edges.push(a),a.vertices.push(r),a})),u.push(...V.range(0,t.edgeCount).map(n=>{const a=new R(n,r,[g[n],g[(n+1)%t.edgeCount]]);return a.edges.forEach(c=>{c.sectors.push(a)}),r.sectors.push(a),a})),l.push(...V.range(0,t.edgeCount).map(n=>{const a=u[n],c=new G(n,!0,[r],[g[n],g[(n+1)%t.edgeCount]],[a]);return r.faces.push(c),c.edges.forEach(h=>{h.faces.push(c)}),a.face=c,c}))}else if(t.type==="exit-vertex"){w()&&v(i.length===1&&i[0].isExit);const r=i[0];g.push(...V.range(0,t.edgeCount).map(a=>{const c=new q(a,!1);return r.edges.push(c),c.vertices.push(r),c}));const n=new q(g.length,!0,r);if(g.push(n),r.edges.push(n),r.exitEdge=n,t.spans.length){const a=[];let c=0;t.spans.forEach((h,d)=>{const f=c,o=f+h;c=o+1,a.push(V.range(f,o+1).map(x=>g[x]))}),w()&&v(c===t.edgeCount),a.forEach(h=>{for(let d=0;d<h.length-1;d++){const f=h[d],o=h[d+1],x=new R(u.length,r,[f,o]);u.push(x),f.sectors.push(x),o.sectors.push(x),r.sectors.push(x);const p=new G(l.length,!0,[r],[f,o],[x]);l.push(p),r.faces.push(p),f.faces.push(p),o.faces.push(p),x.face=p}}),a.forEach(h=>{const d=h[0],f=h[h.length-1],o=new G(l.length,!0,[r],[d],[]);l.push(o),d.faces.push(o),r.faces.push(o);const x=new G(l.length,!0,[r],[f],[]);l.push(x),f.faces.push(x),r.faces.push(x)})}else{w()&&v(t.edgeCount===2);const a=g[0],c=g[1],h=new G(l.length,!0,[r],[a],[]);l.push(h),a.faces.push(h),r.faces.push(h);const d=new G(l.length,!0,[r],[a],[]);l.push(d),a.faces.push(d),r.faces.push(d);const f=new G(l.length,!0,[r],[c],[]);l.push(f),c.faces.push(f),r.faces.push(f);const o=new G(l.length,!0,[r],[c],[]);l.push(o),c.faces.push(o),r.faces.push(o)}}else throw new Error(`Invalid descriptor: ${t}`);this.vertices=i,this.edges=g,this.sectors=u,this.faces=l,s&&(this.name=s)}serialize(){return fe(this.descriptor)}static deserialize(t){return new M(J(t))}}const pe=new WeakMap,O=.3,ve=e=>(w()&&v(e.vertices.length===0),w()&&v(e.sectors.length===0),w()&&v(e.faces.length===2),w()&&v(e.edges.length===1),{vertexMap:new Map,edgeMap:new Map([[e.edges[0],[new E(0,0),new E(1,0)]]]),sectorMap:new Map,faceMap:new Map([[e.faces[0],[new E(0,0),new E(1,0),new E(.5,O)]],[e.faces[1],[new E(0,0),new E(.5,-O),new E(1,0)]]])}),Z=e=>{w()&&v(e.vertices.length===1);const t=e.edges.filter(n=>!n.isExit),s=t.length,i=s===2&&e.sectors.length?3:s,g=new Map([[e.vertices[0],E.ZERO]]),u=new Map;e.edges.forEach((n,a)=>{u.set(n,[E.ZERO,E.createPolar(1,2*Math.PI*a/i)])});const l=new Map;e.sectors.forEach(n=>{const a=n.edges[0],c=n.edges[1];(a.index+1)%s!==c.index?l.set(n,[u.get(a)[1],E.ZERO,u.get(c)[1]]):l.set(n,[u.get(c)[1],E.ZERO,u.get(a)[1]])});const r=new Map;return s===2&&e.sectors.length===0?(t[0].faces.forEach((n,a)=>{r.set(n,a===0?[new E(0,0),new E(1,0),new E(.5,O)]:[new E(0,0),new E(.5,-O),new E(1,0)])}),t[1].faces.forEach((n,a)=>{r.set(n,a===0?[new E(0,0),new E(-.5,O),new E(-1,0)]:[new E(0,0),new E(-1,0),new E(-.5,-O)])})):(e.sectors.forEach((n,a)=>{const c=l.get(n).slice();a===1&&s===2&&(c[1]=c[0].plus(c[2]).negated()),r.set(n.face,c)}),e.faces.forEach(n=>{if(!r.has(n)){w()&&v(n.edges.length===1);const a=n.edges[0],c=u.get(a);w()&&v(a.sectors.length===1);const h=a.sectors[0];{const d=c[1].perpendicular;let f=0;l.get(h).forEach(x=>f+=x.dot(d));const o=c[1].timesScalar(.5);r.set(n,[c[1],E.ZERO,o.plus(d.times(-Math.sign(f)*.5*Math.sin(2*Math.PI/3/s)))])}}})),{vertexMap:g,edgeMap:u,sectorMap:l,faceMap:r}},ht=e=>{if(w()){const n=a=>{v(a.every(c=>c.index<a.length))};n([...e.vertexMap.keys()]),n([...e.edgeMap.keys()]),n([...e.sectorMap.keys()]),n([...e.faceMap.keys()])}const t=V.sortBy([...e.vertexMap.keys()],n=>n.index),s=V.sortBy([...e.edgeMap.keys()],n=>n.index),i=V.sortBy([...e.sectorMap.keys()],n=>n.index),g=V.sortBy([...e.faceMap.keys()],n=>n.index),u=n=>[n.x,n.y],l=n=>{for(let a=0;a<t.length;a++)if(e.vertexMap.get(t[a]).equals(n))return a;return u(n)},r=JSON.stringify([t.map(n=>u(e.vertexMap.get(n))),s.map(n=>e.edgeMap.get(n).map(l)),i.map(n=>e.sectorMap.get(n).map(u)),g.map(n=>e.faceMap.get(n).map(u))]);if(w()){const n=Ee(r,{vertices:t,edges:s,sectors:i,faces:g,descriptor:{}}),a=(c,h)=>{if(c.length!==h.length)return!1;for(let d=0;d<c.length;d++)if(!c[d].equals(h[d]))return!1;return!0};t.forEach(c=>v(e.vertexMap.get(c).equals(n.vertexMap.get(c)))),s.forEach(c=>v(a(e.edgeMap.get(c),n.edgeMap.get(c)))),i.forEach(c=>v(a(e.sectorMap.get(c),n.sectorMap.get(c)))),g.forEach(c=>v(a(e.faceMap.get(c),n.faceMap.get(c))))}return r},Ee=(e,t)=>{const s=JSON.parse(e),i=s[0],g=s[1],u=s[2],l=s[3],r=new Map,n=new Map,a=new Map,c=new Map;i.forEach((d,f)=>{r.set(t.vertices[f],new E(d[0],d[1]))});const h=d=>typeof d=="number"?r.get(t.vertices[d]):new E(d[0],d[1]);return g.forEach((d,f)=>{n.set(t.edges[f],[h(d[0]),h(d[1])])}),u.forEach((d,f)=>{a.set(t.sectors[f],[h(d[0]),h(d[1]),h(d[2])])}),l.forEach((d,f)=>{c.set(t.faces[f],d.map(o=>new E(o[0],o[1])))}),{vertexMap:r,edgeMap:n,sectorMap:a,faceMap:c}},$=(e,t)=>e.vertices.length!==t.vertices.length||e.edges.length!==t.edges.length||e.faces.length!==t.faces.length||e.sectors.length!==t.sectors.length||e.vertices.filter(s=>s.isExit).length!==t.vertices.filter(s=>s.isExit).length||e.edges.filter(s=>s.isExit).length!==t.edges.filter(s=>s.isExit).length||e.faces.filter(s=>s.isExit).length!==t.faces.filter(s=>s.isExit).length?!1:b(e,t).length>0&&b(t,e).length>0,we=(e,t)=>{if(e.forwardHalf.next.edge===t)return e.forwardHalf;if(e.reversedHalf.next.edge===t)return e.reversedHalf;if(t.forwardHalf.next.edge===e)return t.forwardHalf;if(t.reversedHalf.next.edge===e)return t.reversedHalf;throw new Error("Edges are not connected")};class m extends M{constructor(s,i){const g=new Set,u=new Set;i.forEach(o=>{o.vertices.forEach(x=>{g.add(x)}),o.edges.forEach(x=>{u.add(x)})});const l=Array.from(u),r=[],n=[];for(const o of g)o.faces.every(x=>i.includes(x))?n.push(o):r.push(o);const a=[...n,...r];super({numNonExitVertices:n.length,numExitVertices:r.length,type:"faces",vertexLists:i.map(o=>o.vertices.map(x=>a.indexOf(x)))});P(this,"patternBoard");P(this,"planarPatternMap");this.originalBoard=s,this.originalBoardFaces=i;const c=new Map(a.map((o,x)=>[this.vertices[x],o.viewCoordinates])),h=new Map;this.edges.forEach(o=>{if(!o.isExit){const x=a[o.vertices[0].index],p=a[o.vertices[1].index];h.set(o,[x.viewCoordinates,p.viewCoordinates])}});const d=new Map;this.sectors.forEach(o=>{w()&&v(o.edges.length===2);const x=a[o.edges[0].vertices[0].index],p=a[o.edges[0].vertices[1].index],N=a[o.edges[1].vertices[0].index],y=a[o.edges[1].vertices[1].index],T=l.find(A=>A.vertices.includes(x)&&A.vertices.includes(p)),D=l.find(A=>A.vertices.includes(N)&&A.vertices.includes(y));w()&&v(T&&D);const F=we(T,D);w()&&v(F);const K=F.start.viewCoordinates,Q=F.end.viewCoordinates,X=F.next.end.viewCoordinates;d.set(o,[K,Q,X])});const f=new Map;this.faces.forEach(o=>{if(!o.isExit){const x=o.vertices.map(y=>a[y.index]),p=i.find(y=>y.vertices.every(T=>x.includes(T)));w()&&v(p);const N=p.vertices.map(y=>y.viewCoordinates);f.set(o,N)}}),this.faces.forEach(o=>{if(o.isExit){w()&&v(o.edges.length===1);const x=o.edges[0],p=a[x.vertices[0].index],N=a[x.vertices[1].index];w()&&v(p&&N);const y=l.find(F=>F.vertices.includes(p)&&F.vertices.includes(N));w()&&v(y);const T=i.includes(y.faces[0])?y.faces[1]:y.faces[0];w()&&v(T,"Did we hit null as in --- edge of board? can we expand the search pattern?");const D=[p.viewCoordinates,N.viewCoordinates,p.viewCoordinates.average(N.viewCoordinates).average(T.viewCoordinates)];f.set(o,D)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:c,edgeMap:h,sectorMap:d,faceMap:f}}static getSemiAdjacentFaces(s,i){const g=new Set;return i.vertices.forEach(u=>{u.faces.forEach(l=>{l!==i&&g.add(l)})}),g}static getFirstGeneration(s){const i=V.uniq(s.faces.map(u=>u.vertices.length)),g=s.vertices.map(u=>u.viewCoordinates).reduce((u,l)=>u.plus(l)).timesScalar(1/s.vertices.length);return i.map(u=>{const l=V.minBy(s.faces.filter(r=>r.vertices.length===u),r=>r.viewCoordinates.distanceSquared(g));return w()&&v(l),new m(s,[l])})}static getNextGeneration(s){const i=[];return s.forEach(g=>{const u=new Set;g.originalBoardFaces.forEach(l=>{m.getSemiAdjacentFaces(g.originalBoard,l).forEach(r=>{g.originalBoardFaces.includes(r)||u.add(r)})}),u.forEach(l=>{const r=[...g.originalBoardFaces,l],n=new m(g.originalBoard,r);i.some(a=>$(a,n))||i.push(n)})}),i}static getFirstNGenerations(s,i){const u=[m.getFirstGeneration(s)];for(let l=0;l<i-1;l++)u.push(m.getNextGeneration(u[u.length-1]));return u}static getUniformTilingGenerations(s,i){const g=s.generate({width:15,height:15}),u=new z(g,s.scale??1);return m.getFirstNGenerations(u,i)}}const k=new M({numNonExitVertices:0,numExitVertices:0,type:"edge"},"single-edge"),me=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]},"vertex-2-exit-none"),Me=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]},"vertex-2-exit-one"),Pe=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]},"vertex-3-exit-two-adjacent"),ye=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]},"vertex-4-exit-two-opposite"),Ve=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]},"vertex-4-exit-three-adjacent"),Be=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[2,1]},"vertex-5-exit-two-one"),Ne=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[4]},"vertex-5-exit-four"),Ge=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[1,1,1]},"vertex-6-exit-triple"),Ce=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[2,2]},"vertex-6-exit-two-two"),Se=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[3,1]},"vertex-6-exit-three-one"),Te=new M({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[5]},"vertex-6-exit-five"),Fe=new M({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2},"vertex-2"),qe=new M({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3},"vertex-3"),Oe=new M({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4},"vertex-4"),Ae=new M({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:5},"vertex-5"),De=new M({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:6},"vertex-6"),W=[me,Me,Pe,ye,Ve,Be,Ne,Ge,Ce,Se,Te],U=[Fe,qe,Oe,Ae,De],ft=[k,...W,...U],S=e=>{const t=e.generate({width:20,height:20});return new z(t,e.scale??1)},L=[],Le=e=>L.find(t=>V.isEqual(t.descriptor,e))??null,He=e=>{const t=Le(e.descriptor);return t||(L.find(s=>$(e,s))??null)},pt=e=>L.find(t=>t.name===e)??null,H=(e,t)=>{const s=He(e);return s||(L.push(e),pe.set(e,t),e)},B=(e,t)=>t.map((s,i)=>s.map((g,u)=>(g.name=`${e}-${i}-${u}`,H(g,g.planarPatternMap))));H(k,ve(k));W.forEach(e=>H(e,Z(e)));U.forEach(e=>H(e,Z(e)));const Re=S(C(ne)),ke=new ee(20,20),Ie=S(C(re)),be=new te(10,1,!0),je=S(C(ae)),ze=S(C(ie)),Je=S(C(oe)),Ze=S(C(ce)),$e=S(C(de)),We=S(C(ge)),Ue=S(C(le)),Ke=S(C(ue)),Qe=S(C(xe)),Xe=e=>m.getFirstNGenerations(Re,e),Ye=e=>m.getFirstNGenerations(ke,e),_e=e=>m.getFirstNGenerations(Ie,e),et=e=>m.getFirstNGenerations(be,e),tt=e=>m.getFirstNGenerations(je,e),st=e=>m.getFirstNGenerations(ze,e),nt=e=>m.getFirstNGenerations(Je,e),rt=e=>m.getFirstNGenerations(Ze,e),at=e=>m.getFirstNGenerations($e,e),it=e=>m.getFirstNGenerations(We,e),ot=e=>m.getFirstNGenerations(Ue,e),ct=e=>m.getFirstNGenerations(Ke,e),dt=e=>m.getFirstNGenerations(Qe,e),vt=B("square",Ye(5)),Et=B("hexagonal",et(4)),wt=B("triangular",Xe(4)),mt=B("cairo",_e(4)),Mt=B("rhombille",tt(4)),Pt=B("snub-square",st(3)),yt=B("trihexagonal",nt(3)),Vt=B("floret-pentagonal",rt(3)),Bt=B("deltoidal-trihexagonal",at(3)),Nt=B("portugal",it(3)),Gt=B("rhombitrihexagonal",ot(3)),Ct=B("prismatic-pentagonal",ct(3)),St=B("elongated-triangular",dt(3));export{ht as A,M as B,J as C,Ee as D,k as E,m as F,me as G,Me as H,Pe as I,ye as J,Ve as K,Fe as L,qe as M,Oe as N,pt as O,Le as P,Vt as Q,Bt as R,Nt as S,Gt as T,Ct as U,St as V,be as a,Ie as b,Re as c,je as d,ze as e,Je as f,Ze as g,$e as h,We as i,Ue as j,Ke as k,Qe as l,fe as m,ft as n,$ as o,pe as p,b as q,we as r,ke as s,vt as t,wt as u,Et as v,Mt as w,mt as x,Pt as y,yt as z};
