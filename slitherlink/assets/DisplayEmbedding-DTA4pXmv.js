var jt=Object.defineProperty;var Gt=(i,t,e)=>t in i?jt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var C=(i,t,e)=>(Gt(i,typeof t!="symbol"?t+"":t,e),e);import{d as U,h as W,B as ve,F as Ve,N as b,P as G,L as Xt,o as Qe,R as qt,H as mt,M as de,T as Pt,G as Kt,C as Et,p as Jt}from"./PhetioControlledVisibilityProperty-Bd0APyjs.js";import{E as v,F as N,S as T,V as Ke,d as vt,e as _t,f as Zt,g as et,h as tt,i as $t,j as Qt,k as eo,l as to,U as Ye,m as ot,n as Ft,o as Vt,p as rt,q as oo,s as ro,r as st,t as so,B as it,C as io}from"./BasicPuzzle-BMlBNSWn.js";import{T as n,P as Ae,E as Te,e as be,o as Ne,f as ie,l as ao,V as _,k as Re,D as no,c as Tt,C as lo,B as je}from"./UnivariatePolynomial-CzQEP6td.js";import{b as co,L as he,a as bt,c as ho,P as Lt}from"./TextPushButton-7XBbkz6j.js";import{i as at,S as I,L as nt,_ as Be,ac as uo,e as L,f as k,m as po,H as fo,ad as go,ae as kt,k as wo,o as yo,l as So,d as Co}from"./patternBoards-DKw4bfen.js";import{Q as mo,R as Po,S as Eo,T as vo,f as Fo,g as Vo,h as lt,K as To,s as ct,i as bo,j as Lo,v as dt,k as ko,m as ht,w as Ao,n as ae,q as No,x as Oo,y as Io,z as xo,J as ne,H as Do,F as Ro,B as Bo,D as Wo,c as le,U as Ho,r as Mo,u as zo,V as Je}from"./Theme-B6xro5rz.js";import{S as At,J as Nt,K as Ot,L as It,N as xt,V as Dt,O as ye,P as Uo,A as Yo,B as jo,Q as Rt,R as Bt,T as Wt,U as Me,W as Ht,I as Q,X as Go,Y as Xo,Z as qo,_ as Ko,$ as Jo,a0 as _o,a1 as Zo,a2 as $o,a3 as Qo,a4 as er,C as We,z as tr,a5 as ut,a6 as we,F as or,a7 as rr}from"./SATSolver-1D3my44Q.js";import{A as sr}from"./SpinningIndicatorNode-oq9bMnoF.js";import{a as ir,B as ar,R as nr,b as lr,c as cr,d as dr,S as hr,e as ur}from"./PatternRule-BPSy1pyf.js";const Mt=(i,t,e,o)=>(r,s,u)=>{const l=[new At(r,s),new Nt(r,s)];return(i||t||e||o)&&(l.push(new Ot(r,s)),(t||e||o)&&(l.push(new It(r,s)),(e||o)&&(l.push(new xt(r,s)),o&&l.push(new Dt(r,s))))),new ye(l)},pr={allowEdgeEditProperty:mo,allowAbsoluteFaceColorEditProperty:Po,allowFaceColorEditProperty:Eo,allowSectorEditProperty:vo,edgesVisibleProperty:Fo,edgesHaveColorsProperty:Vo,faceColorsVisibleProperty:lt,faceColorThresholdProperty:To,sectorsVisibleProperty:ct,sectorsNextToEdgesVisibleProperty:bo,sectorsTrivialVisibleProperty:Lo,vertexStateVisibleProperty:dt,allVertexStateVisibleProperty:ko,faceStateVisibleProperty:ht,whiteLineVisibleProperty:Ao,redLineVisibleProperty:ae,verticesVisibleProperty:No,smallVertexProperty:Oo,redXsVisibleProperty:Io,redXsAlignedProperty:xo,faceValueStyleProperty:ne,redLineStyleProperty:Do,vertexStyleProperty:Ro,joinedLinesJoinProperty:Bo,joinedLinesCapProperty:Wo,safeSolverFactoryProperty:new U([lt,ct,dt,ht],(i,t,e,o)=>Mt(i,t,e,o)),autoSolverFactoryProperty:Uo,theme:le},ue=(i,t,e,o,r)=>{const s=Mt(i,t,e,o);return{faceColorsVisibleProperty:new ve(i),sectorsVisibleProperty:new ve(t),vertexStateVisibleProperty:new ve(e),faceStateVisibleProperty:new ve(o),safeSolverFactoryProperty:new Ae(s),autoSolverFactoryProperty:r?new U([r],u=>(l,c,d)=>new ye([s(l,c,d),u(l,c,d)])):new Ae(s)}},Ce=new U([Yo,jo],(i,t)=>(e,o,r)=>new ye([new Rt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:i,solveAlmostEmptyToRed:!0},r?void 0:[]),new Bt(e,o,{solveToRed:!0,solveToBlack:i},r?void 0:[]),...t?[new Wt(e,o,{solveToRed:!0,solveToBlack:i,resolveAllRegions:!1},r?void 0:[])]:[]])),fr=new U([Ce],i=>(t,e,o)=>new ye([i(t,e,o),new Me(t,e,{solveToRed:!0,solveToBlack:!0})])),zt=new U([Ce],i=>(t,e,o)=>new ye([i(t,e,o),new Ht(t,e,o?void 0:[])])),gr=new U([zt],i=>(t,e,o)=>new ye([i(t,e,o),new Me(t,e,{solveToRed:!0,solveToBlack:!0})])),wr=i=>({...ue(!0,!1,!1,!1,Ce),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),yr=i=>({...ue(!0,!1,!1,!1,fr),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Sr=i=>({...ue(!0,!1,!1,!1,new Ae((t,e,o)=>new ye([new Me(t,e,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:i,allowEdgeEditProperty:new n(!1),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!1),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Cr=i=>({...ue(!1,!1,!1,!1,Ce),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),Os=i=>({...ue(!1,!0,!1,!1,Ce),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),mr=i=>({...ue(!0,!0,!1,!1,zt),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Pr=i=>({...ue(!0,!0,!1,!1,gr),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Er=i=>({...ue(!0,!1,!0,!1,Ce),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),vr=i=>({...ue(!0,!1,!1,!0,Ce),theme:i,allowEdgeEditProperty:new n(!0),allowAbsoluteFaceColorEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:ae,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:ne,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Fr=wr(le),Vr=yr(le),Tr=Sr(le),Ut=Cr(le),br=mr(le),Lr=Pr(le),kr=Er(le),Ar=vr(le),Ge={basicLines:Fr,basicFaceColoring:Vr,pureFaceColor:Tr,classic:Ut,basicSectors:br,sectorsWithColors:Lr,vertexState:kr,faceState:Ar,custom:pr},pt=Ut,Nr=i=>({allowEdgeEditProperty:new W(i,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new W(i,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new W(i,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new W(i,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new W(i,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new W(i,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new W(i,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new W(i,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new W(i,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new W(i,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new W(i,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new W(i,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new W(i,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new W(i,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new W(i,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new W(i,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new W(i,{derive:"verticesVisibleProperty"}),smallVertexProperty:new W(i,{derive:"smallVertexProperty"}),redXsVisibleProperty:new W(i,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new W(i,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new W(i,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new W(i,{derive:"redLineStyleProperty"}),vertexStyleProperty:new W(i,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new W(i,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new W(i,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new W(i,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new W(i,{derive:"autoSolverFactoryProperty"}),theme:Ho(new U([i],t=>t.theme))}),Or=new co("puzzleStyle",{serialize:i=>Object.keys(Ge).find(t=>Ge[t]===i),deserialize:i=>i?Ge[i]??pt:pt}),q=Nr(Or),Is=new he("showPuzzleStyleProperty",!0),xs=new he("showPuzzleTimerProperty",!1),M=class M extends Te{constructor(t){super(),this.isEnabledProperty=t}};C(M,"EDGE_STATE",new M(q.allowEdgeEditProperty)),C(M,"EDGE_STATE_REVERSED",new M(q.allowEdgeEditProperty)),C(M,"FACE_COLOR_INSIDE",new M(q.allowAbsoluteFaceColorEditProperty)),C(M,"FACE_COLOR_OUTSIDE",new M(q.allowAbsoluteFaceColorEditProperty)),C(M,"FACE_COLOR_MATCH",new M(q.allowFaceColorEditProperty)),C(M,"FACE_COLOR_OPPOSITE",new M(q.allowFaceColorEditProperty)),C(M,"SECTOR_STATE",new M(q.allowSectorEditProperty)),C(M,"VERTEX_STATE",new M(q.vertexStateVisibleProperty)),C(M,"FACE_STATE",new M(q.faceStateVisibleProperty)),C(M,"FACE_VALUE",new M(new ve(!1))),C(M,"DELETE_FACE",new M(new ve(!1))),C(M,"enumeration",new be(M));let z=M;const J=new bt("editModeProperty",z.EDGE_STATE);z.enumeration.values.forEach(i=>{i.isEnabledProperty.lazyLink(t=>{if(!J.value.isEnabledProperty.value){const e=z.enumeration.values.find(o=>o.isEnabledProperty.value)??null;e&&(J.value=e)}})});const Xe=new he("eraserEnabledProperty",!1),Ds=i=>{i.isEnabledProperty.value&&(J.value=i)},Ir=new U([J],i=>i===z.EDGE_STATE||i===z.EDGE_STATE_REVERSED),_e=new U([J],i=>i===z.FACE_COLOR_MATCH||i===z.FACE_COLOR_OPPOSITE),Rs=_e,xr=new U([J],i=>i===z.FACE_COLOR_OUTSIDE||i===z.FACE_COLOR_INSIDE),Dr=new U([J],i=>i===z.SECTOR_STATE),Rr=new U([J],i=>i===z.VERTEX_STATE),Br=new U([J,_e,xr],(i,t,e)=>t||e||i===z.FACE_STATE||i===z.FACE_VALUE||i===z.DELETE_FACE),Wr=(i,t,e)=>{const o=new Ve({mouseButton:0,fire:u=>{var l;return e&&e(i,(l=u.domEvent)!=null&&l.shiftKey?2:0)}}),r=new Ve({mouseButton:2,fire:u=>{var l;return e&&e(i,(l=u.domEvent)!=null&&l.shiftKey?0:2)}}),s=new Ve({mouseButton:1,fire:u=>e&&e(i,1)});t.addInputListener(o),t.addInputListener(r),t.addInputListener(s),t.cursor="pointer",t.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class ze extends b{constructor(t,e,o,r){const s=Ne()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},noninteractive:!1},r);super({pickableProperty:_e}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,!s.noninteractive&&Wr(null,this,s.facePressListener);const u=t.map(f=>f.start.viewCoordinates),l=s.useBackgroundOffsetStroke,c=s.backgroundOffsetDistance,a=at(u)>0?-c:c,h=f=>{const g=new uo;g.addShape(0,f),g.computeSimplifiedFaces(),g.computeFaceInclusion(m=>m[0]>0);const w=g.createFilledSubGraph(),S=w.facesToShape();return g.dispose(),w.dispose(),S},y=ze.getOffsetBackgroundShape(t,l,c),p=e.map(f=>{const g=f.map(S=>S.start.viewCoordinates),w=I.polygon(g);if(l)return h(w.getOffsetShape(a));{const m=w.getStrokedShape(new nt({lineWidth:2*c})).subpaths.map(P=>new I([P]));return h(Be.minBy(m,P=>P.getArea()))}});this.children=[new G(y,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...p.map(f=>new G(f,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(c=>c.start.viewCoordinates),s=I.polygon(r),l=at(r)>0?-o:o;if(e)return s.getOffsetShape(l).getSimplifiedAreaShape();{const c=s.getStrokedShape(new nt({lineWidth:2*o})),d=c.subpaths.map(a=>new I([a]));try{return c.bounds.width===9.718028227819117?I.bounds(c.bounds):Be.maxBy(d,a=>a.getArea()).getSimplifiedAreaShape()}catch{return I.bounds(c.bounds)}}}}class Hr{constructor(t,e,o){C(this,"edgeStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(L()&&k(this.board.edges.includes(t)),e!==v.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new Q(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Mr{constructor(t,e,o){C(this,"faceColorsChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){if(s)throw new Q("invalid face color?");const u=new Set([...o.values(),...r.keys(),...o.values()]),l=new Map(this.currentState.getFaceColorMap());for(const a of o.keys())l.set(a,o.get(a));const c=a=>r.has(a)?r.get(a):[...t].includes(a)?this.currentState.getOppositeFaceColor(a):null,d=new Map;for(const a of l.keys()){const h=l.get(a);d.has(h)||d.set(h,new Set([a])),d.get(h).add(a)}for(const a of u){const h=d.get(a);if(!h)continue;const y=[...h];L()&&k(y.length>0);const p=this.solvedState.getFaceColor(y[0]);for(const g of y)if(this.solvedState.getFaceColor(g)!==p)throw new Q("invalid face color");const f=c(a);if(f){let g;if(f.colorState===N.INSIDE?g=this.solvedState.getInsideColor():f.colorState===N.OUTSIDE?g=this.solvedState.getOutsideColor():g=this.solvedState.getFaceColor([...d.get(f)][0]),p===g)throw new Q("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class zr{constructor(t,e,o){C(this,"simpleRegionsChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new Q("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ur{constructor(t,e,o){C(this,"faceValueChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new Q("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Yr{constructor(t,e,o){C(this,"sectorStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){L()&&k(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new Q(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class jr{constructor(t,e,o){C(this,"vertexStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){L()&&k(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new Q(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new Q("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Gr{constructor(t,e,o){C(this,"faceStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){L()&&k(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new Q(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new Q("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Xr{constructor(t,e,o){C(this,"anyStateChangedEmitter",new ie);C(this,"edgeStateValidator");C(this,"faceValueValidator");C(this,"simpleRegionDataValidator");C(this,"faceColorValidator");C(this,"sectorStateValidator");C(this,"vertexStateValidator");C(this,"faceStateValidator");L()&&k(t),L()&&k(o),this.edgeStateValidator=new Hr(t,e,o),this.faceValueValidator=new Ur(t,e,o),this.simpleRegionDataValidator=new zr(t,e,o),this.faceColorValidator=new Mr(t,e,o),this.sectorStateValidator=new Yr(t,e,o),this.vertexStateValidator=new jr(t,e,o),this.faceStateValidator=new Gr(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){this.faceColorValidator.modifyFaceColors(t,e,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const qr=(i,t,e)=>new ye([new At(i,t),new Nt(i,t),new Ot(i,t),new Rt(i,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Bt(i,t,{solveToRed:!0,solveToBlack:!0}),new Wt(i,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new Go(i,t),new It(i,t),new Ht(i,t),new Xo(i,t),new xt(i,t),new qo(i,t,{solveToRed:!0,solveToBlack:!0}),new Ko(i,t),new Me(i,t,{solveToRed:!0,solveToBlack:!0}),new Jo(i,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new _o(i,t),new Dt(i,t),new Zo(i,t,{solveToRed:!0,solveToBlack:!0}),new $o(i,t),new Qo(i,t),new er(i,t)]),ft=(i,t,e)=>{We(e,i,t,!0)};class Kr{constructor(t){this.hintAction=t}get annotation(){return this.hintAction.annotation}apply(t){this.hintAction.apply(t)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(t,e){throw new Error("unimplemented")}}const Jr=i=>i instanceof po?{type:"SquareBoard",width:i.width,height:i.height}:i instanceof fo?{type:"HexagonalBoard",radius:i.radius,scale:i.scale,isPointyTop:i.isPointyTop,holeRadius:i.holeRadius}:{type:"BaseBoard",vertices:i.vertices.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vx:t.viewCoordinates.x,vy:t.viewCoordinates.y})),faces:i.faces.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vertices:t.vertices.map(e=>i.vertices.indexOf(e))}))},Yt=i=>({version:1,board:Jr(i.board),state:i.stateProperty.value.serializeState(i.board)}),_r=i=>{const t=Yt(i);return go(JSON.stringify(t))};function Zr(i){return new Worker(""+new URL("hintWorker-3McetjA7.js",import.meta.url).href,{name:i==null?void 0:i.name})}let me=null;const De=new n(!1),$r=()=>(me||(me=new Zr,me==null||me.addEventListener("message",i=>{i.data.type==="hint-worker-loaded"&&(De.value=!0)})),me),Qr=i=>{const t=Yt(i),e=i.solution.cleanState.serializeState(i.board),o=i.solution.solvedState.serializeState(i.board),r=[...i.solution.blackEdges].map(s=>i.board.edges.indexOf(s));return{puzzle:t,cleanState:e,solvedState:o,blackEdges:r}},Z=class Z extends Te{};C(Z,"DEFAULT",new Z),C(Z,"LOADING",new Z),C(Z,"SEARCHING",new Z),C(Z,"FOUND",new Z),C(Z,"NOT_FOUND",new Z),C(Z,"enumeration",new be(Z));let re=Z;const es=i=>[i.forwardHalf,i.reversedHalf,i.forwardHalf.previous,i.reversedHalf.previous];class Ue{constructor(t){this.edge=t,L()&&k(t)}apply(t){t.getEdgeState(this.edge)!==v.WHITE&&t.setEdgeState(this.edge,v.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=t.getOutsideColor(),u=t.getInsideColor(),l=o?t.getFaceColor(o):s,c=r?t.getFaceColor(r):s,d=t.getOppositeFaceColor(l);if(l===c||d===c){const a=[...t.getFacesWithColor(l),...l===s?[null]:[]],h=d?[...t.getFacesWithColor(d),...d===s?[null]:[]]:[],y=[...a,...h],p=g=>{const w=new Set,S=new Set([g]);for(;S.size>0;){const m=S.values().next().value;if(S.delete(m),w.add(m),m){for(const P of m.edges)if(t.getEdgeState(P)!==v.WHITE){const E=P.getOtherFace(m),B=E?t.getFaceColor(E):s;(B===l||B===d)&&!w.has(E)&&S.add(E)}}else for(const P of y)if(P&&!w.has(P))for(const E of P.edges)E.getOtherFace(P)===null&&t.getEdgeState(E)!==v.WHITE&&S.add(P)}return w},f=p(o);if(!f.has(r)){const g=p(r);L()&&k(f.size>0&&g.size>0),L()&&k([...f].every(D=>!g.has(D)));const w=y.filter(D=>!f.has(D)&&!g.has(D)),S=[],m=[],P=new Map,E=new Map,B=(D,H,K)=>{const O=D.filter(V=>(V?t.getFaceColor(V):s)===l),R=D.filter(V=>(V?t.getFaceColor(V):s)===d);if(H!==null)H!==s&&H!==u&&(O.length||m.push(H),K&&!R.length&&m.push(K));else if(L()&&k(D.every(V=>V)),H=new et(tt(),N.UNDECIDED),S.push(H),O.length&&R.length){K=new et(tt(),N.UNDECIDED),S.push(K),E.set(H,K),E.set(K,H);for(const V of O)L()&&k(V),P.set(V,H);for(const V of R)L()&&k(V),P.set(V,K)}else{const V=O.length?O:R;L()&&k(V.length);for(const Y of V)L()&&k(Y),P.set(Y,H)}},F=[...f],A=[...g],x=Be.sortBy([...w.length?[w]:[],F,A],D=>-D.length+(D.some(H=>!H)?-1e7:0));for(let D=0;D<x.length;D++)B(x[D],D===0?l:null,D===0?d:null);t.modifyFaceColors(S,m,P,E,!1)}}for(const a of es(this.edge))t.setSectorState(a,T.ANY);for(const a of this.edge.vertices)t.setVertexState(a,Ke.any(a));for(const a of this.edge.faces)t.setFaceState(a,vt.any(a,t.getFaceValue(a)))}getUndo(t){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:_t(this.edge)}}static deserializeAction(t,e){const o=Zt(t,e.edge);return new Ue(o)}}class Oe extends Error{constructor(t){super(t)}}class He{constructor(t){this.face=t,L()&&k(t)}apply(t){this.face.edges.forEach(e=>{new Ue(e).apply(t)})}getUndo(t){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:$t(this.face)}}static deserializeAction(t,e){const o=Qt(t,e.face);return new He(o)}}class Ze{constructor(t){this.sector=t,L()&&k(t)}apply(t){t.setSectorState(this.sector,T.ANY);const e=this.sector.end;t.setVertexState(e,Ke.any(e));const o=this.sector.face;o&&t.setFaceState(o,vt.any(o,t.getFaceValue(o)))}getUndo(t){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:eo(this.sector)}}static deserializeAction(t,e){const o=to(t,e.sector);return new Ze(o)}}const j=class j extends Te{constructor(t,e,o){super(),this.fromWhite=t,this.fromBlack=e,this.fromRed=o}apply(t){return t===v.WHITE?this.fromWhite:t===v.BLACK?this.fromBlack:this.fromRed}};C(j,"CYCLE",new j(v.BLACK,v.RED,v.WHITE)),C(j,"REVERSE_CYCLE",new j(v.RED,v.WHITE,v.BLACK)),C(j,"BLACK_TOGGLE",new j(v.BLACK,v.WHITE,v.BLACK)),C(j,"RED_TOGGLE",new j(v.RED,v.RED,v.WHITE)),C(j,"WHITE_SET",new j(v.WHITE,v.WHITE,v.WHITE)),C(j,"BLACK_SET",new j(v.BLACK,v.BLACK,v.BLACK)),C(j,"RED_SET",new j(v.RED,v.RED,v.RED)),C(j,"enumeration",new be(j));let pe=j;const $=class $ extends Te{constructor(t,e,o){super(),this.fromUndecided=t,this.fromInside=e,this.fromOutside=o}apply(t){return t===N.UNDECIDED?this.fromUndecided:t===N.OUTSIDE?this.fromOutside:this.fromInside}};C($,"CYCLE",new $(N.INSIDE,N.OUTSIDE,N.UNDECIDED)),C($,"REVERSE_CYCLE",new $(N.OUTSIDE,N.UNDECIDED,N.INSIDE)),C($,"INSIDE_TOGGLE",new $(N.INSIDE,N.UNDECIDED,N.INSIDE)),C($,"OUTSIDE_TOGGLE",new $(N.OUTSIDE,N.OUTSIDE,N.UNDECIDED)),C($,"UNDECIDED_SET",new $(N.UNDECIDED,N.UNDECIDED,N.UNDECIDED)),C($,"enumeration",new be($));let fe=$;const ge=class ge extends Te{constructor(t,e){super(),this.edgePressStyles=t,this.faceColorPressStyles=e}};C(ge,"CYCLIC",new ge([pe.CYCLE,pe.WHITE_SET,pe.REVERSE_CYCLE],[fe.CYCLE,fe.UNDECIDED_SET,fe.REVERSE_CYCLE])),C(ge,"TOGGLE",new ge([pe.BLACK_TOGGLE,pe.WHITE_SET,pe.RED_TOGGLE],[fe.INSIDE_TOGGLE,fe.UNDECIDED_SET,fe.OUTSIDE_TOGGLE])),C(ge,"enumeration",new be(ge));let qe=ge;const Ie=new bt("stateTransitionModeProperty",qe.CYCLIC),ts=new he("uiHintUsesBuiltInSolve",!1),Bs=new he("showUndoRedoAllProperty",!1),gt=new he("dimCompletedNumbersProperty",!0),wt=new he("highlightIncorrectNumbersProperty",!0),Ws=new he("highlightIncorrectMovesProperty",!0),os=new he("highlightIntersectionsProperty",!0);class Hs extends ao{constructor(e,o){const r=Ne()({style:q,initialTimeElapsed:0},o),s=r.style;super();C(this,"timeElapsedProperty",new n(0));C(this,"hintStateProperty",new n(re.DEFAULT));C(this,"edgeAutoSolvedEmitter",new ie);C(this,"stack");C(this,"stackLengthProperty",new n(0));C(this,"stackPositionProperty",new n(0));C(this,"undoPossibleProperty");C(this,"redoPossibleProperty");C(this,"currentSnapshotProperty");C(this,"hasErrorProperty");C(this,"isSolvedProperty");C(this,"hintWorkerMessageID",0);C(this,"addedHintListener",!1);C(this,"pendingHintActionProperty",new n(null));C(this,"displayedAnnotationProperty");C(this,"pendingActionFaceColorProperty",new n(null));C(this,"pendingActionSectorProperty",new n(null));C(this,"selectedFaceColorHighlightProperty");C(this,"selectedSectorEditProperty");C(this,"autoSolverFactoryProperty");C(this,"style");this.puzzle=e,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.autoSolverFactoryProperty=new U([tr,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(c,d,a)=>c?a:d),this.displayedAnnotationProperty=new U([this.pendingHintActionProperty],c=>c?c.annotation:null);const u=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(u),J.lazyLink(u),this.disposeEmitter.addListener(()=>J.unlink(u)),this.selectedFaceColorHighlightProperty=new U([e.stateProperty,J,this.pendingActionFaceColorProperty],(c,d,a)=>{if((d===z.FACE_COLOR_MATCH||d===z.FACE_COLOR_OPPOSITE)&&a){const h=c.getFacesWithColor(a.color);return{faceColor:a.color,face:a.face,faces:h}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new U([e.stateProperty,J,this.pendingActionSectorProperty],(c,d,a)=>d===z.SECTOR_STATE&&a?{sector:a,currentState:c.getSectorState(a)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const c=e.stateProperty.value.clone();ft(e.board,c,this.style.safeSolverFactoryProperty.value),e.stateProperty.value=c}this.stack=[new Le(this.puzzle.board,null,e.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new U([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new U([this.currentSnapshotProperty],c=>c.errorDetected),this.isSolvedProperty=new U([this.currentSnapshotProperty],c=>{if(c.state.getWeirdEdges().length||c.state.hasInvalidFaceColors())return!1;const d=c.state.getSimpleRegions();return d.length===1&&d[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new U([this.stackPositionProperty],c=>c>0),this.redoPossibleProperty=new U([this.stackPositionProperty,this.stackLengthProperty],(c,d)=>c<d-1);const l=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(l),this.style.safeSolverFactoryProperty.lazyLink(l),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(l),this.style.safeSolverFactoryProperty.unlink(l)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(e){this.timeElapsedProperty.value+=e,localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",_r(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(e){this.wipeStackTop(),this.stack.push(e),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(e,o){const r=(o==null?void 0:o.forceDirty)||e instanceof Ye,s=this.stack[this.stackPositionProperty.value];let u=!1,l=s.state;o!=null&&o.erase&&(l=l.clone(),o.erase(l));const c=new Xr(this.puzzle.board,l,this.puzzle.solution.solvedState);try{e.apply(c)}catch{u=!0}let d=new Set;const a=p=>{d.add(p)};let h=l.createDelta();try{if(h.edgeStateChangedEmitter.addListener(a),ut(this.autoSolverFactoryProperty.value,this.puzzle.board,h,()=>{e.apply(h)},r),h.edgeStateChangedEmitter.removeListener(a),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(h)))throw new Oe("Auto-solver did not respect user action")}catch(p){if(u=!(p instanceof Oe),d=new Set,p instanceof Q||p instanceof Oe)p instanceof Q?console.log("error"):p instanceof Oe&&console.log("skipping autosolve due to undo"),h=l.createDelta(),h.edgeStateChangedEmitter.addListener(a),ut(this.style.safeSolverFactoryProperty.value,this.puzzle.board,h,()=>{e.apply(h)},r),h.edgeStateChangedEmitter.removeListener(a);else throw p}const y=l.clone();h.apply(y),this.pushTransitionAtCurrentPosition(new Le(this.puzzle.board,e,y,u));for(const p of d)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(p))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(p))}addAutoSolveDelta(){const e=this.puzzle.stateProperty.value.createDelta();try{if(We(this.autoSolverFactoryProperty.value,this.puzzle.board,e,!0),!e.isEmpty()){const o=this.puzzle.stateProperty.value.clone();e.apply(o),this.pushTransitionAtCurrentPosition(new Le(this.puzzle.board,new Ye,o))}}catch(o){if(!(o instanceof Q))throw o}}onAutoSolveChange(){const e=this.stack[this.stackPositionProperty.value];e.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(e.action||new Ye,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(e,o,r){r&&(o=2-o);const s=Ie.value.edgePressStyles[o];return console.log(Ie.value,s,o,e),s.apply(e)}getNewFaceColorState(e,o,r){r&&(o=2-o);const s=Ie.value.faceColorPressStyles[o];return console.log(Ie.value,s,o,e),s.apply(e)}onUserEdgePress(e,o){const r=Xe.value,s=this.puzzle.stateProperty.value.getEdgeState(e),u=r?v.WHITE:this.getNewEdgeState(s,o,J.value===z.EDGE_STATE_REVERSED);if(s!==u){const l=this.stack[this.stackPositionProperty.value];l.action&&l.action instanceof ot&&l.action.edge===e&&this.stackPositionProperty.value--;let c;s!==v.WHITE&&(c=a=>{new Ue(e).apply(a)});const d=new ot(e,u);this.applyUserActionToStack(d,{erase:c,checkAutoSolve:a=>a.getEdgeState(e)===u,excludedEdges:new Set([e])}),this.updateState()}}onUserFacePress(e,o){const r=Xe.value,s=J.value;if(r){if(e){const u=new He(e);this.applyUserActionToStack(u,{erase:l=>u.apply(l)}),this.updateState()}}else if(s===z.FACE_COLOR_MATCH||s===z.FACE_COLOR_OPPOSITE){let u=J.value===z.FACE_COLOR_MATCH;o===2&&(u=!u);const l=e?this.puzzle.stateProperty.value.getFaceColor(e):this.puzzle.stateProperty.value.getOutsideColor(),c=this.pendingActionFaceColorProperty.value;if(c){if(e!==c.face){const d=c.color;d!==l&&(u?this.applyUserActionToStack(new Ft(we(this.puzzle.stateProperty.value,l),we(this.puzzle.stateProperty.value,d))):this.applyUserActionToStack(new Vt(we(this.puzzle.stateProperty.value,l),we(this.puzzle.stateProperty.value,d))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:e,color:l}}else if((s===z.FACE_COLOR_OUTSIDE||s===z.FACE_COLOR_INSIDE)&&e){const u=this.puzzle.stateProperty.value.getOutsideColor(),l=this.puzzle.stateProperty.value.getInsideColor(),c=this.puzzle.stateProperty.value.getFaceColor(e),d=c===u?N.OUTSIDE:c===l?N.INSIDE:N.UNDECIDED,a=this.getNewFaceColorState(d,o,s===z.FACE_COLOR_OUTSIDE);if(d!==a){const h=this.stack[this.stackPositionProperty.value];h.action&&h.action instanceof rt&&h.action.face===e&&this.stackPositionProperty.value--;let y;const p=new He(e);d!==N.UNDECIDED&&(y=f=>{p.apply(f)}),a===N.UNDECIDED?this.applyUserActionToStack(p,{erase:y}):this.applyUserActionToStack(new rt(e,a===N.INSIDE),{erase:y}),this.updateState()}}}onUserSectorPress(e,o){if(Xe.value){const s=new Ze(e);this.applyUserActionToStack(s,{erase:u=>s.apply(u)}),this.updateState()}else this.pendingActionSectorProperty.value=e}onUserSectorSet(e,o){this.applyUserActionToStack(new oo(e,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const e=this.puzzle.stateProperty.value;if(!ro(e))if(ts.value){const o=e.clone();We(qr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(new Le(this.puzzle.board,new st,o,!1)),this.updateState()}else{const o=or(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,v.BLACK)}),ft(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(new Le(this.puzzle.board,new st,r,!1)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=re.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(e){this.hintStateProperty.value=e?re.FOUND:re.NOT_FOUND,e&&(this.pendingHintActionProperty.value=e)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const e=q.allowEdgeEditProperty.value,o=q.allowFaceColorEditProperty.value,r=q.allowSectorEditProperty.value,s=q.vertexStateVisibleProperty.value,u=q.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const l=$r();if(!this.addedHintListener){this.addedHintListener=!0;const c=d=>{if(d.data.type==="hint-response"&&d.data.id===this.hintWorkerMessageID){const a=d.data.action?so(this.puzzle.board,d.data.action):null;this.onHintReceived(a)}};l.addEventListener("message",c),this.disposeEmitter.addListener(()=>self.removeEventListener("message",c))}if(l.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:e,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:u,serializedSolvablePuzzle:Qr(this.puzzle)}),De.value)this.hintStateProperty.value=re.SEARCHING;else{this.hintStateProperty.value=re.LOADING;const c=d=>{d&&(this.hintStateProperty.value===re.LOADING&&(this.hintStateProperty.value=re.SEARCHING),De.unlink(c))};De.link(c)}}onUserApplyHint(){const e=this.pendingHintActionProperty.value;e&&(this.clearPendingHint(),this.applyUserActionToStack(new Kr(e)),this.updateState())}}class Le{constructor(t,e,o,r=!1){this.board=t,this.action=e,this.state=o,this.errorDetected=r}}class rs extends b{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});C(this,"simpleRegionNodeMap",new Map);C(this,"regionIdMap",new Map);C(this,"weirdEdgeNodeMap",new Map);C(this,"regionContainer",new b);C(this,"weirdEdgeContainer",new b);C(this,"adjacentFacesMap",new Map);C(this,"weirdEdgeColorProperty");this.board=e,this.style=r,this.weirdEdgeColorProperty=new U([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,os],(l,c,d)=>d?l:c),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),e.faces.forEach(l=>{this.adjacentFacesMap.set(l,l.edges.map(c=>c.getOtherFace(l)).filter(c=>c!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(l=>this.addRegion(l)),o.value.getWeirdEdges().forEach(l=>this.addWeirdEdge(l)),this.updateHues();const s=(l,c)=>{const d=c.getSimpleRegions(),a=l.getSimpleRegions(),h=c.getWeirdEdges(),y=l.getWeirdEdges(),p=[],f=[];kt(d,a,p,f,[]);const w=new Set(p);for(const S of f)if(this.regionIdMap.has(S.id)){const m=this.regionIdMap.get(S.id);this.replaceRegion(m,S),w.delete(m)}else this.addRegion(S);for(const S of w)this.removeRegion(S);for(const S of h)y.includes(S)||this.removeWeirdEdge(S);for(const S of y)h.includes(S)||this.addWeirdEdge(S);(f.length||p.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const u=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(u),r.edgesHaveColorsProperty.lazyLink(u),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(u),r.edgesHaveColorsProperty.unlink(u)})}addRegion(e){const o=new Fe(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){L()&&k(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=new Xt(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const u=l=>{s.lineCap=l};this.style.joinedLinesCapProperty.link(u),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(u))}this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){this.weirdEdgeNodeMap.get(e).dispose(),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new _(0,0),r=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(1,0)},s=new Map,u=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const h=new Set;for(const p of a.simpleRegion.edges)for(const f of p.faces)h.add(f);const y=new Set;for(const p of h){y.add(p);for(const f of this.adjacentFacesMap.get(p))y.add(f)}for(const p of y){const f=s.get(p);if(f.length)for(const g of f){let w=!1;for(const S of u)if(S.a===g&&S.b===a){S.weight++,w=!0;break}w||u.push({a:g,b:a,weight:1})}f.push(a)}}const l=new Map;for(const a of e)l.set(a,_.ZERO.copy());const c=(a,h,y)=>{const p=l.get(a),f=l.get(h),g=a.hueVector.dot(h.hueVector),w=o.set(h.hueVector).subtract(a.hueVector);if(w.magnitude>1e-9){w.normalize();const S=.3,m=y*((Math.max(S,g)-S)/(1-S))**3;w.multiplyScalar(m),p.subtract(w),f.add(w)}};let d=1;for(let a=0;a<100;a++){d*=.99;for(const h of e)l.get(h).setXY(0,0);for(const h of u){const y=h.a,p=h.b,f=h.weight;c(y,p,f)}if(e.length<8)for(let h=0;h<e.length;h++){const y=e[h];for(let p=h+1;p<e.length;p++)c(y,e[p],.2)}for(const h of e){const y=l.get(h);y.multiplyScalar(d/h.edgeCount),h.hueVector.add(y),l.get(h).setXY(0,0)}r()}for(const a of e)a.updateHue()}}class Fe extends G{constructor(e,o){const r=_.createPolar(1,Re.nextDoubleBetween(0,2*Math.PI));super(Fe.toShape(e),{stroke:Fe.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});C(this,"hueVector");C(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const s=l=>{this.lineJoin=l};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const u=l=>{this.lineCap=l};o.joinedLinesCapProperty.link(u),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(u))}updateHue(){this.stroke=Fe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:_.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=Fe.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return L()&&k(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(e){const o=new I;let r=!0;for(const s of e.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class ss extends b{constructor(e,o,r){const s=new b;super({pickable:!1,children:[s]});C(this,"faceColorNodeMap",new Map);C(this,"faceColorIdMap",new Map);C(this,"adjacentFacesMap",new Map);C(this,"faceColorNodeContainer");C(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,e.faces.forEach(d=>{this.adjacentFacesMap.set(d,d.edges.map(a=>a.getOtherFace(d)).filter(a=>a!==null))});{const d=o.value.getFaceColors();for(const a of d)this.addFaceColor(a,o.value.getFacesWithColor(a));this.addDualColorViews(o.value,d)}this.updateHues();let u=o.value.clone();const l=d=>{const a=u;u=d.clone();const h=a.getFaceColors(),y=d.getFaceColors(),p=[],f=[],g=[];kt(h,y,p,f,g);const w=new Set(p),S=this.removeInvalidDualColorViews(d),m=[...S];for(const P of f)if(S.add(P),this.faceColorIdMap.has(P.id)){const E=this.faceColorIdMap.get(P.id);this.replaceFaceColor(E,P,d.getFacesWithColor(P)),w.delete(E)}else this.addFaceColor(P,d.getFacesWithColor(P));for(const P of g)this.updateFaceColor(P,d.getFacesWithColor(P));for(const P of w)S.delete(P),this.removeFaceColor(P);this.addDualColorViews(d,[...S]),(f.length||p.length||m.length)&&this.updateHues()};o.lazyLink(l),this.disposeEmitter.addListener(()=>o.unlink(l)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const c=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(c),r.theme.faceColorLightHueLUTProperty.lazyLink(c),r.theme.faceColorDarkHueLUTProperty.lazyLink(c),r.theme.faceColorInsideColorProperty.lazyLink(c),r.theme.faceColorOutsideColorProperty.lazyLink(c),r.theme.faceColorDefaultColorProperty.lazyLink(c),r.faceColorThresholdProperty.lazyLink(c),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(c),r.theme.faceColorLightHueLUTProperty.unlink(c),r.theme.faceColorDarkHueLUTProperty.unlink(c),r.theme.faceColorInsideColorProperty.unlink(c),r.theme.faceColorOutsideColorProperty.unlink(c),r.theme.faceColorDefaultColorProperty.unlink(c),r.faceColorThresholdProperty.unlink(c)})}addFaceColor(e,o){const r=new ke(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){L()&&k(e.id===o.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let s=r.faces.length!==o.length;if(!s)for(let u=0;u<o.length;u++){const l=r.faces[u],c=o[u];if(l!==c){s=!0;break}}s&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const u=this.faceColorNodeMap.get(s);L()&&k(u);const l=e.getOppositeFaceColor(s);if(l){L()&&k(r.has(l)),r.delete(l);const c=this.faceColorNodeMap.get(l);L()&&k(c),this.dualColorViews.add(new yt([u,c],this.style))}else this.dualColorViews.add(new yt([u],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const u of s.colorNodes)o.add(u.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==N.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new _(0,0),r=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(Re.nextDouble()-.5,Re.nextDouble()-.5).normalize()},s=new Map,u=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const h=new Set;for(const p of a.faces)h.add(p);const y=new Set;for(const p of h){y.add(p);for(const f of this.adjacentFacesMap.get(p))y.add(f)}for(const p of y){const f=s.get(p);if(f){if(f.length)for(const g of f){let w=!1;for(const S of u)if(S.a===g&&S.b===a){S.weight++,w=!0;break}w||u.push({a:g,b:a,weight:1})}f.push(a)}}}const l=new Map;for(const a of e)l.set(a,_.ZERO.copy());const c=(a,h,y)=>{const p=l.get(a),f=l.get(h),g=a.hueVector.dot(h.hueVector),w=o.set(h.hueVector).subtract(a.hueVector);w.magnitudeSquared>1e-11&&w.normalize();const S=.2,m=Math.abs(g),P=y*((Math.max(S,m)-S)/(1-S))**3;w.multiplyScalar(P),p.subtract(w),f.add(w)};let d=1;for(let a=0;a<100;a++){d*=.99;for(const h of e)l.get(h).setXY(0,0);for(const h of u){const y=h.a,p=h.b,f=h.weight;c(y,p,f)}if(e.length<8)for(let h=0;h<e.length;h++){const y=e[h];for(let p=h+1;p<e.length;p++)c(y,e[p],.2)}for(const h of e){const y=l.get(h);y.multiplyScalar(d/h.faceCount),h.hueVector.add(y),l.get(h).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const se=class se extends Te{};C(se,"BASIC",new se),C(se,"PRIMARY",new se),C(se,"SECONDARY",new se),C(se,"enumeration",new be(se));let te=se;class yt{constructor(t,e){C(this,"hueVector");C(this,"faceCount");if(this.colorNodes=t,this.style=e,L()&&k(t.length===1||t.length===2),this.faceCount=Be.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=te.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let s;o.type===te.PRIMARY?s=o:r.type===te.PRIMARY||o.type===te.SECONDARY?s=r:(r.type,te.SECONDARY,s=o);const u=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=te.PRIMARY,u.type=te.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class ke extends G{constructor(e,o,r){const s=_.createPolar(1,Re.nextDoubleBetween(0,2*Math.PI));super(ke.toShape(o));C(this,"hueVector");C(this,"faceCount");C(this,"dualColorView",null);C(this,"type",te.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==N.UNDECIDED?this.fill=ke.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:_.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=ke.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,s){const u=r===te.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===te.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,l=(Math.round(e.getAngle()*180/Math.PI)+360)%360;L()&&k(l>=0&&l<u.length);const c=u[l];if(o===N.UNDECIDED)return c;{const a=(o===N.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,h=a.alpha,y=new Qe(c);return new Qe((1-h)*y.red+h*a.red,(1-h)*y.green+h*a.green,(1-h)*y.blue+h*a.blue).toCSS()}}static toShape(e){const o=new I;for(const r of e)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class is extends b{constructor(t,e,o,r){let s=[];try{let u=new I;for(const c of t.faces)u.polygon(c.vertices.map(d=>d.viewCoordinates));if(t.faceColor.colorState===N.OUTSIDE)try{const c=I.polygon(e.outerBoundary.map(h=>h.start.viewCoordinates)),a=ze.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(c);u=u.bounds.isValid()?u.shapeUnion(a):a}catch(c){console.error(c)}const l=new G(u.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(l)}catch(u){console.error(u)}super({children:s}),this.selectedFaceColorHighlight=t}}class ce extends b{static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,u=o.minus(r),l=s.minus(r),c=u.normalized(),a=l.normalized().minus(c).angle+Math.PI/2,h=t.face?t.face.viewCoordinates:_.createPolar(e,a).plus(r),y=o.average(r),p=s.average(r);return I.polygon([y,r,p,h]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,u=o.minus(r),l=s.minus(r),c=u.normalized(),d=u.angle;let a=l.angle;return a<d&&(a+=2*Math.PI),new I().moveToPoint(r).lineToPoint(c.timesScalar(e).plus(r)).arcPoint(r,e,d,a,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===T.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===T.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===T.NOT_ONE?e.theme.sectorNotOneColorProperty:t===T.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}}C(ce,"nameMap",new Map([[T.NONE,"Invalid"],[T.ONLY_ZERO,"No Lines"],[T.ONLY_ONE,"Only One Line"],[T.ONLY_TWO,"Both Lines"],[T.NOT_ZERO,"At Least One Line"],[T.NOT_ONE,"Zero or Two Lines"],[T.NOT_TWO,"Less Than Two Lines"],[T.ANY,"Any Lines"]]));class as extends b{constructor(t,e,o,r){const s=[],u=[],l=t.sector,c=t.currentState,d=ce.getSectorArcShape(l,.5),a=new G(d.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(a);const h=[];if(c===T.ANY&&(h.push(T.NOT_ZERO),h.push(T.NOT_ONE),h.push(T.NOT_TWO)),c.one&&c!==T.ONLY_ONE&&h.push(T.ONLY_ONE),h.length){const y=h.map(g=>{const w=ce.getStrokeFromStyle(g,o);return new ho({accessibleName:ce.nameMap.get(g),content:new qt(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(l,g)},buttonAppearanceStrategy:Mo,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});u.push(...y);const p=new Lt(new mt({children:y,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});u.push(p);const f=.1;s.push(p),p.centerBottom=a.centerTop.plusXY(0,-.15),p.top<e.top+f&&(p.centerTop=a.centerBottom.plusXY(0,.15)),p.left<e.left+f&&(p.left=e.left+f),p.right>e.right-f&&(p.right=e.right-f)}super({children:s}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{u.forEach(y=>y.dispose())})}}class ns extends b{constructor(t,e,o,r){const s=new G(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),u=new G(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),l=new G(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,u,l],pickable:!1});const c=t.edges.map(g=>v.BLACK);let d=!1,a=!1,h=!1,y=!1,p=null;const f=de.multilink([e,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(g,w,S,m,P,E,B)=>{if(this.visible=!w,s.visible=S,u.visible=m,l.visible=E,this.visible){let F=!1;for(let A=0;A<t.edges.length;A++){const x=g.getEdgeState(t.edges[A]);x!==c[A]&&(F=!0,c[A]=x)}if(d!==P&&(F=!0,d=P),a!==S&&(F=!0,a=S),h!==m&&(F=!0,h=m),y!==E&&(F=!0,y=E),p!==B&&(F=!0,p=B),F){const A=new I,x=new I,D=new I;for(let H=0;H<t.edges.length;H++){const K=c[H];if(S&&K===v.WHITE){const O=t.edges[H];A.moveTo(O.start.viewCoordinates.x,O.start.viewCoordinates.y),A.lineTo(O.end.viewCoordinates.x,O.end.viewCoordinates.y)}if(K===v.RED){if(m){const O=t.edges[H],R=.07;let V=O.start.viewCoordinates.blend(O.end.viewCoordinates,.5);if(P){const Y=O.end.viewCoordinates.minus(O.start.viewCoordinates).getAngle(),X=new _(-R,-R).rotate(Y).add(V),ee=new _(R,R).rotate(Y).add(V),oe=new _(-R,R).rotate(Y).add(V),Se=new _(R,-R).rotate(Y).add(V);x.moveTo(X.x,X.y),x.lineTo(ee.x,ee.y),x.moveTo(oe.x,oe.y),x.lineTo(Se.x,Se.y)}else x.moveTo(V.x-R,V.y-R),x.lineTo(V.x+R,V.y+R),x.moveTo(V.x-R,V.y+R),x.lineTo(V.x+R,V.y-R)}if(E){const O=t.edges[H],R=.4,V=.017,Y=O.start.viewCoordinates.blend(O.end.viewCoordinates,.5),X=Y.blend(O.start.viewCoordinates,R),ee=Y.blend(O.end.viewCoordinates,R);for(let oe=0;oe<5;oe++){const Se=X.blend(ee,oe/4);D.moveTo(Se.x+V,Se.y),D.arc(Se.x,Se.y,V,0,2*Math.PI,!1)}}}}A.makeImmutable(),x.makeImmutable(),D.makeImmutable(),s.shape=A,u.shape=x,l.shape=D}}});this.disposeEmitter.addListener(()=>f.dispose())}}class $e extends b{constructor(t,e,o,r){super();const s=new Set;if(r!=null&&r.delayInteractionEmitter){const p=r==null?void 0:r.delayInteractionEmitter,f=g=>{s.add(g),setTimeout(()=>{s.delete(g)},700)};p.addListener(f),this.disposeEmitter.addListener(()=>p.removeListener(f))}const u=new I,l=t.map(p=>{const f=e(p);return f.makeImmutable(),u.subpaths.push(...f.subpaths),f});this.mouseArea=this.touchArea=u.makeImmutable();const c=p=>{const f=p.trail.globalToLocalPoint(p.pointer.point);for(let g=0;g<l.length;g++){const w=l[g];if(w.bounds.containsPoint(f)&&w.containsPoint(f)){const S=t[g];if(!s.has(S))return S}}return null},d=(p,f)=>{const g=c(p);g&&o(g,f)},a=new Ve({mouseButton:0,fire:p=>{var f;return d(p,(f=p.domEvent)!=null&&f.shiftKey?2:0)}}),h=new Ve({mouseButton:2,fire:p=>{var f;return d(p,(f=p.domEvent)!=null&&f.shiftKey?0:2)}}),y=new Ve({mouseButton:1,fire:p=>d(p,1)});this.addInputListener(a),this.addInputListener(h),this.addInputListener(y),this.cursor="pointer",this.disposeEmitter.addListener(()=>{a.dispose(),h.dispose(),y.dispose()})}}class ls extends $e{constructor(t,e,o){super(t.edges,r=>{const s=r.start.viewCoordinates,u=r.end.viewCoordinates,l=new I;let c;if(r.faces.length===2)c=[s,r.faces[0].viewCoordinates,u,r.faces[1].viewCoordinates];else{L()&&k(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const d=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;L()&&k(d.previous.face===null),L()&&k(d.next.face===null);const a=d.start.viewCoordinates,h=d.end.viewCoordinates,y=d.previous.start.viewCoordinates,p=d.next.end.viewCoordinates,f=(S,m,P)=>{const E=m.minus(S).normalized(),B=P.minus(m).normalized();let F=E.minus(B);return F.getMagnitude()<1e-6?F=E.getPerpendicular():F=F.normalized(),no.triangleAreaSigned(S,m,m.plus(F))<0&&(F=F.negated()),F},g=f(y,a,h),w=f(a,h,p);c=[a,r.faces[0].viewCoordinates,h,h.plus(w.times(o.backgroundOffsetDistance)),a.plus(g.times(o.backgroundOffsetDistance))]}return l.polygon(c),l.makeImmutable(),l},o.edgePressListener,{delayInteractionEmitter:e})}}const St=[.02,.02],Pe=.2,xe=.02;class cs extends b{constructor(t,e,o){const r=new G(null,{lineWidth:.025,lineCap:"butt",stroke:ce.getStrokeFromStyle(T.NOT_ZERO,o)}),s=new G(null,{lineWidth:.025,lineCap:"butt",stroke:ce.getStrokeFromStyle(T.NOT_ONE,o)}),u=new G(null,{lineWidth:.025,lineCap:"butt",stroke:ce.getStrokeFromStyle(T.NOT_TWO,o)}),l=new G(null,{lineWidth:.025,lineCap:"butt",stroke:ce.getStrokeFromStyle(T.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,u,l]}),this.board=t;const c=t.halfEdges.map(h=>T.NONE),d=t.edges.map(h=>v.BLACK),a=de.multilink([e,o.sectorsVisibleProperty],(h,y)=>{if(y){let p=!1;for(let f=0;f<t.halfEdges.length;f++){const g=h.getSectorState(t.halfEdges[f]);g!==c[f]&&(p=!0,c[f]=g)}for(let f=0;f<t.edges.length;f++){const g=h.getEdgeState(t.edges[f]);g!==d[f]&&(p=!0,d[f]=g)}if(p){const f=new I,g=new I,w=new I,S=new I;for(let m=0;m<t.halfEdges.length;m++){const P=c[m];if(P!==T.NOT_ZERO&&P!==T.NOT_ONE&&P!==T.NOT_TWO&&P!==T.ONLY_ONE)continue;const E=t.halfEdges[m],B=h.getEdgeState(E.edge),F=h.getEdgeState(E.next.edge);if(B!==v.WHITE||F!==v.WHITE)continue;if(P===T.NOT_ONE){const X=E.end.edges.filter(oe=>h.getEdgeState(oe)===v.BLACK),ee=E.end.edges.filter(oe=>h.getEdgeState(oe)===v.WHITE);if(X.length===0&&ee.length===2)continue}const A=E.start.viewCoordinates,x=E.end.viewCoordinates,D=E.next.end.viewCoordinates,H=A.minus(x),K=D.minus(x),O=H.normalized(),R=H.angle;let V=K.angle;V<R&&(V+=2*Math.PI);const Y=(X,ee)=>(X.moveToPoint(O.timesScalar(ee).add(x)),X.arcPoint(x,ee,R,V,!0),X);if(P===T.ONLY_ONE)Y(S,Pe);else if(P===T.NOT_ONE)Y(g,Pe-xe),Y(g,Pe+xe);else if(P===T.NOT_ZERO){const X=new I;Y(X,Pe-xe),Y(X,Pe+xe);const ee=X.getDashedShape(St,0);f.subpaths.push(...ee.subpaths)}else if(P===T.NOT_TWO){const X=new I;Y(X,Pe);const ee=X.getDashedShape(St,0);w.subpaths.push(...ee.subpaths)}}r.shape=f.makeImmutable(),s.shape=g.makeImmutable(),u.shape=w.makeImmutable(),l.shape=S.makeImmutable()}}});this.disposeEmitter.addListener(()=>a.dispose())}}class ds extends $e{constructor(t,e){super(t.halfEdges,o=>ce.getSectorBaseShape(o,e.backgroundOffsetDistance),e.sectorPressListener)}}class hs extends Pt{constructor(t,e){const o=Ne()({font:zo,fill:le.uiForegroundColorProperty},e);super(t,o)}}class us extends b{constructor(t,e,o){super({translation:t.viewCoordinates}),this.face=t;const s=e.value.getFaceState(t),u=s.possibilityCount===0||s.possibilityCount>9;let l;const c=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(u)l=new hs(s.possibilityCount,{font:Je,maxWidth:.4,maxHeight:.4});else{const d=new Set(t.vertices);l=new Kt({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(a=>{const h=new b,y=new Set(a.map(g=>g.start)),p=new Set(a.map(g=>g.end)),f=g=>g.minus(t.viewCoordinates);if(h.addChild(new G(I.polygon(t.vertices.map(g=>f(g.viewCoordinates))),{stroke:c,lineWidth:.03,opacity:.2})),y.size){const g=new I;if(a.length===t.edges.length)g.polygon(t.vertices.map(w=>f(w.viewCoordinates)));else{const w=new Set(a);for(;w.size;){const S=[...d].find(E=>[...w].filter(B=>B.start===E||B.end===E).length===1);L()&&k(S);let m=S,P=[...w].find(E=>E.start===m||E.end===m)??null;for(g.moveToPoint(f(m.viewCoordinates));P;)w.delete(P),m=P.getOtherVertex(m),g.lineToPoint(f(m.viewCoordinates)),P=[...w].find(E=>E.start===m||E.end===m)??null}}h.addChild(new G(g,{stroke:c,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of t.vertices)!y.has(g)&&!p.has(g)&&h.addChild(new Et(.1,{fill:c,translation:f(g.viewCoordinates)}));return h}),maxWidth:.6,maxHeight:.6})}l.center=_.ZERO,this.addChild(l)}}class ps extends b{constructor(t,e,o,r){super({pickable:!1});const s=de.multilink([e,r.faceStateVisibleProperty],(l,c)=>{this.children.forEach(d=>d.dispose()),this.children=[],c&&t.faces.forEach(d=>{this.addChild(new us(d,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const u=l=>{this.visible=!l};o.link(u),this.disposeEmitter.addListener(()=>{o.unlink(u),this.children.forEach(l=>l.dispose())})}}class fs extends $e{constructor(t,e){super(t.faces,o=>o?I.polygon(o.vertices.map(r=>r.viewCoordinates)):new I,e.facePressListener)}}class gs extends b{constructor(t,e,o,r){super({pickable:!1}),this.board=t;const s=t.faces.map(d=>null),u=()=>{const d=[],a=o.faceValueStyleProperty.value,h=o.theme.faceValueColorProperty.value,y=o.theme.faceValueCompletedColorProperty.value,p=o.theme.faceValueErrorColorProperty.value,f=o.theme.faceValueRatioColorProperty.value,g=o.faceStateVisibleProperty.value,w=gt.value,S=wt.value;this.visible=!g;for(let m=0;m<t.faces.length;m++){const P=s[m];if(P!==null){const E=t.faces[m],B=new Jt("",Tt({subScale:.7},r==null?void 0:r.textOptions)),F=de.multilink([e],A=>{let x,D,H=!1,K=!1;if(P===null)x="",D=null;else{let O=0,R=0;for(const V of E.edges){const Y=A.getEdgeState(V);Y===v.BLACK?O++:Y===v.WHITE&&R++}if(a==="static"||P===0)x=`${P}`;else if(a==="remaining")x=`${P-O}`,H=O>0;else if(a==="ratio")P-O===0?x="0":(x=`${P-O}<sub style="color: ${f.toCSS()};">/<sub>${R}</sub></sub>`,K=!0),H=O>0;else throw new Error(`unhandled faceValueStyle: ${a}`);O>P&&S?D=p:O===P&&w?D=y:D=h}B.string=x,B.fill=D,B.maxWidth=K?.8:.9,B.maxHeight=K?.8:.9,B.center=E.viewCoordinates});B.disposeEmitter.addListener(()=>F.dispose()),d.push(B)}}this.children.forEach(m=>m.dispose()),this.children=d},l=de.multilink([e],d=>{let a=!1;for(let h=0;h<t.faces.length;h++){const y=d.getFaceValue(t.faces[h]);y!==s[h]&&(a=!0,s[h]=y)}a&&u()}),c=de.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,gt,wt],u);this.disposeEmitter.addListener(()=>{l.dispose(),c.dispose(),this.children.forEach(d=>d.dispose())})}}class ws extends b{constructor(t,e,o){super({pickable:!1}),this.vertex=t;const r=.12,u=t.edges.map(p=>p.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(p=>p.times(r)),c=I.polygon(lo.grahamScan([_.ZERO,...u],!1)).getOffsetShape(-.05),d=new G(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),a=new G(c,{translation:t.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[d,...u.map(p=>new Et({radius:.02,translation:p,fill:o.theme.vertexStatePointProperty}))]});let h=null;const y=de.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(p,f,g)=>{const w=()=>{this.children=[]};if(!f){w();return}const S=p.getVertexState(t);if(!g){let m=!1,P=!1;const E=new Set;for(const F of t.edges){const A=p.getEdgeState(F);m=m||A===v.BLACK,P=P||A===v.WHITE,A===v.WHITE&&E.add(F)}if(m||!P){w();return}if(Ke.fromLookup(t,(F,A)=>E.has(F)&&E.has(A),!0).equals(S)){w();return}}if(!h||!h.equals(S)){h=S;const m=new I;for(const P of S.getAllowedPairs()){const E=B=>B.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);m.moveToPoint(E(P[0])),m.lineToPoint(E(P[1]))}S.allowsEmpty()&&(m.moveTo(.03,0),m.circle(_.ZERO,.03),m.close()),m.makeImmutable(),d.shape=m}this.children=[a]});this.disposeEmitter.addListener(()=>y.dispose())}}class ys extends b{constructor(t,e,o,r){super({pickable:!1});const s=de.multilink([e,r.vertexStateVisibleProperty],(l,c)=>{this.children.forEach(d=>d.dispose()),this.children=[],c&&t.vertices.forEach(d=>{this.addChild(new ws(d,e,r))})});this.disposeEmitter.addListener(()=>s.dispose());const u=l=>{this.visible=!l};o.link(u),this.disposeEmitter.addListener(()=>{o.unlink(u),this.children.forEach(l=>l.dispose())})}}const Ss=.03,Cs=.05;class ms extends G{constructor(t,e,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=t.edges.map(d=>v.BLACK);let u=r.vertexStyleProperty.value,l=r.smallVertexProperty.value;const c=de.multilink([e,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(d,a,h,y,p)=>{if(this.visible=!a&&h,this.visible){let f=!1;for(let g=0;g<t.edges.length;g++){const w=d.getEdgeState(t.edges[g]);w!==s[g]&&(f=!0,s[g]=w)}if(u!==y&&(u=y,f=!0),l!==p&&(l=p,f=!0),f){const g=new I;for(let w=0;w<t.vertices.length;w++){const S=t.vertices[w];if(S.edges.every(m=>d.getEdgeState(m)!==v.BLACK)){const m=S.viewCoordinates,P=p?Ss:Cs;y==="round"?(g.moveTo(m.x+P,m.y),g.arc(m.x,m.y,P,0,2*Math.PI,!1)):y==="square"?g.rect(m.x-P,m.y-P,2*P,2*P):L()&&k(!1,`unhandled vertex style: ${y}`)}}this.shape=g}}});this.disposeEmitter.addListener(()=>c.dispose())}}class Ct extends b{constructor(e,o){const r=Ne()({textOptions:{font:Je,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},facePressListener:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Ae(null),selectedSectorEditProperty:new Ae(null),style:q,noninteractive:!1,delayEdgeInteractionEmitter:new ie},o),s=r.style,u=new b({visibleProperty:s.faceColorsVisibleProperty}),l=new b({pickableProperty:Br}),c=new b({pickableProperty:Dr}),d=new b({pickableProperty:Ir}),a=new b({pickableProperty:Rr}),h=new b,y=new b({pickable:!1}),p=new b({pickable:!1}),f=new b({renderer:wo.chromium?"canvas":null,pickable:null}),g=new b({pickable:!1}),w=new b,S=new U([e.stateProperty],F=>{if(F.getWeirdEdges().length||F.hasInvalidFaceColors())return!1;const A=F.getSimpleRegions();return A.length===1&&A[0].isSolved}),m=F=>{F?u.addChild(new ss(e.board,e.stateProperty,s)):u.children.forEach(A=>A.dispose())};s.faceColorsVisibleProperty.link(m),l.addChild(new gs(e.board,e.stateProperty,s,r)),r.noninteractive||l.addChild(new fs(e.board,r)),p.addChild(new ps(e.board,e.stateProperty,S,s));const P=new ze(e.board.outerBoundary,e.board.innerBoundaries,s,r);a.addChild(new ms(e.board,e.stateProperty,S,s)),y.addChild(new ys(e.board,e.stateProperty,S,s)),d.addChild(new ns(e.board,e.stateProperty,S,s)),r.noninteractive||d.addChild(new ls(e.board,r.delayEdgeInteractionEmitter,r)),c.addChild(new cs(e.board,e.stateProperty,s)),r.noninteractive||c.addChild(new ds(e.board,r)),h.addChild(new rs(e.board,e.stateProperty,s));super(Tt({children:[P,u,l,c,d,a,h,y,p,g,w,f]},r));C(this,"annotationContainer");C(this,"backgroundNode");this.puzzle=e,this.annotationContainer=f;const E=F=>{g.children.forEach(A=>A.dispose()),F&&g.addChild(new is(F,e.board,s,r))};r.selectedFaceColorHighlightProperty.link(E),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(E));const B=F=>{w.children.forEach(A=>A.dispose()),F&&w.addChild(new as(F,P,s,r))};r.selectedSectorEditProperty.link(B),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(B)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(m),[u,l,d,a,h,y,p,c].forEach(A=>{A.children.forEach(x=>x.dispose()),A.dispose()}),S.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class Ms extends b{constructor(t,e,o){const r=Ne()({style:q},o),s=e.getEmbeddedCompleteData(t.inputFeatureSet),u=e.getEmbeddedCompleteData(t.outputFeatureSet),l=new Ct(new it(e.smallBoard,s),{noninteractive:!0,style:r.style}),c=new Ct(new it(e.smallBoard,u),{noninteractive:!0,style:r.style}),d=t.highlander?new b({children:e.getEmbeddedQuestionFaces(t.inputFeatureSet).map(S=>new Pt("?",{font:Je,maxWidth:.9,maxHeight:.9,opacity:.5,fill:t.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:S.viewCoordinates}))}):new b,h=e.tightBounds.dilated(.5),y=.5,p=I.roundRectangle(h.x,h.y,h.width,h.height,y,y),f=new b({children:[l,d],clipArea:p,localBounds:h}),g=new b({children:[c,d],clipArea:p,localBounds:h}),w=new Lt(new mt({spacing:.2,children:[f,new sr(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),g]}),{cornerRadius:y*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[w],super(r),this.rule=t,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{l.dispose(),c.dispose()})}}const Ps=(i,t)=>{We(rr,i,t,!0)};class Ee{constructor(t,e,o,r,s,u,l,c,d,a){this.sourcePatternBoard=t,this.boardPatternBoard=e,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=u,this.toSmallEdgeMap=l,this.toSmallSectorMap=c,this.tightBounds=d,this.expandedBounds=a}mapFace(t){const e=this.embedding.mapFace(t),o=this.boardPatternBoard.getFace(e);if(o){const r=this.toSmallFaceMap.get(o);return L()&&k(r),r}else return null}mapEdge(t){return(t.isExit?this.embedding.mapExitEdges(t):[this.embedding.mapNonExitEdge(t)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return L()&&k(s),s})}mapSector(t){const e=this.embedding.mapSector(t),o=this.boardPatternBoard.getSector(e),r=this.toSmallSectorMap.get(o);return L()&&k(r),r}getEmbeddedQuestionFaces(t){const e=new Set;for(const o of t.patternBoard.faces)if(t.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&e.add(r)}return this.smallBoard.faces.filter(o=>!e.has(o))}getEmbeddedCompleteData(t){const e=io.empty(this.smallBoard);for(const o of t.getFeaturesArray())if(o instanceof ir)o.value!==null&&e.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof ar)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.BLACK));else if(o instanceof nr)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.RED));else if(o instanceof lr)e.setSectorState(this.mapSector(o.sector),T.NOT_ZERO);else if(o instanceof cr)e.setSectorState(this.mapSector(o.sector),T.NOT_ONE);else if(o instanceof dr)e.setSectorState(this.mapSector(o.sector),T.NOT_TWO);else if(o instanceof hr)e.setSectorState(this.mapSector(o.sector),T.ONLY_ONE);else if(o instanceof ur){const r=(u,l)=>{const c=this.mapFace(u),d=this.mapFace(l),a=c?e.getFaceColor(c):e.getOutsideColor(),h=d?e.getFaceColor(d):e.getOutsideColor();new Ft(we(e,a),we(e,h)).apply(e)},s=(u,l)=>{const c=this.mapFace(u),d=this.mapFace(l),a=c?e.getFaceColor(c):e.getOutsideColor(),h=d?e.getFaceColor(d):e.getOutsideColor();new Vt(we(e,a),we(e,h)).apply(e)};for(let u=1;u<o.primaryFaces.length;u++)r(o.primaryFaces[u-1],o.primaryFaces[u]);for(let u=1;u<o.secondaryFaces.length;u++)r(o.secondaryFaces[u-1],o.secondaryFaces[u]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return Ps(this.smallBoard,e),e}static getEmbeddingBounds(t,e,o,r){const s=je.NOTHING.copy(),u=c=>{s.addPoint(e.getVertex(o.mapVertex(c)).viewCoordinates)};t.vertices.forEach(u);const l=c=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(c))return;const d=e.getFace(o.mapFace(c));d&&d.vertices.forEach(a=>s.addPoint(a.viewCoordinates))};return t.faces.forEach(l),t.edges.forEach(c=>{let d;if(c.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(c))return;d=o.mapExitEdges(c).map(a=>e.getEdge(a))}else d=[e.getEdge(o.mapNonExitEdge(c))];d.forEach(a=>{s.addPoint(a.start.viewCoordinates),s.addPoint(a.end.viewCoordinates)})}),s}static findBestEmbedding(t,e,o){const r=yo(t,e);if(r.length===0)return null;const s=je.NOTHING.copy();o.vertices.forEach(d=>s.addPoint(d.viewCoordinates));const u=s.center;let l=null,c=Number.POSITIVE_INFINITY;for(let d=0;d<r.length;d++){const a=r[d],y=Ee.getEmbeddingBounds(t,e,a).center,p=u.distance(y);p<c&&(c=p,l=a)}return l}static getDisplayEmbedding(t,e,o,r,s){const u=Ee.getEmbeddingBounds(t,e,r,s),l=u.dilated(.5),c=o.faces.filter(w=>{const S=je.NOTHING.copy();return w.vertices.forEach(m=>S.addPoint(m.viewCoordinates)),l.intersectsBounds(S)}),d=o.vertices.filter(w=>w.faces.some(S=>c.includes(S))),a=So({vertices:d.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates})),faces:c.map(w=>({logicalCoordinates:w.logicalCoordinates,vertices:w.vertices.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates}))}))}),h=new Co(a),y=1e-6,p=new Map(c.map((w,S)=>{const m=h.faces.find(P=>P.viewCoordinates.equalsEpsilon(w.viewCoordinates,y));return L()&&k(m),[w,m]})),f=new Map(o.edges.map(w=>{const S=h.edges.find(m=>m.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&m.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)||m.start.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)&&m.end.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y))??null;return S?[w,S]:null}).filter(w=>w!==null)),g=new Map(o.halfEdges.map(w=>{const S=h.halfEdges.find(m=>m.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&m.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y))??null;return S?[w,S]:null}).filter(w=>w!==null));return L()&&k(r),new Ee(t,e,o,r,h,p,f,g,u,l)}static getOptionsForRule(t){const e=t.outputFeatureSet.getAffectedFaces(),o=t.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>e.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(t,e,o){return Ee.getDisplayEmbedding(t.patternBoard,e,e.board,o,Ee.getOptionsForRule(t))}}export{xs as A,Bs as B,ts as C,_r as D,Ms as E,us as F,qr as G,re as H,Hs as I,J,z as K,Xe as L,Ds as M,Nr as N,Ee as O,Ct as P,Xr as Q,qe as S,hs as U,ws as V,Os as a,wr as b,yr as c,Sr as d,Pr as e,q as f,Cr as g,Wr as h,Rs as i,Ut as j,Fr as k,Vr as l,Tr as m,br as n,Lr as o,Or as p,Ar as q,pr as r,Ps as s,gt as t,wt as u,kr as v,Ws as w,os as x,Ie as y,Is as z};
