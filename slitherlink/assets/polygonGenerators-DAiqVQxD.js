import{N as W,F as G,P as R}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{O as z,k as F,R as k,V as h}from"./UnivariatePolynomial-CzQEP6td.js";import{_ as S,S as C,L as B,e as M,f as v,G as $,I as j,J,K as Q,M as U,N as _,O as o,Q as K,R as L,T as X,U as Y,V as Z,W as ee,X as se,Y as le,Z as re,$ as te,a0 as ae,a1 as ie,a2 as pe,a3 as de,a4 as ce,a5 as ge,a6 as oe,a7 as ue,a8 as he,a9 as me,aa as fe}from"./patternBoards-7WmHeiIn.js";import{N as ne,E as Se}from"./DisplayEmbedding-BBo8Vgn-.js";import{c as O}from"./Theme-CMAJrJpo.js";import{C as we}from"./BasicPuzzle-B1djSMlq.js";import{D,F as I,M as A,H as ye}from"./SATSolver-CcH7PLXT.js";import{S as w}from"./SlitherQueryParameters-CBL8UsTw.js";class Be extends W{constructor(c,e,u,i=null){let l;const m=s=>new C().moveToPoint(s.start.viewCoordinates).lineToPoint(s.end.viewCoordinates).getStrokedShape(new B({lineWidth:.2,lineCap:"round"})).getStrokedShape(new B({lineWidth:.02})),r=(s,a)=>new R(m(s),{fill:a}),n=[];if(e.type==="ForcedLine")l=[r(e.whiteEdge,"red"),r(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")l=[r(e.whiteEdge,"red"),...e.redEdges.map(s=>r(s,"blue"))];else if(e.type==="JointToRed")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.blackEdges.map(s=>r(s,"blue"))];else if(e.type==="FaceSatisfied")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.blackEdges.map(s=>r(s,"blue"))];else if(e.type==="FaceAntiSatisfied")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.redEdges.map(s=>r(s,"blue"))];else if(e.type==="ForcedSolveLoop")l=[...e.regionEdges.map(s=>r(s,"blue")),...e.pathEdges.map(s=>r(s,"red"))];else if(e.type==="PrematureForcedLoop")l=[...e.regionEdges.map(s=>r(s,"blue")),...e.pathEdges.map(s=>r(s,"red"))];else if(e.type==="CompletingEdgesAfterSolve")l=[...e.whiteEdges.map(s=>r(s,"red"))];else if(e.type==="FaceColoringBlackEdge")l=[r(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")l=[r(e.edge,"red")];else if(e.type==="FaceColorToBlack")l=[r(e.edge,"red")];else if(e.type==="FaceColorToRed")l=[r(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")l=[...e.face.edges.map(s=>r(s,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")l=[...e.balancedPairs.flatMap((s,a)=>{const p=["green","blue","black"][a%3],g=["magenta","orange","yellow"][a%3];return[...s[0].map(f=>r(f,p)),...s[1].map(f=>r(f,g))]})],e.type==="FaceColorMatchToRed"?l.push(...e.matchingEdges.map(s=>r(s,"red"))):e.type==="FaceColorMatchToBlack"?l.push(...e.matchingEdges.map(s=>r(s,"red"))):e.type==="FaceColorBalance"&&(l.push(...e.matchingEdges.map(s=>r(s,"orange"))),l.push(...e.oppositeEdges.map(s=>r(s,"red"))));else if(e.type==="DoubleMinusOneFaces")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")l=[e.sector.edge,e.sector.next.edge].map(s=>r(s,"red"));else if(e.type==="ForcedSector"){const s=[...e.toRedEdges,...e.toBlackEdges];l=[e.sector.edge,e.sector.next.edge].map(a=>r(a,s.includes(a)?"red":"blue"))}else if(e.type==="StaticFaceSectors")l=S.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="VertexState")l=e.vertex.edges.map(s=>r(s,"blue"));else if(e.type==="VertexStateToEdge")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="VertexStateToSector")l=S.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")l=S.uniq([...e.facesA,...e.facesB].flatMap(s=>s.edges)).map(s=>r(s,"red"));else if(e.type==="FaceState")l=e.face.edges.map(s=>r(s,"red"));else if(e.type==="FaceStateToEdge")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="FaceStateToSector")l=S.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const s=new Set([...e.facesA,...e.facesB].flatMap(p=>p.edges)),a=e.face.edges.filter(p=>!s.has(p));l=[...[...s].map(p=>r(p,"red")),...a.map(p=>r(p,"blue"))]}else if(e.type==="FaceStateToVertexState")l=e.face.edges.filter(a=>e.vertices.includes(a.start)||e.vertices.includes(a.end)).map(a=>r(a,"red"));else if(e.type==="Pattern"){if(l=[],i){const s=ne.getDisplayEmbeddingFromRule(e.rule,e.boardPatternBoard,e.embedding),a=new Se(e.rule,s,{inputListeners:[new G({fire:()=>{console.log(e.rule.getBinaryIdentifier());const t=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");t&&t.focus()}})],cursor:"pointer"}),p=.5+.05,g=.15,f=.1,b=t=>s.expandedBounds[t.minCoordinate]+g-(i[t.minCoordinate]+p),q=t=>i[t.maxCoordinate]-p-(s.expandedBounds[t.maxCoordinate]-g),V=t=>Math.min((i[t.opposite.size]-2*p)/a[t.opposite.size],Math.max(b(t),q(t))/a[t.size],1),H=t=>{a[t.opposite.centerCoordinate]=s.expandedBounds[t.opposite.centerCoordinate],b(t)>q(t)?(a[t.maxSide]=s.expandedBounds[t.minCoordinate]-g,a[t.minSide]<i[t.minCoordinate]+f&&(a[t.minSide]=i[t.minCoordinate]+f)):(a[t.minSide]=s.expandedBounds[t.maxCoordinate]+g,a[t.maxSide]>i[t.maxCoordinate]-f&&(a[t.maxSide]=i[t.maxCoordinate]-f)),a[t.opposite.minSide]<i[t.opposite.minCoordinate]+f&&(a[t.opposite.minSide]=i[t.opposite.minCoordinate]+f),a[t.opposite.maxSide]>i[t.opposite.maxCoordinate]-f&&(a[t.opposite.maxSide]=i[t.opposite.maxCoordinate]-f)};let x=z.VERTICAL,E=V(x);if(E<1){const t=V(x.opposite);t>E&&(x=x.opposite,E=t)}a.scale(Math.max(E,.3)),H(x);{const t=s.tightBounds.dilated(.21),T=.3;l.push(new R(C.roundRectangle(t.x,t.y,t.width,t.height,T,T),{stroke:O.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const t=s.tightBounds.dilated(.21),T=.3;l.push(new R(C.roundRectangle(t.x,t.y,t.width,t.height,T,T),{stroke:O.blackLineColorProperty,lineWidth:.13,pickable:!1}))}l.push(a)}}else l=[],console.log(`unknown type: ${e.type}`);super({children:l,pickable:e.type==="Pattern"?null:!1}),this.board=c,this.annotation=e,this.style=u,this.disposeEmitter.addListener(()=>n.forEach(s=>s()))}}let y=null,P=0;const Oe=()=>{if(y&&(P++,P>5)){const d=y;y=null,d(null)}},be=async function(d){return new Promise((c,e)=>{y=c,P=0,w.debugSleep&&console.log("sleep start"),setTimeout(()=>{w.debugSleep&&console.log("sleep end"),y===c&&(y=null,c(null)),w.debugSleep&&console.log("resolved")},d)})};class xe extends Error{constructor(){super("Interrupted")}}const N=async function(d,c){if(await be(d),w.debugSleep&&console.log("after sleep before interrupt check"),c.value)throw new xe},De=async(d,c,e)=>{let u=0;for(;u++<100;){const i=we.fromFaces(d,()=>null),l=F.shuffle(d.faces);let m=-1,r=[];const n=s=>{try{return r=I(d,s,{maxIterations:1e4,failOnMultipleSolutions:!0}),r.length}catch(a){if(a instanceof A)return 2;if(a instanceof ye)return 0;throw a}};for(const s of l){w.debugSleep&&console.log("going to sleep"),c&&await N(0,c),w.debugSleep&&console.log("finished sleep, generating next!");let a=F.shuffle(S.range(0,s.edges.length));a[0]===0&&(a=F.shuffle(a));for(const p of a){const g=i.createDelta();if(g.setFaceValue(s,p),m=n(g),m>=1){g.apply(i),e&&e.emit(d.faces.indexOf(s),p);break}}if(m===1)break}if(m===1)return D(d,i,r[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},Ie=async(d,c=()=>!0,e,u)=>{const i=d.board,l=d.cleanState.clone(),m=F.shuffle(i.faces),r=n=>{try{return I(i,n,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(s){if(s instanceof A)return!0;throw s}};M()&&v(!r(l),"Initial state has multiple solutions"),M()&&v(c(i,l.clone()),"Initial state is not easy enough");for(const n of m){e&&await N(0,e);const s=l.getFaceValue(n);if(s===null){u&&u.emit(i.faces.indexOf(n),null);continue}const a=l.createDelta();a.setFaceValue(n,null),!r(a)&&c(i,a.clone())?(a.apply(l),u&&u.emit(i.faces.indexOf(n),null)):u&&u.emit(i.faces.indexOf(n),s)}return D(d.board,l,d.blackEdges)},Te={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new k(2,50)},height:{label:"Height",type:"integer",range:new k(2,50)}},defaultParameterValues:{width:6,height:10},generate:d=>{const c=d.width,e=d.height;return S.range(0,e).flatMap(u=>S.range(0,c).map(i=>[new h(i,u),new h(i+1,u),new h(i+1,u+1),new h(i,u+1)]))}},Ee={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new k(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new k(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:d=>{const c=d.radius,e=d.isPointyTop,u=d.holeRadius;let i,l;e?(i=new h(Math.sqrt(3),0),l=new h(Math.sqrt(3)/2,3/2)):(i=new h(3/2,Math.sqrt(3)/2),l=new h(0,Math.sqrt(3)));const m=[new h(1,0),new h(1,-1),new h(0,-1),new h(-1,0),new h(-1,1),new h(0,1)],r=S.range(0,6).map(p=>m[p].plus(m[(p+1)%6])),n=p=>r.map(g=>g.plus(p.timesScalar(3))),s=(p,g)=>(Math.abs(p.x-g.x)+Math.abs(p.x+p.y-g.x-g.y)+Math.abs(p.y-g.y))/2,a=[];for(let p=-c;p<=c;p++)for(let g=Math.max(-c,-p-c);g<=Math.min(c,-p+c);g++){const f=new h(p,g);s(f,new h(0,0))>=u&&a.push(n(f).map(b=>i.timesScalar(b.x).plus(l.timesScalar(b.y)).timesScalar(1/3)))}return a}},Fe={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:d=>{const c={6:$,10:j,11:J,13:Q,14:U,20:_}[d.radius];M()&&v(c);const e=.01,u=c.thinShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(m=>m.timesScalar(e)));return[...c.thickShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(m=>m.timesScalar(e))),...u]}},Ae=[Te,o(K,{width:8,height:8}),Ee,o(L,{width:8,height:8,squareRegion:!0}),o(X,{width:5,height:6,squareRegion:!0}),o(Y,{width:6,height:5}),o(Z,{width:9,height:9}),o(ee,{width:9,height:9}),o(se,{width:7,height:8}),o(le),o(re),o(te),o(ae,{squareRegion:!0}),o(ie),o(pe),o(de,{width:9,height:9}),o(ce),o(ge,{width:9,height:9}),o(oe),o(ue),o(he,{width:6,height:8,squareRegion:!0}),o(me),o(fe),Fe];export{Be as A,Ie as a,De as g,N as i,Ae as p,be as s,Oe as w};
