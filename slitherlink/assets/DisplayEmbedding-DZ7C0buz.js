var ho=Object.defineProperty;var uo=(a,e,t)=>e in a?ho(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var f=(a,e,t)=>uo(a,typeof e!="symbol"?e+"":e,t);import{u as po,c as de,R as it,S as go,T as fo,U as So,V as wo,f as yo,g as Co,h as pt,J as Eo,s as gt,i as mo,j as Po,v as ft,k as vo,m as St,w as Fo,n as he,o as Vo,q as To,x as Do,y as Oo,I as ue,G as Ao,E as bo,A as Io,C as No,W as Lo,r as ko}from"./Theme-33Og6UOJ.js";import{E as we,a as ye,d as xo,V as J,k as je,o as Ue,b as pe,T as h,P as Re,l as Ro,c as Bt,C as Mo,B as Qe}from"./Vector2Property-mpypjo8N.js";import{a as z,N as L,F as Le,q as wt,P as K,M as Se,r as yt,T as Wt,G as Bo,C as Ut,h as U,B as be,g as Wo,R as Uo,H as Ht,L as Ho}from"./PhetioControlledVisibilityProperty-C-W8fgEx.js";import{a as nt,b as zo,L as ge,f as Yo,c as Go,P as zt}from"./localStorage-B8VWGy9j.js";import{S as B,d as A,e as b,_ as Ke,ac as Yt,m as jo,H as Ko,ad as Xo,h as Ct,L as Et,ae as _o,k as qo,o as Jo,l as Zo,i as $o}from"./patternBoards-59tNjMFd.js";import{E as v,F as D,S as N,V as lt,d as Gt,e as jt,f as Kt,g as mt,h as Pt,i as rt,j as st,k as Qo,l as er,m as Xe,n as ct,U as et,o as vt,p as tr,q as Ft,r as or,s as rr,t as Vt,u as sr,B as Tt,C as ar}from"./BasicPuzzle-D1EmEwC1.js";import{I as ee,D as _e,J as Fe,S as Xt,K as _t,L as qt,N as Jt,O as Zt,P as $t,Q as ir,R as Qt,T as eo,U as nr,V as to,W as lr,X as cr,Y as Ze,Z as dr,_ as hr,$ as oo,a0 as ur,a1 as pr,a2 as gr,a3 as fr,a4 as Sr,B as wr,C as yr,a5 as oe,A as Cr,a6 as Dt,F as Er,a7 as mr}from"./SATSolver-I2LwIpNX.js";import{A as Pr}from"./SpinningIndicatorNode-BFgzh9_P.js";import{a as vr,B as Fr,R as Vr,b as Tr,c as Dr,d as Or,S as Ar,e as br}from"./PatternRule-DfusC3Hu.js";const Pe=class Pe extends we{};f(Pe,"PAN_ONLY",new Pe),f(Pe,"DRAG_ONLY",new Pe),f(Pe,"enumeration",new ye(Pe));let Me=Pe;const ro=new nt("panDragModeProperty",Me.PAN_ONLY),so=new z([ro],a=>a===Me.DRAG_ONLY);class dt extends L{constructor(t,o,r,s){super();f(this,"triggerDrag");const n=new Set;if(s!=null&&s.delayInteractionEmitter){const g=s==null?void 0:s.delayInteractionEmitter,p=S=>{n.add(S),setTimeout(()=>{n.delete(S)},700)};g.addListener(p),this.disposeEmitter.addListener(()=>g.removeListener(p))}const d=new B,i=t.map(g=>{const p=o(g);return p.makeImmutable(),d.subpaths.push(...p.subpaths),p});this.mouseArea=this.touchArea=d.makeImmutable();const l=g=>{const p=g.trail.globalToLocalPoint(g.pointer.point);for(let S=0;S<i.length;S++){const C=i[S];if(C.bounds.containsPoint(p)&&C.containsPoint(p)){const E=t[S];if(!n.has(E))return E}}return!1},c=(g,p)=>{const S=l(g);S!==!1&&r(S,p)};this.cursor="pointer";const u=new Le({mouseButton:0,fire:g=>{var p;return c(g,(p=g.domEvent)!=null&&p.shiftKey?2:0)}}),w=new Le({mouseButton:2,fire:g=>{var p;return c(g,(p=g.domEvent)!=null&&p.shiftKey?0:2)}}),y=new Le({mouseButton:1,fire:g=>c(g,1)});if(this.disposeEmitter.addListener(()=>{u.dispose(),w.dispose(),y.dispose()}),s!=null&&s.isDragModeProperty){const g=s.isDragModeProperty,p=(F,V)=>{var I,x;const T=l(F);T!==!1?(I=s.onDragStart)==null||I.call(s,T,V):s.noItemItem!==void 0&&((x=s.onDragStart)==null||x.call(s,s.noItemItem,V))},S=F=>{var I,x;const V=F.trail.globalToLocalPoint(F.pointer.point),T=l(F);T!==!1?(I=s.onDrag)==null||I.call(s,T,V):s.noItemItem!==void 0&&((x=s.onDrag)==null||x.call(s,s.noItemItem,V))},C=()=>{var F;(F=s.onDragEnd)==null||F.call(s)},E=F=>F?l(F)!==!1||s.noItemItem!==void 0:!1,m=new wt({mouseButton:0,start:F=>{var V;return p(F,(V=F.domEvent)!=null&&V.shiftKey?2:0)},drag:S,end:C,canStartPress:E}),P=new wt({mouseButton:2,start:F=>{var V;return p(F,(V=F.domEvent)!=null&&V.shiftKey?0:2)},drag:S,end:C,canStartPress:E});this.triggerDrag=F=>{F.domEvent.button===2?P.press(F,this):m.press(F,this)},this.disposeEmitter.addListener(()=>{m.dispose(),P.dispose()});const R=F=>{this.inputListeners=F?[m,P]:[u,w,y]};g.link(R),this.disposeEmitter.addListener(()=>g.unlink(R))}else this.addInputListener(u),this.addInputListener(w),this.addInputListener(y)}}class Ir extends dt{constructor(e,t,o){super(e.edges,r=>{const s=r.start.viewCoordinates,n=r.end.viewCoordinates,d=new B;let i;if(r.faces.length===2)i=[s,r.faces[0].viewCoordinates,n,r.faces[1].viewCoordinates];else{A()&&b(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const l=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;A()&&b(l.previous.face===null),A()&&b(l.next.face===null);const c=l.start.viewCoordinates,u=l.end.viewCoordinates,w=l.previous.start.viewCoordinates,y=l.next.end.viewCoordinates,g=(C,E,m)=>{const P=E.minus(C).normalized(),R=m.minus(E).normalized();let F=P.minus(R);return F.getMagnitude()<1e-6?F=P.getPerpendicular():F=F.normalized(),xo.triangleAreaSigned(C,E,E.plus(F))<0&&(F=F.negated()),F},p=g(w,c,u),S=g(c,u,y);i=[c,r.faces[0].viewCoordinates,u,u.plus(S.times(o.backgroundOffsetDistance)),c.plus(p.times(o.backgroundOffsetDistance))]}return d.polygon(i),d.makeImmutable(),d},o.edgePressListener,{delayInteractionEmitter:t,isDragModeProperty:so,onDragStart:o.onEdgeDragStart,onDrag:o.onEdgeDrag,onDragEnd:o.onEdgeDragEnd})}}class Nr extends L{constructor(e,t,o,r){const s=new K(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),n=new K(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),d=new K(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,n,d],pickable:!1});const i=e.edges.map(p=>v.BLACK);let l=!1,c=!1,u=!1,w=!1,y=null;const g=Se.multilink([t,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(p,S,C,E,m,P,R)=>{if(this.visible=!S,s.visible=C,n.visible=E,d.visible=P,this.visible){let F=!1;for(let V=0;V<e.edges.length;V++){const T=p.getEdgeState(e.edges[V]);T!==i[V]&&(F=!0,i[V]=T)}if(l!==m&&(F=!0,l=m),c!==C&&(F=!0,c=C),u!==E&&(F=!0,u=E),w!==P&&(F=!0,w=P),y!==R&&(F=!0,y=R),F){const V=new B,T=new B,I=new B;for(let x=0;x<e.edges.length;x++){const q=i[x];if(C&&q===v.WHITE){const M=e.edges[x];V.moveTo(M.start.viewCoordinates.x,M.start.viewCoordinates.y),V.lineTo(M.end.viewCoordinates.x,M.end.viewCoordinates.y)}if(q===v.RED){if(E){const M=e.edges[x],W=.07;let O=M.start.viewCoordinates.blend(M.end.viewCoordinates,.5);if(m){const Y=M.end.viewCoordinates.minus(M.start.viewCoordinates).getAngle(),X=new J(-W,-W).rotate(Y).add(O),te=new J(W,W).rotate(Y).add(O),ie=new J(-W,W).rotate(Y).add(O),Ve=new J(W,-W).rotate(Y).add(O);T.moveTo(X.x,X.y),T.lineTo(te.x,te.y),T.moveTo(ie.x,ie.y),T.lineTo(Ve.x,Ve.y)}else T.moveTo(O.x-W,O.y-W),T.lineTo(O.x+W,O.y+W),T.moveTo(O.x-W,O.y+W),T.lineTo(O.x+W,O.y-W)}if(P){const M=e.edges[x],W=.4,O=.017,Y=M.start.viewCoordinates.blend(M.end.viewCoordinates,.5),X=Y.blend(M.start.viewCoordinates,W),te=Y.blend(M.end.viewCoordinates,W);for(let ie=0;ie<5;ie++){const Ve=X.blend(te,ie/4);I.moveTo(Ve.x+O,Ve.y),I.arc(Ve.x,Ve.y,O,0,2*Math.PI,!1)}}}}V.makeImmutable(),T.makeImmutable(),I.makeImmutable(),s.shape=V,n.shape=T,d.shape=I}}});this.disposeEmitter.addListener(()=>g.dispose())}}class Lr extends L{constructor(t,o,r){const s=new L;super({pickable:!1,children:[s]});f(this,"faceColorNodeMap",new Map);f(this,"faceColorIdMap",new Map);f(this,"adjacentFacesMap",new Map);f(this,"faceColorNodeContainer");f(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,t.faces.forEach(l=>{this.adjacentFacesMap.set(l,l.edges.map(c=>c.getOtherFace(l)).filter(c=>c!==null))});{const l=o.value.getFaceColors();for(const c of l)this.addFaceColor(c,o.value.getFacesWithColor(c));this.addDualColorViews(o.value,l)}this.updateHues();let n=o.value.clone();const d=l=>{const c=n;n=l.clone();const u=c.getFaceColors(),w=l.getFaceColors(),y=[],g=[],p=[];Yt(u,w,y,g,p);const S=new Set(y),C=this.removeInvalidDualColorViews(l),E=[...C];for(const m of g)if(C.add(m),this.faceColorIdMap.has(m.id)){const P=this.faceColorIdMap.get(m.id);this.replaceFaceColor(P,m,l.getFacesWithColor(m)),S.delete(P)}else this.addFaceColor(m,l.getFacesWithColor(m));for(const m of p)this.updateFaceColor(m,l.getFacesWithColor(m));for(const m of S)C.delete(m),this.removeFaceColor(m);this.addDualColorViews(l,[...C]),(g.length||y.length||E.length)&&this.updateHues()};o.lazyLink(d),this.disposeEmitter.addListener(()=>o.unlink(d)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const i=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(i),r.theme.faceColorLightHueLUTProperty.lazyLink(i),r.theme.faceColorDarkHueLUTProperty.lazyLink(i),r.theme.faceColorInsideColorProperty.lazyLink(i),r.theme.faceColorOutsideColorProperty.lazyLink(i),r.theme.faceColorDefaultColorProperty.lazyLink(i),r.faceColorThresholdProperty.lazyLink(i),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(i),r.theme.faceColorLightHueLUTProperty.unlink(i),r.theme.faceColorDarkHueLUTProperty.unlink(i),r.theme.faceColorInsideColorProperty.unlink(i),r.theme.faceColorOutsideColorProperty.unlink(i),r.theme.faceColorDefaultColorProperty.unlink(i),r.faceColorThresholdProperty.unlink(i)})}addFaceColor(t,o){const r=new xe(t,o,this.style);this.faceColorNodeMap.set(t,r),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(t,o,r){A()&&b(t.id===o.id);const s=this.faceColorNodeMap.get(t);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const r=this.faceColorNodeMap.get(t);let s=r.faces.length!==o.length;if(!s)for(let n=0;n<o.length;n++){const d=r.faces[n],i=o[n];if(d!==i){s=!0;break}}s&&r.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const n=this.faceColorNodeMap.get(s);A()&&b(n);const d=t.getOppositeFaceColor(s);if(d){A()&&b(r.has(d)),r.delete(d);const i=this.faceColorNodeMap.get(d);A()&&b(i),this.dualColorViews.add(new Ot([n,i],this.style))}else this.dualColorViews.add(new Ot([n],this.style))}}removeInvalidDualColorViews(t){const o=new Set,r=new Set(t.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const n of s.colorNodes)o.add(n.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==D.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new J(0,0),r=()=>{for(const c of t)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(je.nextDouble()-.5,je.nextDouble()-.5).normalize()},s=new Map,n=[];this.board.faces.forEach(c=>{s.set(c,[])});for(const c of t){const u=new Set;for(const y of c.faces)u.add(y);const w=new Set;for(const y of u){w.add(y);for(const g of this.adjacentFacesMap.get(y))w.add(g)}for(const y of w){const g=s.get(y);if(g){if(g.length)for(const p of g){let S=!1;for(const C of n)if(C.a===p&&C.b===c){C.weight++,S=!0;break}S||n.push({a:p,b:c,weight:1})}g.push(c)}}}const d=new Map;for(const c of t)d.set(c,J.ZERO.copy());const i=(c,u,w)=>{const y=d.get(c),g=d.get(u),p=c.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(c.hueVector);S.magnitudeSquared>1e-11&&S.normalize();const C=.2,E=Math.abs(p),m=w*((Math.max(C,E)-C)/(1-C))**3;S.multiplyScalar(m),y.subtract(S),g.add(S)};let l=1;for(let c=0;c<100;c++){l*=.99;for(const u of t)d.get(u).setXY(0,0);for(const u of n){const w=u.a,y=u.b,g=u.weight;i(w,y,g)}if(t.length<8)for(let u=0;u<t.length;u++){const w=t[u];for(let y=u+1;y<t.length;y++)i(w,t[y],.2)}for(const u of t){const w=d.get(u);w.multiplyScalar(l/u.faceCount),u.hueVector.add(w),d.get(u).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const le=class le extends we{};f(le,"BASIC",new le),f(le,"PRIMARY",new le),f(le,"SECONDARY",new le),f(le,"enumeration",new ye(le));let se=le;class Ot{constructor(e,t){f(this,"hueVector");f(this,"faceCount");if(this.colorNodes=e,this.style=t,A()&&b(e.length===1||e.length===2),this.faceCount=Ke.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=se.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],r=o===e[0]?e[1]:e[0];let s;o.type===se.PRIMARY?s=o:r.type===se.PRIMARY||o.type===se.SECONDARY?s=r:(r.type,se.SECONDARY,s=o);const n=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=se.PRIMARY,n.type=se.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class xe extends K{constructor(t,o,r){const s=J.createPolar(1,je.nextDoubleBetween(0,2*Math.PI));super(xe.toShape(o));f(this,"hueVector");f(this,"faceCount");f(this,"dualColorView",null);f(this,"type",se.BASIC);this.faceColor=t,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==D.UNDECIDED?this.fill=xe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const r=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=xe.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(t,o,r,s){const n=r===se.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===se.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,d=(Math.round(t.getAngle()*180/Math.PI)+360)%360;A()&&b(d>=0&&d<n.length);const i=n[d];if(o===D.UNDECIDED)return i;{const c=(o===D.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,u=c.alpha,w=new yt(i);return new yt((1-u)*w.red+u*c.red,(1-u)*w.green+u*c.green,(1-u)*w.blue+u*c.blue).toCSS()}}static toShape(t){const o=new B;for(const r of t)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class kr extends Wt{constructor(e,t){const o=Ue()({font:po,fill:de.uiForegroundColorProperty},t);super(e,o)}}class xr extends L{constructor(e,t,o){super({translation:e.viewCoordinates}),this.face=e;const s=t.value.getFaceState(e),n=s.possibilityCount===0||s.possibilityCount>9;let d;const i=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(n)d=new kr(s.possibilityCount,{font:it,maxWidth:.4,maxHeight:.4});else{const l=new Set(e.vertices);d=new Bo({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(c=>{const u=new L,w=new Set(c.map(p=>p.start)),y=new Set(c.map(p=>p.end)),g=p=>p.minus(e.viewCoordinates);if(u.addChild(new K(B.polygon(e.vertices.map(p=>g(p.viewCoordinates))),{stroke:i,lineWidth:.03,opacity:.2})),w.size){const p=new B;if(c.length===e.edges.length)p.polygon(e.vertices.map(S=>g(S.viewCoordinates)));else{const S=new Set(c);for(;S.size;){const C=[...l].find(P=>[...S].filter(R=>R.start===P||R.end===P).length===1);A()&&b(C);let E=C,m=[...S].find(P=>P.start===E||P.end===E)??null;for(p.moveToPoint(g(E.viewCoordinates));m;)S.delete(m),E=m.getOtherVertex(E),p.lineToPoint(g(E.viewCoordinates)),m=[...S].find(P=>P.start===E||P.end===E)??null}}u.addChild(new K(p,{stroke:i,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const p of e.vertices)!w.has(p)&&!y.has(p)&&u.addChild(new Ut(.1,{fill:i,translation:g(p.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}d.center=J.ZERO,this.addChild(d)}}class Rr extends L{constructor(e,t,o,r){super({pickable:!1});const s=Se.multilink([t,r.faceStateVisibleProperty],(d,i)=>{this.children.forEach(l=>l.dispose()),this.children=[],i&&e.faces.forEach(l=>{this.addChild(new xr(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const n=d=>{this.visible=!d};o.link(n),this.disposeEmitter.addListener(()=>{o.unlink(n),this.children.forEach(d=>d.dispose())})}}class Mr extends dt{constructor(e,t){super(e.faces,o=>o?B.polygon(o.vertices.map(r=>r.viewCoordinates)):new B,t.facePressListener,{isDragModeProperty:so,onDragStart:t.onFaceDragStart,onDrag:t.onFaceDrag,onDragEnd:t.onFaceDragEnd,noItemItem:null})}}const Ne=class Ne{constructor(e,t){this.incorrectEdges=e,this.incorrectFaces=t}isCorrect(){return this.incorrectEdges.size===0&&this.incorrectFaces.size===0}with(e){return this.isCorrect()?e:e.isCorrect()?this:new Ne(new Set([...this.incorrectEdges,...e.incorrectEdges]),new Set([...this.incorrectFaces,...e.incorrectFaces]))}static with(e){return e.reduce((t,o)=>t.with(o),Ne.CORRECT)}};f(Ne,"CORRECT",new Ne(new Set,new Set));let ke=Ne;class At{constructor(e,t,o){f(this,"edgeStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(A()&&b(this.board.edges.includes(e)),t!==v.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new ee(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.edges){const n=t.getEdgeState(s);n!==v.WHITE&&n!==o.getEdgeState(s)&&r.add(s)}return new ke(r,new Set)}}class bt{constructor(e,t,o){f(this,"faceColorsChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){if(s)throw new ee("invalid face color?");const n=new Set([...o.values(),...r.keys(),...o.values()]),d=new Map(this.currentState.getFaceColorMap());for(const c of o.keys())d.set(c,o.get(c));const i=c=>r.has(c)?r.get(c):[...e].includes(c)?this.currentState.getOppositeFaceColor(c):null,l=new Map;for(const c of d.keys()){const u=d.get(c);l.has(u)||l.set(u,new Set([c])),l.get(u).add(c)}for(const c of n){const u=l.get(c);if(!u)continue;const w=[...u];A()&&b(w.length>0);const y=this.solvedState.getFaceColor(w[0]);for(const p of w)if(this.solvedState.getFaceColor(p)!==y)throw new ee("invalid face color");const g=i(c);if(g){let p;if(g.colorState===D.INSIDE?p=this.solvedState.getInsideColor():g.colorState===D.OUTSIDE?p=this.solvedState.getOutsideColor():p=this.solvedState.getFaceColor([...l.get(g)][0]),y===p)throw new ee("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set,s=new Set,n=t.getOutsideColor(),d=t.getInsideColor(),i=o.getOutsideColor(),l=o.getInsideColor();for(const c of t.getFaceColors()){if(s.has(c))continue;const u=t.getOppositeFaceColor(c);s.add(c),u&&s.add(u);const w=t.getFacesWithColor(c),y=u?t.getFacesWithColor(u):[],g=(p,S)=>{o.getFaceColor(p)!==S&&r.add(p)};if(c===n)w.forEach(p=>g(p,i)),y.forEach(p=>g(p,l));else if(c===d)w.forEach(p=>g(p,l)),y.forEach(p=>g(p,i));else if(w.length){let p=w.filter(C=>o.getFaceColor(C)===i).length+y.filter(C=>o.getFaceColor(C)===l).length,S=w.length+y.length;if(p>0&&p<S){const C=p>S/2,E=C?i:l,m=C?l:i;w.forEach(P=>g(P,E)),y.forEach(P=>g(P,m))}}}return new ke(new Set,r)}}class Br{constructor(e,t,o){f(this,"faceStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){A()&&b(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make face ${t} when it should be ${o}`);const r=this.currentState.getFaceState(e);if(!t.isSubsetOf(r))throw new ee("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Wr{constructor(e,t,o){f(this,"faceValueChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new ee("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class It{constructor(e,t,o){f(this,"sectorStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){A()&&b(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.halfEdges){const n=s.edge,d=s.next.edge,i=t.getSectorState(s),l=(o.getEdgeState(n)===v.BLACK?1:0)+(o.getEdgeState(d)===v.BLACK?1:0);i.allows(l)||(r.add(n),r.add(d))}return new ke(r,new Set)}}class Ur{constructor(e,t,o){f(this,"simpleRegionsChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,r){if([...o].length)throw new ee("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Hr{constructor(e,t,o){f(this,"vertexStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){A()&&b(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make vertex ${t} when it should be ${o}`);const r=this.currentState.getVertexState(e);if(!t.isSubsetOf(r))throw new ee("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class zr{constructor(e,t,o){f(this,"anyStateChangedEmitter",new pe);f(this,"edgeStateValidator");f(this,"faceValueValidator");f(this,"simpleRegionDataValidator");f(this,"faceColorValidator");f(this,"sectorStateValidator");f(this,"vertexStateValidator");f(this,"faceStateValidator");A()&&b(e),A()&&b(o),this.edgeStateValidator=new At(e,t,o),this.faceValueValidator=new Wr(e,t,o),this.simpleRegionDataValidator=new Ur(e,t,o),this.faceColorValidator=new bt(e,t,o),this.sectorStateValidator=new It(e,t,o),this.vertexStateValidator=new Hr(e,t,o),this.faceStateValidator=new Br(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,r){this.simpleRegionDataValidator.modifyRegions(e,t,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){this.faceColorValidator.modifyFaceColors(e,t,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){return ke.with([At.getCorrectnessState(e,t,o),bt.getCorrectnessState(e,t,o),It.getCorrectnessState(e,t,o)])}}const Yr=a=>[a.forwardHalf,a.reversedHalf,a.forwardHalf.previous,a.reversedHalf.previous];class Be{constructor(e){this.edge=e,A()&&b(e)}apply(e){e.getEdgeState(this.edge)!==v.WHITE&&e.setEdgeState(this.edge,v.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=e.getOutsideColor(),n=e.getInsideColor(),d=o?e.getFaceColor(o):s,i=r?e.getFaceColor(r):s,l=e.getOppositeFaceColor(d);if(d===i||l===i){const c=[...e.getFacesWithColor(d),...d===s?[null]:[]],u=l?[...e.getFacesWithColor(l),...l===s?[null]:[]]:[],w=[...c,...u],y=p=>{const S=new Set,C=new Set([p]);for(;C.size>0;){const E=C.values().next().value;if(C.delete(E),S.add(E),E){for(const m of E.edges)if(e.getEdgeState(m)!==v.WHITE){const P=m.getOtherFace(E),R=P?e.getFaceColor(P):s;(R===d||R===l)&&!S.has(P)&&C.add(P)}}else for(const m of w)if(m&&!S.has(m))for(const P of m.edges)P.getOtherFace(m)===null&&e.getEdgeState(P)!==v.WHITE&&C.add(m)}return S},g=y(o);if(!g.has(r)){const p=y(r);A()&&b(g.size>0&&p.size>0),A()&&b([...g].every(I=>!p.has(I)));const S=w.filter(I=>!g.has(I)&&!p.has(I)),C=[],E=[],m=new Map,P=new Map,R=(I,x,q)=>{const M=I.filter(O=>(O?e.getFaceColor(O):s)===d),W=I.filter(O=>(O?e.getFaceColor(O):s)===l);if(x!==null)x!==s&&x!==n&&(M.length||E.push(x),q&&!W.length&&E.push(q));else if(A()&&b(I.every(O=>O)),x=new mt(Pt(),D.UNDECIDED),C.push(x),M.length&&W.length){q=new mt(Pt(),D.UNDECIDED),C.push(q),P.set(x,q),P.set(q,x);for(const O of M)A()&&b(O),m.set(O,x);for(const O of W)A()&&b(O),m.set(O,q)}else{const O=M.length?M:W;A()&&b(O.length);for(const Y of O)A()&&b(Y),m.set(Y,x)}},F=[...g],V=[...p],T=Ke.sortBy([...S.length?[S]:[],F,V],I=>-I.length+(I.some(x=>!x)?-1e7:0));for(let I=0;I<T.length;I++)R(T[I],I===0?d:null,I===0?l:null);e.modifyFaceColors(C,E,m,P,!1)}}for(const c of Yr(this.edge))e.setSectorState(c,N.ANY);for(const c of this.edge.vertices)e.setVertexState(c,lt.any(c));for(const c of this.edge.faces)e.setFaceState(c,Gt.any(c,e.getFaceValue(c)))}getUndo(e){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:jt(this.edge)}}static deserializeAction(e,t){const o=Kt(e,t.edge);return new Be(o)}}class We{constructor(e){this.face=e,A()&&b(e)}apply(e){this.face.edges.forEach(t=>{new Be(t).apply(e)})}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:rt(this.face)}}static deserializeAction(e,t){const o=st(e,t.face);return new We(o)}}class ht{constructor(e){this.sector=e,A()&&b(e)}apply(e){e.setSectorState(this.sector,N.ANY);const t=this.sector.end;e.setVertexState(t,lt.any(t));const o=this.sector.face;o&&e.setFaceState(o,Gt.any(o,e.getFaceValue(o)))}getUndo(e){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:Qo(this.sector)}}static deserializeAction(e,t){const o=er(e,t.sector);return new ht(o)}}class tt extends Error{constructor(e){super(e)}}const Nt=(a,e,t)=>{_e(t,a,e,!0)},Gr=(a,e,t)=>new Fe([new Xt(a,e),new _t(a,e),new qt(a,e),new Jt(a,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Zt(a,e,{solveToRed:!0,solveToBlack:!0}),new $t(a,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new ir(a,e),new Qt(a,e),new eo(a,e),new nr(a,e),new to(a,e),new lr(a,e,{solveToRed:!0,solveToBlack:!0}),new cr(a,e),new Ze(a,e,{solveToRed:!0,solveToBlack:!0}),new dr(a,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new hr(a,e),new oo(a,e),new ur(a,e,{solveToRed:!0,solveToBlack:!0}),new pr(a,e),new gr(a,e),new fr(a,e)]),ao=(a,e,t,o)=>(r,s,n)=>{const d=[new Xt(r,s),new _t(r,s)];return(a||e||t||o)&&(d.push(new qt(r,s)),(e||t||o)&&(d.push(new Qt(r,s)),(t||o)&&(d.push(new to(r,s)),o&&d.push(new oo(r,s))))),new Fe(d)},jr={allowEdgeEditProperty:go,allowAbsoluteFaceColorEditProperty:fo,allowFaceColorEditProperty:So,allowSectorEditProperty:wo,edgesVisibleProperty:yo,edgesHaveColorsProperty:Co,faceColorsVisibleProperty:pt,faceColorThresholdProperty:Eo,sectorsVisibleProperty:gt,sectorsNextToEdgesVisibleProperty:mo,sectorsTrivialVisibleProperty:Po,vertexStateVisibleProperty:ft,allVertexStateVisibleProperty:vo,faceStateVisibleProperty:St,whiteLineVisibleProperty:Fo,redLineVisibleProperty:he,verticesVisibleProperty:Vo,smallVertexProperty:To,redXsVisibleProperty:Do,redXsAlignedProperty:Oo,faceValueStyleProperty:ue,redLineStyleProperty:Ao,vertexStyleProperty:bo,joinedLinesJoinProperty:Io,joinedLinesCapProperty:No,safeSolverFactoryProperty:new z([pt,gt,ft,St],(a,e,t,o)=>ao(a,e,t,o)),autoSolverFactoryProperty:Sr,theme:de},Ce=(a,e,t,o,r)=>{const s=ao(a,e,t,o);return{faceColorsVisibleProperty:new be(a),sectorsVisibleProperty:new be(e),vertexStateVisibleProperty:new be(t),faceStateVisibleProperty:new be(o),safeSolverFactoryProperty:new Re(s),autoSolverFactoryProperty:r?new z([r],n=>(d,i,l)=>new Fe([s(d,i,l),n(d,i,l)])):new Re(s)}},Te=new z([wr,yr],(a,e)=>(t,o,r)=>new Fe([new Jt(t,o,{solveJointToRed:!0,solveForcedLineToBlack:a,solveAlmostEmptyToRed:!0},r?void 0:[]),new Zt(t,o,{solveToRed:!0,solveToBlack:a},r?void 0:[]),...e?[new $t(t,o,{solveToRed:!0,solveToBlack:a,resolveAllRegions:!1},r?void 0:[])]:[]])),Kr=new z([Te],a=>(e,t,o)=>new Fe([a(e,t,o),new Ze(e,t,{solveToRed:!0,solveToBlack:!0})])),io=new z([Te],a=>(e,t,o)=>new Fe([a(e,t,o),new eo(e,t,o?void 0:[])])),Xr=new z([io],a=>(e,t,o)=>new Fe([a(e,t,o),new Ze(e,t,{solveToRed:!0,solveToBlack:!0})])),_r=a=>({...Ce(!0,!1,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),qr=a=>({...Ce(!0,!1,!1,!1,Kr),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Jr=a=>({...Ce(!0,!1,!1,!1,new Re((e,t,o)=>new Fe([new Ze(e,t,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:a,allowEdgeEditProperty:new h(!1),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!1),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Zr=a=>({...Ce(!1,!1,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),qs=a=>({...Ce(!1,!0,!1,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),$r=a=>({...Ce(!0,!0,!1,!1,io),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Qr=a=>({...Ce(!0,!0,!1,!1,Xr),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),es=a=>({...Ce(!0,!1,!0,!1,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),ts=a=>({...Ce(!0,!1,!1,!0,Te),theme:a,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),os=_r(de),rs=qr(de),ss=Jr(de),no=Zr(de),as=$r(de),is=Qr(de),ns=es(de),ls=ts(de),ot={basicLines:os,basicFaceColoring:rs,pureFaceColor:ss,classic:no,basicSectors:as,sectorsWithColors:is,vertexState:ns,faceState:ls,custom:jr},Lt=no,cs=a=>({allowEdgeEditProperty:new U(a,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new U(a,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new U(a,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new U(a,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new U(a,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new U(a,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new U(a,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new U(a,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new U(a,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new U(a,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new U(a,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new U(a,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new U(a,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new U(a,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new U(a,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new U(a,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new U(a,{derive:"verticesVisibleProperty"}),smallVertexProperty:new U(a,{derive:"smallVertexProperty"}),redXsVisibleProperty:new U(a,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new U(a,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new U(a,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new U(a,{derive:"redLineStyleProperty"}),vertexStyleProperty:new U(a,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new U(a,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new U(a,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new U(a,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new U(a,{derive:"autoSolverFactoryProperty"}),theme:Lo(new z([a],e=>e.theme))}),ds=new zo("puzzleStyle",{serialize:a=>Object.keys(ot).find(e=>ot[e]===a),deserialize:a=>a?ot[a]??Lt:Lt}),_=cs(ds),Js=new ge("showPuzzleStyleProperty",!0),Zs=new ge("showPuzzleTimerProperty",!1),$s=new ge("showSectorViewModesProperty",!1),H=class H extends we{constructor(e){super(),this.isEnabledProperty=e}};f(H,"EDGE_STATE",new H(_.allowEdgeEditProperty)),f(H,"EDGE_STATE_REVERSED",new H(_.allowEdgeEditProperty)),f(H,"FACE_COLOR_INSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),f(H,"FACE_COLOR_OUTSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),f(H,"FACE_COLOR_MATCH",new H(_.allowFaceColorEditProperty)),f(H,"FACE_COLOR_OPPOSITE",new H(_.allowFaceColorEditProperty)),f(H,"SECTOR_STATE",new H(_.allowSectorEditProperty)),f(H,"VERTEX_STATE",new H(_.vertexStateVisibleProperty)),f(H,"FACE_STATE",new H(_.faceStateVisibleProperty)),f(H,"FACE_VALUE",new H(new be(!1))),f(H,"DELETE_FACE",new H(new be(!1))),f(H,"enumeration",new ye(H));let k=H;const G=new nt("editModeProperty",k.EDGE_STATE);k.enumeration.values.forEach(a=>{a.isEnabledProperty.lazyLink(e=>{if(!G.value.isEnabledProperty.value){const t=k.enumeration.values.find(o=>o.isEnabledProperty.value)??null;t&&(G.value=t)}})});const He=new ge("eraserEnabledProperty",!1),Qs=a=>{a.isEnabledProperty.value&&(G.value=a)},hs=new z([G],a=>a===k.EDGE_STATE||a===k.EDGE_STATE_REVERSED),ut=new z([G],a=>a===k.FACE_COLOR_MATCH||a===k.FACE_COLOR_OPPOSITE),ea=ut,us=new z([G],a=>a===k.FACE_COLOR_OUTSIDE||a===k.FACE_COLOR_INSIDE),ps=new z([G],a=>a===k.SECTOR_STATE),gs=new z([G],a=>a===k.VERTEX_STATE),fs=new z([G,ut,us],(a,e,t)=>e||t||a===k.FACE_STATE||a===k.FACE_VALUE||a===k.DELETE_FACE),re=class re extends we{};f(re,"NONE",new re),f(re,"ABSOLUTE_PAINT",new re),f(re,"MAKE_SAME",new re),f(re,"MAKE_OPPOSITE",new re),f(re,"enumeration",new ye(re));let Z=re;class Ss{constructor(e){f(this,"paintFaceSet",new Set);f(this,"paintFaceOppositeSet",new Set);f(this,"absolutePaintState",D.INSIDE);f(this,"lastFace",null);f(this,"faceDragStateProperty",new h(Z.NONE));f(this,"dragIndex",0);this.board=e}isNoOpSingleFace(){return(this.faceDragStateProperty.value===Z.MAKE_SAME||this.faceDragStateProperty.value===Z.MAKE_OPPOSITE)&&this.paintFaceSet.size===1&&this.paintFaceOppositeSet.size===0}onAbsolutePaintStart(e,t){this.faceDragStateProperty.value=Z.ABSOLUTE_PAINT,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeSameStart(e){this.faceDragStateProperty.value=Z.MAKE_SAME,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=D.UNDECIDED,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeOppositeStart(e){this.faceDragStateProperty.value=Z.MAKE_OPPOSITE,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=D.UNDECIDED,this.lastFace=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(e){const r=e.viewCoordinates.distance(t),s=e.vertices.map(n=>n.viewCoordinates.distance(t)).reduce((n,d)=>Math.min(n,d),Number.POSITIVE_INFINITY);if(r>.3&&s/r<.7)return!1}const o=this.lastFace;return this.lastFace=e,!this.paintFaceSet.has(e)&&!this.paintFaceOppositeSet.has(e)?(this.faceDragStateProperty.value===Z.MAKE_OPPOSITE&&this.paintFaceSet.has(o)?(A()&&b(!this.paintFaceSet.has(e)),this.paintFaceOppositeSet.add(e)):(A()&&b(!this.paintFaceOppositeSet.has(e)),this.paintFaceSet.add(e)),!0):!1}onDragEnd(){this.faceDragStateProperty.value=Z.NONE}}const $=class $ extends we{};f($,"DEFAULT",new $),f($,"LOADING",new $),f($,"SEARCHING",new $),f($,"FOUND",new $),f($,"NOT_FOUND",new $),f($,"enumeration",new ye($));let ne=$;const ce=class ce extends we{};f(ce,"NONE",new ce),f(ce,"LINE_DRAG",new ce),f(ce,"EDGE_PAINT",new ce),f(ce,"enumeration",new ye(ce));let ae=ce;class ws{constructor(e){f(this,"edgeStack",[]);f(this,"vertexStack",[]);f(this,"paintEdgeSet",new Set);f(this,"paintEdgeState",v.WHITE);f(this,"lineDragStateProperty",new h(ae.NONE));f(this,"dragIndex",0);this.board=e}onLineDragStart(e){this.lineDragStateProperty.value=ae.LINE_DRAG,this.edgeStack.length=0,this.edgeStack.push(e),this.vertexStack.length=0,this.dragIndex=Math.ceil(Math.random()*1e10)}onPaintDragStart(e,t){this.lineDragStateProperty.value=ae.EDGE_PAINT,this.paintEdgeSet.clear(),this.paintEdgeSet.add(e),this.paintEdgeState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(this.lineDragStateProperty.value===ae.LINE_DRAG){const o=this.edgeStack[this.edgeStack.length-1],r=this.edgeStack.length>1?this.edgeStack[this.edgeStack.length-2]:null;if(e===o)return!1;if(e===r)return this.edgeStack.pop(),this.vertexStack.pop(),!0;if(this.edgeStack.includes(e))return!1;if(this.vertexStack.length===0){const s=o.vertices.find(n=>e.vertices.includes(n))??null;return s?(this.edgeStack.push(e),this.vertexStack.push(s),!0):!1}else{const s=this.vertexStack[this.vertexStack.length-1];if(e.vertices.includes(s))return this.edgeStack.pop(),this.edgeStack.push(e),!0;{const n=o.getOtherVertex(s);return e.vertices.includes(n)?(this.edgeStack.push(e),this.vertexStack.push(n),!0):!1}}}else if(this.lineDragStateProperty.value===ae.EDGE_PAINT){const o=e.start.viewCoordinates.distance(e.end.viewCoordinates),r=Math.min(...e.vertices.map(n=>n.viewCoordinates.distance(t))),s=Math.min(...e.faces.map(n=>n.viewCoordinates.distance(t)));if(Math.min(r,s)/o<.3)return!1;if(!this.paintEdgeSet.has(e))return this.paintEdgeSet.add(e),!0}return!1}onDragEnd(){this.lineDragStateProperty.value=ae.NONE}}const j=class j extends we{constructor(e,t,o){super(),this.fromWhite=e,this.fromBlack=t,this.fromRed=o}apply(e){return e===v.WHITE?this.fromWhite:e===v.BLACK?this.fromBlack:this.fromRed}};f(j,"CYCLE",new j(v.BLACK,v.RED,v.WHITE)),f(j,"REVERSE_CYCLE",new j(v.RED,v.WHITE,v.BLACK)),f(j,"BLACK_TOGGLE",new j(v.BLACK,v.WHITE,v.BLACK)),f(j,"RED_TOGGLE",new j(v.RED,v.RED,v.WHITE)),f(j,"WHITE_SET",new j(v.WHITE,v.WHITE,v.WHITE)),f(j,"BLACK_SET",new j(v.BLACK,v.BLACK,v.BLACK)),f(j,"RED_SET",new j(v.RED,v.RED,v.RED)),f(j,"enumeration",new ye(j));let Ee=j;const Q=class Q extends we{constructor(e,t,o){super(),this.fromUndecided=e,this.fromInside=t,this.fromOutside=o}apply(e){return e===D.UNDECIDED?this.fromUndecided:e===D.OUTSIDE?this.fromOutside:this.fromInside}};f(Q,"CYCLE",new Q(D.INSIDE,D.OUTSIDE,D.UNDECIDED)),f(Q,"REVERSE_CYCLE",new Q(D.OUTSIDE,D.UNDECIDED,D.INSIDE)),f(Q,"INSIDE_TOGGLE",new Q(D.INSIDE,D.UNDECIDED,D.INSIDE)),f(Q,"OUTSIDE_TOGGLE",new Q(D.OUTSIDE,D.OUTSIDE,D.UNDECIDED)),f(Q,"UNDECIDED_SET",new Q(D.UNDECIDED,D.UNDECIDED,D.UNDECIDED)),f(Q,"enumeration",new ye(Q));let me=Q;const ve=class ve extends we{constructor(e,t){super(),this.edgePressStyles=e,this.faceColorPressStyles=t}};f(ve,"CYCLIC",new ve([Ee.CYCLE,Ee.WHITE_SET,Ee.REVERSE_CYCLE],[me.CYCLE,me.UNDECIDED_SET,me.REVERSE_CYCLE])),f(ve,"TOGGLE",new ve([Ee.BLACK_TOGGLE,Ee.WHITE_SET,Ee.RED_TOGGLE],[me.INSIDE_TOGGLE,me.UNDECIDED_SET,me.OUTSIDE_TOGGLE])),f(ve,"enumeration",new ye(ve));let at=ve;const ze=new nt("stateTransitionModeProperty",at.CYCLIC);class qe{constructor(e,t,o){this.edges=e,this.state=t,this.dragIndex=o}apply(e){for(const t of this.edges)e.setEdgeState(t,this.state)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.edges.length===0}serializeAction(){return{type:"UserEdgeDragAction",edges:this.edges.map(e=>jt(e)),state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new qe(t.edges.map(o=>Kt(e,o)),v.enumeration.getValue(t.state),t.dragIndex)}}class Je{constructor(e,t,o,r,s){this.primaryFaces=e,this.secondaryFaces=t,this.isAbsolute=o,this.state=r,this.dragIndex=s}apply(e){if(console.log(this.state,this.primaryFaces,this.secondaryFaces),this.state!==D.UNDECIDED){const t=this.state===D.OUTSIDE;console.log("absolute",t?"outside":"inside");const o=t?e.getOutsideColor():e.getInsideColor();for(const r of this.primaryFaces){const s=r?e.getFaceColor(r):e.getOutsideColor();o!==s&&new Xe(oe(e,s),{type:"absolute",isOutside:t}).apply(e)}}else if(this.isAbsolute){console.log("absolute erase");for(const t of this.primaryFaces)t&&new We(t).apply(e)}else{console.log("normal");const t=o=>{for(let r=1;r<o.length;r++){const s=o[r-1],n=o[r],d=s?e.getFaceColor(s):e.getOutsideColor(),i=n?e.getFaceColor(n):e.getOutsideColor();d!==i&&new Xe(oe(e,d),oe(e,i)).apply(e)}};if(t(this.primaryFaces),t(this.secondaryFaces),this.primaryFaces.length&&this.secondaryFaces.length){const o=this.primaryFaces[0],r=this.secondaryFaces[0],s=o?e.getFaceColor(o):e.getOutsideColor(),n=r?e.getFaceColor(r):e.getOutsideColor();new ct(oe(e,s),oe(e,n)).apply(e)}}}getUndo(e){throw new Error("unimplemented")}isEmpty(){return(this.primaryFaces.length===0||this.state===D.UNDECIDED&&this.primaryFaces.length===1)&&this.secondaryFaces.length===0}serializeAction(){return{type:"UserFaceDragAction",primaryFaces:this.primaryFaces.map(e=>e?rt(e):null),secondaryFaces:this.secondaryFaces.map(e=>e?rt(e):null),isAbsolute:this.isAbsolute,state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new Je(t.primaryFaces.map(o=>o?st(e,o):null),t.secondaryFaces.map(o=>o?st(e,o):null),t.isAbsolute,D.enumeration.getValue(t.state),t.dragIndex)}}class ys{constructor(e){this.hintAction=e}get annotation(){return this.hintAction.annotation}apply(e){this.hintAction.apply(e)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}const Cs=a=>a instanceof jo?{type:"SquareBoard",width:a.width,height:a.height}:a instanceof Ko?{type:"HexagonalBoard",radius:a.radius,scale:a.scale,isPointyTop:a.isPointyTop,holeRadius:a.holeRadius}:{type:"BaseBoard",vertices:a.vertices.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vx:e.viewCoordinates.x,vy:e.viewCoordinates.y})),faces:a.faces.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vertices:e.vertices.map(t=>a.vertices.indexOf(t))}))},lo=a=>({version:1,board:Cs(a.board),state:a.stateProperty.value.serializeState(a.board)}),Es=a=>{const e=lo(a);return Xo(JSON.stringify(e))},ms=a=>{const e=lo(a),t=a.solution.cleanState.serializeState(a.board),o=a.solution.solvedState.serializeState(a.board),r=[...a.solution.blackEdges].map(s=>a.board.edges.indexOf(s));return{puzzle:e,cleanState:t,solvedState:o,blackEdges:r}};function Ps(a){return new Worker(""+new URL("hintWorker-C0UQluhd.js",import.meta.url).href,{name:a==null?void 0:a.name})}let De=null;const Ge=new h(!1),co=()=>(De||(De=new Ps,De==null||De.addEventListener("message",a=>{a.data.type==="hint-worker-loaded"&&(Ge.value=!0)})),De);co();const vs=new ge("uiHintUsesBuiltInSolve",!1),ta=new ge("showUndoRedoAllProperty",!1),kt=new ge("dimCompletedNumbersProperty",!0),xt=new ge("highlightIncorrectNumbersProperty",!0),oa=new ge("highlightIncorrectMovesProperty",!0),Fs=new ge("highlightIntersectionsProperty",!0),ra=new Yo("highlightIncorrectMovesDelayProperty",.7);class sa extends Ro{constructor(t,o){const r=Ue()({style:_,initialTimeElapsed:0},o),s=r.style;super();f(this,"timeElapsedProperty",new h(0));f(this,"hintStateProperty",new h(ne.DEFAULT));f(this,"edgeAutoSolvedEmitter",new pe);f(this,"stack");f(this,"stackLengthProperty",new h(0));f(this,"stackPositionProperty",new h(0));f(this,"undoPossibleProperty");f(this,"redoPossibleProperty");f(this,"currentSnapshotProperty");f(this,"hasErrorProperty");f(this,"correctnessStateProperty");f(this,"isSolvedProperty");f(this,"hintWorkerMessageID",0);f(this,"addedHintListener",!1);f(this,"pendingHintActionProperty",new h(null));f(this,"displayedAnnotationProperty");f(this,"pendingActionFaceColorProperty",new h(null));f(this,"pendingActionSectorProperty",new h(null));f(this,"selectedFaceColorHighlightProperty");f(this,"selectedSectorEditProperty");f(this,"autoSolverFactoryProperty");f(this,"style");f(this,"lineDrag");f(this,"faceDrag");this.puzzle=t,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.lineDrag=new ws(t.board),this.faceDrag=new Ss(t.board),this.autoSolverFactoryProperty=new z([Cr,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(i,l,c)=>i?c:l),this.displayedAnnotationProperty=new z([this.pendingHintActionProperty],i=>i?i.annotation:null);const n=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(n),G.lazyLink(n),this.disposeEmitter.addListener(()=>G.unlink(n)),this.selectedFaceColorHighlightProperty=new z([t.stateProperty,G,this.pendingActionFaceColorProperty],(i,l,c)=>{if((l===k.FACE_COLOR_MATCH||l===k.FACE_COLOR_OPPOSITE)&&c){const u=i.getFacesWithColor(c.color);return{faceColor:c.color,face:c.face,faces:u}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new z([t.stateProperty,G,this.pendingActionSectorProperty],(i,l,c)=>l===k.SECTOR_STATE&&c?{sector:c,currentState:i.getSectorState(c)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const i=t.stateProperty.value.clone();Nt(t.board,i,this.style.safeSolverFactoryProperty.value),t.stateProperty.value=i}this.stack=[this.getSnapshot(null,t.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new z([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new z([this.currentSnapshotProperty],i=>!i.correctnessState.isCorrect()),this.correctnessStateProperty=new z([this.currentSnapshotProperty],i=>i.correctnessState),this.isSolvedProperty=new z([this.currentSnapshotProperty],i=>{if(i.state.getWeirdEdges().length||i.state.hasInvalidFaceColors())return!1;const l=i.state.getSimpleRegions();return l.length===1&&l[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new z([this.stackPositionProperty],i=>i>0),this.redoPossibleProperty=new z([this.stackPositionProperty,this.stackLengthProperty],(i,l)=>i<l-1);const d=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(d),this.style.safeSolverFactoryProperty.lazyLink(d),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(d),this.style.safeSolverFactoryProperty.unlink(d)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(t){this.isSolvedProperty.value||(this.timeElapsedProperty.value+=Math.min(t,5),localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value)))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Es(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(t){this.wipeStackTop(),this.stack.push(t),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(t,o){const r=(o==null?void 0:o.forceDirty)||t instanceof et;let n=this.stack[this.stackPositionProperty.value].state;o!=null&&o.erase&&(n=n.clone(),o.erase(n));let d=new Set;const i=u=>{d.add(u)};let l=n.createDelta();try{if(l.edgeStateChangedEmitter.addListener(i),Dt(this.autoSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(i),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(l)))throw new tt("Auto-solver did not respect user action")}catch(u){if(d=new Set,u instanceof ee||u instanceof tt)u instanceof ee?console.log("error"):u instanceof tt&&console.log("skipping autosolve due to undo"),l=n.createDelta(),l.edgeStateChangedEmitter.addListener(i),Dt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(i);else throw u}const c=n.clone();l.apply(c),this.pushTransitionAtCurrentPosition(this.getSnapshot(t,c));for(const u of d)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(u))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(u))}computeCorrectnessState(t=this.puzzle.stateProperty.value){return zr.getCorrectnessState(this.puzzle.board,t,this.puzzle.solution.solvedState)}getSnapshot(t,o){return new Vs(this.puzzle.board,t,o,this.computeCorrectnessState(o))}addAutoSolveDelta(){const t=this.puzzle.stateProperty.value.createDelta();try{if(_e(this.autoSolverFactoryProperty.value,this.puzzle.board,t,!0),!t.isEmpty()){const o=this.puzzle.stateProperty.value.clone();t.apply(o),this.pushTransitionAtCurrentPosition(this.getSnapshot(new et,o))}}catch(o){if(!(o instanceof ee))throw o}}onAutoSolveChange(){const t=this.stack[this.stackPositionProperty.value];t.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(t.action||new et,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(t,o,r){r&&(o=2-o);const s=ze.value.edgePressStyles[o];return console.log(ze.value,s,o,t),s.apply(t)}getNewFaceColorState(t,o,r){r&&(o=2-o);const s=ze.value.faceColorPressStyles[o];return console.log(ze.value,s,o,t),s.apply(t)}getNextEdgeState(t,o){const r=He.value,s=this.puzzle.stateProperty.value.getEdgeState(t);return r?v.WHITE:this.getNewEdgeState(s,o,G.value===k.EDGE_STATE_REVERSED)}getNextFaceColorState(t,o){const r=this.puzzle.stateProperty.value.getOutsideColor(),s=this.puzzle.stateProperty.value.getInsideColor(),n=this.puzzle.stateProperty.value.getFaceColor(t),d=n===r?D.OUTSIDE:n===s?D.INSIDE:D.UNDECIDED;return this.getNewFaceColorState(d,o,G.value===k.FACE_COLOR_OUTSIDE)}onUserEdgePress(t,o){const r=this.puzzle.stateProperty.value.getEdgeState(t),s=this.getNextEdgeState(t,o);if(r!==s){const n=this.stack[this.stackPositionProperty.value];n.action&&n.action instanceof vt&&n.action.edge===t&&this.stackPositionProperty.value--;let d;r!==v.WHITE&&(d=l=>{new Be(t).apply(l)});const i=new vt(t,s);this.applyUserActionToStack(i,{erase:d,checkAutoSolve:l=>l.getEdgeState(t)===s,excludedEdges:new Set([t])}),this.updateState()}}onUserEdgeDragStart(t,o){if(this.lineDrag.lineDragStateProperty.value!==ae.NONE)return;const r=this.getNextEdgeState(t,o);r===v.BLACK?this.lineDrag.onLineDragStart(t):this.lineDrag.onPaintDragStart(t,r),this.updateEdgeDrag()}onUserEdgeDrag(t,o){this.lineDrag.onDrag(t,o)&&this.updateEdgeDrag()}onUserEdgeDragEnd(){this.lineDrag.onDragEnd()}updateEdgeDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof qe&&t.action.dragIndex===this.lineDrag.dragIndex&&this.stackPositionProperty.value--,A()&&b(this.lineDrag.lineDragStateProperty.value!==ae.NONE,"line drag state should not be NONE");const o=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?this.lineDrag.edgeStack.slice():Array.from(this.lineDrag.paintEdgeSet),r=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?v.BLACK:this.lineDrag.paintEdgeState,s=o.filter(i=>this.puzzle.stateProperty.value.getEdgeState(i)!==v.WHITE),n=new tr(s.map(i=>new Be(i))),d=new qe(o,r,this.lineDrag.dragIndex);this.applyUserActionToStack(d,{erase:i=>n.apply(i),checkAutoSolve:i=>o.every(l=>i.getEdgeState(l)===r),excludedEdges:new Set(this.puzzle.board.edges)}),this.updateState()}onUserFacePress(t,o){const r=He.value,s=G.value;if(r){if(t){const n=new We(t);this.applyUserActionToStack(n,{erase:d=>n.apply(d)}),this.updateState()}}else if(s===k.FACE_COLOR_MATCH||s===k.FACE_COLOR_OPPOSITE){let n=G.value===k.FACE_COLOR_MATCH;o===2&&(n=!n);const d=t?this.puzzle.stateProperty.value.getFaceColor(t):this.puzzle.stateProperty.value.getOutsideColor(),i=this.pendingActionFaceColorProperty.value;if(i){if(t!==i.face){const l=i.color;l!==d&&(n?this.applyUserActionToStack(new Xe(oe(this.puzzle.stateProperty.value,d),oe(this.puzzle.stateProperty.value,l))):this.applyUserActionToStack(new ct(oe(this.puzzle.stateProperty.value,d),oe(this.puzzle.stateProperty.value,l))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:t,color:d}}else if((s===k.FACE_COLOR_OUTSIDE||s===k.FACE_COLOR_INSIDE)&&t){const n=this.puzzle.stateProperty.value.getOutsideColor(),d=this.puzzle.stateProperty.value.getInsideColor(),i=this.puzzle.stateProperty.value.getFaceColor(t),l=i===n?D.OUTSIDE:i===d?D.INSIDE:D.UNDECIDED,c=this.getNewFaceColorState(l,o,s===k.FACE_COLOR_OUTSIDE);if(l!==c){const u=this.stack[this.stackPositionProperty.value];u.action&&u.action instanceof Ft&&u.action.face===t&&this.stackPositionProperty.value--;let w;const y=new We(t);l!==D.UNDECIDED&&(w=g=>{y.apply(g)}),c===D.UNDECIDED?this.applyUserActionToStack(y,{erase:w}):this.applyUserActionToStack(new Ft(t,c===D.INSIDE),{erase:w}),this.updateState()}}}onUserFaceDragStart(t,o){if(this.faceDrag.faceDragStateProperty.value!==Z.NONE)return;const r=G.value;if(He.value)this.faceDrag.onAbsolutePaintStart(t,D.UNDECIDED);else if(r===k.FACE_COLOR_MATCH||r===k.FACE_COLOR_OPPOSITE)r===k.FACE_COLOR_MATCH==(o===0)?this.faceDrag.onMakeSameStart(t):this.faceDrag.onMakeOppositeStart(t);else if(r===k.FACE_COLOR_INSIDE||r===k.FACE_COLOR_OUTSIDE){const s=t?this.getNextFaceColorState(t,o):k.FACE_COLOR_OUTSIDE;this.faceDrag.onAbsolutePaintStart(t,s)}this.updateFaceDrag()}onUserFaceDrag(t,o){this.faceDrag.onDrag(t,o)&&this.updateFaceDrag()}onUserFaceDragEnd(){if(this.faceDrag.isNoOpSingleFace()){const t=G.value===k.FACE_COLOR_MATCH==(this.faceDrag.faceDragStateProperty.value===Z.MAKE_SAME);this.onUserFacePress([...this.faceDrag.paintFaceSet][0],t?0:2)}this.faceDrag.onDragEnd()}updateFaceDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof Je&&t.action.dragIndex===this.faceDrag.dragIndex&&this.stackPositionProperty.value--;const o=this.faceDrag.faceDragStateProperty.value;if(A()&&b(o!==Z.NONE,"line drag state should not be NONE"),this.faceDrag.isNoOpSingleFace())return;const r=[...this.faceDrag.paintFaceSet],s=o===Z.MAKE_OPPOSITE?[...this.faceDrag.paintFaceOppositeSet]:[],n=this.faceDrag.absolutePaintState,d=o===Z.ABSOLUTE_PAINT,i=new Je(r,s,d,n,this.faceDrag.dragIndex);this.applyUserActionToStack(i,{checkAutoSolve:l=>{if(r.length){const c=r[0]?l.getFaceColor(r[0]):l.getOutsideColor();if(r.some(u=>(u?l.getFaceColor(u):l.getOutsideColor())!==c))return!1;if(s.length){const u=s[0]?l.getFaceColor(s[0]):l.getOutsideColor();if(s.some(w=>(w?l.getFaceColor(w):l.getOutsideColor())!==u)||l.getOppositeFaceColor(c)!==u)return!1}}return!0}}),this.updateState()}onUserSectorPress(t,o){if(He.value){const s=new ht(t);this.applyUserActionToStack(s,{erase:n=>s.apply(n)}),this.updateState()}else this.pendingActionSectorProperty.value=t}onUserSectorSet(t,o){this.applyUserActionToStack(new or(t,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const t=this.puzzle.stateProperty.value;if(!rr(t))if(vs.value){const o=t.clone();_e(Gr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Vt,o)),this.updateState()}else{const o=Er(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,v.BLACK)}),Nt(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Vt,r)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ne.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(t){this.hintStateProperty.value=t?ne.FOUND:ne.NOT_FOUND,t&&(this.pendingHintActionProperty.value=t)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const t=_.allowEdgeEditProperty.value,o=_.allowFaceColorEditProperty.value,r=_.allowSectorEditProperty.value,s=_.vertexStateVisibleProperty.value,n=_.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const d=co();if(!this.addedHintListener){this.addedHintListener=!0;const i=l=>{if(l.data.type==="hint-response"&&l.data.id===this.hintWorkerMessageID){const c=l.data.action?sr(this.puzzle.board,l.data.action):null;this.onHintReceived(c)}};d.addEventListener("message",i),this.disposeEmitter.addListener(()=>self.removeEventListener("message",i))}if(d.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:t,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:n,serializedSolvablePuzzle:ms(this.puzzle)}),Ge.value)this.hintStateProperty.value=ne.SEARCHING;else{this.hintStateProperty.value=ne.LOADING;const i=l=>{l&&(this.hintStateProperty.value===ne.LOADING&&(this.hintStateProperty.value=ne.SEARCHING),Ge.unlink(i))};Ge.link(i)}}onUserApplyHint(){const t=this.pendingHintActionProperty.value;t&&(this.clearPendingHint(),this.applyUserActionToStack(new ys(t)),this.updateState())}}class Vs{constructor(e,t,o,r){this.board=e,this.action=t,this.state=o,this.correctnessState=r}}class Ts extends L{constructor(e,t,o,r){super({pickable:!1}),this.board=e;const s=e.faces.map(l=>null),n=()=>{const l=[],c=o.faceValueStyleProperty.value,u=o.theme.faceValueColorProperty.value,w=o.theme.faceValueCompletedColorProperty.value,y=o.theme.faceValueErrorColorProperty.value,g=o.theme.faceValueRatioColorProperty.value,p=o.faceStateVisibleProperty.value,S=kt.value,C=xt.value;this.visible=!p;for(let E=0;E<e.faces.length;E++){const m=s[E];if(m!==null){const P=e.faces[E],R=new Wo("",Bt({subScale:.7},r==null?void 0:r.textOptions)),F=Se.multilink([t],V=>{let T,I,x=!1,q=!1;if(m===null)T="",I=null;else{let M=0,W=0;for(const O of P.edges){const Y=V.getEdgeState(O);Y===v.BLACK?M++:Y===v.WHITE&&W++}if(c==="static"||m===0)T=`${m}`;else if(c==="remaining")T=`${m-M}`,x=M>0;else if(c==="ratio")m-M===0?T="0":(T=`${m-M}<sub style="color: ${g.toCSS()};">/<sub>${W}</sub></sub>`,q=!0),x=M>0;else throw new Error(`unhandled faceValueStyle: ${c}`);M>m&&C?I=y:M===m&&S?I=w:I=u}R.string=T,R.fill=I,R.maxWidth=q?.8:.9,R.maxHeight=q?.8:.9,R.center=P.viewCoordinates});R.disposeEmitter.addListener(()=>F.dispose()),l.push(R)}}this.children.forEach(E=>E.dispose()),this.children=l},d=Se.multilink([t],l=>{let c=!1;for(let u=0;u<e.faces.length;u++){const w=l.getFaceValue(e.faces[u]);w!==s[u]&&(c=!0,s[u]=w)}c&&n()}),i=Se.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,kt,xt],n);this.disposeEmitter.addListener(()=>{d.dispose(),i.dispose(),this.children.forEach(l=>l.dispose())})}}const Ds=(a,e,t)=>{const o=new Le({mouseButton:0,fire:n=>{var d;return e&&e((d=n.domEvent)!=null&&d.shiftKey?2:0)}}),r=new Le({mouseButton:2,fire:n=>{var d;return e&&e((d=n.domEvent)!=null&&d.shiftKey?0:2)}}),s=new Le({mouseButton:1,fire:n=>e&&e(1)});a.addInputListener({down:n=>{ro.value===Me.DRAG_ONLY&&t&&t(n)}}),a.addInputListener(o),a.addInputListener(r),a.addInputListener(s),a.cursor="pointer",a.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class $e extends L{constructor(e,t,o,r){const s=Ue()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceBackgroundDragStartListener:()=>{},noninteractive:!1},r);super({pickableProperty:ut}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!s.noninteractive&&Ds(this,g=>s.facePressListener(null,g),s.faceBackgroundDragStartListener);const n=e.map(g=>g.start.viewCoordinates),d=s.useBackgroundOffsetStroke,i=s.backgroundOffsetDistance,c=Ct(n)>0?-i:i,u=g=>{const p=new _o;p.addShape(0,g),p.computeSimplifiedFaces(),p.computeFaceInclusion(E=>E[0]>0);const S=p.createFilledSubGraph(),C=S.facesToShape();return p.dispose(),S.dispose(),C},w=$e.getOffsetBackgroundShape(e,d,i),y=t.map(g=>{const p=g.map(C=>C.start.viewCoordinates),S=B.polygon(p);if(d)return u(S.getOffsetShape(c));{const E=S.getStrokedShape(new Et({lineWidth:2*i})).subpaths.map(m=>new B([m]));return u(Ke.minBy(E,m=>m.getArea()))}});this.children=[new K(w,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...y.map(g=>new K(g,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const r=e.map(i=>i.start.viewCoordinates),s=B.polygon(r),d=Ct(r)>0?-o:o;if(t)return s.getOffsetShape(d).getSimplifiedAreaShape();{const i=s.getStrokedShape(new Et({lineWidth:2*o})),l=i.subpaths.map(c=>new B([c]));try{return i.bounds.width===9.718028227819117?B.bounds(i.bounds):Ke.maxBy(l,c=>c.getArea()).getSimplifiedAreaShape()}catch{return B.bounds(i.bounds)}}}}class fe extends L{static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,n=o.minus(r),d=s.minus(r),i=n.normalized(),c=d.normalized().minus(i).angle+Math.PI/2,u=e.face?e.face.viewCoordinates:J.createPolar(t,c).plus(r),w=o.average(r),y=s.average(r);return B.polygon([w,r,y,u]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,n=o.minus(r),d=s.minus(r),i=n.normalized(),l=n.angle;let c=d.angle;return c<l&&(c+=2*Math.PI),new B().moveToPoint(r).lineToPoint(i.timesScalar(t).plus(r)).arcPoint(r,t,l,c,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===N.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===N.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===N.NOT_ONE?t.theme.sectorNotOneColorProperty:e===N.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}}f(fe,"nameMap",new Map([[N.NONE,"Invalid"],[N.ONLY_ZERO,"No Lines"],[N.ONLY_ONE,"Only One Line"],[N.ONLY_TWO,"Both Lines"],[N.NOT_ZERO,"At Least One Line"],[N.NOT_ONE,"Zero or Two Lines"],[N.NOT_TWO,"Less Than Two Lines"],[N.ANY,"Any Lines"]]));class Os extends dt{constructor(e,t){super(e.halfEdges,o=>fe.getSectorBaseShape(o,t.backgroundOffsetDistance),t.sectorPressListener)}}const Rt=[.02,.02],Oe=.2,Ye=.02;class As extends L{constructor(e,t,o){const r=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ZERO,o)}),s=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ONE,o)}),n=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_TWO,o)}),d=new K(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,n,d]}),this.board=e;const i=e.halfEdges.map(u=>N.NONE),l=e.edges.map(u=>v.BLACK),c=Se.multilink([t,o.sectorsVisibleProperty],(u,w)=>{if(w){let y=!1;for(let g=0;g<e.halfEdges.length;g++){const p=u.getSectorState(e.halfEdges[g]);p!==i[g]&&(y=!0,i[g]=p)}for(let g=0;g<e.edges.length;g++){const p=u.getEdgeState(e.edges[g]);p!==l[g]&&(y=!0,l[g]=p)}if(y){const g=new B,p=new B,S=new B,C=new B;for(let E=0;E<e.halfEdges.length;E++){const m=i[E];if(m!==N.NOT_ZERO&&m!==N.NOT_ONE&&m!==N.NOT_TWO&&m!==N.ONLY_ONE)continue;const P=e.halfEdges[E],R=u.getEdgeState(P.edge),F=u.getEdgeState(P.next.edge);if(R!==v.WHITE||F!==v.WHITE)continue;if(m===N.NOT_ONE){const X=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.BLACK),te=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.WHITE);if(X.length===0&&te.length===2)continue}const V=P.start.viewCoordinates,T=P.end.viewCoordinates,I=P.next.end.viewCoordinates,x=V.minus(T),q=I.minus(T),M=x.normalized(),W=x.angle;let O=q.angle;O<W&&(O+=2*Math.PI);const Y=(X,te)=>(X.moveToPoint(M.timesScalar(te).add(T)),X.arcPoint(T,te,W,O,!0),X);if(m===N.ONLY_ONE)Y(C,Oe);else if(m===N.NOT_ONE)Y(p,Oe-Ye),Y(p,Oe+Ye);else if(m===N.NOT_ZERO){const X=new B;Y(X,Oe-Ye),Y(X,Oe+Ye);const te=X.getDashedShape(Rt,0);g.subpaths.push(...te.subpaths)}else if(m===N.NOT_TWO){const X=new B;Y(X,Oe);const te=X.getDashedShape(Rt,0);S.subpaths.push(...te.subpaths)}}r.shape=g.makeImmutable(),s.shape=p.makeImmutable(),n.shape=S.makeImmutable(),d.shape=C.makeImmutable()}}});this.disposeEmitter.addListener(()=>c.dispose())}}class bs extends L{constructor(e,t,o,r){let s=[];try{let n=new B;for(const i of e.faces)n.polygon(i.vertices.map(l=>l.viewCoordinates));if(e.faceColor.colorState===D.OUTSIDE)try{const i=B.polygon(t.outerBoundary.map(u=>u.start.viewCoordinates)),c=$e.getOffsetBackgroundShape(t.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(i);n=n.bounds.isValid()?n.shapeUnion(c):c}catch(i){console.error(i)}const d=new K(n.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(d)}catch(n){console.error(n)}super({children:s}),this.selectedFaceColorHighlight=e}}class Is extends L{constructor(e,t,o,r){const s=[],n=[],d=e.sector,i=e.currentState,l=fe.getSectorArcShape(d,.5),c=new K(l.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(c);const u=[];if(i===N.ANY&&(u.push(N.NOT_ZERO),u.push(N.NOT_ONE),u.push(N.NOT_TWO)),i.one&&i!==N.ONLY_ONE&&u.push(N.ONLY_ONE),u.length){const w=u.map(p=>{const S=fe.getStrokeFromStyle(p,o);return new Go({accessibleName:fe.nameMap.get(p),content:new Uo(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(d,p)},buttonAppearanceStrategy:ko,baseColor:S,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});n.push(...w);const y=new zt(new Ht({children:w,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});n.push(y);const g=.1;s.push(y),y.centerBottom=c.centerTop.plusXY(0,-.15),y.top<t.top+g&&(y.centerTop=c.centerBottom.plusXY(0,.15)),y.left<t.left+g&&(y.left=t.left+g),y.right>t.right-g&&(y.right=t.right-g)}super({children:s}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{n.forEach(w=>w.dispose())})}}class Ns extends L{constructor(t,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});f(this,"simpleRegionNodeMap",new Map);f(this,"regionIdMap",new Map);f(this,"weirdEdgeNodeMap",new Map);f(this,"regionContainer",new L);f(this,"weirdEdgeContainer",new L);f(this,"adjacentFacesMap",new Map);f(this,"weirdEdgeColorProperty");this.board=t,this.style=r,this.weirdEdgeColorProperty=new z([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,Fs],(d,i,l)=>l?d:i),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),t.faces.forEach(d=>{this.adjacentFacesMap.set(d,d.edges.map(i=>i.getOtherFace(d)).filter(i=>i!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(d=>this.addRegion(d)),o.value.getWeirdEdges().forEach(d=>this.addWeirdEdge(d)),this.updateHues();const s=(d,i)=>{const l=i.getSimpleRegions(),c=d.getSimpleRegions(),u=i.getWeirdEdges(),w=d.getWeirdEdges(),y=[],g=[];Yt(l,c,y,g,[]);const S=new Set(y);for(const C of g)if(this.regionIdMap.has(C.id)){const E=this.regionIdMap.get(C.id);this.replaceRegion(E,C),S.delete(E)}else this.addRegion(C);for(const C of S)this.removeRegion(C);for(const C of u)w.includes(C)||this.removeWeirdEdge(C);for(const C of w)u.includes(C)||this.addWeirdEdge(C);(g.length||y.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const n=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(n),r.edgesHaveColorsProperty.lazyLink(n),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(n),r.edgesHaveColorsProperty.unlink(n)})}addRegion(t){const o=new Ie(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){A()&&b(t.id===o.id);const r=this.simpleRegionNodeMap.get(t);r.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=new Ho(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const n=d=>{s.lineCap=d};this.style.joinedLinesCapProperty.link(n),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(n))}this.weirdEdgeNodeMap.set(t,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(t){this.weirdEdgeNodeMap.get(t).dispose(),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new J(0,0),r=()=>{for(const c of t)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(1,0)},s=new Map,n=[];this.board.faces.forEach(c=>{s.set(c,[])});for(const c of t){const u=new Set;for(const y of c.simpleRegion.edges)for(const g of y.faces)u.add(g);const w=new Set;for(const y of u){w.add(y);for(const g of this.adjacentFacesMap.get(y))w.add(g)}for(const y of w){const g=s.get(y);if(g.length)for(const p of g){let S=!1;for(const C of n)if(C.a===p&&C.b===c){C.weight++,S=!0;break}S||n.push({a:p,b:c,weight:1})}g.push(c)}}const d=new Map;for(const c of t)d.set(c,J.ZERO.copy());const i=(c,u,w)=>{const y=d.get(c),g=d.get(u),p=c.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(c.hueVector);if(S.magnitude>1e-9){S.normalize();const C=.3,E=w*((Math.max(C,p)-C)/(1-C))**3;S.multiplyScalar(E),y.subtract(S),g.add(S)}};let l=1;for(let c=0;c<100;c++){l*=.99;for(const u of t)d.get(u).setXY(0,0);for(const u of n){const w=u.a,y=u.b,g=u.weight;i(w,y,g)}if(t.length<8)for(let u=0;u<t.length;u++){const w=t[u];for(let y=u+1;y<t.length;y++)i(w,t[y],.2)}for(const u of t){const w=d.get(u);w.multiplyScalar(l/u.edgeCount),u.hueVector.add(w),d.get(u).setXY(0,0)}r()}for(const c of t)c.updateHue()}}class Ie extends K{constructor(t,o){const r=J.createPolar(1,je.nextDoubleBetween(0,2*Math.PI));super(Ie.toShape(t),{stroke:Ie.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});f(this,"hueVector");f(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=r,this.edgeCount=t.edges.length;const s=d=>{this.lineJoin=d};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const n=d=>{this.lineCap=d};o.joinedLinesCapProperty.link(n),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(n))}updateHue(){this.stroke=Ie.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=Ie.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return A()&&b(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(t){const o=new B;let r=!0;for(const s of t.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class Ls extends L{constructor(e,t,o){super({pickable:!1}),this.vertex=e;const r=.12,n=e.edges.map(y=>y.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(y=>y.times(r)),i=B.polygon(Mo.grahamScan([J.ZERO,...n],!1)).getOffsetShape(-.05),l=new K(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),c=new K(i,{translation:e.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[l,...n.map(y=>new Ut({radius:.02,translation:y,fill:o.theme.vertexStatePointProperty}))]});let u=null;const w=Se.multilink([t,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(y,g,p)=>{const S=()=>{this.children=[]};if(!g){S();return}const C=y.getVertexState(e);if(!p){let E=!1,m=!1;const P=new Set;for(const F of e.edges){const V=y.getEdgeState(F);E=E||V===v.BLACK,m=m||V===v.WHITE,V===v.WHITE&&P.add(F)}if(E||!m){S();return}if(lt.fromLookup(e,(F,V)=>P.has(F)&&P.has(V),!0).equals(C)){S();return}}if(!u||!u.equals(C)){u=C;const E=new B;for(const m of C.getAllowedPairs()){const P=R=>R.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(r);E.moveToPoint(P(m[0])),E.lineToPoint(P(m[1]))}C.allowsEmpty()&&(E.moveTo(.03,0),E.circle(J.ZERO,.03),E.close()),E.makeImmutable(),l.shape=E}this.children=[c]});this.disposeEmitter.addListener(()=>w.dispose())}}class ks extends L{constructor(e,t,o,r){super({pickable:!1});const s=Se.multilink([t,r.vertexStateVisibleProperty],(d,i)=>{this.children.forEach(l=>l.dispose()),this.children=[],i&&e.vertices.forEach(l=>{this.addChild(new Ls(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const n=d=>{this.visible=!d};o.link(n),this.disposeEmitter.addListener(()=>{o.unlink(n),this.children.forEach(d=>d.dispose())})}}const xs=.03,Rs=.05;class Ms extends K{constructor(e,t,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=e.edges.map(l=>v.BLACK);let n=r.vertexStyleProperty.value,d=r.smallVertexProperty.value;const i=Se.multilink([t,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(l,c,u,w,y)=>{if(this.visible=!c&&u,this.visible){let g=!1;for(let p=0;p<e.edges.length;p++){const S=l.getEdgeState(e.edges[p]);S!==s[p]&&(g=!0,s[p]=S)}if(n!==w&&(n=w,g=!0),d!==y&&(d=y,g=!0),g){const p=new B;for(let S=0;S<e.vertices.length;S++){const C=e.vertices[S];if(C.edges.every(E=>l.getEdgeState(E)!==v.BLACK)){const E=C.viewCoordinates,m=y?xs:Rs;w==="round"?(p.moveTo(E.x+m,E.y),p.arc(E.x,E.y,m,0,2*Math.PI,!1)):w==="square"?p.rect(E.x-m,E.y-m,2*m,2*m):A()&&b(!1,`unhandled vertex style: ${w}`)}}this.shape=p}}});this.disposeEmitter.addListener(()=>i.dispose())}}class Mt extends L{constructor(t,o){const r=Ue()({textOptions:{font:it,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},onEdgeDragStart:()=>{},onEdgeDrag:()=>{},onEdgeDragEnd:()=>{},facePressListener:()=>{},faceBackgroundDragStartListener:V=>this.onFaceBackgroundDragStart(V),onFaceDragStart:()=>{},onFaceDrag:()=>{},onFaceDragEnd:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Re(null),selectedSectorEditProperty:new Re(null),style:_,noninteractive:!1,delayEdgeInteractionEmitter:new pe},o),s=r.style,n=new L({visibleProperty:s.faceColorsVisibleProperty}),d=new L({pickableProperty:fs}),i=new L({pickableProperty:ps}),l=new L({pickableProperty:hs}),c=new L({pickableProperty:gs}),u=new L,w=new L({pickable:!1}),y=new L({pickable:!1}),g=new L({renderer:qo.chromium?"canvas":null,pickable:null}),p=new L({pickable:!1}),S=new L,C=new z([t.stateProperty],V=>{if(V.getWeirdEdges().length||V.hasInvalidFaceColors())return!1;const T=V.getSimpleRegions();return T.length===1&&T[0].isSolved}),E=V=>{V?n.addChild(new Lr(t.board,t.stateProperty,s)):n.children.forEach(T=>T.dispose())};s.faceColorsVisibleProperty.link(E),d.addChild(new Ts(t.board,t.stateProperty,s,r));let m=null;r.noninteractive||(m=new Mr(t.board,r),d.addChild(m)),y.addChild(new Rr(t.board,t.stateProperty,C,s));const P=new $e(t.board.outerBoundary,t.board.innerBoundaries,s,r);c.addChild(new Ms(t.board,t.stateProperty,C,s)),w.addChild(new ks(t.board,t.stateProperty,C,s)),l.addChild(new Nr(t.board,t.stateProperty,C,s)),r.noninteractive||l.addChild(new Ir(t.board,r.delayEdgeInteractionEmitter,r)),i.addChild(new As(t.board,t.stateProperty,s)),r.noninteractive||i.addChild(new Os(t.board,r)),u.addChild(new Ns(t.board,t.stateProperty,s));super(Bt({children:[P,n,d,i,l,c,u,w,y,p,S,g]},r));f(this,"annotationContainer");f(this,"backgroundNode");f(this,"onFaceBackgroundDragStart");this.puzzle=t,m?this.onFaceBackgroundDragStart=V=>{var T;return(T=m.triggerDrag)==null?void 0:T.call(m,V)}:this.onFaceBackgroundDragStart=()=>{},this.annotationContainer=g;const R=V=>{p.children.forEach(T=>T.dispose()),V&&p.addChild(new bs(V,t.board,s,r))};r.selectedFaceColorHighlightProperty.link(R),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(R));const F=V=>{S.children.forEach(T=>T.dispose()),V&&S.addChild(new Is(V,P,s,r))};r.selectedSectorEditProperty.link(F),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(F)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(E),[n,d,l,c,u,w,y,i].forEach(T=>{T.children.forEach(I=>I.dispose()),T.dispose()}),C.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class aa extends L{constructor(e,t,o){const r=Ue()({style:_},o),s=t.getEmbeddedCompleteData(e.inputFeatureSet),n=t.getEmbeddedCompleteData(e.outputFeatureSet),d=new Mt(new Tt(t.smallBoard,s),{noninteractive:!0,style:r.style}),i=new Mt(new Tt(t.smallBoard,n),{noninteractive:!0,style:r.style}),l=e.highlander?new L({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(C=>new Wt("?",{font:it,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:C.viewCoordinates}))}):new L,u=t.tightBounds.dilated(.5),w=.5,y=B.roundRectangle(u.x,u.y,u.width,u.height,w,w),g=new L({children:[d,l],clipArea:y,localBounds:u}),p=new L({children:[i,l],clipArea:y,localBounds:u}),S=new zt(new Ht({spacing:.2,children:[g,new Pr(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),p]}),{cornerRadius:w*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[S],super(r),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{d.dispose(),i.dispose()})}}const Bs=(a,e)=>{_e(mr,a,e,!0)};class Ae{constructor(e,t,o,r,s,n,d,i,l,c){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=n,this.toSmallEdgeMap=d,this.toSmallSectorMap=i,this.tightBounds=l,this.expandedBounds=c}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const r=this.toSmallFaceMap.get(o);return A()&&b(r),r}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return A()&&b(s),s})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),r=this.toSmallSectorMap.get(o);return A()&&b(r),r}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&t.add(r)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=ar.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof vr)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof Fr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,v.BLACK));else if(o instanceof Vr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,v.RED));else if(o instanceof Tr)t.setSectorState(this.mapSector(o.sector),N.NOT_ZERO);else if(o instanceof Dr)t.setSectorState(this.mapSector(o.sector),N.NOT_ONE);else if(o instanceof Or)t.setSectorState(this.mapSector(o.sector),N.NOT_TWO);else if(o instanceof Ar)t.setSectorState(this.mapSector(o.sector),N.ONLY_ONE);else if(o instanceof br){const r=(n,d)=>{const i=this.mapFace(n),l=this.mapFace(d),c=i?t.getFaceColor(i):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new Xe(oe(t,c),oe(t,u)).apply(t)},s=(n,d)=>{const i=this.mapFace(n),l=this.mapFace(d),c=i?t.getFaceColor(i):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new ct(oe(t,c),oe(t,u)).apply(t)};for(let n=1;n<o.primaryFaces.length;n++)r(o.primaryFaces[n-1],o.primaryFaces[n]);for(let n=1;n<o.secondaryFaces.length;n++)r(o.secondaryFaces[n-1],o.secondaryFaces[n]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return Bs(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o,r){const s=Qe.NOTHING.copy(),n=i=>{s.addPoint(t.getVertex(o.mapVertex(i)).viewCoordinates)};e.vertices.forEach(n);const d=i=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(i))return;const l=t.getFace(o.mapFace(i));l&&l.vertices.forEach(c=>s.addPoint(c.viewCoordinates))};return e.faces.forEach(d),e.edges.forEach(i=>{let l;if(i.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(i))return;l=o.mapExitEdges(i).map(c=>t.getEdge(c))}else l=[t.getEdge(o.mapNonExitEdge(i))];l.forEach(c=>{s.addPoint(c.start.viewCoordinates),s.addPoint(c.end.viewCoordinates)})}),s}static findBestEmbedding(e,t,o){const r=Jo(e,t);if(r.length===0)return null;const s=Qe.NOTHING.copy();o.vertices.forEach(l=>s.addPoint(l.viewCoordinates));const n=s.center;let d=null,i=Number.POSITIVE_INFINITY;for(let l=0;l<r.length;l++){const c=r[l],w=Ae.getEmbeddingBounds(e,t,c).center,y=n.distance(w);y<i&&(i=y,d=c)}return d}static getDisplayEmbedding(e,t,o,r,s){const n=Ae.getEmbeddingBounds(e,t,r,s),d=n.dilated(.5),i=o.faces.filter(S=>{const C=Qe.NOTHING.copy();return S.vertices.forEach(E=>C.addPoint(E.viewCoordinates)),d.intersectsBounds(C)}),l=o.vertices.filter(S=>S.faces.some(C=>i.includes(C))),c=Zo({vertices:l.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates})),faces:i.map(S=>({logicalCoordinates:S.logicalCoordinates,vertices:S.vertices.map(C=>({logicalCoordinates:C.logicalCoordinates,viewCoordinates:C.viewCoordinates}))}))}),u=new $o(c),w=1e-6,y=new Map(i.map((S,C)=>{const E=u.faces.find(m=>m.viewCoordinates.equalsEpsilon(S.viewCoordinates,w));return A()&&b(E),[S,E]})),g=new Map(o.edges.map(S=>{const C=u.edges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w)||E.start.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w))??null;return C?[S,C]:null}).filter(S=>S!==null)),p=new Map(o.halfEdges.map(S=>{const C=u.halfEdges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w))??null;return C?[S,C]:null}).filter(S=>S!==null));return A()&&b(r),new Ae(e,t,o,r,u,y,g,p,n,d)}static getOptionsForRule(e){const t=e.outputFeatureSet.getAffectedFaces(),o=e.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>t.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(e,t,o){return Ae.getDisplayEmbedding(e.patternBoard,t,t.board,o,Ae.getOptionsForRule(e))}}export{vs as A,Gr as B,Bs as C,G as D,aa as E,xr as F,k as G,He as H,ro as I,Me as J,Es as K,ne as L,ra as M,ea as N,Ds as O,Mt as P,_ as Q,Qs as R,at as S,cs as T,kr as U,Ls as V,Ae as W,zr as X,qs as a,_r as b,qr as c,Jr as d,Qr as e,sa as f,Zr as g,no as h,os as i,rs as j,ss as k,as as l,is as m,ls as n,jr as o,ds as p,kt as q,xt as r,$s as s,oa as t,Fs as u,ns as v,ze as w,Js as x,Zs as y,ta as z};
