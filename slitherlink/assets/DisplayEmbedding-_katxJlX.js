var Lt=Object.defineProperty;var Nt=(s,t,e)=>t in s?Lt(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var y=(s,t,e)=>(Nt(s,typeof t!="symbol"?t+"":t,e),e);import{d as B,h as N,B as Se,F as Pe,N as b,P as z,L as xt,m as Ue,R as Ot,H as nt,M as ae,T as at,G as At,C as lt,n as Rt}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{E as v,F as fe,U as Be,d as je,e as ct,f as dt,S as It,s as Bt,g as Ye,h as Dt,i as F,V as Wt,B as Xe,C as Mt}from"./BasicPuzzle-B1djSMlq.js";import{T as n,P as Ee,E as xe,e as Oe,o as Fe,f as oe,l as Ht,V as Y,k as Le,D as zt,c as ht,C as Ut,B as De}from"./UnivariatePolynomial-CzQEP6td.js";import{b as jt,L as le,a as Ae,c as Yt,P as ut}from"./TextPushButton-B0wSyc3V.js";import{i as qe,S as k,L as Ke,_ as Me,ab as Xt,e as A,f as R,m as qt,H as Kt,ac as pt,k as Gt,n as Jt,l as Zt,d as _t}from"./patternBoards-7WmHeiIn.js";import{Q as $t,R as Qt,S as eo,f as to,g as oo,h as Ge,K as ro,s as Je,i as so,j as io,v as Ze,k as no,m as _e,w as ao,n as re,q as lo,x as co,y as ho,z as uo,J as se,H as po,F as fo,B as go,D as wo,c as ie,T as yo,r as So,u as mo,U as He}from"./Theme-CMAJrJpo.js";import{S as ft,J as gt,K as wt,L as yt,N as St,V as mt,O as ue,P as Po,A as Co,B as vo,Q as Pt,R as Ct,T as vt,U as Re,W as Et,I as G,X as Eo,Y as Vo,Z as Fo,_ as bo,$ as To,a0 as ko,a1 as Lo,a2 as No,a3 as xo,a4 as Oo,C as Ne,z as Ao,a5 as $e,a6 as he,F as Ro,a7 as Io}from"./SATSolver-CcH7PLXT.js";import{c as Bo}from"./compression-L63-wCoo.js";import{A as Do}from"./SpinningIndicatorNode-Cnu8VvuS.js";import{a as Wo,B as Mo,R as Ho,b as zo,c as Uo,d as jo,S as Yo,e as Xo}from"./PatternRule-DJzvheEf.js";const Vt=(s,t,e,o)=>(r,i,h)=>{const a=[new ft(r,i),new gt(r,i)];return(s||t||e||o)&&(a.push(new wt(r,i)),(t||e||o)&&(a.push(new yt(r,i)),(e||o)&&(a.push(new St(r,i)),o&&a.push(new mt(r,i))))),new ue(a)},qo={allowEdgeEditProperty:$t,allowFaceColorEditProperty:Qt,allowSectorEditProperty:eo,edgesVisibleProperty:to,edgesHaveColorsProperty:oo,faceColorsVisibleProperty:Ge,faceColorThresholdProperty:ro,sectorsVisibleProperty:Je,sectorsNextToEdgesVisibleProperty:so,sectorsTrivialVisibleProperty:io,vertexStateVisibleProperty:Ze,allVertexStateVisibleProperty:no,faceStateVisibleProperty:_e,whiteLineVisibleProperty:ao,redLineVisibleProperty:re,verticesVisibleProperty:lo,smallVertexProperty:co,redXsVisibleProperty:ho,redXsAlignedProperty:uo,faceValueStyleProperty:se,redLineStyleProperty:po,vertexStyleProperty:fo,joinedLinesJoinProperty:go,joinedLinesCapProperty:wo,safeSolverFactoryProperty:new B([Ge,Je,Ze,_e],(s,t,e,o)=>Vt(s,t,e,o)),autoSolverFactoryProperty:Po,theme:ie},ce=(s,t,e,o,r)=>{const i=Vt(s,t,e,o);return{faceColorsVisibleProperty:new Se(s),sectorsVisibleProperty:new Se(t),vertexStateVisibleProperty:new Se(e),faceStateVisibleProperty:new Se(o),safeSolverFactoryProperty:new Ee(i),autoSolverFactoryProperty:r?new B([r],h=>(a,c,u)=>new ue([i(a,c,u),h(a,c,u)])):new Ee(i)}},ge=new B([Co,vo],(s,t)=>(e,o,r)=>new ue([new Pt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:s,solveAlmostEmptyToRed:!0},r?void 0:[]),new Ct(e,o,{solveToRed:!0,solveToBlack:s},r?void 0:[]),...t?[new vt(e,o,{solveToRed:!0,solveToBlack:s,resolveAllRegions:!1},r?void 0:[])]:[]])),Ko=new B([ge],s=>(t,e,o)=>new ue([s(t,e,o),new Re(t,e,{solveToRed:!0,solveToBlack:!0})])),Ft=new B([ge],s=>(t,e,o)=>new ue([s(t,e,o),new Et(t,e,o?void 0:[])])),Go=new B([Ft],s=>(t,e,o)=>new ue([s(t,e,o),new Re(t,e,{solveToRed:!0,solveToBlack:!0})])),Jo=s=>({...ce(!0,!1,!1,!1,ge),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Zo=s=>({...ce(!0,!1,!1,!1,Ko),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),_o=s=>({...ce(!0,!1,!1,!1,new Ee((t,e,o)=>new ue([new Re(t,e,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:s,allowEdgeEditProperty:new n(!1),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!1),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),$o=s=>({...ce(!1,!1,!1,!1,ge),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:re,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),fs=s=>({...ce(!1,!0,!1,!1,ge),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:re,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),Qo=s=>({...ce(!0,!0,!1,!1,Ft),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!1),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),er=s=>({...ce(!0,!0,!1,!1,Go),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!0),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),tr=s=>({...ce(!0,!1,!0,!1,ge),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),or=s=>({...ce(!0,!1,!1,!0,ge),theme:s,allowEdgeEditProperty:new n(!0),allowFaceColorEditProperty:new n(!0),allowSectorEditProperty:new n(!1),edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:re,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:se,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),rr=Jo(ie),sr=Zo(ie),ir=_o(ie),bt=$o(ie),nr=Qo(ie),ar=er(ie),lr=tr(ie),cr=or(ie),We={basicLines:rr,basicFaceColoring:sr,pureFaceColor:ir,classic:bt,basicSectors:nr,sectorsWithColors:ar,vertexState:lr,faceState:cr,custom:qo},Qe=bt,dr=s=>({allowEdgeEditProperty:new N(s,{derive:"allowEdgeEditProperty"}),allowFaceColorEditProperty:new N(s,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new N(s,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new N(s,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new N(s,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new N(s,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new N(s,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new N(s,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new N(s,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new N(s,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new N(s,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new N(s,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new N(s,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new N(s,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new N(s,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new N(s,{derive:"verticesVisibleProperty"}),smallVertexProperty:new N(s,{derive:"smallVertexProperty"}),redXsVisibleProperty:new N(s,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new N(s,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new N(s,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new N(s,{derive:"redLineStyleProperty"}),vertexStyleProperty:new N(s,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new N(s,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new N(s,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new N(s,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new N(s,{derive:"autoSolverFactoryProperty"}),theme:yo(new B([s],t=>t.theme))}),hr=new jt("puzzleStyle",{serialize:s=>Object.keys(We).find(t=>We[t]===s),deserialize:s=>s?We[s]??Qe:Qe}),X=dr(hr),gs=new le("showPuzzleStyleProperty",!0),ws=new le("showPuzzleTimerProperty",!1),W=class W extends xe{constructor(t){super(),this.isEnabledProperty=t}};y(W,"EDGE_STATE",new W(X.allowEdgeEditProperty)),y(W,"EDGE_STATE_REVERSED",new W(X.allowEdgeEditProperty)),y(W,"FACE_COLOR_MATCH",new W(X.allowFaceColorEditProperty)),y(W,"FACE_COLOR_OPPOSITE",new W(X.allowFaceColorEditProperty)),y(W,"SECTOR_STATE",new W(X.allowSectorEditProperty)),y(W,"VERTEX_STATE",new W(X.vertexStateVisibleProperty)),y(W,"FACE_STATE",new W(X.faceStateVisibleProperty)),y(W,"FACE_VALUE",new W(new Se(!1))),y(W,"DELETE_FACE",new W(new Se(!1))),y(W,"enumeration",new Oe(W));let M=W;const K=new Ae("editModeProperty",M.EDGE_STATE);M.enumeration.values.forEach(s=>{s.isEnabledProperty.lazyLink(t=>{if(!K.value.isEnabledProperty.value){const e=M.enumeration.values.find(o=>o.isEnabledProperty.value)??null;e&&(K.value=e)}})});const ys=new le("eraserEnabledProperty",!1),Ss=s=>{s.isEnabledProperty.value&&(K.value=s)},ur=new B([K],s=>s===M.EDGE_STATE||s===M.EDGE_STATE_REVERSED),Tt=new B([K],s=>s===M.FACE_COLOR_MATCH||s===M.FACE_COLOR_OPPOSITE),pr=new B([K],s=>s===M.SECTOR_STATE),fr=new B([K],s=>s===M.VERTEX_STATE),gr=new B([K,Tt],(s,t)=>t||s===M.FACE_STATE||s===M.FACE_VALUE||s===M.DELETE_FACE),wr=(s,t,e)=>{const o=new Pe({mouseButton:0,fire:h=>{var a;return e&&e(s,(a=h.domEvent)!=null&&a.shiftKey?2:0)}}),r=new Pe({mouseButton:2,fire:h=>{var a;return e&&e(s,(a=h.domEvent)!=null&&a.shiftKey?0:2)}}),i=new Pe({mouseButton:1,fire:h=>e&&e(s,1)});t.addInputListener(o),t.addInputListener(r),t.addInputListener(i),t.cursor="pointer",t.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),i.dispose()})};class Ie extends b{constructor(t,e,o,r){const i=Fe()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},noninteractive:!1},r);super({pickableProperty:Tt}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,!i.noninteractive&&wr(null,this,i.facePressListener);const h=t.map(g=>g.start.viewCoordinates),a=i.useBackgroundOffsetStroke,c=i.backgroundOffsetDistance,l=qe(h)>0?-c:c,d=g=>{const p=new Xt;p.addShape(0,g),p.computeSimplifiedFaces(),p.computeFaceInclusion(C=>C[0]>0);const m=p.createFilledSubGraph(),S=m.facesToShape();return p.dispose(),m.dispose(),S},w=Ie.getOffsetBackgroundShape(t,a,c),f=e.map(g=>{const p=g.map(S=>S.start.viewCoordinates),m=k.polygon(p);if(a)return d(m.getOffsetShape(l));{const C=m.getStrokedShape(new Ke({lineWidth:2*c})).subpaths.map(P=>new k([P]));return d(Me.minBy(C,P=>P.getArea()))}});this.children=[new z(w,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...f.map(g=>new z(g,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(c=>c.start.viewCoordinates),i=k.polygon(r),a=qe(r)>0?-o:o;if(e)return i.getOffsetShape(a).getSimplifiedAreaShape();{const c=i.getStrokedShape(new Ke({lineWidth:2*o})),u=c.subpaths.map(l=>new k([l]));try{return c.bounds.width===9.718028227819117?k.bounds(c.bounds):Me.maxBy(u,l=>l.getArea()).getSimplifiedAreaShape()}catch{return k.bounds(c.bounds)}}}}class yr{constructor(t,e,o){y(this,"edgeStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(A()&&R(this.board.edges.includes(t)),e!==v.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new G(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Sr{constructor(t,e,o){y(this,"faceColorsChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,i){if(i)throw new G("invalid face color?");const h=new Set([...o.values(),...r.keys(),...o.values()]),a=new Map(this.currentState.getFaceColorMap());for(const l of o.keys())a.set(l,o.get(l));const c=l=>r.has(l)?r.get(l):[...t].includes(l)?this.currentState.getOppositeFaceColor(l):null,u=new Map;for(const l of a.keys()){const d=a.get(l);u.has(d)||u.set(d,new Set([l])),u.get(d).add(l)}for(const l of h){const d=u.get(l);if(!d)continue;const w=[...d];A()&&R(w.length>0);const f=this.solvedState.getFaceColor(w[0]);for(const p of w)if(this.solvedState.getFaceColor(p)!==f)throw new G("invalid face color");const g=c(l);if(g){let p;if(g.colorState===fe.INSIDE?p=this.solvedState.getInsideColor():g.colorState===fe.OUTSIDE?p=this.solvedState.getOutsideColor():p=this.solvedState.getFaceColor([...u.get(g)][0]),f===p)throw new G("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class mr{constructor(t,e,o){y(this,"simpleRegionsChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new G("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Pr{constructor(t,e,o){y(this,"faceValueChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new G("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Cr{constructor(t,e,o){y(this,"sectorStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){A()&&R(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class vr{constructor(t,e,o){y(this,"vertexStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){A()&&R(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new G("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Er{constructor(t,e,o){y(this,"faceStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){A()&&R(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new G("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Vr{constructor(t,e,o){y(this,"anyStateChangedEmitter",new oe);y(this,"edgeStateValidator");y(this,"faceValueValidator");y(this,"simpleRegionDataValidator");y(this,"faceColorValidator");y(this,"sectorStateValidator");y(this,"vertexStateValidator");y(this,"faceStateValidator");A()&&R(t),A()&&R(o),this.edgeStateValidator=new yr(t,e,o),this.faceValueValidator=new Pr(t,e,o),this.simpleRegionDataValidator=new mr(t,e,o),this.faceColorValidator=new Sr(t,e,o),this.sectorStateValidator=new Cr(t,e,o),this.vertexStateValidator=new vr(t,e,o),this.faceStateValidator=new Er(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,i){this.faceColorValidator.modifyFaceColors(t,e,o,r,i)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const H=class H extends xe{constructor(t,e,o){super(),this.fromWhite=t,this.fromBlack=e,this.fromRed=o}apply(t){return t===v.WHITE?this.fromWhite:t===v.BLACK?this.fromBlack:this.fromRed}};y(H,"CYCLE",new H(v.BLACK,v.RED,v.WHITE)),y(H,"REVERSE_CYCLE",new H(v.RED,v.WHITE,v.BLACK)),y(H,"WHITE_SET",new H(v.WHITE,v.WHITE,v.WHITE)),y(H,"BLACK_SET",new H(v.BLACK,v.BLACK,v.BLACK)),y(H,"RED_SET",new H(v.RED,v.RED,v.RED)),y(H,"BLACK_TOGGLE",new H(v.BLACK,v.WHITE,v.BLACK)),y(H,"RED_TOGGLE",new H(v.RED,v.RED,v.WHITE)),y(H,"enumeration",new Oe(H));let Ve=H;const Fr=new Ae("pressStyle0",Ve.CYCLE),br=new Ae("pressStyle1",Ve.WHITE_SET),Tr=new Ae("pressStyle2",Ve.REVERSE_CYCLE),kr=s=>{switch(s){case 0:return Fr.value;case 1:return br.value;case 2:return Tr.value}},Lr=(s,t,e)=>new ue([new ft(s,t),new gt(s,t),new wt(s,t),new Pt(s,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Ct(s,t,{solveToRed:!0,solveToBlack:!0}),new vt(s,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new Eo(s,t),new yt(s,t),new Et(s,t),new Vo(s,t),new St(s,t),new Fo(s,t,{solveToRed:!0,solveToBlack:!0}),new bo(s,t),new Re(s,t,{solveToRed:!0,solveToBlack:!0}),new To(s,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new ko(s,t),new mt(s,t),new Lo(s,t,{solveToRed:!0,solveToBlack:!0}),new No(s,t),new xo(s,t),new Oo(s,t)]),et=(s,t,e)=>{Ne(e,s,t,!0)};class Nr{constructor(t){this.hintAction=t}get annotation(){return this.hintAction.annotation}apply(t){this.hintAction.apply(t)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(t,e){throw new Error("unimplemented")}}const xr=s=>s instanceof qt?{type:"SquareBoard",width:s.width,height:s.height}:s instanceof Kt?{type:"HexagonalBoard",radius:s.radius,scale:s.scale,isPointyTop:s.isPointyTop,holeRadius:s.holeRadius}:{type:"BaseBoard",vertices:s.vertices.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vx:t.viewCoordinates.x,vy:t.viewCoordinates.y})),faces:s.faces.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vertices:t.vertices.map(e=>s.vertices.indexOf(e))}))},kt=s=>({version:1,board:xr(s.board),state:s.stateProperty.value.serializeState(s.board)}),Or=s=>{const t=kt(s);return Bo(JSON.stringify(t))};function Ar(s){return new Worker(""+new URL("hintWorker-CVZ9o6xx.js",import.meta.url).href,{name:s==null?void 0:s.name})}let we=null;const Te=new n(!1),Rr=()=>(we||(we=new Ar,we==null||we.addEventListener("message",s=>{s.data.type==="hint-worker-loaded"&&(Te.value=!0)})),we),Ir=s=>{const t=kt(s),e=s.solution.cleanState.serializeState(s.board),o=s.solution.solvedState.serializeState(s.board),r=[...s.solution.blackEdges].map(i=>s.board.edges.indexOf(i));return{puzzle:t,cleanState:e,solvedState:o,blackEdges:r}},q=class q extends xe{};y(q,"DEFAULT",new q),y(q,"LOADING",new q),y(q,"SEARCHING",new q),y(q,"FOUND",new q),y(q,"NOT_FOUND",new q),y(q,"enumeration",new Oe(q));let ee=q;const Br=new le("uiHintUsesBuiltInSolve",!1),ms=new le("showUndoRedoAllProperty",!1),tt=new le("dimCompletedNumbersProperty",!0),ot=new le("highlightIncorrectNumbersProperty",!0),Ps=new le("highlightIncorrectMovesProperty",!0),Dr=new le("highlightIntersectionsProperty",!0);class Cs extends Ht{constructor(e,o){const r=Fe()({style:X,initialTimeElapsed:0},o),i=r.style;super();y(this,"timeElapsedProperty",new n(0));y(this,"hintStateProperty",new n(ee.DEFAULT));y(this,"edgeAutoSolvedEmitter",new oe);y(this,"stack");y(this,"stackLengthProperty",new n(0));y(this,"stackPositionProperty",new n(0));y(this,"undoPossibleProperty");y(this,"redoPossibleProperty");y(this,"currentSnapshotProperty");y(this,"hasErrorProperty");y(this,"isSolvedProperty");y(this,"hintWorkerMessageID",0);y(this,"addedHintListener",!1);y(this,"pendingHintActionProperty",new n(null));y(this,"displayedAnnotationProperty");y(this,"pendingActionFaceColorProperty",new n(null));y(this,"pendingActionSectorProperty",new n(null));y(this,"selectedFaceColorHighlightProperty");y(this,"selectedSectorEditProperty");y(this,"autoSolverFactoryProperty");y(this,"style");this.puzzle=e,this.style=i,this.timeElapsedProperty.value=r.initialTimeElapsed,this.autoSolverFactoryProperty=new B([Ao,i.safeSolverFactoryProperty,i.autoSolverFactoryProperty],(c,u,l)=>c?l:u),this.displayedAnnotationProperty=new B([this.pendingHintActionProperty],c=>c?c.annotation:null);const h=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(h),K.lazyLink(h),this.disposeEmitter.addListener(()=>K.unlink(h)),this.selectedFaceColorHighlightProperty=new B([e.stateProperty,K,this.pendingActionFaceColorProperty],(c,u,l)=>{if((u===M.FACE_COLOR_MATCH||u===M.FACE_COLOR_OPPOSITE)&&l){const d=c.getFacesWithColor(l.color);return{faceColor:l.color,face:l.face,faces:d}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new B([e.stateProperty,K,this.pendingActionSectorProperty],(c,u,l)=>u===M.SECTOR_STATE&&l?{sector:l,currentState:c.getSectorState(l)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const c=e.stateProperty.value.clone();et(e.board,c,this.style.safeSolverFactoryProperty.value),e.stateProperty.value=c}this.stack=[new Ce(this.puzzle.board,null,e.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new B([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new B([this.currentSnapshotProperty],c=>c.errorDetected),this.isSolvedProperty=new B([this.currentSnapshotProperty],c=>{if(c.state.getWeirdEdges().length||c.state.hasInvalidFaceColors())return!1;const u=c.state.getSimpleRegions();return u.length===1&&u[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new B([this.stackPositionProperty],c=>c>0),this.redoPossibleProperty=new B([this.stackPositionProperty,this.stackLengthProperty],(c,u)=>c<u-1);const a=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(a),this.style.safeSolverFactoryProperty.lazyLink(a),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(a),this.style.safeSolverFactoryProperty.unlink(a)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(e){this.timeElapsedProperty.value+=e,localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Or(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(e){this.wipeStackTop(),this.stack.push(e),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(e,o){const r=(o==null?void 0:o.forceDirty)||e instanceof Be,h=this.stack[this.stackPositionProperty.value].state;let a=!1;const c=new Vr(this.puzzle.board,h,this.puzzle.solution.solvedState);try{e.apply(c)}catch{a=!0}let u=new Set;const l=f=>{u.add(f)};let d=h.createDelta();try{if(d.edgeStateChangedEmitter.addListener(l),$e(this.autoSolverFactoryProperty.value,this.puzzle.board,d,()=>{e.apply(d)},r),d.edgeStateChangedEmitter.removeListener(l),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(d)))throw new G("Auto-solver did not respect user action")}catch(f){if(a=!0,u=new Set,f instanceof G)console.log("error"),d=h.createDelta(),d.edgeStateChangedEmitter.addListener(l),$e(this.style.safeSolverFactoryProperty.value,this.puzzle.board,d,()=>{e.apply(d)},r),d.edgeStateChangedEmitter.removeListener(l);else throw f}const w=h.clone();d.apply(w),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,e,w,a));for(const f of u)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(f))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(f))}addAutoSolveDelta(){const e=this.puzzle.stateProperty.value.createDelta();try{if(Ne(this.autoSolverFactoryProperty.value,this.puzzle.board,e,!0),!e.isEmpty()){const o=this.puzzle.stateProperty.value.clone();e.apply(o),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Be,o))}}catch(o){if(!(o instanceof G))throw o}}onAutoSolveChange(){const e=this.stack[this.stackPositionProperty.value];e.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(e.action||new Be,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(e,o){const r=K.value===M.EDGE_STATE_REVERSED;return kr(r?2-o:o).apply(e)}onUserEdgePress(e,o){const r=this.puzzle.stateProperty.value.getEdgeState(e),i=this.getNewEdgeState(r,o);if(r!==i){const h=this.stack[this.stackPositionProperty.value];h.action&&h.action instanceof je&&h.action.edge===e&&this.stackPositionProperty.value--;const a=new je(e,i);this.applyUserActionToStack(a,{checkAutoSolve:c=>c.getEdgeState(e)===i,excludedEdges:new Set([e])}),this.updateState()}}onUserFacePress(e,o){let r=K.value===M.FACE_COLOR_MATCH;o===2&&(r=!r);const i=e?this.puzzle.stateProperty.value.getFaceColor(e):this.puzzle.stateProperty.value.getOutsideColor(),h=this.pendingActionFaceColorProperty.value;if(h){if(e!==h.face){const a=h.color;a!==i&&(r?this.applyUserActionToStack(new ct(he(this.puzzle.stateProperty.value,i),he(this.puzzle.stateProperty.value,a))):this.applyUserActionToStack(new dt(he(this.puzzle.stateProperty.value,i),he(this.puzzle.stateProperty.value,a))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:e,color:i}}onUserSectorPress(e,o){this.pendingActionSectorProperty.value=e}onUserSectorSet(e,o){this.applyUserActionToStack(new It(e,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const e=this.puzzle.stateProperty.value;if(!Bt(e))if(Br.value){const o=e.clone();Ne(Lr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Ye,o,!1)),this.updateState()}else{const o=Ro(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(i=>{r.setEdgeState(i,v.BLACK)}),et(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Ye,r,!1)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ee.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(e){this.hintStateProperty.value=e?ee.FOUND:ee.NOT_FOUND,e&&(this.pendingHintActionProperty.value=e)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const e=X.allowEdgeEditProperty.value,o=X.allowFaceColorEditProperty.value,r=X.allowSectorEditProperty.value,i=X.vertexStateVisibleProperty.value,h=X.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const a=Rr();if(!this.addedHintListener){this.addedHintListener=!0;const c=u=>{if(u.data.type==="hint-response"&&u.data.id===this.hintWorkerMessageID){const l=u.data.action?Dt(this.puzzle.board,u.data.action):null;this.onHintReceived(l)}};a.addEventListener("message",c),this.disposeEmitter.addListener(()=>self.removeEventListener("message",c))}if(a.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:e,solveColors:o,solveSectors:r,solveVertexState:i,solveFaceState:h,serializedSolvablePuzzle:Ir(this.puzzle)}),Te.value)this.hintStateProperty.value=ee.SEARCHING;else{this.hintStateProperty.value=ee.LOADING;const c=u=>{u&&(this.hintStateProperty.value===ee.LOADING&&(this.hintStateProperty.value=ee.SEARCHING),Te.unlink(c))};Te.link(c)}}onUserApplyHint(){const e=this.pendingHintActionProperty.value;e&&(this.clearPendingHint(),this.applyUserActionToStack(new Nr(e)),this.updateState())}}class Ce{constructor(t,e,o,r=!1){this.board=t,this.action=e,this.state=o,this.errorDetected=r}}class Wr extends b{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});y(this,"simpleRegionNodeMap",new Map);y(this,"regionIdMap",new Map);y(this,"weirdEdgeNodeMap",new Map);y(this,"regionContainer",new b);y(this,"weirdEdgeContainer",new b);y(this,"adjacentFacesMap",new Map);y(this,"weirdEdgeColorProperty");this.board=e,this.style=r,this.weirdEdgeColorProperty=new B([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,Dr],(a,c,u)=>u?a:c),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),e.faces.forEach(a=>{this.adjacentFacesMap.set(a,a.edges.map(c=>c.getOtherFace(a)).filter(c=>c!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(a=>this.addRegion(a)),o.value.getWeirdEdges().forEach(a=>this.addWeirdEdge(a)),this.updateHues();const i=(a,c)=>{const u=c.getSimpleRegions(),l=a.getSimpleRegions(),d=c.getWeirdEdges(),w=a.getWeirdEdges(),f=[],g=[];pt(u,l,f,g,[]);const m=new Set(f);for(const S of g)if(this.regionIdMap.has(S.id)){const C=this.regionIdMap.get(S.id);this.replaceRegion(C,S),m.delete(C)}else this.addRegion(S);for(const S of m)this.removeRegion(S);for(const S of d)w.includes(S)||this.removeWeirdEdge(S);for(const S of w)d.includes(S)||this.addWeirdEdge(S);(g.length||f.length)&&this.updateHues()};o.lazyLink(i),this.disposeEmitter.addListener(()=>o.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const h=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(h),r.edgesHaveColorsProperty.lazyLink(h),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(h),r.edgesHaveColorsProperty.unlink(h)})}addRegion(e){const o=new me(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){A()&&R(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,i=new xt(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const h=a=>{i.lineCap=a};this.style.joinedLinesCapProperty.link(h),i.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(h))}this.weirdEdgeNodeMap.set(e,i),this.weirdEdgeContainer.addChild(i)}removeWeirdEdge(e){this.weirdEdgeNodeMap.get(e).dispose(),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new Y(0,0),r=()=>{for(const l of e)l.hueVector.getMagnitude()>1e-6?l.hueVector.normalize():l.hueVector.setXY(1,0)},i=new Map,h=[];this.board.faces.forEach(l=>{i.set(l,[])});for(const l of e){const d=new Set;for(const f of l.simpleRegion.edges)for(const g of f.faces)d.add(g);const w=new Set;for(const f of d){w.add(f);for(const g of this.adjacentFacesMap.get(f))w.add(g)}for(const f of w){const g=i.get(f);if(g.length)for(const p of g){let m=!1;for(const S of h)if(S.a===p&&S.b===l){S.weight++,m=!0;break}m||h.push({a:p,b:l,weight:1})}g.push(l)}}const a=new Map;for(const l of e)a.set(l,Y.ZERO.copy());const c=(l,d,w)=>{const f=a.get(l),g=a.get(d),p=l.hueVector.dot(d.hueVector),m=o.set(d.hueVector).subtract(l.hueVector);if(m.magnitude>1e-9){m.normalize();const S=.3,C=w*((Math.max(S,p)-S)/(1-S))**3;m.multiplyScalar(C),f.subtract(m),g.add(m)}};let u=1;for(let l=0;l<100;l++){u*=.99;for(const d of e)a.get(d).setXY(0,0);for(const d of h){const w=d.a,f=d.b,g=d.weight;c(w,f,g)}if(e.length<8)for(let d=0;d<e.length;d++){const w=e[d];for(let f=d+1;f<e.length;f++)c(w,e[f],.2)}for(const d of e){const w=a.get(d);w.multiplyScalar(u/d.edgeCount),d.hueVector.add(w),a.get(d).setXY(0,0)}r()}for(const l of e)l.updateHue()}}class me extends z{constructor(e,o){const r=Y.createPolar(1,Le.nextDoubleBetween(0,2*Math.PI));super(me.toShape(e),{stroke:me.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});y(this,"hueVector");y(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const i=a=>{this.lineJoin=a};o.joinedLinesJoinProperty.link(i),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(i));const h=a=>{this.lineCap=a};o.joinedLinesCapProperty.link(h),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(h))}updateHue(){this.stroke=me.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Y.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=me.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,i=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&R(i>=0&&i<r.length),o.edgesHaveColorsProperty.value?r[i]:o.theme.blackLineColorProperty}static toShape(e){const o=new k;let r=!0;for(const i of e.halfEdges)r&&(r=!1,o.moveToPoint(i.start.viewCoordinates)),o.lineToPoint(i.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class Mr extends b{constructor(e,o,r){const i=new b;super({pickable:!1,children:[i]});y(this,"faceColorNodeMap",new Map);y(this,"faceColorIdMap",new Map);y(this,"adjacentFacesMap",new Map);y(this,"faceColorNodeContainer");y(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=i,e.faces.forEach(u=>{this.adjacentFacesMap.set(u,u.edges.map(l=>l.getOtherFace(u)).filter(l=>l!==null))});{const u=o.value.getFaceColors();for(const l of u)this.addFaceColor(l,o.value.getFacesWithColor(l));this.addDualColorViews(o.value,u)}this.updateHues();let h=o.value.clone();const a=u=>{const l=h;h=u.clone();const d=l.getFaceColors(),w=u.getFaceColors(),f=[],g=[],p=[];pt(d,w,f,g,p);const m=new Set(f),S=this.removeInvalidDualColorViews(u),C=[...S];for(const P of g)if(S.add(P),this.faceColorIdMap.has(P.id)){const E=this.faceColorIdMap.get(P.id);this.replaceFaceColor(E,P,u.getFacesWithColor(P)),m.delete(E)}else this.addFaceColor(P,u.getFacesWithColor(P));for(const P of p)this.updateFaceColor(P,u.getFacesWithColor(P));for(const P of m)S.delete(P),this.removeFaceColor(P);this.addDualColorViews(u,[...S]),(g.length||f.length||C.length)&&this.updateHues()};o.lazyLink(a),this.disposeEmitter.addListener(()=>o.unlink(a)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const c=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(c),r.theme.faceColorLightHueLUTProperty.lazyLink(c),r.theme.faceColorDarkHueLUTProperty.lazyLink(c),r.theme.faceColorInsideColorProperty.lazyLink(c),r.theme.faceColorOutsideColorProperty.lazyLink(c),r.theme.faceColorDefaultColorProperty.lazyLink(c),r.faceColorThresholdProperty.lazyLink(c),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(c),r.theme.faceColorLightHueLUTProperty.unlink(c),r.theme.faceColorDarkHueLUTProperty.unlink(c),r.theme.faceColorInsideColorProperty.unlink(c),r.theme.faceColorOutsideColorProperty.unlink(c),r.theme.faceColorDefaultColorProperty.unlink(c),r.faceColorThresholdProperty.unlink(c)})}addFaceColor(e,o){const r=new ve(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){A()&&R(e.id===o.id);const i=this.faceColorNodeMap.get(e);i.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,i),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let i=r.faces.length!==o.length;if(!i)for(let h=0;h<o.length;h++){const a=r.faces[h],c=o[h];if(a!==c){i=!0;break}}i&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const i=r.values().next().value;r.delete(i);const h=this.faceColorNodeMap.get(i);A()&&R(h);const a=e.getOppositeFaceColor(i);if(a){A()&&R(r.has(a)),r.delete(a);const c=this.faceColorNodeMap.get(a);A()&&R(c),this.dualColorViews.add(new rt([h,c],this.style))}else this.dualColorViews.add(new rt([h],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const i of[...this.dualColorViews])if(!i.isStillValidInState(this.stateProperty.value,r)){for(const h of i.colorNodes)o.add(h.faceColor);this.dualColorViews.delete(i),i.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==fe.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new Y(0,0),r=()=>{for(const l of e)l.hueVector.getMagnitude()>1e-6?l.hueVector.normalize():l.hueVector.setXY(Le.nextDouble()-.5,Le.nextDouble()-.5).normalize()},i=new Map,h=[];this.board.faces.forEach(l=>{i.set(l,[])});for(const l of e){const d=new Set;for(const f of l.faces)d.add(f);const w=new Set;for(const f of d){w.add(f);for(const g of this.adjacentFacesMap.get(f))w.add(g)}for(const f of w){const g=i.get(f);if(g){if(g.length)for(const p of g){let m=!1;for(const S of h)if(S.a===p&&S.b===l){S.weight++,m=!0;break}m||h.push({a:p,b:l,weight:1})}g.push(l)}}}const a=new Map;for(const l of e)a.set(l,Y.ZERO.copy());const c=(l,d,w)=>{const f=a.get(l),g=a.get(d),p=l.hueVector.dot(d.hueVector),m=o.set(d.hueVector).subtract(l.hueVector);m.magnitudeSquared>1e-11&&m.normalize();const S=.2,C=Math.abs(p),P=w*((Math.max(S,C)-S)/(1-S))**3;m.multiplyScalar(P),f.subtract(m),g.add(m)};let u=1;for(let l=0;l<100;l++){u*=.99;for(const d of e)a.get(d).setXY(0,0);for(const d of h){const w=d.a,f=d.b,g=d.weight;c(w,f,g)}if(e.length<8)for(let d=0;d<e.length;d++){const w=e[d];for(let f=d+1;f<e.length;f++)c(w,e[f],.2)}for(const d of e){const w=a.get(d);w.multiplyScalar(u/d.faceCount),d.hueVector.add(w),a.get(d).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const te=class te extends xe{};y(te,"BASIC",new te),y(te,"PRIMARY",new te),y(te,"SECONDARY",new te),y(te,"enumeration",new Oe(te));let $=te;class rt{constructor(t,e){y(this,"hueVector");y(this,"faceCount");if(this.colorNodes=t,this.style=e,A()&&R(t.length===1||t.length===2),this.faceCount=Me.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=$.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let i;o.type===$.PRIMARY?i=o:r.type===$.PRIMARY||o.type===$.SECONDARY?i=r:(r.type,$.SECONDARY,i=o);const h=i===o?r:o;this.hueVector=o.hueVector.copy(),i.type=$.PRIMARY,h.type=$.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class ve extends z{constructor(e,o,r){const i=Y.createPolar(1,Le.nextDoubleBetween(0,2*Math.PI));super(ve.toShape(o));y(this,"hueVector");y(this,"faceCount");y(this,"dualColorView",null);y(this,"type",$.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=i,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==fe.UNDECIDED?this.fill=ve.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Y.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=ve.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,i){const h=r===$.BASIC?i.theme.faceColorBasicHueLUTProperty.value:r===$.PRIMARY?i.theme.faceColorLightHueLUTProperty.value:i.theme.faceColorDarkHueLUTProperty.value,a=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&R(a>=0&&a<h.length);const c=h[a];if(o===fe.UNDECIDED)return c;{const l=(o===fe.INSIDE?i.theme.faceColorInsideColorProperty:i.theme.faceColorOutsideColorProperty).value,d=l.alpha,w=new Ue(c);return new Ue((1-d)*w.red+d*l.red,(1-d)*w.green+d*l.green,(1-d)*w.blue+d*l.blue).toCSS()}}static toShape(e){const o=new k;for(const r of e)o.polygon(r.vertices.map(i=>i.viewCoordinates));return o.makeImmutable()}}class Hr extends b{constructor(t,e,o,r){let i=[];try{let h=new k;for(const c of t.faces)h.polygon(c.vertices.map(u=>u.viewCoordinates));if(t.faceColor.colorState===fe.OUTSIDE)try{const c=k.polygon(e.outerBoundary.map(d=>d.start.viewCoordinates)),l=Ie.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(c);h=h.shapeUnion(l)}catch(c){console.error(c)}const a=new z(h.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});i.push(a)}catch(h){console.error(h)}super({children:i}),this.selectedFaceColorHighlight=t}}class ne extends b{static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,i=t.next.end.viewCoordinates,h=o.minus(r),a=i.minus(r),c=h.normalized(),l=a.normalized().minus(c).angle+Math.PI/2,d=t.face?t.face.viewCoordinates:Y.createPolar(e,l).plus(r),w=o.average(r),f=i.average(r);return k.polygon([w,r,f,d]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,i=t.next.end.viewCoordinates,h=o.minus(r),a=i.minus(r),c=h.normalized(),u=h.angle;let l=a.angle;return l<u&&(l+=2*Math.PI),new k().moveToPoint(r).lineToPoint(c.timesScalar(e).plus(r)).arcPoint(r,e,u,l,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===F.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===F.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===F.NOT_ONE?e.theme.sectorNotOneColorProperty:t===F.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}}y(ne,"nameMap",new Map([[F.NONE,"Invalid"],[F.ONLY_ZERO,"No Lines"],[F.ONLY_ONE,"Only One Line"],[F.ONLY_TWO,"Both Lines"],[F.NOT_ZERO,"At Least One Line"],[F.NOT_ONE,"Zero or Two Lines"],[F.NOT_TWO,"Less Than Two Lines"],[F.ANY,"Any Lines"]]));class zr extends b{constructor(t,e,o,r){const i=[],h=[],a=t.sector,c=t.currentState,u=ne.getSectorArcShape(a,.5),l=new z(u.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});i.push(l);const d=[];if(c===F.ANY&&(d.push(F.NOT_ZERO),d.push(F.NOT_ONE),d.push(F.NOT_TWO)),c.one&&c!==F.ONLY_ONE&&d.push(F.ONLY_ONE),d.length){const w=d.map(p=>{const m=ne.getStrokeFromStyle(p,o);return new Yt({accessibleName:ne.nameMap.get(p),content:new Ot(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(a,p)},buttonAppearanceStrategy:So,baseColor:m,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});h.push(...w);const f=new ut(new nt({children:w,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});h.push(f);const g=.1;i.push(f),f.centerBottom=l.centerTop.plusXY(0,-.15),f.top<e.top+g&&(f.centerTop=l.centerBottom.plusXY(0,.15)),f.left<e.left+g&&(f.left=e.left+g),f.right>e.right-g&&(f.right=e.right-g)}super({children:i}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{h.forEach(w=>w.dispose())})}}class Ur extends b{constructor(t,e,o,r){const i=new z(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),h=new z(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),a=new z(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[i,h,a],pickable:!1});const c=t.edges.map(p=>v.BLACK);let u=!1,l=!1,d=!1,w=!1,f=null;const g=ae.multilink([e,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(p,m,S,C,P,E,I)=>{if(this.visible=!m,i.visible=S,h.visible=C,a.visible=E,this.visible){let V=!1;for(let T=0;T<t.edges.length;T++){const L=p.getEdgeState(t.edges[T]);L!==c[T]&&(V=!0,c[T]=L)}if(u!==P&&(V=!0,u=P),l!==S&&(V=!0,l=S),d!==C&&(V=!0,d=C),w!==E&&(V=!0,w=E),f!==I&&(V=!0,f=I),V){const T=new k,L=new k,_=new k;for(let J=0;J<t.edges.length;J++){const de=c[J];if(S&&de===v.WHITE){const x=t.edges[J];T.moveTo(x.start.viewCoordinates.x,x.start.viewCoordinates.y),T.lineTo(x.end.viewCoordinates.x,x.end.viewCoordinates.y)}if(de===v.RED){if(C){const x=t.edges[J],O=.07;let D=x.start.viewCoordinates.blend(x.end.viewCoordinates,.5);if(P){const U=x.end.viewCoordinates.minus(x.start.viewCoordinates).getAngle(),j=new Y(-O,-O).rotate(U).add(D),Z=new Y(O,O).rotate(U).add(D),Q=new Y(-O,O).rotate(U).add(D),pe=new Y(O,-O).rotate(U).add(D);L.moveTo(j.x,j.y),L.lineTo(Z.x,Z.y),L.moveTo(Q.x,Q.y),L.lineTo(pe.x,pe.y)}else L.moveTo(D.x-O,D.y-O),L.lineTo(D.x+O,D.y+O),L.moveTo(D.x-O,D.y+O),L.lineTo(D.x+O,D.y-O)}if(E){const x=t.edges[J],O=.4,D=.017,U=x.start.viewCoordinates.blend(x.end.viewCoordinates,.5),j=U.blend(x.start.viewCoordinates,O),Z=U.blend(x.end.viewCoordinates,O);for(let Q=0;Q<5;Q++){const pe=j.blend(Z,Q/4);_.moveTo(pe.x+D,pe.y),_.arc(pe.x,pe.y,D,0,2*Math.PI,!1)}}}}T.makeImmutable(),L.makeImmutable(),_.makeImmutable(),i.shape=T,h.shape=L,a.shape=_}}});this.disposeEmitter.addListener(()=>g.dispose())}}class ze extends b{constructor(t,e,o,r){super();const i=new Set;if(r!=null&&r.delayInteractionEmitter){const f=r==null?void 0:r.delayInteractionEmitter,g=p=>{i.add(p),setTimeout(()=>{i.delete(p)},700)};f.addListener(g),this.disposeEmitter.addListener(()=>f.removeListener(g))}const h=new k,a=t.map(f=>{const g=e(f);return g.makeImmutable(),h.subpaths.push(...g.subpaths),g});this.mouseArea=this.touchArea=h.makeImmutable();const c=f=>{const g=f.trail.globalToLocalPoint(f.pointer.point);for(let p=0;p<a.length;p++){const m=a[p];if(m.bounds.containsPoint(g)&&m.containsPoint(g)){const S=t[p];if(!i.has(S))return S}}return null},u=(f,g)=>{const p=c(f);p&&o(p,g)},l=new Pe({mouseButton:0,fire:f=>{var g;return u(f,(g=f.domEvent)!=null&&g.shiftKey?2:0)}}),d=new Pe({mouseButton:2,fire:f=>{var g;return u(f,(g=f.domEvent)!=null&&g.shiftKey?0:2)}}),w=new Pe({mouseButton:1,fire:f=>u(f,1)});this.addInputListener(l),this.addInputListener(d),this.addInputListener(w),this.cursor="pointer",this.disposeEmitter.addListener(()=>{l.dispose(),d.dispose(),w.dispose()})}}class jr extends ze{constructor(t,e,o){super(t.edges,r=>{const i=r.start.viewCoordinates,h=r.end.viewCoordinates,a=new k;let c;if(r.faces.length===2)c=[i,r.faces[0].viewCoordinates,h,r.faces[1].viewCoordinates];else{A()&&R(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const u=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;A()&&R(u.previous.face===null),A()&&R(u.next.face===null);const l=u.start.viewCoordinates,d=u.end.viewCoordinates,w=u.previous.start.viewCoordinates,f=u.next.end.viewCoordinates,g=(S,C,P)=>{const E=C.minus(S).normalized(),I=P.minus(C).normalized();let V=E.minus(I);return V.getMagnitude()<1e-6?V=E.getPerpendicular():V=V.normalized(),zt.triangleAreaSigned(S,C,C.plus(V))<0&&(V=V.negated()),V},p=g(w,l,d),m=g(l,d,f);c=[l,r.faces[0].viewCoordinates,d,d.plus(m.times(o.backgroundOffsetDistance)),l.plus(p.times(o.backgroundOffsetDistance))]}return a.polygon(c),a.makeImmutable(),a},o.edgePressListener,{delayInteractionEmitter:e})}}const st=[.02,.02],ye=.2,be=.02;class Yr extends b{constructor(t,e,o){const r=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(F.NOT_ZERO,o)}),i=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(F.NOT_ONE,o)}),h=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(F.NOT_TWO,o)}),a=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ne.getStrokeFromStyle(F.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,i,h,a]}),this.board=t;const c=t.halfEdges.map(d=>F.NONE),u=t.edges.map(d=>v.BLACK),l=ae.multilink([e,o.sectorsVisibleProperty],(d,w)=>{if(w){let f=!1;for(let g=0;g<t.halfEdges.length;g++){const p=d.getSectorState(t.halfEdges[g]);p!==c[g]&&(f=!0,c[g]=p)}for(let g=0;g<t.edges.length;g++){const p=d.getEdgeState(t.edges[g]);p!==u[g]&&(f=!0,u[g]=p)}if(f){const g=new k,p=new k,m=new k,S=new k;for(let C=0;C<t.halfEdges.length;C++){const P=c[C];if(P!==F.NOT_ZERO&&P!==F.NOT_ONE&&P!==F.NOT_TWO&&P!==F.ONLY_ONE)continue;const E=t.halfEdges[C],I=d.getEdgeState(E.edge),V=d.getEdgeState(E.next.edge);if(I!==v.WHITE||V!==v.WHITE)continue;if(P===F.NOT_ONE){const j=E.end.edges.filter(Q=>d.getEdgeState(Q)===v.BLACK),Z=E.end.edges.filter(Q=>d.getEdgeState(Q)===v.WHITE);if(j.length===0&&Z.length===2)continue}const T=E.start.viewCoordinates,L=E.end.viewCoordinates,_=E.next.end.viewCoordinates,J=T.minus(L),de=_.minus(L),x=J.normalized(),O=J.angle;let D=de.angle;D<O&&(D+=2*Math.PI);const U=(j,Z)=>(j.moveToPoint(x.timesScalar(Z).add(L)),j.arcPoint(L,Z,O,D,!0),j);if(P===F.ONLY_ONE)U(S,ye);else if(P===F.NOT_ONE)U(p,ye-be),U(p,ye+be);else if(P===F.NOT_ZERO){const j=new k;U(j,ye-be),U(j,ye+be);const Z=j.getDashedShape(st,0);g.subpaths.push(...Z.subpaths)}else if(P===F.NOT_TWO){const j=new k;U(j,ye);const Z=j.getDashedShape(st,0);m.subpaths.push(...Z.subpaths)}}r.shape=g.makeImmutable(),i.shape=p.makeImmutable(),h.shape=m.makeImmutable(),a.shape=S.makeImmutable()}}});this.disposeEmitter.addListener(()=>l.dispose())}}class Xr extends ze{constructor(t,e){super(t.halfEdges,o=>ne.getSectorBaseShape(o,e.backgroundOffsetDistance),e.sectorPressListener)}}class qr extends at{constructor(t,e){const o=Fe()({font:mo,fill:ie.uiForegroundColorProperty},e);super(t,o)}}class Kr extends b{constructor(t,e,o){super({translation:t.viewCoordinates}),this.face=t;const i=e.value.getFaceState(t),h=i.possibilityCount===0||i.possibilityCount>9;let a;const c=i.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(h)a=new qr(i.possibilityCount,{font:He,maxWidth:.4,maxHeight:.4});else{const u=new Set(t.vertices);a=new At({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(i.possibilityCount)),children:i.getAllowedCombinations().map(l=>{const d=new b,w=new Set(l.map(p=>p.start)),f=new Set(l.map(p=>p.end)),g=p=>p.minus(t.viewCoordinates);if(d.addChild(new z(k.polygon(t.vertices.map(p=>g(p.viewCoordinates))),{stroke:c,lineWidth:.03,opacity:.2})),w.size){const p=new k;if(l.length===t.edges.length)p.polygon(t.vertices.map(m=>g(m.viewCoordinates)));else{const m=new Set(l);for(;m.size;){const S=[...u].find(E=>[...m].filter(I=>I.start===E||I.end===E).length===1);A()&&R(S);let C=S,P=[...m].find(E=>E.start===C||E.end===C)??null;for(p.moveToPoint(g(C.viewCoordinates));P;)m.delete(P),C=P.getOtherVertex(C),p.lineToPoint(g(C.viewCoordinates)),P=[...m].find(E=>E.start===C||E.end===C)??null}}d.addChild(new z(p,{stroke:c,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const p of t.vertices)!w.has(p)&&!f.has(p)&&d.addChild(new lt(.1,{fill:c,translation:g(p.viewCoordinates)}));return d}),maxWidth:.6,maxHeight:.6})}a.center=Y.ZERO,this.addChild(a)}}class Gr extends b{constructor(t,e,o,r){super({pickable:!1});const i=ae.multilink([e,r.faceStateVisibleProperty],(a,c)=>{this.children.forEach(u=>u.dispose()),this.children=[],c&&t.faces.forEach(u=>{this.addChild(new Kr(u,e,r))})});this.disposeEmitter.addListener(()=>i.dispose());const h=a=>{this.visible=!a};o.link(h),this.disposeEmitter.addListener(()=>{o.unlink(h),this.children.forEach(a=>a.dispose())})}}class Jr extends ze{constructor(t,e){super(t.faces,o=>o?k.polygon(o.vertices.map(r=>r.viewCoordinates)):new k,e.facePressListener)}}class Zr extends b{constructor(t,e,o,r){super({pickable:!1}),this.board=t;const i=t.faces.map(u=>null),h=()=>{const u=[],l=o.faceValueStyleProperty.value,d=o.theme.faceValueColorProperty.value,w=o.theme.faceValueCompletedColorProperty.value,f=o.theme.faceValueErrorColorProperty.value,g=o.theme.faceValueRatioColorProperty.value,p=o.faceStateVisibleProperty.value,m=tt.value,S=ot.value;this.visible=!p;for(let C=0;C<t.faces.length;C++){const P=i[C];if(P!==null){const E=t.faces[C],I=new Rt("",ht({subScale:.7},r==null?void 0:r.textOptions)),V=ae.multilink([e],T=>{let L,_,J=!1,de=!1;if(P===null)L="",_=null;else{let x=0,O=0;for(const D of E.edges){const U=T.getEdgeState(D);U===v.BLACK?x++:U===v.WHITE&&O++}if(l==="static"||P===0)L=`${P}`;else if(l==="remaining")L=`${P-x}`,J=x>0;else if(l==="ratio")P-x===0?L="0":(L=`${P-x}<sub style="color: ${g.toCSS()};">/<sub>${O}</sub></sub>`,de=!0),J=x>0;else throw new Error(`unhandled faceValueStyle: ${l}`);x>P&&S?_=f:x===P&&m?_=w:_=d}I.string=L,I.fill=_,I.maxWidth=de?.8:.9,I.maxHeight=de?.8:.9,I.center=E.viewCoordinates});I.disposeEmitter.addListener(()=>V.dispose()),u.push(I)}}this.children.forEach(C=>C.dispose()),this.children=u},a=ae.multilink([e],u=>{let l=!1;for(let d=0;d<t.faces.length;d++){const w=u.getFaceValue(t.faces[d]);w!==i[d]&&(l=!0,i[d]=w)}l&&h()}),c=ae.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,tt,ot],h);this.disposeEmitter.addListener(()=>{a.dispose(),c.dispose(),this.children.forEach(u=>u.dispose())})}}class _r extends b{constructor(t,e,o){super({pickable:!1}),this.vertex=t;const r=.12,h=t.edges.map(f=>f.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(f=>f.times(r)),c=k.polygon(Ut.grahamScan([Y.ZERO,...h],!1)).getOffsetShape(-.05),u=new z(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),l=new z(c,{translation:t.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[u,...h.map(f=>new lt({radius:.02,translation:f,fill:o.theme.vertexStatePointProperty}))]});let d=null;const w=ae.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(f,g,p)=>{const m=()=>{this.children=[]};if(!g){m();return}const S=f.getVertexState(t);if(!p){let C=!1,P=!1;const E=new Set;for(const V of t.edges){const T=f.getEdgeState(V);C=C||T===v.BLACK,P=P||T===v.WHITE,T===v.WHITE&&E.add(V)}if(C||!P){m();return}if(Wt.fromLookup(t,(V,T)=>E.has(V)&&E.has(T),!0).equals(S)){m();return}}if(!d||!d.equals(S)){d=S;const C=new k;for(const P of S.getAllowedPairs()){const E=I=>I.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);C.moveToPoint(E(P[0])),C.lineToPoint(E(P[1]))}S.allowsEmpty()&&(C.moveTo(.03,0),C.circle(Y.ZERO,.03),C.close()),C.makeImmutable(),u.shape=C}this.children=[l]});this.disposeEmitter.addListener(()=>w.dispose())}}class $r extends b{constructor(t,e,o,r){super({pickable:!1});const i=ae.multilink([e,r.vertexStateVisibleProperty],(a,c)=>{this.children.forEach(u=>u.dispose()),this.children=[],c&&t.vertices.forEach(u=>{this.addChild(new _r(u,e,r))})});this.disposeEmitter.addListener(()=>i.dispose());const h=a=>{this.visible=!a};o.link(h),this.disposeEmitter.addListener(()=>{o.unlink(h),this.children.forEach(a=>a.dispose())})}}const Qr=.03,es=.05;class ts extends z{constructor(t,e,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const i=t.edges.map(u=>v.BLACK);let h=r.vertexStyleProperty.value,a=r.smallVertexProperty.value;const c=ae.multilink([e,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(u,l,d,w,f)=>{if(this.visible=!l&&d,this.visible){let g=!1;for(let p=0;p<t.edges.length;p++){const m=u.getEdgeState(t.edges[p]);m!==i[p]&&(g=!0,i[p]=m)}if(h!==w&&(h=w,g=!0),a!==f&&(a=f,g=!0),g){const p=new k;for(let m=0;m<t.vertices.length;m++){const S=t.vertices[m];if(S.edges.every(C=>u.getEdgeState(C)!==v.BLACK)){const C=S.viewCoordinates,P=f?Qr:es;w==="round"?(p.moveTo(C.x+P,C.y),p.arc(C.x,C.y,P,0,2*Math.PI,!1)):w==="square"?p.rect(C.x-P,C.y-P,2*P,2*P):A()&&R(!1,`unhandled vertex style: ${w}`)}}this.shape=p}}});this.disposeEmitter.addListener(()=>c.dispose())}}class it extends b{constructor(e,o){const r=Fe()({textOptions:{font:He,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},facePressListener:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Ee(null),selectedSectorEditProperty:new Ee(null),style:X,noninteractive:!1,delayEdgeInteractionEmitter:new oe},o),i=r.style,h=new b({visibleProperty:i.faceColorsVisibleProperty}),a=new b({pickableProperty:gr}),c=new b({pickableProperty:pr}),u=new b({pickableProperty:ur}),l=new b({pickableProperty:fr}),d=new b,w=new b({pickable:!1}),f=new b({pickable:!1}),g=new b({renderer:Gt.chromium?"canvas":null,pickable:null}),p=new b({pickable:!1}),m=new b,S=new B([e.stateProperty],V=>{if(V.getWeirdEdges().length||V.hasInvalidFaceColors())return!1;const T=V.getSimpleRegions();return T.length===1&&T[0].isSolved}),C=V=>{V?h.addChild(new Mr(e.board,e.stateProperty,i)):h.children.forEach(T=>T.dispose())};i.faceColorsVisibleProperty.link(C),a.addChild(new Zr(e.board,e.stateProperty,i,r)),r.noninteractive||a.addChild(new Jr(e.board,r)),f.addChild(new Gr(e.board,e.stateProperty,S,i));const P=new Ie(e.board.outerBoundary,e.board.innerBoundaries,i,r);l.addChild(new ts(e.board,e.stateProperty,S,i)),w.addChild(new $r(e.board,e.stateProperty,S,i)),u.addChild(new Ur(e.board,e.stateProperty,S,i)),r.noninteractive||u.addChild(new jr(e.board,r.delayEdgeInteractionEmitter,r)),c.addChild(new Yr(e.board,e.stateProperty,i)),r.noninteractive||c.addChild(new Xr(e.board,r)),d.addChild(new Wr(e.board,e.stateProperty,i));super(ht({children:[P,h,a,c,u,l,d,w,f,p,m,g]},r));y(this,"annotationContainer");y(this,"backgroundNode");this.puzzle=e,this.annotationContainer=g;const E=V=>{p.children.forEach(T=>T.dispose()),V&&p.addChild(new Hr(V,e.board,i,r))};r.selectedFaceColorHighlightProperty.link(E),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(E));const I=V=>{m.children.forEach(T=>T.dispose()),V&&m.addChild(new zr(V,P,i,r))};r.selectedSectorEditProperty.link(I),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(I)),this.disposeEmitter.addListener(()=>{i.faceColorsVisibleProperty.unlink(C),[h,a,u,l,d,w,f,c].forEach(T=>{T.children.forEach(L=>L.dispose()),T.dispose()}),S.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class vs extends b{constructor(t,e,o){const r=Fe()({style:X},o),i=e.getEmbeddedCompleteData(t.inputFeatureSet),h=e.getEmbeddedCompleteData(t.outputFeatureSet),a=new it(new Xe(e.smallBoard,i),{noninteractive:!0,style:r.style}),c=new it(new Xe(e.smallBoard,h),{noninteractive:!0,style:r.style}),u=t.highlander?new b({children:e.getEmbeddedQuestionFaces(t.inputFeatureSet).map(S=>new at("?",{font:He,maxWidth:.9,maxHeight:.9,opacity:.5,fill:t.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:S.viewCoordinates}))}):new b,d=e.tightBounds.dilated(.5),w=.5,f=k.roundRectangle(d.x,d.y,d.width,d.height,w,w),g=new b({children:[a,u],clipArea:f,localBounds:d}),p=new b({children:[c,u],clipArea:f,localBounds:d}),m=new ut(new nt({spacing:.2,children:[g,new Do(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),p]}),{cornerRadius:w*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[m],super(r),this.rule=t,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{a.dispose(),c.dispose()})}}const os=(s,t)=>{Ne(Io,s,t,!0)};class ke{constructor(t,e,o,r,i,h,a,c,u,l){this.sourcePatternBoard=t,this.boardPatternBoard=e,this.largeBoard=o,this.embedding=r,this.smallBoard=i,this.toSmallFaceMap=h,this.toSmallEdgeMap=a,this.toSmallSectorMap=c,this.tightBounds=u,this.expandedBounds=l}mapFace(t){const e=this.embedding.mapFace(t),o=this.boardPatternBoard.getFace(e);if(o){const r=this.toSmallFaceMap.get(o);return A()&&R(r),r}else return null}mapEdge(t){return(t.isExit?this.embedding.mapExitEdges(t):[this.embedding.mapNonExitEdge(t)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const i=this.toSmallEdgeMap.get(r);return A()&&R(i),i})}mapSector(t){const e=this.embedding.mapSector(t),o=this.boardPatternBoard.getSector(e),r=this.toSmallSectorMap.get(o);return A()&&R(r),r}getEmbeddedQuestionFaces(t){const e=new Set;for(const o of t.patternBoard.faces)if(t.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&e.add(r)}return this.smallBoard.faces.filter(o=>!e.has(o))}getEmbeddedCompleteData(t){const e=Mt.empty(this.smallBoard);for(const o of t.getFeaturesArray())if(o instanceof Wo)o.value!==null&&e.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof Mo)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.BLACK));else if(o instanceof Ho)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.RED));else if(o instanceof zo)e.setSectorState(this.mapSector(o.sector),F.NOT_ZERO);else if(o instanceof Uo)e.setSectorState(this.mapSector(o.sector),F.NOT_ONE);else if(o instanceof jo)e.setSectorState(this.mapSector(o.sector),F.NOT_TWO);else if(o instanceof Yo)e.setSectorState(this.mapSector(o.sector),F.ONLY_ONE);else if(o instanceof Xo){const r=(h,a)=>{const c=this.mapFace(h),u=this.mapFace(a),l=c?e.getFaceColor(c):e.getOutsideColor(),d=u?e.getFaceColor(u):e.getOutsideColor();new ct(he(e,l),he(e,d)).apply(e)},i=(h,a)=>{const c=this.mapFace(h),u=this.mapFace(a),l=c?e.getFaceColor(c):e.getOutsideColor(),d=u?e.getFaceColor(u):e.getOutsideColor();new dt(he(e,l),he(e,d)).apply(e)};for(let h=1;h<o.primaryFaces.length;h++)r(o.primaryFaces[h-1],o.primaryFaces[h]);for(let h=1;h<o.secondaryFaces.length;h++)r(o.secondaryFaces[h-1],o.secondaryFaces[h]);o.secondaryFaces.length&&i(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return os(this.smallBoard,e),e}static getEmbeddingBounds(t,e,o){const r=De.NOTHING.copy(),i=a=>{r.addPoint(e.getVertex(o.mapVertex(a)).viewCoordinates)};t.vertices.forEach(i);const h=a=>{const c=e.getFace(o.mapFace(a));c&&c.vertices.forEach(u=>r.addPoint(u.viewCoordinates))};return t.faces.forEach(h),t.edges.forEach(a=>{let c;a.isExit?c=o.mapExitEdges(a).map(u=>e.getEdge(u)):c=[e.getEdge(o.mapNonExitEdge(a))],c.forEach(u=>{r.addPoint(u.start.viewCoordinates),r.addPoint(u.end.viewCoordinates)})}),r}static findBestEmbedding(t,e,o){const r=Jt(t,e);if(r.length===0)return null;const i=De.NOTHING.copy();o.vertices.forEach(u=>i.addPoint(u.viewCoordinates));const h=i.center;let a=null,c=Number.POSITIVE_INFINITY;for(let u=0;u<r.length;u++){const l=r[u],w=ke.getEmbeddingBounds(t,e,l).center,f=h.distance(w);f<c&&(c=f,a=l)}return a}static getDisplayEmbedding(t,e,o,r){const i=ke.getEmbeddingBounds(t,e,r),h=i.dilated(.5),a=o.faces.filter(p=>{const m=De.NOTHING.copy();return p.vertices.forEach(S=>m.addPoint(S.viewCoordinates)),h.intersectsBounds(m)}),c=o.vertices.filter(p=>p.faces.some(m=>a.includes(m))),u=Zt({vertices:c.map(p=>({logicalCoordinates:p.logicalCoordinates,viewCoordinates:p.viewCoordinates})),faces:a.map(p=>({logicalCoordinates:p.logicalCoordinates,vertices:p.vertices.map(m=>({logicalCoordinates:m.logicalCoordinates,viewCoordinates:m.viewCoordinates}))}))}),l=new _t(u),d=1e-6,w=new Map(a.map((p,m)=>{const S=l.faces.find(C=>C.viewCoordinates.equalsEpsilon(p.viewCoordinates,d));return A()&&R(S),[p,S]})),f=new Map(o.edges.map(p=>{const m=l.edges.find(S=>S.start.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,d)&&S.end.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,d)||S.start.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,d)&&S.end.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,d))??null;return m?[p,m]:null}).filter(p=>p!==null)),g=new Map(o.halfEdges.map(p=>{const m=l.halfEdges.find(S=>S.start.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,d)&&S.end.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,d))??null;return m?[p,m]:null}).filter(p=>p!==null));return A()&&R(r),new ke(t,e,o,r,l,w,f,g,i,h)}}export{ms as A,Br as B,Or as C,Lr as D,vs as E,Kr as F,Cs as G,ee as H,K as I,M as J,ys as K,Ss as L,dr as M,ke as N,Vr as O,it as P,qr as U,_r as V,fs as a,Jo as b,Zo as c,_o as d,er as e,X as f,$o as g,wr as h,gr as i,bt as j,rr as k,sr as l,ir as m,nr as n,ar as o,hr as p,cr as q,qo as r,os as s,tt as t,ot as u,lr as v,Ps as w,Dr as x,gs as y,ws as z};
