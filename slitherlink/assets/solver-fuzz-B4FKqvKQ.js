import"./UnivariatePolynomial-CzQEP6td.js";import{N as E,D as x,B as D}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{m as H,H as F,_ as h,e as W,f as k,P as G}from"./patternBoards-7WmHeiIn.js";import{p as L,g as M,a as V,s as d,A as y}from"./polygonGenerators-60g7ei5Y.js";import{E as z,B as I,s as w}from"./BasicPuzzle-B1djSMlq.js";import{P as O,D as v,O as q,f as S}from"./DisplayEmbedding-_katxJlX.js";import"./TextPushButton-B0wSyc3V.js";import{G as K}from"./SATSolver-CcH7PLXT.js";import"./Theme-CMAJrJpo.js";import"./SlitherQueryParameters-CBL8UsTw.js";import"./PatternRule-DJzvheEf.js";import"./PatternBoardSolver-D5oFTW2t.js";import"./compression-L63-wCoo.js";import"./SpinningIndicatorNode-Cnu8VvuS.js";self.assertions.enableAssert();const A=new E,R=new E({renderer:"svg",children:[A]}),c=new x(R,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(c.domElement);c.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");const T=e=>{const r=e.generate(e.defaultParameterValues);return new G(r,e.scale??1)},P=[new H(10,10),new F(4,1,!0),...L.map(T)];(async()=>{let e=null;const r=new D(!1);for(;;){console.log("board loaded");const t=P[Math.floor(Math.random()*P.length)],b=await M(t,r),p=await V(b,()=>!0,r),l=p.cleanState.clone();p.blackEdges.forEach(u=>l.setEdgeState(u,z.BLACK)),K(t,l);const m=I.fromSolvedPuzzle(p);e&&e.dispose(),e=new O(m,{scale:30,left:20,top:20}),A.addChild(e),c.updateDisplay(),await d(50);const o=m.stateProperty.value.clone(),f=v(t,o),g=()=>{m.stateProperty.value=o.clone(),c.updateDisplay()};let B=0;for(;!w(o);){if(e.clearAnnotationNodes(),B++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const u=o.clone(),N=f.clone(u),n=f.nextAction();if(n){console.log(n);const s=new q(t,o,l);e.addAnnotationNode(new y(t,n.annotation,S)),g(),await d(0);try{n.apply(s)}catch(i){console.error(i);debugger;const a=N.nextAction();a&&a.apply(s)}n.apply(o)}else if(!w(o)){const s=v(t,o),i=s.nextAction();if(i)throw e.addAnnotationNode(new y(t,i.annotation,S)),g(),await d(0),new Error("Fresh solver should not have any actions");s.dispose();const a=h.find(h.shuffle(t.edges),C=>o.getEdgeState(C)===z.WHITE);if(W()&&k(a),o.setEdgeState(a,l.getEdgeState(a)),console.log("setting white edge to red/black",a),!f.dirty)throw new Error("Solver should be dirty after setting edge state")}g(),await d(0)}if(!w(o))throw new Error("Solver did not solve the puzzle")}})();
