var Lt=Object.defineProperty;var Nt=(s,t,e)=>t in s?Lt(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var m=(s,t,e)=>(Nt(s,typeof t!="symbol"?t+"":t,e),e);import{d as B,h as N,B as Se,F as Pe,N as b,P as z,L as xt,m as Ue,R as Ot,H as at,M as ne,T as nt,G as At,C as lt,n as Rt}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{E as v,F as fe,U as Be,d as je,e as ct,f as dt,S as It,s as Bt,g as Ye,h as Dt,i as F,V as Wt,B as Xe,C as Mt}from"./BasicPuzzle-B1djSMlq.js";import{T as a,P as Ve,E as xe,e as Oe,o as be,f as oe,l as Ht,V as Y,k as Le,D as zt,c as ht,C as Ut,B as De}from"./UnivariatePolynomial-CzQEP6td.js";import{b as jt,L as le,a as Ae,c as Yt,P as ut}from"./TextPushButton-B0wSyc3V.js";import{i as qe,S as k,L as Ke,_ as Me,ab as Xt,e as A,f as R,m as qt,H as Kt,ac as pt,k as Gt,n as Jt,l as Zt,d as _t}from"./patternBoards-7WmHeiIn.js";import{Q as $t,R as Qt,S as eo,f as to,g as oo,h as Ge,K as ro,s as Je,i as so,j as io,v as Ze,k as ao,m as _e,w as no,n as re,q as lo,x as co,y as ho,z as uo,J as se,H as po,F as fo,B as go,D as wo,c as ie,T as yo,r as So,u as mo,U as He}from"./Theme-CMAJrJpo.js";import{S as ft,J as gt,K as wt,L as yt,N as St,V as mt,O as ue,P as Po,A as Co,B as vo,Q as Pt,R as Ct,T as vt,U as Re,W as Et,I as G,X as Eo,Y as Vo,Z as Fo,_ as bo,$ as To,a0 as ko,a1 as Lo,a2 as No,a3 as xo,a4 as Oo,C as Ne,z as Ao,a5 as $e,a6 as he,F as Ro,a7 as Io}from"./SATSolver-CcH7PLXT.js";import{c as Bo}from"./compression-L63-wCoo.js";import{A as Do}from"./SpinningIndicatorNode-Cnu8VvuS.js";import{a as Wo,B as Mo,R as Ho,b as zo,c as Uo,d as jo,S as Yo,e as Xo}from"./PatternRule-DJzvheEf.js";const Vt=(s,t,e,o)=>(r,i,h)=>{const c=[new ft(r,i),new gt(r,i)];return(s||t||e||o)&&(c.push(new wt(r,i)),(t||e||o)&&(c.push(new yt(r,i)),(e||o)&&(c.push(new St(r,i)),o&&c.push(new mt(r,i))))),new ue(c)},qo={allowEdgeEditProperty:$t,allowFaceColorEditProperty:Qt,allowSectorEditProperty:eo,edgesVisibleProperty:to,edgesHaveColorsProperty:oo,faceColorsVisibleProperty:Ge,faceColorThresholdProperty:ro,sectorsVisibleProperty:Je,sectorsNextToEdgesVisibleProperty:so,sectorsTrivialVisibleProperty:io,vertexStateVisibleProperty:Ze,allVertexStateVisibleProperty:ao,faceStateVisibleProperty:_e,whiteLineVisibleProperty:no,redLineVisibleProperty:re,verticesVisibleProperty:lo,smallVertexProperty:co,redXsVisibleProperty:ho,redXsAlignedProperty:uo,faceValueStyleProperty:se,redLineStyleProperty:po,vertexStyleProperty:fo,joinedLinesJoinProperty:go,joinedLinesCapProperty:wo,safeSolverFactoryProperty:new B([Ge,Je,Ze,_e],(s,t,e,o)=>Vt(s,t,e,o)),autoSolverFactoryProperty:Po,theme:ie},ce=(s,t,e,o,r)=>{const i=Vt(s,t,e,o);return{faceColorsVisibleProperty:new Se(s),sectorsVisibleProperty:new Se(t),vertexStateVisibleProperty:new Se(e),faceStateVisibleProperty:new Se(o),safeSolverFactoryProperty:new Ve(i),autoSolverFactoryProperty:r?new B([r],h=>(c,l,u)=>new ue([i(c,l,u),h(c,l,u)])):new Ve(i)}},ge=new B([Co,vo],(s,t)=>(e,o,r)=>new ue([new Pt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:s,solveAlmostEmptyToRed:!0},r?void 0:[]),new Ct(e,o,{solveToRed:!0,solveToBlack:s},r?void 0:[]),...t?[new vt(e,o,{solveToRed:!0,solveToBlack:s,resolveAllRegions:!1},r?void 0:[])]:[]])),Ko=new B([ge],s=>(t,e,o)=>new ue([s(t,e,o),new Re(t,e,{solveToRed:!0,solveToBlack:!0})])),Ft=new B([ge],s=>(t,e,o)=>new ue([s(t,e,o),new Et(t,e,o?void 0:[])])),Go=new B([Ft],s=>(t,e,o)=>new ue([s(t,e,o),new Re(t,e,{solveToRed:!0,solveToBlack:!0})])),Jo=s=>({...ce(!0,!1,!1,!1,ge),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!0),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),Zo=s=>({...ce(!0,!1,!1,!1,Ko),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),_o=s=>({...ce(!0,!1,!1,!1,new Ve((t,e,o)=>new ue([new Re(t,e,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:s,allowEdgeEditProperty:new a(!1),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!1),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),$o=s=>({...ce(!1,!1,!1,!1,ge),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:re,verticesVisibleProperty:new a(!0),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!0),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("square"),joinedLinesJoinProperty:new a("miter"),joinedLinesCapProperty:new a("square")}),fs=s=>({...ce(!1,!0,!1,!1,ge),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!1),redLineVisibleProperty:re,verticesVisibleProperty:new a(!0),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!0),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("square"),joinedLinesJoinProperty:new a("miter"),joinedLinesCapProperty:new a("square")}),Qo=s=>({...ce(!0,!0,!1,!1,Ft),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!1),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!0),faceColorThresholdProperty:new a(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),er=s=>({...ce(!0,!0,!1,!1,Go),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!0),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),tr=s=>({...ce(!0,!1,!0,!1,ge),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),or=s=>({...ce(!0,!1,!1,!0,ge),theme:s,allowEdgeEditProperty:new a(!0),allowFaceColorEditProperty:new a(!0),allowSectorEditProperty:new a(!1),edgesVisibleProperty:new a(!0),edgesHaveColorsProperty:new a(!1),faceColorThresholdProperty:new a(2),sectorsNextToEdgesVisibleProperty:new a(!1),sectorsTrivialVisibleProperty:new a(!1),allVertexStateVisibleProperty:new a(!1),whiteLineVisibleProperty:new a(!0),redLineVisibleProperty:re,verticesVisibleProperty:new a(!1),smallVertexProperty:new a(!1),redXsVisibleProperty:new a(!1),redXsAlignedProperty:new a(!1),faceValueStyleProperty:se,redLineStyleProperty:new a("middle"),vertexStyleProperty:new a("round"),joinedLinesJoinProperty:new a("round"),joinedLinesCapProperty:new a("round")}),rr=Jo(ie),sr=Zo(ie),ir=_o(ie),bt=$o(ie),ar=Qo(ie),nr=er(ie),lr=tr(ie),cr=or(ie),We={basicLines:rr,basicFaceColoring:sr,pureFaceColor:ir,classic:bt,basicSectors:ar,sectorsWithColors:nr,vertexState:lr,faceState:cr,custom:qo},Qe=bt,dr=s=>({allowEdgeEditProperty:new N(s,{derive:"allowEdgeEditProperty"}),allowFaceColorEditProperty:new N(s,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new N(s,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new N(s,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new N(s,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new N(s,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new N(s,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new N(s,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new N(s,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new N(s,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new N(s,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new N(s,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new N(s,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new N(s,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new N(s,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new N(s,{derive:"verticesVisibleProperty"}),smallVertexProperty:new N(s,{derive:"smallVertexProperty"}),redXsVisibleProperty:new N(s,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new N(s,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new N(s,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new N(s,{derive:"redLineStyleProperty"}),vertexStyleProperty:new N(s,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new N(s,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new N(s,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new N(s,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new N(s,{derive:"autoSolverFactoryProperty"}),theme:yo(new B([s],t=>t.theme))}),hr=new jt("puzzleStyle",{serialize:s=>Object.keys(We).find(t=>We[t]===s),deserialize:s=>s?We[s]??Qe:Qe}),X=dr(hr),gs=new le("showPuzzleStyleProperty",!0),ws=new le("showPuzzleTimerProperty",!1),W=class W extends xe{constructor(t){super(),this.isEnabledProperty=t}};m(W,"EDGE_STATE",new W(X.allowEdgeEditProperty)),m(W,"EDGE_STATE_REVERSED",new W(X.allowEdgeEditProperty)),m(W,"FACE_COLOR_MATCH",new W(X.allowFaceColorEditProperty)),m(W,"FACE_COLOR_OPPOSITE",new W(X.allowFaceColorEditProperty)),m(W,"SECTOR_STATE",new W(X.allowSectorEditProperty)),m(W,"VERTEX_STATE",new W(X.vertexStateVisibleProperty)),m(W,"FACE_STATE",new W(X.faceStateVisibleProperty)),m(W,"FACE_VALUE",new W(new Se(!1))),m(W,"DELETE_FACE",new W(new Se(!1))),m(W,"enumeration",new Oe(W));let M=W;const K=new Ae("editModeProperty",M.EDGE_STATE);M.enumeration.values.forEach(s=>{s.isEnabledProperty.lazyLink(t=>{if(!K.value.isEnabledProperty.value){const e=M.enumeration.values.find(o=>o.isEnabledProperty.value)??null;e&&(K.value=e)}})});const ys=new le("eraserEnabledProperty",!1),Ss=s=>{s.isEnabledProperty.value&&(K.value=s)},ur=new B([K],s=>s===M.EDGE_STATE||s===M.EDGE_STATE_REVERSED),Tt=new B([K],s=>s===M.FACE_COLOR_MATCH||s===M.FACE_COLOR_OPPOSITE),pr=new B([K],s=>s===M.SECTOR_STATE),fr=new B([K],s=>s===M.VERTEX_STATE),gr=new B([K,Tt],(s,t)=>t||s===M.FACE_STATE||s===M.FACE_VALUE||s===M.DELETE_FACE),wr=(s,t,e)=>{const o=new Pe({mouseButton:0,fire:h=>{var c;return e&&e(s,(c=h.domEvent)!=null&&c.shiftKey?2:0)}}),r=new Pe({mouseButton:2,fire:h=>{var c;return e&&e(s,(c=h.domEvent)!=null&&c.shiftKey?0:2)}}),i=new Pe({mouseButton:1,fire:h=>e&&e(s,1)});t.addInputListener(o),t.addInputListener(r),t.addInputListener(i),t.cursor="pointer",t.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),i.dispose()})};class Ie extends b{constructor(t,e,o,r){const i=be()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},noninteractive:!1},r);super({pickableProperty:Tt}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,!i.noninteractive&&wr(null,this,i.facePressListener);const h=t.map(f=>f.start.viewCoordinates),c=i.useBackgroundOffsetStroke,l=i.backgroundOffsetDistance,n=qe(h)>0?-l:l,d=f=>{const g=new Xt;g.addShape(0,f),g.computeSimplifiedFaces(),g.computeFaceInclusion(P=>P[0]>0);const w=g.createFilledSubGraph(),S=w.facesToShape();return g.dispose(),w.dispose(),S},y=Ie.getOffsetBackgroundShape(t,c,l),p=e.map(f=>{const g=f.map(S=>S.start.viewCoordinates),w=k.polygon(g);if(c)return d(w.getOffsetShape(n));{const P=w.getStrokedShape(new Ke({lineWidth:2*l})).subpaths.map(C=>new k([C]));return d(Me.minBy(P,C=>C.getArea()))}});this.children=[new z(y,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...p.map(f=>new z(f,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(l=>l.start.viewCoordinates),i=k.polygon(r),c=qe(r)>0?-o:o;if(e)return i.getOffsetShape(c).getSimplifiedAreaShape();{const l=i.getStrokedShape(new Ke({lineWidth:2*o})),u=l.subpaths.map(n=>new k([n]));try{return l.bounds.width===9.718028227819117?k.bounds(l.bounds):Me.maxBy(u,n=>n.getArea()).getSimplifiedAreaShape()}catch{return k.bounds(l.bounds)}}}}class yr{constructor(t,e,o){m(this,"edgeStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(A()&&R(this.board.edges.includes(t)),e!==v.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new G(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Sr{constructor(t,e,o){m(this,"faceColorsChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,i){if(i)throw new G("invalid face color?");const h=new Set([...o.values(),...r.keys(),...o.values()]),c=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())c.set(n,o.get(n));const l=n=>r.has(n)?r.get(n):[...t].includes(n)?this.currentState.getOppositeFaceColor(n):null,u=new Map;for(const n of c.keys()){const d=c.get(n);u.has(d)||u.set(d,new Set([n])),u.get(d).add(n)}for(const n of h){const d=u.get(n);if(!d)continue;const y=[...d];A()&&R(y.length>0);const p=this.solvedState.getFaceColor(y[0]);for(const g of y)if(this.solvedState.getFaceColor(g)!==p)throw new G("invalid face color");const f=l(n);if(f){let g;if(f.colorState===fe.INSIDE?g=this.solvedState.getInsideColor():f.colorState===fe.OUTSIDE?g=this.solvedState.getOutsideColor():g=this.solvedState.getFaceColor([...u.get(f)][0]),p===g)throw new G("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class mr{constructor(t,e,o){m(this,"simpleRegionsChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new G("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Pr{constructor(t,e,o){m(this,"faceValueChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new G("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Cr{constructor(t,e,o){m(this,"sectorStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){A()&&R(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class vr{constructor(t,e,o){m(this,"vertexStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){A()&&R(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new G("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Er{constructor(t,e,o){m(this,"faceStateChangedEmitter",new oe);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){A()&&R(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new G(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new G("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Vr{constructor(t,e,o){m(this,"anyStateChangedEmitter",new oe);m(this,"edgeStateValidator");m(this,"faceValueValidator");m(this,"simpleRegionDataValidator");m(this,"faceColorValidator");m(this,"sectorStateValidator");m(this,"vertexStateValidator");m(this,"faceStateValidator");A()&&R(t),A()&&R(o),this.edgeStateValidator=new yr(t,e,o),this.faceValueValidator=new Pr(t,e,o),this.simpleRegionDataValidator=new mr(t,e,o),this.faceColorValidator=new Sr(t,e,o),this.sectorStateValidator=new Cr(t,e,o),this.vertexStateValidator=new vr(t,e,o),this.faceStateValidator=new Er(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,i){this.faceColorValidator.modifyFaceColors(t,e,o,r,i)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const H=class H extends xe{constructor(t,e,o){super(),this.fromWhite=t,this.fromBlack=e,this.fromRed=o}apply(t){return t===v.WHITE?this.fromWhite:t===v.BLACK?this.fromBlack:this.fromRed}};m(H,"CYCLE",new H(v.BLACK,v.RED,v.WHITE)),m(H,"REVERSE_CYCLE",new H(v.RED,v.WHITE,v.BLACK)),m(H,"WHITE_SET",new H(v.WHITE,v.WHITE,v.WHITE)),m(H,"BLACK_SET",new H(v.BLACK,v.BLACK,v.BLACK)),m(H,"RED_SET",new H(v.RED,v.RED,v.RED)),m(H,"BLACK_TOGGLE",new H(v.BLACK,v.WHITE,v.BLACK)),m(H,"RED_TOGGLE",new H(v.RED,v.RED,v.WHITE)),m(H,"enumeration",new Oe(H));let Fe=H;const Fr=new Ae("pressStyle0",Fe.CYCLE),br=new Ae("pressStyle1",Fe.WHITE_SET),Tr=new Ae("pressStyle2",Fe.REVERSE_CYCLE),kr=s=>{switch(s){case 0:return Fr.value;case 1:return br.value;case 2:return Tr.value}},Lr=(s,t,e)=>new ue([new ft(s,t),new gt(s,t),new wt(s,t),new Pt(s,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Ct(s,t,{solveToRed:!0,solveToBlack:!0}),new vt(s,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new Eo(s,t),new yt(s,t),new Et(s,t),new Vo(s,t),new St(s,t),new Fo(s,t,{solveToRed:!0,solveToBlack:!0}),new bo(s,t),new Re(s,t,{solveToRed:!0,solveToBlack:!0}),new To(s,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new ko(s,t),new mt(s,t),new Lo(s,t,{solveToRed:!0,solveToBlack:!0}),new No(s,t),new xo(s,t),new Oo(s,t)]),et=(s,t,e)=>{Ne(e,s,t,!0)};class Nr{constructor(t){this.hintAction=t}get annotation(){return this.hintAction.annotation}apply(t){this.hintAction.apply(t)}getUndo(t){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(t,e){throw new Error("unimplemented")}}const xr=s=>s instanceof qt?{type:"SquareBoard",width:s.width,height:s.height}:s instanceof Kt?{type:"HexagonalBoard",radius:s.radius,scale:s.scale,isPointyTop:s.isPointyTop,holeRadius:s.holeRadius}:{type:"BaseBoard",vertices:s.vertices.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vx:t.viewCoordinates.x,vy:t.viewCoordinates.y})),faces:s.faces.map(t=>({x:t.logicalCoordinates.x,y:t.logicalCoordinates.y,vertices:t.vertices.map(e=>s.vertices.indexOf(e))}))},kt=s=>({version:1,board:xr(s.board),state:s.stateProperty.value.serializeState(s.board)}),Or=s=>{const t=kt(s);return Bo(JSON.stringify(t))};function Ar(s){return new Worker(""+new URL("hintWorker-CVZ9o6xx.js",import.meta.url).href,{name:s==null?void 0:s.name})}let we=null;const ke=new a(!1),Rr=()=>(we||(we=new Ar,we==null||we.addEventListener("message",s=>{s.data.type==="hint-worker-loaded"&&(ke.value=!0)})),we),Ir=s=>{const t=kt(s),e=s.solution.cleanState.serializeState(s.board),o=s.solution.solvedState.serializeState(s.board),r=[...s.solution.blackEdges].map(i=>s.board.edges.indexOf(i));return{puzzle:t,cleanState:e,solvedState:o,blackEdges:r}},q=class q extends xe{};m(q,"DEFAULT",new q),m(q,"LOADING",new q),m(q,"SEARCHING",new q),m(q,"FOUND",new q),m(q,"NOT_FOUND",new q),m(q,"enumeration",new Oe(q));let ee=q;const Br=new le("uiHintUsesBuiltInSolve",!1),ms=new le("showUndoRedoAllProperty",!1),tt=new le("dimCompletedNumbersProperty",!0),ot=new le("highlightIncorrectNumbersProperty",!0),Ps=new le("highlightIncorrectMovesProperty",!0),Dr=new le("highlightIntersectionsProperty",!0);class Cs extends Ht{constructor(e,o){const r=be()({style:X,initialTimeElapsed:0},o),i=r.style;super();m(this,"timeElapsedProperty",new a(0));m(this,"hintStateProperty",new a(ee.DEFAULT));m(this,"edgeAutoSolvedEmitter",new oe);m(this,"stack");m(this,"stackLengthProperty",new a(0));m(this,"stackPositionProperty",new a(0));m(this,"undoPossibleProperty");m(this,"redoPossibleProperty");m(this,"currentSnapshotProperty");m(this,"hasErrorProperty");m(this,"isSolvedProperty");m(this,"hintWorkerMessageID",0);m(this,"addedHintListener",!1);m(this,"pendingHintActionProperty",new a(null));m(this,"displayedAnnotationProperty");m(this,"pendingActionFaceColorProperty",new a(null));m(this,"pendingActionSectorProperty",new a(null));m(this,"selectedFaceColorHighlightProperty");m(this,"selectedSectorEditProperty");m(this,"autoSolverFactoryProperty");m(this,"style");this.puzzle=e,this.style=i,this.timeElapsedProperty.value=r.initialTimeElapsed,this.autoSolverFactoryProperty=new B([Ao,i.safeSolverFactoryProperty,i.autoSolverFactoryProperty],(l,u,n)=>l?n:u),this.displayedAnnotationProperty=new B([this.pendingHintActionProperty],l=>l?l.annotation:null);const h=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(h),K.lazyLink(h),this.disposeEmitter.addListener(()=>K.unlink(h)),this.selectedFaceColorHighlightProperty=new B([e.stateProperty,K,this.pendingActionFaceColorProperty],(l,u,n)=>{if((u===M.FACE_COLOR_MATCH||u===M.FACE_COLOR_OPPOSITE)&&n){const d=l.getFacesWithColor(n.color);return{faceColor:n.color,face:n.face,faces:d}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new B([e.stateProperty,K,this.pendingActionSectorProperty],(l,u,n)=>u===M.SECTOR_STATE&&n?{sector:n,currentState:l.getSectorState(n)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const l=e.stateProperty.value.clone();et(e.board,l,this.style.safeSolverFactoryProperty.value),e.stateProperty.value=l}this.stack=[new Ce(this.puzzle.board,null,e.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new B([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new B([this.currentSnapshotProperty],l=>l.errorDetected),this.isSolvedProperty=new B([this.currentSnapshotProperty],l=>{if(l.state.getWeirdEdges().length||l.state.hasInvalidFaceColors())return!1;const u=l.state.getSimpleRegions();return u.length===1&&u[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new B([this.stackPositionProperty],l=>l>0),this.redoPossibleProperty=new B([this.stackPositionProperty,this.stackLengthProperty],(l,u)=>l<u-1);const c=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(c),this.style.safeSolverFactoryProperty.lazyLink(c),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(c),this.style.safeSolverFactoryProperty.unlink(c)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(e){this.timeElapsedProperty.value+=e,localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Or(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(e){this.wipeStackTop(),this.stack.push(e),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(e,o){const r=(o==null?void 0:o.forceDirty)||e instanceof Be,h=this.stack[this.stackPositionProperty.value].state;let c=!1;const l=new Vr(this.puzzle.board,h,this.puzzle.solution.solvedState);try{e.apply(l)}catch{c=!0}let u=new Set;const n=p=>{u.add(p)};let d=h.createDelta();try{if(d.edgeStateChangedEmitter.addListener(n),$e(this.autoSolverFactoryProperty.value,this.puzzle.board,d,()=>{e.apply(d)},r),d.edgeStateChangedEmitter.removeListener(n),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(d)))throw new G("Auto-solver did not respect user action")}catch(p){if(c=!0,u=new Set,p instanceof G)console.log("error"),d=h.createDelta(),d.edgeStateChangedEmitter.addListener(n),$e(this.style.safeSolverFactoryProperty.value,this.puzzle.board,d,()=>{e.apply(d)},r),d.edgeStateChangedEmitter.removeListener(n);else throw p}const y=h.clone();d.apply(y),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,e,y,c));for(const p of u)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(p))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(p))}addAutoSolveDelta(){const e=this.puzzle.stateProperty.value.createDelta();try{if(Ne(this.autoSolverFactoryProperty.value,this.puzzle.board,e,!0),!e.isEmpty()){const o=this.puzzle.stateProperty.value.clone();e.apply(o),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Be,o))}}catch(o){if(!(o instanceof G))throw o}}onAutoSolveChange(){const e=this.stack[this.stackPositionProperty.value];e.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(e.action||new Be,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(e,o){const r=K.value===M.EDGE_STATE_REVERSED;return kr(r?2-o:o).apply(e)}onUserEdgePress(e,o){const r=this.puzzle.stateProperty.value.getEdgeState(e),i=this.getNewEdgeState(r,o);if(r!==i){const h=this.stack[this.stackPositionProperty.value];h.action&&h.action instanceof je&&h.action.edge===e&&this.stackPositionProperty.value--;const c=new je(e,i);this.applyUserActionToStack(c,{checkAutoSolve:l=>l.getEdgeState(e)===i,excludedEdges:new Set([e])}),this.updateState()}}onUserFacePress(e,o){let r=K.value===M.FACE_COLOR_MATCH;o===2&&(r=!r);const i=e?this.puzzle.stateProperty.value.getFaceColor(e):this.puzzle.stateProperty.value.getOutsideColor(),h=this.pendingActionFaceColorProperty.value;if(h){if(e!==h.face){const c=h.color;c!==i&&(r?this.applyUserActionToStack(new ct(he(this.puzzle.stateProperty.value,i),he(this.puzzle.stateProperty.value,c))):this.applyUserActionToStack(new dt(he(this.puzzle.stateProperty.value,i),he(this.puzzle.stateProperty.value,c))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:e,color:i}}onUserSectorPress(e,o){this.pendingActionSectorProperty.value=e}onUserSectorSet(e,o){this.applyUserActionToStack(new It(e,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const e=this.puzzle.stateProperty.value;if(!Bt(e))if(Br.value){const o=e.clone();Ne(Lr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Ye,o,!1)),this.updateState()}else{const o=Ro(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(i=>{r.setEdgeState(i,v.BLACK)}),et(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(new Ce(this.puzzle.board,new Ye,r,!1)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ee.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(e){this.hintStateProperty.value=e?ee.FOUND:ee.NOT_FOUND,e&&(this.pendingHintActionProperty.value=e)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const e=X.allowEdgeEditProperty.value,o=X.allowFaceColorEditProperty.value,r=X.allowSectorEditProperty.value,i=X.vertexStateVisibleProperty.value,h=X.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const c=Rr();if(!this.addedHintListener){this.addedHintListener=!0;const l=u=>{if(u.data.type==="hint-response"&&u.data.id===this.hintWorkerMessageID){const n=u.data.action?Dt(this.puzzle.board,u.data.action):null;this.onHintReceived(n)}};c.addEventListener("message",l),this.disposeEmitter.addListener(()=>self.removeEventListener("message",l))}if(c.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:e,solveColors:o,solveSectors:r,solveVertexState:i,solveFaceState:h,serializedSolvablePuzzle:Ir(this.puzzle)}),ke.value)this.hintStateProperty.value=ee.SEARCHING;else{this.hintStateProperty.value=ee.LOADING;const l=u=>{u&&(this.hintStateProperty.value===ee.LOADING&&(this.hintStateProperty.value=ee.SEARCHING),ke.unlink(l))};ke.link(l)}}onUserApplyHint(){const e=this.pendingHintActionProperty.value;e&&(this.clearPendingHint(),this.applyUserActionToStack(new Nr(e)),this.updateState())}}class Ce{constructor(t,e,o,r=!1){this.board=t,this.action=e,this.state=o,this.errorDetected=r}}class Wr extends b{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});m(this,"simpleRegionNodeMap",new Map);m(this,"regionIdMap",new Map);m(this,"weirdEdgeNodeMap",new Map);m(this,"regionContainer",new b);m(this,"weirdEdgeContainer",new b);m(this,"adjacentFacesMap",new Map);m(this,"weirdEdgeColorProperty");this.board=e,this.style=r,this.weirdEdgeColorProperty=new B([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,Dr],(c,l,u)=>u?c:l),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),e.faces.forEach(c=>{this.adjacentFacesMap.set(c,c.edges.map(l=>l.getOtherFace(c)).filter(l=>l!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(c=>this.addRegion(c)),o.value.getWeirdEdges().forEach(c=>this.addWeirdEdge(c)),this.updateHues();const i=(c,l)=>{const u=l.getSimpleRegions(),n=c.getSimpleRegions(),d=l.getWeirdEdges(),y=c.getWeirdEdges(),p=[],f=[];pt(u,n,p,f,[]);const w=new Set(p);for(const S of f)if(this.regionIdMap.has(S.id)){const P=this.regionIdMap.get(S.id);this.replaceRegion(P,S),w.delete(P)}else this.addRegion(S);for(const S of w)this.removeRegion(S);for(const S of d)y.includes(S)||this.removeWeirdEdge(S);for(const S of y)d.includes(S)||this.addWeirdEdge(S);(f.length||p.length)&&this.updateHues()};o.lazyLink(i),this.disposeEmitter.addListener(()=>o.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const h=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(h),r.edgesHaveColorsProperty.lazyLink(h),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(h),r.edgesHaveColorsProperty.unlink(h)})}addRegion(e){const o=new me(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){A()&&R(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,i=new xt(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const h=c=>{i.lineCap=c};this.style.joinedLinesCapProperty.link(h),i.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(h))}this.weirdEdgeNodeMap.set(e,i),this.weirdEdgeContainer.addChild(i)}removeWeirdEdge(e){this.weirdEdgeNodeMap.get(e).dispose(),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new Y(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},i=new Map,h=[];this.board.faces.forEach(n=>{i.set(n,[])});for(const n of e){const d=new Set;for(const p of n.simpleRegion.edges)for(const f of p.faces)d.add(f);const y=new Set;for(const p of d){y.add(p);for(const f of this.adjacentFacesMap.get(p))y.add(f)}for(const p of y){const f=i.get(p);if(f.length)for(const g of f){let w=!1;for(const S of h)if(S.a===g&&S.b===n){S.weight++,w=!0;break}w||h.push({a:g,b:n,weight:1})}f.push(n)}}const c=new Map;for(const n of e)c.set(n,Y.ZERO.copy());const l=(n,d,y)=>{const p=c.get(n),f=c.get(d),g=n.hueVector.dot(d.hueVector),w=o.set(d.hueVector).subtract(n.hueVector);if(w.magnitude>1e-9){w.normalize();const S=.3,P=y*((Math.max(S,g)-S)/(1-S))**3;w.multiplyScalar(P),p.subtract(w),f.add(w)}};let u=1;for(let n=0;n<100;n++){u*=.99;for(const d of e)c.get(d).setXY(0,0);for(const d of h){const y=d.a,p=d.b,f=d.weight;l(y,p,f)}if(e.length<8)for(let d=0;d<e.length;d++){const y=e[d];for(let p=d+1;p<e.length;p++)l(y,e[p],.2)}for(const d of e){const y=c.get(d);y.multiplyScalar(u/d.edgeCount),d.hueVector.add(y),c.get(d).setXY(0,0)}r()}for(const n of e)n.updateHue()}}class me extends z{constructor(e,o){const r=Y.createPolar(1,Le.nextDoubleBetween(0,2*Math.PI));super(me.toShape(e),{stroke:me.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});m(this,"hueVector");m(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const i=c=>{this.lineJoin=c};o.joinedLinesJoinProperty.link(i),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(i));const h=c=>{this.lineCap=c};o.joinedLinesCapProperty.link(h),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(h))}updateHue(){this.stroke=me.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Y.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=me.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,i=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&R(i>=0&&i<r.length),o.edgesHaveColorsProperty.value?r[i]:o.theme.blackLineColorProperty}static toShape(e){const o=new k;let r=!0;for(const i of e.halfEdges)r&&(r=!1,o.moveToPoint(i.start.viewCoordinates)),o.lineToPoint(i.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class Mr extends b{constructor(e,o,r){const i=new b;super({pickable:!1,children:[i]});m(this,"faceColorNodeMap",new Map);m(this,"faceColorIdMap",new Map);m(this,"adjacentFacesMap",new Map);m(this,"faceColorNodeContainer");m(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=i,e.faces.forEach(u=>{this.adjacentFacesMap.set(u,u.edges.map(n=>n.getOtherFace(u)).filter(n=>n!==null))});{const u=o.value.getFaceColors();for(const n of u)this.addFaceColor(n,o.value.getFacesWithColor(n));this.addDualColorViews(o.value,u)}this.updateHues();let h=o.value.clone();const c=u=>{const n=h;h=u.clone();const d=n.getFaceColors(),y=u.getFaceColors(),p=[],f=[],g=[];pt(d,y,p,f,g);const w=new Set(p),S=this.removeInvalidDualColorViews(u),P=[...S];for(const C of f)if(S.add(C),this.faceColorIdMap.has(C.id)){const E=this.faceColorIdMap.get(C.id);this.replaceFaceColor(E,C,u.getFacesWithColor(C)),w.delete(E)}else this.addFaceColor(C,u.getFacesWithColor(C));for(const C of g)this.updateFaceColor(C,u.getFacesWithColor(C));for(const C of w)S.delete(C),this.removeFaceColor(C);this.addDualColorViews(u,[...S]),(f.length||p.length||P.length)&&this.updateHues()};o.lazyLink(c),this.disposeEmitter.addListener(()=>o.unlink(c)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const l=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(l),r.theme.faceColorLightHueLUTProperty.lazyLink(l),r.theme.faceColorDarkHueLUTProperty.lazyLink(l),r.theme.faceColorInsideColorProperty.lazyLink(l),r.theme.faceColorOutsideColorProperty.lazyLink(l),r.theme.faceColorDefaultColorProperty.lazyLink(l),r.faceColorThresholdProperty.lazyLink(l),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(l),r.theme.faceColorLightHueLUTProperty.unlink(l),r.theme.faceColorDarkHueLUTProperty.unlink(l),r.theme.faceColorInsideColorProperty.unlink(l),r.theme.faceColorOutsideColorProperty.unlink(l),r.theme.faceColorDefaultColorProperty.unlink(l),r.faceColorThresholdProperty.unlink(l)})}addFaceColor(e,o){const r=new Ee(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){A()&&R(e.id===o.id);const i=this.faceColorNodeMap.get(e);i.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,i),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let i=r.faces.length!==o.length;if(!i)for(let h=0;h<o.length;h++){const c=r.faces[h],l=o[h];if(c!==l){i=!0;break}}i&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const i=r.values().next().value;r.delete(i);const h=this.faceColorNodeMap.get(i);A()&&R(h);const c=e.getOppositeFaceColor(i);if(c){A()&&R(r.has(c)),r.delete(c);const l=this.faceColorNodeMap.get(c);A()&&R(l),this.dualColorViews.add(new rt([h,l],this.style))}else this.dualColorViews.add(new rt([h],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const i of[...this.dualColorViews])if(!i.isStillValidInState(this.stateProperty.value,r)){for(const h of i.colorNodes)o.add(h.faceColor);this.dualColorViews.delete(i),i.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==fe.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new Y(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(Le.nextDouble()-.5,Le.nextDouble()-.5).normalize()},i=new Map,h=[];this.board.faces.forEach(n=>{i.set(n,[])});for(const n of e){const d=new Set;for(const p of n.faces)d.add(p);const y=new Set;for(const p of d){y.add(p);for(const f of this.adjacentFacesMap.get(p))y.add(f)}for(const p of y){const f=i.get(p);if(f){if(f.length)for(const g of f){let w=!1;for(const S of h)if(S.a===g&&S.b===n){S.weight++,w=!0;break}w||h.push({a:g,b:n,weight:1})}f.push(n)}}}const c=new Map;for(const n of e)c.set(n,Y.ZERO.copy());const l=(n,d,y)=>{const p=c.get(n),f=c.get(d),g=n.hueVector.dot(d.hueVector),w=o.set(d.hueVector).subtract(n.hueVector);w.magnitudeSquared>1e-11&&w.normalize();const S=.2,P=Math.abs(g),C=y*((Math.max(S,P)-S)/(1-S))**3;w.multiplyScalar(C),p.subtract(w),f.add(w)};let u=1;for(let n=0;n<100;n++){u*=.99;for(const d of e)c.get(d).setXY(0,0);for(const d of h){const y=d.a,p=d.b,f=d.weight;l(y,p,f)}if(e.length<8)for(let d=0;d<e.length;d++){const y=e[d];for(let p=d+1;p<e.length;p++)l(y,e[p],.2)}for(const d of e){const y=c.get(d);y.multiplyScalar(u/d.faceCount),d.hueVector.add(y),c.get(d).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const te=class te extends xe{};m(te,"BASIC",new te),m(te,"PRIMARY",new te),m(te,"SECONDARY",new te),m(te,"enumeration",new Oe(te));let $=te;class rt{constructor(t,e){m(this,"hueVector");m(this,"faceCount");if(this.colorNodes=t,this.style=e,A()&&R(t.length===1||t.length===2),this.faceCount=Me.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=$.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let i;o.type===$.PRIMARY?i=o:r.type===$.PRIMARY||o.type===$.SECONDARY?i=r:(r.type,$.SECONDARY,i=o);const h=i===o?r:o;this.hueVector=o.hueVector.copy(),i.type=$.PRIMARY,h.type=$.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class Ee extends z{constructor(e,o,r){const i=Y.createPolar(1,Le.nextDoubleBetween(0,2*Math.PI));super(Ee.toShape(o));m(this,"hueVector");m(this,"faceCount");m(this,"dualColorView",null);m(this,"type",$.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=i,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==fe.UNDECIDED?this.fill=Ee.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Y.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=Ee.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,i){const h=r===$.BASIC?i.theme.faceColorBasicHueLUTProperty.value:r===$.PRIMARY?i.theme.faceColorLightHueLUTProperty.value:i.theme.faceColorDarkHueLUTProperty.value,c=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&R(c>=0&&c<h.length);const l=h[c];if(o===fe.UNDECIDED)return l;{const n=(o===fe.INSIDE?i.theme.faceColorInsideColorProperty:i.theme.faceColorOutsideColorProperty).value,d=n.alpha,y=new Ue(l);return new Ue((1-d)*y.red+d*n.red,(1-d)*y.green+d*n.green,(1-d)*y.blue+d*n.blue).toCSS()}}static toShape(e){const o=new k;for(const r of e)o.polygon(r.vertices.map(i=>i.viewCoordinates));return o.makeImmutable()}}class Hr extends b{constructor(t,e,o,r){let i=[];try{let h=new k;for(const l of t.faces)h.polygon(l.vertices.map(u=>u.viewCoordinates));if(t.faceColor.colorState===fe.OUTSIDE)try{const l=k.polygon(e.outerBoundary.map(d=>d.start.viewCoordinates)),n=Ie.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(l);h=h.bounds.isValid()?h.shapeUnion(n):n}catch(l){console.error(l)}const c=new z(h.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});i.push(c)}catch(h){console.error(h)}super({children:i}),this.selectedFaceColorHighlight=t}}class ae extends b{static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,i=t.next.end.viewCoordinates,h=o.minus(r),c=i.minus(r),l=h.normalized(),n=c.normalized().minus(l).angle+Math.PI/2,d=t.face?t.face.viewCoordinates:Y.createPolar(e,n).plus(r),y=o.average(r),p=i.average(r);return k.polygon([y,r,p,d]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,i=t.next.end.viewCoordinates,h=o.minus(r),c=i.minus(r),l=h.normalized(),u=h.angle;let n=c.angle;return n<u&&(n+=2*Math.PI),new k().moveToPoint(r).lineToPoint(l.timesScalar(e).plus(r)).arcPoint(r,e,u,n,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===F.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===F.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===F.NOT_ONE?e.theme.sectorNotOneColorProperty:t===F.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}}m(ae,"nameMap",new Map([[F.NONE,"Invalid"],[F.ONLY_ZERO,"No Lines"],[F.ONLY_ONE,"Only One Line"],[F.ONLY_TWO,"Both Lines"],[F.NOT_ZERO,"At Least One Line"],[F.NOT_ONE,"Zero or Two Lines"],[F.NOT_TWO,"Less Than Two Lines"],[F.ANY,"Any Lines"]]));class zr extends b{constructor(t,e,o,r){const i=[],h=[],c=t.sector,l=t.currentState,u=ae.getSectorArcShape(c,.5),n=new z(u.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});i.push(n);const d=[];if(l===F.ANY&&(d.push(F.NOT_ZERO),d.push(F.NOT_ONE),d.push(F.NOT_TWO)),l.one&&l!==F.ONLY_ONE&&d.push(F.ONLY_ONE),d.length){const y=d.map(g=>{const w=ae.getStrokeFromStyle(g,o);return new Yt({accessibleName:ae.nameMap.get(g),content:new Ot(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(c,g)},buttonAppearanceStrategy:So,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});h.push(...y);const p=new ut(new at({children:y,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});h.push(p);const f=.1;i.push(p),p.centerBottom=n.centerTop.plusXY(0,-.15),p.top<e.top+f&&(p.centerTop=n.centerBottom.plusXY(0,.15)),p.left<e.left+f&&(p.left=e.left+f),p.right>e.right-f&&(p.right=e.right-f)}super({children:i}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{h.forEach(y=>y.dispose())})}}class Ur extends b{constructor(t,e,o,r){const i=new z(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),h=new z(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),c=new z(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[i,h,c],pickable:!1});const l=t.edges.map(g=>v.BLACK);let u=!1,n=!1,d=!1,y=!1,p=null;const f=ne.multilink([e,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(g,w,S,P,C,E,I)=>{if(this.visible=!w,i.visible=S,h.visible=P,c.visible=E,this.visible){let V=!1;for(let T=0;T<t.edges.length;T++){const L=g.getEdgeState(t.edges[T]);L!==l[T]&&(V=!0,l[T]=L)}if(u!==C&&(V=!0,u=C),n!==S&&(V=!0,n=S),d!==P&&(V=!0,d=P),y!==E&&(V=!0,y=E),p!==I&&(V=!0,p=I),V){const T=new k,L=new k,_=new k;for(let J=0;J<t.edges.length;J++){const de=l[J];if(S&&de===v.WHITE){const x=t.edges[J];T.moveTo(x.start.viewCoordinates.x,x.start.viewCoordinates.y),T.lineTo(x.end.viewCoordinates.x,x.end.viewCoordinates.y)}if(de===v.RED){if(P){const x=t.edges[J],O=.07;let D=x.start.viewCoordinates.blend(x.end.viewCoordinates,.5);if(C){const U=x.end.viewCoordinates.minus(x.start.viewCoordinates).getAngle(),j=new Y(-O,-O).rotate(U).add(D),Z=new Y(O,O).rotate(U).add(D),Q=new Y(-O,O).rotate(U).add(D),pe=new Y(O,-O).rotate(U).add(D);L.moveTo(j.x,j.y),L.lineTo(Z.x,Z.y),L.moveTo(Q.x,Q.y),L.lineTo(pe.x,pe.y)}else L.moveTo(D.x-O,D.y-O),L.lineTo(D.x+O,D.y+O),L.moveTo(D.x-O,D.y+O),L.lineTo(D.x+O,D.y-O)}if(E){const x=t.edges[J],O=.4,D=.017,U=x.start.viewCoordinates.blend(x.end.viewCoordinates,.5),j=U.blend(x.start.viewCoordinates,O),Z=U.blend(x.end.viewCoordinates,O);for(let Q=0;Q<5;Q++){const pe=j.blend(Z,Q/4);_.moveTo(pe.x+D,pe.y),_.arc(pe.x,pe.y,D,0,2*Math.PI,!1)}}}}T.makeImmutable(),L.makeImmutable(),_.makeImmutable(),i.shape=T,h.shape=L,c.shape=_}}});this.disposeEmitter.addListener(()=>f.dispose())}}class ze extends b{constructor(t,e,o,r){super();const i=new Set;if(r!=null&&r.delayInteractionEmitter){const p=r==null?void 0:r.delayInteractionEmitter,f=g=>{i.add(g),setTimeout(()=>{i.delete(g)},700)};p.addListener(f),this.disposeEmitter.addListener(()=>p.removeListener(f))}const h=new k,c=t.map(p=>{const f=e(p);return f.makeImmutable(),h.subpaths.push(...f.subpaths),f});this.mouseArea=this.touchArea=h.makeImmutable();const l=p=>{const f=p.trail.globalToLocalPoint(p.pointer.point);for(let g=0;g<c.length;g++){const w=c[g];if(w.bounds.containsPoint(f)&&w.containsPoint(f)){const S=t[g];if(!i.has(S))return S}}return null},u=(p,f)=>{const g=l(p);g&&o(g,f)},n=new Pe({mouseButton:0,fire:p=>{var f;return u(p,(f=p.domEvent)!=null&&f.shiftKey?2:0)}}),d=new Pe({mouseButton:2,fire:p=>{var f;return u(p,(f=p.domEvent)!=null&&f.shiftKey?0:2)}}),y=new Pe({mouseButton:1,fire:p=>u(p,1)});this.addInputListener(n),this.addInputListener(d),this.addInputListener(y),this.cursor="pointer",this.disposeEmitter.addListener(()=>{n.dispose(),d.dispose(),y.dispose()})}}class jr extends ze{constructor(t,e,o){super(t.edges,r=>{const i=r.start.viewCoordinates,h=r.end.viewCoordinates,c=new k;let l;if(r.faces.length===2)l=[i,r.faces[0].viewCoordinates,h,r.faces[1].viewCoordinates];else{A()&&R(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const u=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;A()&&R(u.previous.face===null),A()&&R(u.next.face===null);const n=u.start.viewCoordinates,d=u.end.viewCoordinates,y=u.previous.start.viewCoordinates,p=u.next.end.viewCoordinates,f=(S,P,C)=>{const E=P.minus(S).normalized(),I=C.minus(P).normalized();let V=E.minus(I);return V.getMagnitude()<1e-6?V=E.getPerpendicular():V=V.normalized(),zt.triangleAreaSigned(S,P,P.plus(V))<0&&(V=V.negated()),V},g=f(y,n,d),w=f(n,d,p);l=[n,r.faces[0].viewCoordinates,d,d.plus(w.times(o.backgroundOffsetDistance)),n.plus(g.times(o.backgroundOffsetDistance))]}return c.polygon(l),c.makeImmutable(),c},o.edgePressListener,{delayInteractionEmitter:e})}}const st=[.02,.02],ye=.2,Te=.02;class Yr extends b{constructor(t,e,o){const r=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ae.getStrokeFromStyle(F.NOT_ZERO,o)}),i=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ae.getStrokeFromStyle(F.NOT_ONE,o)}),h=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ae.getStrokeFromStyle(F.NOT_TWO,o)}),c=new z(null,{lineWidth:.025,lineCap:"butt",stroke:ae.getStrokeFromStyle(F.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,i,h,c]}),this.board=t;const l=t.halfEdges.map(d=>F.NONE),u=t.edges.map(d=>v.BLACK),n=ne.multilink([e,o.sectorsVisibleProperty],(d,y)=>{if(y){let p=!1;for(let f=0;f<t.halfEdges.length;f++){const g=d.getSectorState(t.halfEdges[f]);g!==l[f]&&(p=!0,l[f]=g)}for(let f=0;f<t.edges.length;f++){const g=d.getEdgeState(t.edges[f]);g!==u[f]&&(p=!0,u[f]=g)}if(p){const f=new k,g=new k,w=new k,S=new k;for(let P=0;P<t.halfEdges.length;P++){const C=l[P];if(C!==F.NOT_ZERO&&C!==F.NOT_ONE&&C!==F.NOT_TWO&&C!==F.ONLY_ONE)continue;const E=t.halfEdges[P],I=d.getEdgeState(E.edge),V=d.getEdgeState(E.next.edge);if(I!==v.WHITE||V!==v.WHITE)continue;if(C===F.NOT_ONE){const j=E.end.edges.filter(Q=>d.getEdgeState(Q)===v.BLACK),Z=E.end.edges.filter(Q=>d.getEdgeState(Q)===v.WHITE);if(j.length===0&&Z.length===2)continue}const T=E.start.viewCoordinates,L=E.end.viewCoordinates,_=E.next.end.viewCoordinates,J=T.minus(L),de=_.minus(L),x=J.normalized(),O=J.angle;let D=de.angle;D<O&&(D+=2*Math.PI);const U=(j,Z)=>(j.moveToPoint(x.timesScalar(Z).add(L)),j.arcPoint(L,Z,O,D,!0),j);if(C===F.ONLY_ONE)U(S,ye);else if(C===F.NOT_ONE)U(g,ye-Te),U(g,ye+Te);else if(C===F.NOT_ZERO){const j=new k;U(j,ye-Te),U(j,ye+Te);const Z=j.getDashedShape(st,0);f.subpaths.push(...Z.subpaths)}else if(C===F.NOT_TWO){const j=new k;U(j,ye);const Z=j.getDashedShape(st,0);w.subpaths.push(...Z.subpaths)}}r.shape=f.makeImmutable(),i.shape=g.makeImmutable(),h.shape=w.makeImmutable(),c.shape=S.makeImmutable()}}});this.disposeEmitter.addListener(()=>n.dispose())}}class Xr extends ze{constructor(t,e){super(t.halfEdges,o=>ae.getSectorBaseShape(o,e.backgroundOffsetDistance),e.sectorPressListener)}}class qr extends nt{constructor(t,e){const o=be()({font:mo,fill:ie.uiForegroundColorProperty},e);super(t,o)}}class Kr extends b{constructor(t,e,o){super({translation:t.viewCoordinates}),this.face=t;const i=e.value.getFaceState(t),h=i.possibilityCount===0||i.possibilityCount>9;let c;const l=i.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(h)c=new qr(i.possibilityCount,{font:He,maxWidth:.4,maxHeight:.4});else{const u=new Set(t.vertices);c=new At({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(i.possibilityCount)),children:i.getAllowedCombinations().map(n=>{const d=new b,y=new Set(n.map(g=>g.start)),p=new Set(n.map(g=>g.end)),f=g=>g.minus(t.viewCoordinates);if(d.addChild(new z(k.polygon(t.vertices.map(g=>f(g.viewCoordinates))),{stroke:l,lineWidth:.03,opacity:.2})),y.size){const g=new k;if(n.length===t.edges.length)g.polygon(t.vertices.map(w=>f(w.viewCoordinates)));else{const w=new Set(n);for(;w.size;){const S=[...u].find(E=>[...w].filter(I=>I.start===E||I.end===E).length===1);A()&&R(S);let P=S,C=[...w].find(E=>E.start===P||E.end===P)??null;for(g.moveToPoint(f(P.viewCoordinates));C;)w.delete(C),P=C.getOtherVertex(P),g.lineToPoint(f(P.viewCoordinates)),C=[...w].find(E=>E.start===P||E.end===P)??null}}d.addChild(new z(g,{stroke:l,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of t.vertices)!y.has(g)&&!p.has(g)&&d.addChild(new lt(.1,{fill:l,translation:f(g.viewCoordinates)}));return d}),maxWidth:.6,maxHeight:.6})}c.center=Y.ZERO,this.addChild(c)}}class Gr extends b{constructor(t,e,o,r){super({pickable:!1});const i=ne.multilink([e,r.faceStateVisibleProperty],(c,l)=>{this.children.forEach(u=>u.dispose()),this.children=[],l&&t.faces.forEach(u=>{this.addChild(new Kr(u,e,r))})});this.disposeEmitter.addListener(()=>i.dispose());const h=c=>{this.visible=!c};o.link(h),this.disposeEmitter.addListener(()=>{o.unlink(h),this.children.forEach(c=>c.dispose())})}}class Jr extends ze{constructor(t,e){super(t.faces,o=>o?k.polygon(o.vertices.map(r=>r.viewCoordinates)):new k,e.facePressListener)}}class Zr extends b{constructor(t,e,o,r){super({pickable:!1}),this.board=t;const i=t.faces.map(u=>null),h=()=>{const u=[],n=o.faceValueStyleProperty.value,d=o.theme.faceValueColorProperty.value,y=o.theme.faceValueCompletedColorProperty.value,p=o.theme.faceValueErrorColorProperty.value,f=o.theme.faceValueRatioColorProperty.value,g=o.faceStateVisibleProperty.value,w=tt.value,S=ot.value;this.visible=!g;for(let P=0;P<t.faces.length;P++){const C=i[P];if(C!==null){const E=t.faces[P],I=new Rt("",ht({subScale:.7},r==null?void 0:r.textOptions)),V=ne.multilink([e],T=>{let L,_,J=!1,de=!1;if(C===null)L="",_=null;else{let x=0,O=0;for(const D of E.edges){const U=T.getEdgeState(D);U===v.BLACK?x++:U===v.WHITE&&O++}if(n==="static"||C===0)L=`${C}`;else if(n==="remaining")L=`${C-x}`,J=x>0;else if(n==="ratio")C-x===0?L="0":(L=`${C-x}<sub style="color: ${f.toCSS()};">/<sub>${O}</sub></sub>`,de=!0),J=x>0;else throw new Error(`unhandled faceValueStyle: ${n}`);x>C&&S?_=p:x===C&&w?_=y:_=d}I.string=L,I.fill=_,I.maxWidth=de?.8:.9,I.maxHeight=de?.8:.9,I.center=E.viewCoordinates});I.disposeEmitter.addListener(()=>V.dispose()),u.push(I)}}this.children.forEach(P=>P.dispose()),this.children=u},c=ne.multilink([e],u=>{let n=!1;for(let d=0;d<t.faces.length;d++){const y=u.getFaceValue(t.faces[d]);y!==i[d]&&(n=!0,i[d]=y)}n&&h()}),l=ne.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,tt,ot],h);this.disposeEmitter.addListener(()=>{c.dispose(),l.dispose(),this.children.forEach(u=>u.dispose())})}}class _r extends b{constructor(t,e,o){super({pickable:!1}),this.vertex=t;const r=.12,h=t.edges.map(p=>p.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(p=>p.times(r)),l=k.polygon(Ut.grahamScan([Y.ZERO,...h],!1)).getOffsetShape(-.05),u=new z(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),n=new z(l,{translation:t.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[u,...h.map(p=>new lt({radius:.02,translation:p,fill:o.theme.vertexStatePointProperty}))]});let d=null;const y=ne.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(p,f,g)=>{const w=()=>{this.children=[]};if(!f){w();return}const S=p.getVertexState(t);if(!g){let P=!1,C=!1;const E=new Set;for(const V of t.edges){const T=p.getEdgeState(V);P=P||T===v.BLACK,C=C||T===v.WHITE,T===v.WHITE&&E.add(V)}if(P||!C){w();return}if(Wt.fromLookup(t,(V,T)=>E.has(V)&&E.has(T),!0).equals(S)){w();return}}if(!d||!d.equals(S)){d=S;const P=new k;for(const C of S.getAllowedPairs()){const E=I=>I.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);P.moveToPoint(E(C[0])),P.lineToPoint(E(C[1]))}S.allowsEmpty()&&(P.moveTo(.03,0),P.circle(Y.ZERO,.03),P.close()),P.makeImmutable(),u.shape=P}this.children=[n]});this.disposeEmitter.addListener(()=>y.dispose())}}class $r extends b{constructor(t,e,o,r){super({pickable:!1});const i=ne.multilink([e,r.vertexStateVisibleProperty],(c,l)=>{this.children.forEach(u=>u.dispose()),this.children=[],l&&t.vertices.forEach(u=>{this.addChild(new _r(u,e,r))})});this.disposeEmitter.addListener(()=>i.dispose());const h=c=>{this.visible=!c};o.link(h),this.disposeEmitter.addListener(()=>{o.unlink(h),this.children.forEach(c=>c.dispose())})}}const Qr=.03,es=.05;class ts extends z{constructor(t,e,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const i=t.edges.map(u=>v.BLACK);let h=r.vertexStyleProperty.value,c=r.smallVertexProperty.value;const l=ne.multilink([e,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(u,n,d,y,p)=>{if(this.visible=!n&&d,this.visible){let f=!1;for(let g=0;g<t.edges.length;g++){const w=u.getEdgeState(t.edges[g]);w!==i[g]&&(f=!0,i[g]=w)}if(h!==y&&(h=y,f=!0),c!==p&&(c=p,f=!0),f){const g=new k;for(let w=0;w<t.vertices.length;w++){const S=t.vertices[w];if(S.edges.every(P=>u.getEdgeState(P)!==v.BLACK)){const P=S.viewCoordinates,C=p?Qr:es;y==="round"?(g.moveTo(P.x+C,P.y),g.arc(P.x,P.y,C,0,2*Math.PI,!1)):y==="square"?g.rect(P.x-C,P.y-C,2*C,2*C):A()&&R(!1,`unhandled vertex style: ${y}`)}}this.shape=g}}});this.disposeEmitter.addListener(()=>l.dispose())}}class it extends b{constructor(e,o){const r=be()({textOptions:{font:He,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},facePressListener:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Ve(null),selectedSectorEditProperty:new Ve(null),style:X,noninteractive:!1,delayEdgeInteractionEmitter:new oe},o),i=r.style,h=new b({visibleProperty:i.faceColorsVisibleProperty}),c=new b({pickableProperty:gr}),l=new b({pickableProperty:pr}),u=new b({pickableProperty:ur}),n=new b({pickableProperty:fr}),d=new b,y=new b({pickable:!1}),p=new b({pickable:!1}),f=new b({renderer:Gt.chromium?"canvas":null,pickable:null}),g=new b({pickable:!1}),w=new b,S=new B([e.stateProperty],V=>{if(V.getWeirdEdges().length||V.hasInvalidFaceColors())return!1;const T=V.getSimpleRegions();return T.length===1&&T[0].isSolved}),P=V=>{V?h.addChild(new Mr(e.board,e.stateProperty,i)):h.children.forEach(T=>T.dispose())};i.faceColorsVisibleProperty.link(P),c.addChild(new Zr(e.board,e.stateProperty,i,r)),r.noninteractive||c.addChild(new Jr(e.board,r)),p.addChild(new Gr(e.board,e.stateProperty,S,i));const C=new Ie(e.board.outerBoundary,e.board.innerBoundaries,i,r);n.addChild(new ts(e.board,e.stateProperty,S,i)),y.addChild(new $r(e.board,e.stateProperty,S,i)),u.addChild(new Ur(e.board,e.stateProperty,S,i)),r.noninteractive||u.addChild(new jr(e.board,r.delayEdgeInteractionEmitter,r)),l.addChild(new Yr(e.board,e.stateProperty,i)),r.noninteractive||l.addChild(new Xr(e.board,r)),d.addChild(new Wr(e.board,e.stateProperty,i));super(ht({children:[C,h,c,l,u,n,d,y,p,g,w,f]},r));m(this,"annotationContainer");m(this,"backgroundNode");this.puzzle=e,this.annotationContainer=f;const E=V=>{g.children.forEach(T=>T.dispose()),V&&g.addChild(new Hr(V,e.board,i,r))};r.selectedFaceColorHighlightProperty.link(E),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(E));const I=V=>{w.children.forEach(T=>T.dispose()),V&&w.addChild(new zr(V,C,i,r))};r.selectedSectorEditProperty.link(I),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(I)),this.disposeEmitter.addListener(()=>{i.faceColorsVisibleProperty.unlink(P),[h,c,u,n,d,y,p,l].forEach(T=>{T.children.forEach(L=>L.dispose()),T.dispose()}),S.dispose(),C.dispose()}),this.backgroundNode=C}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class vs extends b{constructor(t,e,o){const r=be()({style:X},o),i=e.getEmbeddedCompleteData(t.inputFeatureSet),h=e.getEmbeddedCompleteData(t.outputFeatureSet),c=new it(new Xe(e.smallBoard,i),{noninteractive:!0,style:r.style}),l=new it(new Xe(e.smallBoard,h),{noninteractive:!0,style:r.style}),u=t.highlander?new b({children:e.getEmbeddedQuestionFaces(t.inputFeatureSet).map(S=>new nt("?",{font:He,maxWidth:.9,maxHeight:.9,opacity:.5,fill:t.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:S.viewCoordinates}))}):new b,d=e.tightBounds.dilated(.5),y=.5,p=k.roundRectangle(d.x,d.y,d.width,d.height,y,y),f=new b({children:[c,u],clipArea:p,localBounds:d}),g=new b({children:[l,u],clipArea:p,localBounds:d}),w=new ut(new at({spacing:.2,children:[f,new Do(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),g]}),{cornerRadius:y*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[w],super(r),this.rule=t,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{c.dispose(),l.dispose()})}}const os=(s,t)=>{Ne(Io,s,t,!0)};class ve{constructor(t,e,o,r,i,h,c,l,u,n){this.sourcePatternBoard=t,this.boardPatternBoard=e,this.largeBoard=o,this.embedding=r,this.smallBoard=i,this.toSmallFaceMap=h,this.toSmallEdgeMap=c,this.toSmallSectorMap=l,this.tightBounds=u,this.expandedBounds=n}mapFace(t){const e=this.embedding.mapFace(t),o=this.boardPatternBoard.getFace(e);if(o){const r=this.toSmallFaceMap.get(o);return A()&&R(r),r}else return null}mapEdge(t){return(t.isExit?this.embedding.mapExitEdges(t):[this.embedding.mapNonExitEdge(t)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const i=this.toSmallEdgeMap.get(r);return A()&&R(i),i})}mapSector(t){const e=this.embedding.mapSector(t),o=this.boardPatternBoard.getSector(e),r=this.toSmallSectorMap.get(o);return A()&&R(r),r}getEmbeddedQuestionFaces(t){const e=new Set;for(const o of t.patternBoard.faces)if(t.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&e.add(r)}return this.smallBoard.faces.filter(o=>!e.has(o))}getEmbeddedCompleteData(t){const e=Mt.empty(this.smallBoard);for(const o of t.getFeaturesArray())if(o instanceof Wo)o.value!==null&&e.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof Mo)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.BLACK));else if(o instanceof Ho)this.mapEdge(o.edge).forEach(r=>e.setEdgeState(r,v.RED));else if(o instanceof zo)e.setSectorState(this.mapSector(o.sector),F.NOT_ZERO);else if(o instanceof Uo)e.setSectorState(this.mapSector(o.sector),F.NOT_ONE);else if(o instanceof jo)e.setSectorState(this.mapSector(o.sector),F.NOT_TWO);else if(o instanceof Yo)e.setSectorState(this.mapSector(o.sector),F.ONLY_ONE);else if(o instanceof Xo){const r=(h,c)=>{const l=this.mapFace(h),u=this.mapFace(c),n=l?e.getFaceColor(l):e.getOutsideColor(),d=u?e.getFaceColor(u):e.getOutsideColor();new ct(he(e,n),he(e,d)).apply(e)},i=(h,c)=>{const l=this.mapFace(h),u=this.mapFace(c),n=l?e.getFaceColor(l):e.getOutsideColor(),d=u?e.getFaceColor(u):e.getOutsideColor();new dt(he(e,n),he(e,d)).apply(e)};for(let h=1;h<o.primaryFaces.length;h++)r(o.primaryFaces[h-1],o.primaryFaces[h]);for(let h=1;h<o.secondaryFaces.length;h++)r(o.secondaryFaces[h-1],o.secondaryFaces[h]);o.secondaryFaces.length&&i(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return os(this.smallBoard,e),e}static getEmbeddingBounds(t,e,o,r){const i=De.NOTHING.copy(),h=l=>{i.addPoint(e.getVertex(o.mapVertex(l)).viewCoordinates)};t.vertices.forEach(h);const c=l=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(l))return;const u=e.getFace(o.mapFace(l));u&&u.vertices.forEach(n=>i.addPoint(n.viewCoordinates))};return t.faces.forEach(c),t.edges.forEach(l=>{let u;l.isExit?u=o.mapExitEdges(l).map(n=>e.getEdge(n)):u=[e.getEdge(o.mapNonExitEdge(l))],u.forEach(n=>{i.addPoint(n.start.viewCoordinates),i.addPoint(n.end.viewCoordinates)})}),i}static findBestEmbedding(t,e,o){const r=Jt(t,e);if(r.length===0)return null;const i=De.NOTHING.copy();o.vertices.forEach(u=>i.addPoint(u.viewCoordinates));const h=i.center;let c=null,l=Number.POSITIVE_INFINITY;for(let u=0;u<r.length;u++){const n=r[u],y=ve.getEmbeddingBounds(t,e,n).center,p=h.distance(y);p<l&&(l=p,c=n)}return c}static getDisplayEmbedding(t,e,o,r,i){const h=ve.getEmbeddingBounds(t,e,r,i),c=h.dilated(.5),l=o.faces.filter(w=>{const S=De.NOTHING.copy();return w.vertices.forEach(P=>S.addPoint(P.viewCoordinates)),c.intersectsBounds(S)}),u=o.vertices.filter(w=>w.faces.some(S=>l.includes(S))),n=Zt({vertices:u.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates})),faces:l.map(w=>({logicalCoordinates:w.logicalCoordinates,vertices:w.vertices.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates}))}))}),d=new _t(n),y=1e-6,p=new Map(l.map((w,S)=>{const P=d.faces.find(C=>C.viewCoordinates.equalsEpsilon(w.viewCoordinates,y));return A()&&R(P),[w,P]})),f=new Map(o.edges.map(w=>{const S=d.edges.find(P=>P.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&P.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)||P.start.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y)&&P.end.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y))??null;return S?[w,S]:null}).filter(w=>w!==null)),g=new Map(o.halfEdges.map(w=>{const S=d.halfEdges.find(P=>P.start.viewCoordinates.equalsEpsilon(w.start.viewCoordinates,y)&&P.end.viewCoordinates.equalsEpsilon(w.end.viewCoordinates,y))??null;return S?[w,S]:null}).filter(w=>w!==null));return A()&&R(r),new ve(t,e,o,r,d,p,f,g,h,c)}static getDisplayEmbeddingFromRule(t,e,o){return ve.getDisplayEmbedding(t.patternBoard,e,e.board,o,{sourceFaceFilter:r=>t.inputFeatureSet.getAffectedFaces().has(r)||t.outputFeatureSet.getAffectedFaces().has(r)})}}export{ms as A,Br as B,Or as C,Lr as D,vs as E,Kr as F,Cs as G,ee as H,K as I,M as J,ys as K,Ss as L,dr as M,ve as N,Vr as O,it as P,qr as U,_r as V,fs as a,Jo as b,Zo as c,_o as d,er as e,X as f,$o as g,wr as h,gr as i,bt as j,rr as k,sr as l,ir as m,ar as n,nr as o,hr as p,cr as q,qo as r,os as s,tt as t,ot as u,lr as v,Ps as w,Dr as x,gs as y,ws as z};
