var os=Object.defineProperty;var hs=(u,t,e)=>t in u?os(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var z=(u,t,e)=>(hs(u,typeof t!="symbol"?t+"":t,e),e);import{z as Z,N as us,D as O,t as Se,ai as X,M as Le,S as cs,V as E,aj as jt,ak as qt,g as Fe,o as Ee,B as ut,b as Bt,E as ds,d as gs,Z as Qe,c as He,h as fs,a5 as Yt,a as kt,a9 as ps,O as Ft}from"./UnivariatePolynomial-1rLpyqfN.js";function ms(u,t){if(u[t]!==void 0)return t;if(t=t.charAt(0).toUpperCase()+t.slice(1),u[`moz${t}`]!==void 0)return`moz${t}`;if(u[`Moz${t}`]!==void 0)return`Moz${t}`;if(u[`webkit${t}`]!==void 0)return`webkit${t}`;if(u[`ms${t}`]!==void 0)return`ms${t}`;if(u[`o${t}`]!==void 0)return`o${t}`}Z.register("detectPrefix",ms);const G=navigator.userAgent;function we(u){return Ge()===u}function Oe(){return!!(window.phet&&phet.chipper&&phet.chipper.queryParameters&&phet.chipper.queryParameters["phet-app"]||(G.match(/(iPod|iPhone|iPad)/)||navigator.platform==="MacIntel"&&navigator.maxTouchPoints>=2)&&G.match(/AppleWebKit/))}function Ge(){let u=-1,t=null;return navigator.appName==="Microsoft Internet Explorer"?(t=new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})"),t.exec(G)!==null&&(u=parseFloat(RegExp.$1))):navigator.appName==="Netscape"&&(t=new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"),t.exec(G)!==null&&(u=parseFloat(RegExp.$1))),u}const _s={firefox:G.toLowerCase().includes("firefox"),mobileSafari:Oe(),safari5:!!(G.match(/Version\/5\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari6:!!(G.match(/Version\/6\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari7:!!(G.match(/Version\/7\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari10:!!(G.match(/Version\/10\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari11:!!(G.match(/Version\/11\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari9:!!(G.match(/Version\/9\./)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),safari:Oe()||!!(G.match(/Version\//)&&G.match(/Safari\//)&&G.match(/AppleWebKit/)),ie:Ge()!==-1,ie9:we(9),ie10:we(10),ie11:we(11),android:G.indexOf("Android")>0,edge:!!G.match(/Edge\//),chromium:/chrom(e|ium)/.test(G.toLowerCase())&&!G.match(/Edge\//),chromeOS:G.indexOf("CrOS")>0,mac:navigator.platform.includes("Mac")};Z.register("platform",_s);function vs(u,t){if(u[`on${t}`]!==void 0)return t;if(u[`onmoz${t}`]!==void 0)return`moz${t}`;if(u[`onMoz${t}`]!==void 0)return`Moz${t}`;if(u[`onwebkit${t}`]!==void 0)return`webkit${t}`;if(u[`onms${t}`]!==void 0)return`ms${t}`;if(u[`ono${t}`]!==void 0)return`o${t}`}Z.register("detectPrefixEvent",vs);const Q=new us("kite"),As=O.lineLineIntersection,bs={lineWidth:1,lineCap:"butt",lineJoin:"miter",lineDash:[],lineDashOffset:0,miterLimit:10};class ve{constructor(t){const e=Se({},bs,t);this.lineWidth=e.lineWidth,this.lineCap=e.lineCap,this.lineJoin=e.lineJoin,this.lineDash=e.lineDash,this.lineDashOffset=e.lineDashOffset,this.miterLimit=e.miterLimit,assert&&assert(typeof this.lineWidth=="number",`lineWidth should be a number: ${this.lineWidth}`),assert&&assert(isFinite(this.lineWidth),`lineWidth should be a finite number: ${this.lineWidth}`),assert&&assert(this.lineWidth>=0,`lineWidth should be non-negative: ${this.lineWidth}`),assert&&assert(this.lineCap==="butt"||this.lineCap==="round"||this.lineCap==="square",`Invalid lineCap: ${this.lineCap}`),assert&&assert(this.lineJoin==="miter"||this.lineJoin==="round"||this.lineJoin==="bevel",`Invalid lineJoin: ${this.lineJoin}`),assert&&assert(Array.isArray(this.lineDash),`lineDash should be an array: ${this.lineDash}`),assert&&assert(_.every(this.lineDash,s=>typeof s=="number"&&isFinite(s)&&s>=0),`Every lineDash should be a non-negative finite number: ${this.lineDash}`),assert&&assert(typeof this.lineDashOffset=="number",`lineDashOffset should be a number: ${this.lineDashOffset}`),assert&&assert(isFinite(this.lineDashOffset),`lineDashOffset should be a finite number: ${this.lineDashOffset}`),assert&&assert(typeof this.miterLimit=="number",`miterLimit should be a number: ${this.miterLimit}`),assert&&assert(isFinite(this.miterLimit),`miterLimit should be a finite number: ${this.miterLimit}`)}equals(t){if(!(this.lineWidth===t.lineWidth&&this.lineCap===t.lineCap&&this.lineJoin===t.lineJoin&&this.miterLimit===t.miterLimit&&this.lineDashOffset===t.lineDashOffset))return!1;if(this.lineDash.length===t.lineDash.length){for(let s=0;s<this.lineDash.length;s++)if(this.lineDash[s]!==t.lineDash[s])return!1}else return!1;return!0}copy(){return new ve({lineWidth:this.lineWidth,lineCap:this.lineCap,lineJoin:this.lineJoin,lineDash:this.lineDash,lineDashOffset:this.lineDashOffset,miterLimit:this.miterLimit})}leftJoin(t,e,s){e=e.normalized(),s=s.normalized();const n=t.plus(e.perpendicular.negated().times(this.lineWidth/2)),r=t.plus(s.perpendicular.negated().times(this.lineWidth/2)),a=n.equals(r)?[]:[new F(n,r)];let l,o,h;if(e.perpendicular.dot(s)>1e-12)switch(this.lineJoin){case"round":return l=e.angle+Math.PI/2,o=s.angle+Math.PI/2,[new D(t,this.lineWidth/2,l,o,!0)];case"miter":if(h=e.angleBetween(s.negated()),1/Math.sin(h/2)<=this.miterLimit&&h<Math.PI-1e-5){const d=As(n,n.plus(e),r,r.plus(s));return d?[new F(n,d),new F(d,r)]:[new F(n,r)]}else return a;case"bevel":return a;default:throw new Error(`invalid lineJoin: ${this.lineJoin}`)}else return a}rightJoin(t,e,s){return this.leftJoin(t,s.negated(),e.negated())}cap(t,e){e=e.normalized();const s=t.plus(e.perpendicular.times(-this.lineWidth/2)),n=t.plus(e.perpendicular.times(this.lineWidth/2));let r,a,l,o,h,d;switch(this.lineCap){case"butt":return[new F(s,n)];case"round":return r=e.angle,[new D(t,this.lineWidth/2,r+Math.PI/2,r-Math.PI/2,!0)];case"square":return a=e.perpendicular.negated().times(this.lineWidth/2),l=e.perpendicular.times(this.lineWidth/2),o=e.times(this.lineWidth/2),h=t.plus(a).plus(o),d=t.plus(l).plus(o),[new F(s,h),new F(h,d),new F(d,n)];default:throw new Error(`invalid lineCap: ${this.lineCap}`)}}}Q.register("LineStyles",ve);class Gt{constructor(t,e){assert&&assert(isFinite(t)&&t!==0,"a should be a finite non-zero number"),assert&&assert(isFinite(e),"b should be a finite number"),this.a=t,this.b=e;let s=0,n=1,r=this.apply(s),a=this.apply(n);r>1&&(r=1,s=this.applyInverse(r)),r<0&&(r=0,s=this.applyInverse(r)),a>1&&(a=1,n=this.applyInverse(a)),a<0&&(a=0,n=this.applyInverse(a)),this.t0=s,this.t1=n,t>0?(this.qt0=r,this.qt1=a):(this.qt0=a,this.qt1=r),this.t0<0&&this.t0>-1e-8&&(this.t0=0),this.t0>1&&this.t0<1+1e-8&&(this.t0=1),this.t1<0&&this.t1>-1e-8&&(this.t1=0),this.t1>1&&this.t1<1+1e-8&&(this.t1=1),this.qt0<0&&this.qt0>-1e-8&&(this.qt0=0),this.qt0>1&&this.qt0<1+1e-8&&(this.qt0=1),this.qt1<0&&this.qt1>-1e-8&&(this.qt1=0),this.qt1>1&&this.qt1<1+1e-8&&(this.qt1=1),assert&&assert(this.t0>=0&&this.t0<=1,`t0 out of range: ${this.t0}`),assert&&assert(this.t1>=0&&this.t1<=1,`t1 out of range: ${this.t1}`),assert&&assert(this.qt0>=0&&this.qt0<=1,`qt0 out of range: ${this.qt0}`),assert&&assert(this.qt1>=0&&this.qt1<=1,`qt1 out of range: ${this.qt1}`)}apply(t){return this.a*t+this.b}applyInverse(t){return(t-this.b)/this.a}static createLinear(t,e,s,n){const r=(n-e)/(s-t);return new Gt(r,e-t*r)}}Q.register("Overlap",Gt);class zt{constructor(t,e,s,n,r){assert&&assert(isFinite(t)&&t>=0,"invalid distance"),assert&&assert(Math.abs(s.magnitude-1)<1e-7,"invalid normal"),assert&&assert(r>=-1e-10&&r<=1+1e-10,`t out of range: ${r}`),this.point=e,this.normal=s,this.distance=t,this.wind=n,this.t=O.clamp(r,0,1)}}Q.register("RayIntersection",zt);class vt{constructor(t,e,s){assert&&assert(e>=-1e-10&&e<=1+1e-10,"aT out of range"),assert&&assert(s>=-1e-10&&s<=1+1e-10,"bT out of range"),this.point=t,this.aT=O.clamp(e,0,1),this.bT=O.clamp(s,0,1)}getSwapped(){return new vt(this.point,this.bT,this.aT)}}Q.register("SegmentIntersection",vt);const H=u=>u.toFixed(20);Q.register("svgNumber",H);const Ot=(u,t,e,s)=>u.times(s).minus(t.times(e)),ws=u=>{const t=u[0],e=u[1],s=u[2],n=u[3],r=u[4],a=u[5],l=u[6],o=u[7],h=u[8];return t.times(r).times(h).plus(e.times(a).times(l)).plus(s.times(n).times(o)).minus(s.times(r).times(l)).minus(e.times(n).times(h)).minus(t.times(a).times(o))},xs=u=>{const t=u[0],e=u[1],s=u[2],n=u[3],r=u[4],a=u[5],l=u[6],o=u[7],h=u[8];return[Ot(r,a,o,h),Ot(e,s,o,h).negate(),Ot(e,s,r,a),Ot(n,a,l,h).negate(),Ot(t,s,l,h),Ot(t,s,n,a).negate(),Ot(n,r,l,o),Ot(t,e,l,o).negate(),Ot(t,e,n,r)]},ys=u=>[u[0],u[3],u[6],u[1],u[4],u[7],u[2],u[5],u[8]],Re=(u,t=!1)=>_.sortBy([u.slice(0,3),u.slice(3,6),u.slice(6,9)],e=>-(e[0].magnitude+e[1].magnitude+(t?e[2].magnitude:0)))[0],Ps=(u,t=!1)=>Re(ys(u),t),Ss=u=>{const t=xs(u),e=Re(t);return[X.ZERO,e[2],e[1].negated(),e[2].negated(),X.ZERO,e[0],e[1],e[0].negated(),X.ZERO]},Es=(u,t)=>{const e=u[0],s=u[1],n=u[3],r=u[4],a=t[0],l=t[1],o=t[3],h=t[4],d=l.times(o).minus(a.times(h)),p=h.negated().times(e).plus(o.times(s)).plus(l.times(n)).minus(a.times(r)),A=s.times(n).minus(e.times(r)),b=X.solveQuadraticRoots(d,p,A);return b===null?null:b[0]},Ts=u=>{const t=Ss(u),e=Es(u,t);return e===null?u:[u[0].plus(e.times(t[0])),u[1].plus(e.times(t[1])),u[2].plus(e.times(t[2])),u[3].plus(e.times(t[3])),u[4].plus(e.times(t[4])),u[5].plus(e.times(t[5])),u[6].plus(e.times(t[6])),u[7].plus(e.times(t[7])),u[8].plus(e.times(t[8]))]},Cs=u=>{const t=[],e=u[0],s=u[1].times(X.real(2)),n=u[4],r=u[2].times(X.real(2)),a=u[5].times(X.real(2)),l=u[8];let o=[];const h=new X(-2.51653525696959,1.5292850284402),d=n,p=s.times(h).plus(a),A=e.times(h).times(h).plus(r.times(h)).plus(l),b=X.solveQuadraticRoots(d,p,A);if(b&&b.length>=2)o=[[h,b[0]],[h,b[1]]];else{const S=e,P=s.times(h).plus(r),w=n.times(h).times(h).plus(a.times(h)).plus(l),x=X.solveQuadraticRoots(S,P,w);if(x&&x.length>=2)o=[[x[0],h],[x[1],h]];else if(b&&b.length===1)o=[[h,b[0]]];else if(x&&x.length===1)o=[[x[0],h]];else throw new Error("Implement more advanced initialization to find two solutions")}return o.forEach(S=>{const P=S[0].real,w=S[1].real,x=S[0].imaginary,v=S[1].imaginary,T=e.real,M=s.real,$=n.real,B=r.real,N=a.real,W=e.imaginary,k=s.imaginary,q=n.imaginary,L=r.imaginary,tt=a.imaginary,Pt=new jt(-2*W*x-k*v+B+2*T*P+M*w,-k*x-2*q*v+N+M*P+2*$*w,-L-2*x*T-v*M-2*W*P-k*w,-tt-x*M-2*v*$-k*P-2*q*w),U=new jt(L+2*x*T+v*M+2*W*P+k*w,tt+x*M+2*v*$+k*P+2*q*w,-2*W*x-k*v+B+2*T*P+M*w,-k*x-2*q*v+N+M*P+2*$*w),at=new jt(6.1951068548253,-1.159268950386,.1602918829294,3.205818692048202),At=new jt(-5.420628549296924,-15.2069583028685,.159590602048868,5.10688288040682),ot=(dt,pt)=>pt.timesScalar(dt.dot(pt)/pt.dot(pt)),ft=Pt,st=U.minus(ot(U,ft)),et=at.minus(ot(at,ft)).minus(ot(at,st)),J=At.minus(ot(At,ft)).minus(ot(At,st)).minus(ot(At,et)),It=new Le(2,2,[et.z,J.z,et.w,J.w]),Y=new cs(It).getSingularValues();let ct=null;if(Math.abs(x)<1e-10&&Math.abs(v)<1e-10)ct=new E(P,w);else{if(Math.abs(Y[1])>1e-10){const dt=It.solve(new Le(2,1,[-x,-v])).extractVector2(0);ct=new E(P+dt.x*et.z+dt.y*J.z,w+dt.x*et.w+dt.y*J.w)}else if(Math.abs(Y[0])>1e-10){const dt=Math.abs(et.z)+Math.abs(et.w)>Math.abs(J.z)+Math.abs(J.w)?et:J,pt=new E(dt.z,dt.w),St=new E(x,v).dot(pt)/pt.dot(pt),Tt=new jt(P,w,x,v).minus(dt.timesScalar(St));Math.abs(Tt.z)<1e-8&&Math.abs(Tt.w)<1e-8&&(ct=new E(Tt.x,Tt.y))}else ct=null;if(ct){if(Math.abs(Y[1])>1e-10)t.push(ct);else if(Math.abs(Y[0])>1e-10){const dt=Math.abs(et.z)+Math.abs(et.w)>Math.abs(J.z)+Math.abs(J.w),pt=dt?J:et,St=dt?et:J,Et=Math.abs(St.z)>Math.abs(St.w)?pt.z/St.z:pt.w/St.w,Nt=St.timesScalar(Et).minus(pt);t.push(new qt(ct,new E(Nt.x,Nt.y).normalized()))}}}}),t},Is=u=>{const t=Ts(u);return[Re(t),Ps(t)]},te=(u,t)=>{const e=u[0],s=u[1],n=u[2],r=t[0],a=t[1],l=t[2],o=r.times(s).minus(e.times(a));if(o.equalsEpsilon(X.ZERO,1e-8))return null;{const h=a.times(n).minus(s.times(l)).dividedBy(o);let d;if(!s.equalsEpsilon(X.ZERO,1e-8))d=e.negated().times(h).minus(n).dividedBy(s);else if(!a.equalsEpsilon(X.ZERO,1e-8))d=r.negated().times(h).minus(l).dividedBy(a);else return null;return Math.abs(h.imaginary)<1e-8&&Math.abs(d.imaginary)<1e-8?new E(h.real,d.real):null}},Ms=(u,t)=>{const e=u.m00(),s=u.m01(),n=u.m02(),r=u.m10(),a=u.m11(),l=u.m12(),o=u.m20(),h=u.m21(),d=u.m22(),p=t.m00(),A=t.m01(),b=t.m02(),S=t.m10(),P=t.m11(),w=t.m12(),x=t.m20(),v=t.m21(),T=t.m22(),M=-n*a*o+s*l*o+n*r*h-e*l*h-s*r*d+e*a*d,$=-r*d*A+r*h*b+n*h*S-s*d*S-n*o*P+e*d*P+s*o*w-e*h*w+n*r*v+l*(-h*p+o*A+s*x-e*v)-s*r*T+a*(d*p-o*b-n*x+e*T),B=-d*A*S+h*b*S+d*p*P-o*b*P-h*p*w+o*A*w+l*A*x-a*b*x-n*P*x+s*w*x-l*p*v+r*b*v+n*S*v-e*w*v+a*p*T-r*A*T-s*S*T+e*P*T,N=-b*P*x+A*w*x+b*S*v-p*w*v-A*S*T+p*P*T,W=X.solveCubicRoots(X.real(M),X.real($),X.real(B),X.real(N));if(!W||W.length===0)return{degenerateConicMatrices:[],intersectionCollections:[],points:[],lines:[]};const q=_.uniqWith(W,(U,at)=>U.equals(at)).map(U=>[X.real(e).multiply(U).add(X.real(p)),X.real(s).multiply(U).add(X.real(A)),X.real(n).multiply(U).add(X.real(b)),X.real(r).multiply(U).add(X.real(S)),X.real(a).multiply(U).add(X.real(P)),X.real(l).multiply(U).add(X.real(w)),X.real(o).multiply(U).add(X.real(x)),X.real(h).multiply(U).add(X.real(v)),X.real(d).multiply(U).add(X.real(T))]);console.log("determinant magnitudes",q.map(U=>ws(U).magnitude));const L=[],tt=q.map(Is);console.log(tt);const Pt=q.map(Cs);console.log(Pt);for(let U=0;U<tt.length;U++){const at=tt[U],At=te(at[0],at[1]);At&&L.push(At);for(let ot=U+1;ot<tt.length;ot++){const ft=tt[ot],st=[te(at[0],ft[0]),te(at[0],ft[1]),te(at[1],ft[0]),te(at[1],ft[1])];for(let et=0;et<4;et++){const J=st[et];J&&L.push(J)}}}return{points:L,degenerateConicMatrices:q,lines:_.flatten(tt),intersectionCollections:Pt}};Q.register("intersectConicMatrices",Ms);function Ze(u){return'"'+u.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}const Ve={parse:function(u,t){const e={svgPath:l,movetoDrawtoCommandGroups:o,movetoDrawtoCommandGroup:h,drawtoCommands:d,drawtoCommand:p,moveto:A,movetoArgumentSequence:b,closepath:S,lineto:P,linetoArgumentSequence:w,horizontalLineto:x,horizontalLinetoArgumentSequence:v,verticalLineto:T,verticalLinetoArgumentSequence:M,curveto:$,curvetoArgumentSequence:B,curvetoArgument:N,smoothCurveto:W,smoothCurvetoArgumentSequence:k,smoothCurvetoArgument:q,quadraticBezierCurveto:L,quadraticBezierCurvetoArgumentSequence:tt,quadraticBezierCurvetoArgument:Pt,smoothQuadraticBezierCurveto:U,smoothQuadraticBezierCurvetoArgumentSequence:at,ellipticalArc:At,ellipticalArcArgumentSequence:ot,ellipticalArcArgument:ft,coordinatePair:st,nonnegativeNumber:et,number:J,flag:It,commaWsp:Y,comma:ct,floatingPointConstant:dt,fractionalConstant:pt,exponent:St,sign:Tt,digitSequence:Et,digit:Nt,wsp:V};if(t!==void 0){if(e[t]===void 0)throw new Error("Invalid rule name: "+Ze(t)+".")}else t="svgPath";let s=0,n=0,r=[];function a(i){s<n||(s>n&&(n=s,r=[]),r.push(i))}function l(){let i,c,g,f,m,I;for(m=s,I=s,i=[],c=V();c!==null;)i.push(c),c=V();if(i!==null)if(c=o(),c=c!==null?c:"",c!==null){for(g=[],f=V();f!==null;)g.push(f),f=V();g!==null?i=[i,c,g]:(i=null,s=I)}else i=null,s=I;else i=null,s=I;return i!==null&&(i=function(y,C){return C||[]}(m,i[1])),i===null&&(s=m),i}function o(){let i,c,g,f,m;if(f=s,m=s,i=h(),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=o(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;return i!==null&&(i=function(I,y,C){return y.concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=h(),i!==null&&(i=function(I,y){return y}(f,i)),i===null&&(s=f)),i}function h(){let i,c,g,f,m;if(f=s,m=s,i=A(),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=d(),g=g!==null?g:"",g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;return i!==null&&(i=function(I,y,C){return C.length?y.concat(C):y}(f,i[0],i[2])),i===null&&(s=f),i}function d(){let i,c,g,f,m;if(f=s,m=s,i=p(),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=d(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;return i!==null&&(i=function(I,y,C){return y.concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=p(),i!==null&&(i=function(I,y){return y}(f,i)),i===null&&(s=f)),i}function p(){let i;return i=S(),i===null&&(i=P(),i===null&&(i=x(),i===null&&(i=T(),i===null&&(i=$(),i===null&&(i=W(),i===null&&(i=L(),i===null&&(i=U(),i===null&&(i=At())))))))),i}function A(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===77?(i="M",s++):(i=null,a('"M"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=b(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return Rt(y,!1)}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===109?(i="m",s++):(i=null,a('"m"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=b(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return Rt(y,!0)}(f,i[2])),i===null&&(s=f)}return i}function b(){let i,c,g,f,m;return f=s,m=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=w(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=st(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function S(){let i,c;return c=s,u.charCodeAt(s)===90?(i="Z",s++):(i=null,a('"Z"')),i===null&&(u.charCodeAt(s)===122?(i="z",s++):(i=null,a('"z"'))),i!==null&&(i=function(g,f){return{cmd:"close"}}()),i===null&&(s=c),i}function P(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===76?(i="L",s++):(i=null,a('"L"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=w(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"lineTo",args:[C.x,C.y]}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===108?(i="l",s++):(i=null,a('"l"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=w(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"lineToRelative",args:[C.x,C.y]}))}(f,i[2])),i===null&&(s=f)}return i}function w(){let i,c,g,f,m;return f=s,m=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=w(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=st(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function x(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===72?(i="H",s++):(i=null,a('"H"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=v(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"horizontalLineTo",args:[C]}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===104?(i="h",s++):(i=null,a('"h"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=v(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"horizontalLineToRelative",args:[C]}))}(f,i[2])),i===null&&(s=f)}return i}function v(){let i,c,g,f,m;return f=s,m=s,i=J(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=v(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=J(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function T(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===86?(i="V",s++):(i=null,a('"V"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=M(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"verticalLineTo",args:[C]}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===118?(i="v",s++):(i=null,a('"v"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=M(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"verticalLineToRelative",args:[C]}))}(f,i[2])),i===null&&(s=f)}return i}function M(){let i,c,g,f,m;return f=s,m=s,i=J(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=M(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=J(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function $(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===67?(i="C",s++):(i=null,a('"C"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=B(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"cubicCurveTo",args:C}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===99?(i="c",s++):(i=null,a('"c"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=B(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"cubicCurveToRelative",args:C}))}(f,i[2])),i===null&&(s=f)}return i}function B(){let i,c,g,f,m;return f=s,m=s,i=N(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=B(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=N(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function N(){let i,c,g,f,m,I,y;return I=s,y=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=st(),g!==null?(f=Y(),f=f!==null?f:"",f!==null?(m=st(),m!==null?i=[i,c,g,f,m]:(i=null,s=y)):(i=null,s=y)):(i=null,s=y)):(i=null,s=y)):(i=null,s=y),i!==null&&(i=function(C,Dt,Ht,Zt){return[Dt.x,Dt.y,Ht.x,Ht.y,Zt.x,Zt.y]}(I,i[0],i[2],i[4])),i===null&&(s=I),i}function W(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===83?(i="S",s++):(i=null,a('"S"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=k(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"smoothCubicCurveTo",args:C}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===115?(i="s",s++):(i=null,a('"s"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=k(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"smoothCubicCurveToRelative",args:C}))}(f,i[2])),i===null&&(s=f)}return i}function k(){let i,c,g,f,m;return f=s,m=s,i=q(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=k(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=q(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function q(){let i,c,g,f,m;return f=s,m=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=st(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y.x,y.y,C.x,C.y]}(f,i[0],i[2])),i===null&&(s=f),i}function L(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===81?(i="Q",s++):(i=null,a('"Q"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=tt(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"quadraticCurveTo",args:C}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===113?(i="q",s++):(i=null,a('"q"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=tt(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"quadraticCurveToRelative",args:C}))}(f,i[2])),i===null&&(s=f)}return i}function tt(){let i,c,g,f,m;return f=s,m=s,i=Pt(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=tt(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=Pt(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function Pt(){let i,c,g,f,m;return f=s,m=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=st(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y.x,y.y,C.x,C.y]}(f,i[0],i[2])),i===null&&(s=f),i}function U(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===84?(i="T",s++):(i=null,a('"T"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=at(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>({cmd:"smoothQuadraticCurveTo",args:[C.x,C.y]}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===116?(i="t",s++):(i=null,a('"t"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=at(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>({cmd:"smoothQuadraticCurveToRelative",args:[C.x,C.y]}))}(f,i[2])),i===null&&(s=f)}return i}function at(){let i,c,g,f,m;return f=s,m=s,i=st(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=at(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=st(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function At(){let i,c,g,f,m;if(f=s,m=s,u.charCodeAt(s)===65?(i="A",s++):(i=null,a('"A"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=ot(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;if(i!==null&&(i=function(I,y){return y.map(C=>(C[2]*=Math.PI/180,{cmd:"ellipticalArcTo",args:C}))}(f,i[2])),i===null&&(s=f),i===null){if(f=s,m=s,u.charCodeAt(s)===97?(i="a",s++):(i=null,a('"a"')),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?(g=ot(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)}else i=null,s=m;i!==null&&(i=function(I,y){return y.map(C=>(C[2]*=Math.PI/180,{cmd:"ellipticalArcToRelative",args:C}))}(f,i[2])),i===null&&(s=f)}return i}function ot(){let i,c,g,f,m;return f=s,m=s,i=ft(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=ot(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return[y].concat(C)}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,i=ft(),i!==null&&(i=function(I,y){return[y]}(f,i)),i===null&&(s=f)),i}function ft(){let i,c,g,f,m,I,y,C,Dt,Ht,Zt,be,Mt;return be=s,Mt=s,i=et(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=et(),g!==null?(f=Y(),f=f!==null?f:"",f!==null?(m=J(),m!==null?(I=Y(),I!==null?(y=It(),y!==null?(C=Y(),C=C!==null?C:"",C!==null?(Dt=It(),Dt!==null?(Ht=Y(),Ht=Ht!==null?Ht:"",Ht!==null?(Zt=st(),Zt!==null?i=[i,c,g,f,m,I,y,C,Dt,Ht,Zt]:(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt)):(i=null,s=Mt),i!==null&&(i=function(Cn,ns,is,rs,as,ls,Ne){return[ns,is,rs,as,ls,Ne.x,Ne.y]}(be,i[0],i[2],i[4],i[6],i[8],i[10])),i===null&&(s=be),i}function st(){let i,c,g,f,m;return f=s,m=s,i=J(),i!==null?(c=Y(),c=c!==null?c:"",c!==null?(g=J(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return{x:y,y:C}}(f,i[0],i[2])),i===null&&(s=f),i}function et(){let i,c;return c=s,i=dt(),i!==null&&(i=function(g,f){return parseFloat(f)}(c,i)),i===null&&(s=c),i===null&&(c=s,i=Et(),i!==null&&(i=function(g,f){return Number(f)}(c,i)),i===null&&(s=c)),i}function J(){let i,c,g,f;return g=s,f=s,i=Tt(),i=i!==null?i:"",i!==null?(c=dt(),c!==null?i=[i,c]:(i=null,s=f)):(i=null,s=f),i!==null&&(i=function(m,I,y){return parseFloat(I+y)}(g,i[0],i[1])),i===null&&(s=g),i===null&&(g=s,f=s,i=Tt(),i=i!==null?i:"",i!==null?(c=Et(),c!==null?i=[i,c]:(i=null,s=f)):(i=null,s=f),i!==null&&(i=function(m,I,y){return Number(I+y)}(g,i[0],i[1])),i===null&&(s=g)),i}function It(){let i,c;return c=s,u.charCodeAt(s)===48?(i="0",s++):(i=null,a('"0"')),i!==null&&(i=function(g){return!1}()),i===null&&(s=c),i===null&&(c=s,u.charCodeAt(s)===49?(i="1",s++):(i=null,a('"1"')),i!==null&&(i=function(g){return!0}()),i===null&&(s=c)),i}function Y(){let i,c,g,f,m;if(m=s,c=V(),c!==null)for(i=[];c!==null;)i.push(c),c=V();else i=null;if(i!==null)if(c=ct(),c=c!==null?c:"",c!==null){for(g=[],f=V();f!==null;)g.push(f),f=V();g!==null?i=[i,c,g]:(i=null,s=m)}else i=null,s=m;else i=null,s=m;if(i===null)if(m=s,i=ct(),i!==null){for(c=[],g=V();g!==null;)c.push(g),g=V();c!==null?i=[i,c]:(i=null,s=m)}else i=null,s=m;return i}function ct(){let i;return u.charCodeAt(s)===44?(i=",",s++):(i=null,a('","')),i}function dt(){let i,c,g,f;return g=s,f=s,i=pt(),i!==null?(c=St(),c=c!==null?c:"",c!==null?i=[i,c]:(i=null,s=f)):(i=null,s=f),i!==null&&(i=function(m,I,y){return I+y}(g,i[0],i[1])),i===null&&(s=g),i===null&&(g=s,f=s,i=Et(),i!==null?(c=St(),c!==null?i=[i,c]:(i=null,s=f)):(i=null,s=f),i!==null&&(i=function(m,I,y){return I+y}(g,i[0],i[1])),i===null&&(s=g)),i}function pt(){let i,c,g,f,m;return f=s,m=s,i=Et(),i=i!==null?i:"",i!==null?(u.charCodeAt(s)===46?(c=".",s++):(c=null,a('"."')),c!==null?(g=Et(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C){return y+"."+C}(f,i[0],i[2])),i===null&&(s=f),i===null&&(f=s,m=s,i=Et(),i!==null?(u.charCodeAt(s)===46?(c=".",s++):(c=null,a('"."')),c!==null?i=[i,c]:(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y){return y}(f,i[0])),i===null&&(s=f)),i}function St(){let i,c,g,f,m;return f=s,m=s,u.charCodeAt(s)===101?(i="e",s++):(i=null,a('"e"')),i===null&&(u.charCodeAt(s)===69?(i="E",s++):(i=null,a('"E"'))),i!==null?(c=Tt(),c=c!==null?c:"",c!==null?(g=Et(),g!==null?i=[i,c,g]:(i=null,s=m)):(i=null,s=m)):(i=null,s=m),i!==null&&(i=function(I,y,C,Dt){return y+C+Dt}(f,i[0],i[1],i[2])),i===null&&(s=f),i}function Tt(){let i;return u.charCodeAt(s)===43?(i="+",s++):(i=null,a('"+"')),i===null&&(u.charCodeAt(s)===45?(i="-",s++):(i=null,a('"-"'))),i}function Et(){let i,c,g,f;return g=s,f=s,i=Nt(),i!==null?(c=Et(),c!==null?i=[i,c]:(i=null,s=f)):(i=null,s=f),i!==null&&(i=function(m,I,y){return I+y}(g,i[0],i[1])),i===null&&(s=g),i===null&&(i=Nt()),i}function Nt(){let i;return/^[0-9]/.test(u.charAt(s))?(i=u.charAt(s),s++):(i=null,a("[0-9]")),i}function V(){let i;return u.charCodeAt(s)===32?(i=" ",s++):(i=null,a('" "')),i===null&&(u.charCodeAt(s)===9?(i="	",s++):(i=null,a('"\\t"')),i===null&&(u.charCodeAt(s)===13?(i="\r",s++):(i=null,a('"\\r"')),i===null&&(u.charCodeAt(s)===10?(i=`
`,s++):(i=null,a('"\\n"'))))),i}function ce(i){i.sort();let c=null;const g=[];for(let f=0;f<i.length;f++)i[f]!==c&&(g.push(i[f]),c=i[f]);return g}function Lt(){let i=1,c=1,g=!1;for(let f=0;f<Math.max(s,n);f++){const m=u.charAt(f);m===`
`?(g||i++,c=1,g=!1):m==="\r"||m==="\u2028"||m==="\u2029"?(i++,c=1,g=!0):(c++,g=!1)}return{line:i,column:c}}function Rt(i,c){const g=[{cmd:c?"moveToRelative":"moveTo",args:[i[0].x,i[0].y]}];if(i.length>1)for(let f=1;f<i.length;f++)g.push({cmd:c?"lineToRelative":"lineTo",args:[i[f].x,i[f].y]});return g}const Be=e[t]();if(Be===null||s!==u.length){const i=Math.max(s,n),c=i<u.length?u.charAt(i):null,g=Lt();throw new this.SyntaxError(ce(r),c,i,g.line,g.column)}return Be},toSource:function(){return this._source}};Ve.SyntaxError=function(u,t,e,s,n){function r(a,l){let o,h;switch(a.length){case 0:o="end of input";break;case 1:o=a[0];break;default:o=a.slice(0,a.length-1).join(", ")+" or "+a[a.length-1]}return h=l?Ze(l):"end of input","Expected "+o+" but "+h+" found."}this.name="SyntaxError",this.expected=u,this.found=t,this.message=r(u,t),this.offset=e,this.line=s,this.column=n};Ve.SyntaxError.prototype=Error.prototype;Q.register("svgPath",Ve);const Fs=Q.svgPath;class rt{constructor(){this.invalidationEmitter=new Fe}areStrokedBoundsDilated(){return Math.abs(this.startTangent.x*this.startTangent.y)<1e-7&&Math.abs(this.endTangent.x*this.endTangent.y)<1e-7}getBoundsWithTransform(t){return this.transformed(t).getBounds()}slice(t,e){assert&&assert(t>=0&&t<=1&&e>=0&&e<=1,"Parametric value out of range"),assert&&assert(t<e);let s=this;return e<1&&(s=s.subdivided(e)[0]),t>0&&(s=s.subdivided(O.linear(0,e,0,1,t))[1]),s}subdivisions(t){let e=this;const s=[];for(let n=0;n<t.length;n++){const r=t[n],a=e.subdivided(r);assert&&assert(a.length===2),s.push(a[0]),e=a[1];for(let l=n+1;l<t.length;l++)t[l]=O.linear(r,1,0,1,t[l])}return s.push(e),s}subdividedIntoMonotone(){return this.subdivisions(this.getInteriorExtremaTs())}isSufficientlyFlat(t,e){const s=this.start,n=this.positionAt(.5),r=this.end;return rt.isSufficientlyFlat(t,e,s,n,r)}getArcLength(t,e,s){if(t=t===void 0?1e-10:t,e=e===void 0?1e-8:e,s=s===void 0?15:s,s<=0||this.isSufficientlyFlat(t,e))return this.start.distance(this.end);{const n=this.subdivided(.5);return n[0].getArcLength(t,e,s-1)+n[1].getArcLength(t,e,s-1)}}getDashValues(t,e,s,n){assert&&assert(t.length>0,"Do not call with an empty dash array");const r=this,a=[];let l=0;const o=_.sum(t);e=e%o,e<0&&(e+=o);let h=0,d=0,p=!0;function A(){h=(h+1)%t.length,p=!p}for(;e>0;)e>=t[h]?(e-=t[h],A()):(d=e,e=0);const b=p;return function S(P,w,x,v,T){const M=(P+w)/2,$=r.positionAt(M);if(T>14||rt.isSufficientlyFlat(s,n,x,$,v)){const B=x.distance($)+$.distance(v);l+=B;let N=B;for(;d+N>=t[h];){const W=O.linear(0,B,P,w,B-N+t[h]-d);a.push(W),N-=t[h]-d,d=0,A()}d=d+N}else S(P,M,x,$,T+1),S(M,w,$,v,T+1)}(0,1,this.start,this.end,0),{values:a,arcLength:l,initiallyInside:b}}toPiecewiseLinearSegments(t,e,s,n,r,a){e=e===void 0?t.minLevels:e,s=s===void 0?t.maxLevels:s,n=n||[];const l=t.pointMap||_.identity;r=r||l(this.start),a=a||l(this.end);const o=l(this.positionAt(.5));assert&&assert(e<=s),assert&&assert(t.distanceEpsilon===null||typeof t.distanceEpsilon=="number"),assert&&assert(t.curveEpsilon===null||typeof t.curveEpsilon=="number"),assert&&assert(!l||typeof l=="function");let h=s===0;if(!h&&e<=0&&(h=this.isSufficientlyFlat(t.distanceEpsilon===null||t.distanceEpsilon===void 0?Number.POSITIVE_INFINITY:t.distanceEpsilon,t.curveEpsilon===null||t.curveEpsilon===void 0?Number.POSITIVE_INFINITY:t.curveEpsilon)),h)n.push(new F(r,a));else{const d=this.subdivided(.5);d[0].toPiecewiseLinearSegments(t,e-1,s-1,n,r,o),d[1].toPiecewiseLinearSegments(t,e-1,s-1,n,o,a)}return n}toPiecewiseLinearOrArcSegments(t){const e=Ee()({minLevels:2,maxLevels:7,curvatureThreshold:.02,errorThreshold:10,errorPoints:[.25,.75]},t),s=[];return this.toPiecewiseLinearOrArcRecursion(e,e.minLevels,e.maxLevels,s,0,1,this.positionAt(0),this.positionAt(1),this.curvatureAt(0),this.curvatureAt(1)),s}toPiecewiseLinearOrArcRecursion(t,e,s,n,r,a,l,o,h,d){const p=(r+a)/2,A=this.positionAt(p),b=this.curvatureAt(p);if(s<=0||e<=0&&Math.abs(h-b)+Math.abs(b-d)<t.curvatureThreshold*2){const S=D.createFromPoints(l,A,o);let P=!1;if(S instanceof D){const w=S.radius*S.radius;for(let x=0;x<t.errorPoints.length;x++){const v=t.errorPoints[x],T=this.positionAt(r*(1-v)+a*v);if(Math.abs(T.distanceSquared(S.center)-w)>t.errorThreshold){P=!0;break}}}if(!P){n.push(S);return}}this.toPiecewiseLinearOrArcRecursion(t,e-1,s-1,n,r,p,l,A,h,b),this.toPiecewiseLinearOrArcRecursion(t,e-1,s-1,n,p,a,A,o,b,d)}toShape(){return new qs([new yt([this])])}getClosestPoints(t){return rt.closestToPoint([this],t,1e-7)}static closestToPoint(t,e,s){const n=s*s;let r=[],a=[],l=Number.POSITIVE_INFINITY,o=!1;for(_.each(t,h=>{if(h instanceof F){const d=h.explicitClosestToPoint(e);_.each(d,p=>{p.distanceSquared<l?(a=[p],l=p.distanceSquared):p.distanceSquared===l&&a.push(p)})}else{const d=[0].concat(h.getInteriorExtremaTs()).concat([1]);for(let p=0;p<d.length-1;p++){const A=d[p],b=d[p+1],S=h.positionAt(A),P=h.positionAt(b),w=ut.point(S).addPoint(P),x=w.minimumDistanceToPointSquared(e);if(x<=l){const v=w.maximumDistanceToPointSquared(e);v<l&&(l=v,a=[]),r.push({ta:A,tb:b,pa:S,pb:P,segment:h,bounds:w,min:x,max:v})}}}});r.length&&!o;){const h=r;r=[],o=!0;for(const d of h){if(d.min>l)continue;o&&d.pa.distanceSquared(d.pb)>n&&(o=!1);const p=(d.ta+d.tb)/2,A=d.segment.positionAt(p),b=ut.point(d.pa).addPoint(A),S=ut.point(d.pb).addPoint(A),P=b.minimumDistanceToPointSquared(e),w=S.minimumDistanceToPointSquared(e);if(P<=l){const x=b.maximumDistanceToPointSquared(e);x<l&&(l=x,a=[]),r.push({ta:d.ta,tb:p,pa:d.pa,pb:A,segment:d.segment,bounds:b,min:P,max:x})}if(w<=l){const x=S.maximumDistanceToPointSquared(e);x<l&&(l=x,a=[]),r.push({ta:p,tb:d.tb,pa:A,pb:d.pb,segment:d.segment,bounds:S,min:w,max:x})}}}return _.each(r,h=>{const d=(h.ta+h.tb)/2,p=h.segment.positionAt(d);a.push({segment:h.segment,t:d,closestPoint:p,distanceSquared:e.distanceSquared(p)})}),a}static polynomialGetOverlapCubic(t,e,s,n,r,a,l,o){if(o===0)return rt.polynomialGetOverlapQuadratic(t,e,s,r,a,l);const h=Math.sign(n/o)*Math.pow(Math.abs(n/o),1/3);if(h===0)return null;const d=(s-h*h*l)/(3*h*h*o);return{a:h,b:d}}static polynomialGetOverlapQuadratic(t,e,s,n,r,a){if(a===0)return rt.polynomialGetOverlapLinear(t,e,n,r);if(s/a<0)return null;const o=Math.sqrt(s/a);if(o===0)return null;const h=(e-o*r)/(2*o*a);return{a:o,b:h}}static polynomialGetOverlapLinear(t,e,s,n){if(n===0)return t===s?!0:null;const r=e/n;if(r===0)return null;const a=(t-s)/n;return{a:r,b:a}}static intersect(t,e){if(F&&t instanceof F&&e instanceof F)return F.intersect(t,e);if(F&&t instanceof F)return F.intersectOther(t,e);if(F&&e instanceof F)return F.intersectOther(e,t).map(Rs);if(D&&t instanceof D&&e instanceof D)return D.intersect(t,e);if(lt&&t instanceof lt&&e instanceof lt)return lt.intersect(t,e);if(nt&&ht&&(t instanceof nt||t instanceof ht)&&(e instanceof nt||e instanceof ht)){const s=t instanceof ht?t:t.degreeElevated(),n=e instanceof ht?e:e.degreeElevated(),r=new paper.Curve(s.start.x,s.start.y,s.control1.x,s.control1.y,s.control2.x,s.control2.y,s.end.x,s.end.y),a=new paper.Curve(n.start.x,n.start.y,n.control1.x,n.control1.y,n.control2.x,n.control2.y,n.end.x,n.end.y);return r.getIntersections(a).map(o=>{const h=new E(o.point.x,o.point.y);return new vt(h,o.time,o.intersection.time)})}else return Kt.intersect(t,e)}static deserialize(t){return assert&&assert(t.type&&Q[t.type]&&Q[t.type].deserialize),Q[t.type].deserialize(t)}static isSufficientlyFlat(t,e,s,n,r){return!(O.distToSegmentSquared(n,s,r)/s.distanceSquared(r)>e||O.distToSegmentSquared(n,s,r)>t)}static filterClosestToPointResult(t){if(t.length===0)return[];const e=_.minBy(t,s=>s.distanceSquared).distanceSquared;return _.uniqWith(t.filter(s=>Math.abs(s.distanceSquared-e)<1e-11),(s,n)=>s.closestPoint.distanceSquared(n.closestPoint)<1e-11)}}Q.register("Segment",rt);function Rs(u){return u.getSwapped()}const ke=new E(0,0);class F extends rt{constructor(t,e){super(),this._start=t,this._end=e,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Line start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setEnd(t){return assert&&assert(t.isFinite(),`Line end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this._start.plus(this._end.minus(this._start).times(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.getStartTangent()}curvatureAt(t){return assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),0}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.positionAt(t);return[new F(this._start,e),new F(e,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Line start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Line start should be finite: ${this._start.toString()}`),assert&&assert(this._end instanceof E,`Line end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Line end should be finite: ${this._end.toString()}`),this._tangent=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){return this._tangent===null&&(this._tangent=this._end.minus(this._start).normalized()),this._tangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this.getStartTangent()}get endTangent(){return this.getEndTangent()}getBounds(){return this._bounds===null&&(this._bounds=ut.NOTHING.copy().addPoint(this._start).addPoint(this._end)),this._bounds}get bounds(){return this.getBounds()}getBoundsWithTransform(t){const e=ut.NOTHING.copy();return e.addPoint(t.multiplyVector2(ke.set(this._start))),e.addPoint(t.multiplyVector2(ke.set(this._end))),e}getNondegenerateSegments(){return this._start.equals(this._end)?[]:[this]}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`L ${H(this._end.x)} ${H(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){const e=this.getEndTangent().perpendicular.negated().times(t/2);return[new F(this._start.plus(e),this._end.plus(e))]}strokeRight(t){const e=this.getStartTangent().perpendicular.times(t/2);return[new F(this._end.plus(e),this._start.plus(e))]}getInteriorExtremaTs(){return[]}intersection(t){const e=[],s=this._start,r=this._end.minus(s);if(r.magnitudeSquared===0)return e;const a=t.direction.y*r.x-t.direction.x*r.y;if(a===0)return e;const l=(t.direction.x*(s.y-t.position.y)-t.direction.y*(s.x-t.position.x))/a;if(l<0||l>=1)return e;const o=(r.x*(s.y-t.position.y)-r.y*(s.x-t.position.x))/a;if(o<1e-8)return e;const h=r.perpendicular,d=s.plus(r.times(l)),p=(h.dot(t.direction)>0?h.negated():h).normalized(),A=t.direction.perpendicular.dot(r)<0?1:-1;return e.push(new zt(o,d,p,A,l)),e}windingIntersection(t){const e=this.intersection(t);return e.length?e[0].wind:0}writeToContext(t){t.lineTo(this._end.x,this._end.y)}transformed(t){return new F(t.timesVector2(this._start),t.timesVector2(this._end))}explicitClosestToPoint(t){const e=this._end.minus(this._start);let s=t.minus(this._start).dot(e)/e.magnitudeSquared;s=O.clamp(s,0,1);const n=this.positionAt(s);return[{segment:this,t:s,closestPoint:n,distanceSquared:t.distanceSquared(n)}]}getSignedAreaFragment(){return 1/2*(this._start.x*this._end.y-this._start.y*this._end.x)}reparameterized(t,e){return new F(this.positionAt(e),this.positionAt(t+e))}reversed(){return new F(this._end,this._start)}polarToCartesian(t){return this._start.x===this._end.x?[new F(E.createPolar(this._start.y,this._start.x),E.createPolar(this._end.y,this._end.x))]:this._start.y===this._end.y?[new D(E.ZERO,this._start.y,this._start.x,this._end.x,this._start.x>this._end.x)]:this.toPiecewiseLinearSegments(t)}getArcLength(){return this.start.distance(this.end)}toPiecewiseLinearOrArcSegments(){return[this]}serialize(){return{type:"Line",startX:this._start.x,startY:this._start.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof F?F.getOverlaps(this,t):null}getClosestPoints(t){const e=this._end.minus(this._start),s=e.normalized(),n=t.minus(this._start).dot(s),r=O.clamp(n/e.magnitude,0,1),a=this.positionAt(r);return[{segment:this,t:r,closestPoint:a,distanceSquared:a.distanceSquared(t)}]}static deserialize(t){return assert&&assert(t.type==="Line"),new F(new E(t.startX,t.startY),new E(t.endX,t.endY))}static getOverlaps(t,e,s=1e-6){const n=[],r=t._start.x,a=-1*t._start.x+t._end.x,l=t._start.y,o=-1*t._start.y+t._end.y,h=e._start.x,d=-1*e._start.x+e._end.x,p=e._start.y,A=-1*e._start.y+e._end.y,b=Math.abs(Math.max(t._start.x,t._end.x,e._start.x,e._end.x)-Math.min(t._start.x,t._end.x,e._start.x,e._end.x)),S=Math.abs(Math.max(t._start.y,t._end.y,e._start.y,e._end.y)-Math.min(t._start.y,t._end.y,e._start.y,e._end.y)),P=rt.polynomialGetOverlapLinear(r,a,h,d),w=rt.polynomialGetOverlapLinear(l,o,p,A);let x;if(b>S?x=P===null||P===!0?w:P:x=w===null||w===!0?P:w,x===null||x===!0)return n;const v=x.a,T=x.b,M=h+T*d-r,$=v*d-a,B=p+T*A-l,N=v*A-o;if(Math.abs(M)>s||Math.abs($+M)>s||Math.abs(B)>s||Math.abs(N+B)>s)return n;const W=T,k=v+T;return W>1&&k>1||W<0&&k<0?n:[new Gt(v,T)]}static intersect(t,e){const s=O.lineSegmentIntersection(t.start.x,t.start.y,t.end.x,t.end.y,e.start.x,e.start.y,e.end.x,e.end.y);if(s!==null){const n=t.explicitClosestToPoint(s)[0].t,r=e.explicitClosestToPoint(s)[0].t;return[new vt(s,n,r)]}else return[]}static intersectOther(t,e){const s=t.end.minus(t.start),n=s.magnitude,r=new qt(t.start,s.normalize()),a=e.intersection(r),l=[];for(let o=0;o<a.length;o++){const h=a[o],d=h.distance/n;d>1e-8&&d<1-1e-8&&l.push(new vt(h.point,d,h.t))}return l}}Q.register("Line",F);const Vs=O.solveQuadraticRootsReal,$s=O.arePointsCollinear;function qe(u){return u>=0&&u<=1}class nt extends rt{constructor(t,e,s){super(),this._start=t,this._control=e,this._end=s,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Quadratic start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setControl(t){return assert&&assert(t.isFinite(),`Quadratic control should be finite: ${t.toString()}`),this._control.equals(t)||(this._control=t,this.invalidate()),this}set control(t){this.setControl(t)}get control(){return this.getControl()}getControl(){return this._control}setEnd(t){return assert&&assert(t.isFinite(),`Quadratic end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1");const e=1-t;return this._start.times(e*e).plus(this._control.times(2*e*t)).plus(this._end.times(t*t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this._control.minus(this._start).times(2*(1-t)).plus(this._end.minus(this._control).times(2*t))}curvatureAt(t){if(assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),Math.abs(t-.5)>.5-1e-7){const s=t<.5,n=s?this._start:this._end,r=this._control,a=s?this._end:this._start,l=r.minus(n),o=l.magnitude;return(s?-1:1)*l.perpendicular.normalized().dot(a.minus(r))*(this.degree-1)/(this.degree*o*o)}else return this.subdivided(t)[0].curvatureAt(1)}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this._start.blend(this._control,t),s=this._control.blend(this._end,t),n=e.blend(s,t);return[new nt(this._start,e,n),new nt(n,s,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Quadratic start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Quadratic start should be finite: ${this._start.toString()}`),assert&&assert(this._control instanceof E,`Quadratic control should be a Vector2: ${this._control}`),assert&&assert(this._control.isFinite(),`Quadratic control should be finite: ${this._control.toString()}`),assert&&assert(this._end instanceof E,`Quadratic end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Quadratic end should be finite: ${this._end.toString()}`),this._startTangent=null,this._endTangent=null,this._tCriticalX=null,this._tCriticalY=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){if(this._startTangent===null){const t=this._start.equals(this._control);this._startTangent=t?this._end.minus(this._start).normalized():this._control.minus(this._start).normalized()}return this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){if(this._endTangent===null){const t=this._end.equals(this._control);this._endTangent=t?this._end.minus(this._start).normalized():this._end.minus(this._control).normalized()}return this._endTangent}get endTangent(){return this.getEndTangent()}getTCriticalX(){return this._tCriticalX===null&&(this._tCriticalX=nt.extremaT(this._start.x,this._control.x,this._end.x)),this._tCriticalX}get tCriticalX(){return this.getTCriticalX()}getTCriticalY(){return this._tCriticalY===null&&(this._tCriticalY=nt.extremaT(this._start.y,this._control.y,this._end.y)),this._tCriticalY}get tCriticalY(){return this.getTCriticalY()}getNondegenerateSegments(){const t=this._start,e=this._control,s=this._end,n=t.equals(s),r=t.equals(e),a=t.equals(e);if(n&&r)return[];if(n){const l=this.positionAt(.5);return[new F(t,l),new F(l,s)]}else if($s(t,e,s)){if(r||a)return[new F(t,s)];const l=s.minus(t),o=e.minus(t).dot(l.normalized())/l.magnitude,h=nt.extremaT(0,o,1);if(!isNaN(h)&&h>0&&h<1){const d=this.positionAt(h);return _.flatten([new F(t,d).getNondegenerateSegments(),new F(d,s).getNondegenerateSegments()])}else return[new F(t,s)]}else return[this]}getBounds(){if(this._bounds===null){this._bounds=new ut(Math.min(this._start.x,this._end.x),Math.min(this._start.y,this._end.y),Math.max(this._start.x,this._end.x),Math.max(this._start.y,this._end.y));const t=this.getTCriticalX(),e=this.getTCriticalY();!isNaN(t)&&t>0&&t<1&&(this._bounds=this._bounds.withPoint(this.positionAt(t))),!isNaN(e)&&e>0&&e<1&&(this._bounds=this._bounds.withPoint(this.positionAt(e)))}return this._bounds}get bounds(){return this.getBounds()}offsetTo(t,e){let s=[this];const n=5;for(let a=0;a<n;a++)s=_.flatten(_.map(s,l=>l.subdivided(.5)));let r=_.map(s,a=>a.approximateOffset(t));return e&&(r.reverse(),r=_.map(r,a=>a.reversed())),r}degreeElevated(){return new ht(this._start,this._start.plus(this._control.timesScalar(2)).dividedScalar(3),this._end.plus(this._control.timesScalar(2)).dividedScalar(3),this._end)}approximateOffset(t){return new nt(this._start.plus((this._start.equals(this._control)?this._end.minus(this._start):this._control.minus(this._start)).perpendicular.normalized().times(t)),this._control.plus(this._end.minus(this._start).perpendicular.normalized().times(t)),this._end.plus((this._end.equals(this._control)?this._end.minus(this._start):this._end.minus(this._control)).perpendicular.normalized().times(t)))}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`Q ${H(this._control.x)} ${H(this._control.y)} ${H(this._end.x)} ${H(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=[],s=this.getTCriticalX(),n=this.getTCriticalY();return!isNaN(s)&&s>1e-10&&s<1-1e-10&&t.push(this.tCriticalX),!isNaN(n)&&n>1e-10&&n<1-1e-10&&t.push(this.tCriticalY),t.sort()}intersection(t){const e=[],s=Bt.rotation2(-t.direction.angle).timesMatrix(Bt.translation(-t.position.x,-t.position.y)),n=s.timesVector2(this._start),r=s.timesVector2(this._control),a=s.timesVector2(this._end),l=n.y-2*r.y+a.y,o=-2*n.y+2*r.y,h=n.y,d=Vs(l,o,h);return _.each(d,p=>{if(p>=0&&p<=1){const A=this.positionAt(p),b=this.tangentAt(p).normalized(),S=b.perpendicular,P=A.minus(t.position);if(P.dot(t.direction)>0){const w=S.dot(t.direction)>0?S.negated():S,x=t.direction.perpendicular.dot(b)<0?1:-1;e.push(new zt(P.magnitude,A,w,x,p))}}}),e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,n=>{e+=n.wind}),e}writeToContext(t){t.quadraticCurveTo(this._control.x,this._control.y,this._end.x,this._end.y)}transformed(t){return new nt(t.timesVector2(this._start),t.timesVector2(this._control),t.timesVector2(this._end))}getSignedAreaFragment(){return 1/6*(this._start.x*(2*this._control.y+this._end.y)+this._control.x*(-2*this._start.y+2*this._end.y)+this._end.x*(-this._start.y-2*this._control.y))}reparameterized(t,e){const s=this._start.plus(this._end.plus(this._control.timesScalar(-2))),n=this._control.minus(this._start).timesScalar(2),r=this._start,a=s.timesScalar(t*t),l=s.timesScalar(t*e).timesScalar(2).plus(n.timesScalar(t)),o=s.timesScalar(e*e).plus(n.timesScalar(e)).plus(r);return new nt(o,l.timesScalar(.5).plus(o),a.plus(l).plus(o))}reversed(){return new nt(this._end,this._control,this._start)}serialize(){return{type:"Quadratic",startX:this._start.x,startY:this._start.y,controlX:this._control.x,controlY:this._control.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof nt?nt.getOverlaps(this,t):null}static deserialize(t){return assert&&assert(t.type==="Quadratic"),new nt(new E(t.startX,t.startY),new E(t.controlX,t.controlY),new E(t.endX,t.endY))}static extremaT(t,e,s){const n=2*(s-2*e+t);return n!==0?-2*(e-t)/n:NaN}static getOverlaps(t,e,s=1e-6){const n=[],r=t._start.x,a=-2*t._start.x+2*t._control.x,l=t._start.x-2*t._control.x+t._end.x,o=t._start.y,h=-2*t._start.y+2*t._control.y,d=t._start.y-2*t._control.y+t._end.y,p=e._start.x,A=-2*e._start.x+2*e._control.x,b=e._start.x-2*e._control.x+e._end.x,S=e._start.y,P=-2*e._start.y+2*e._control.y,w=e._start.y-2*e._control.y+e._end.y,x=Math.abs(Math.max(t._start.x,t._control.x,t._end.x,e._start.x,e._control.x,e._end.x)-Math.min(t._start.x,t._control.x,t._end.x,e._start.x,e._control.x,e._end.x)),v=Math.abs(Math.max(t._start.y,t._control.y,t._end.y,e._start.y,e._control.y,e._end.y)-Math.min(t._start.y,t._control.y,t._end.y,e._start.y,e._control.y,e._end.y)),T=rt.polynomialGetOverlapQuadratic(r,a,l,p,A,b),M=rt.polynomialGetOverlapQuadratic(o,h,d,S,P,w);let $;if(x>v?$=T===null||T===!0?M:T:$=M===null||M===!0?T:M,$===null||$===!0)return n;const B=$.a,N=$.b,W=B*B,k=N*N,q=2*B*N,L=p+N*A+k*b-r,tt=B*A+q*b-a,Pt=W*b-l,U=S+N*P+k*w-o,at=B*P+q*w-h,At=W*w-d,ot=O.solveLinearRootsReal(2*Pt,tt),ft=O.solveLinearRootsReal(2*At,at),st=_.uniq([0,1].concat(ot?ot.filter(qe):[])),et=_.uniq([0,1].concat(ft?ft.filter(qe):[]));for(let Y=0;Y<st.length;Y++){const ct=st[Y];if(Math.abs((Pt*ct+tt)*ct+L)>s)return n}for(let Y=0;Y<et.length;Y++){const ct=et[Y];if(Math.abs((At*ct+at)*ct+U)>s)return n}const J=N,It=B+N;return J>1&&It>1||J<0&&It<0?n:[new Gt(B,N)]}}nt.prototype.degree=2;Q.register("Quadratic",nt);const Bs=O.solveQuadraticRootsReal,Ns=O.solveCubicRootsReal,De=O.arePointsCollinear,de=new E(0,0),Ls=new E(0,0),Hs=new E(0,0);function xe(u){return u>=0&&u<=1}class ht extends rt{constructor(t,e,s,n){super(),this._start=t,this._control1=e,this._control2=s,this._end=n,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Cubic start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setControl1(t){return assert&&assert(t.isFinite(),`Cubic control1 should be finite: ${t.toString()}`),this._control1.equals(t)||(this._control1=t,this.invalidate()),this}set control1(t){this.setControl1(t)}get control1(){return this.getControl1()}getControl1(){return this._control1}setControl2(t){return assert&&assert(t.isFinite(),`Cubic control2 should be finite: ${t.toString()}`),this._control2.equals(t)||(this._control2=t,this.invalidate()),this}set control2(t){this.setControl2(t)}get control2(){return this.getControl2()}getControl2(){return this._control2}setEnd(t){return assert&&assert(t.isFinite(),`Cubic end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1");const e=1-t,s=e*e*e,n=3*e*e*t,r=3*e*t*t,a=t*t*t;return new E(this._start.x*s+this._control1.x*n+this._control2.x*r+this._end.x*a,this._start.y*s+this._control1.y*n+this._control2.y*r+this._end.y*a)}tangentAt(t){assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1");const e=1-t;return new E(0,0).set(this._start).multiplyScalar(-3*e*e).add(de.set(this._control1).multiplyScalar(3*e*e-6*e*t)).add(de.set(this._control2).multiplyScalar(6*e*t-3*t*t)).add(de.set(this._end).multiplyScalar(3*t*t))}curvatureAt(t){if(assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),Math.abs(t-.5)>.5-1e-7){const s=t<.5,n=s?this._start:this._end,r=s?this._control1:this._control2,a=s?this._control2:this._control1,l=r.minus(n),o=l.magnitude;return(s?-1:1)*l.perpendicular.normalized().dot(a.minus(r))*(this.degree-1)/(this.degree*o*o)}else return this.subdivided(t)[0].curvatureAt(1)}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this._start.blend(this._control1,t),s=this._control2.blend(this._end,t),n=this._control1.blend(this._control2,t),r=e.blend(n,t),a=n.blend(s,t),l=r.blend(a,t);return[new ht(this._start,e,r,l),new ht(l,a,s,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Cubic start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Cubic start should be finite: ${this._start.toString()}`),assert&&assert(this._control1 instanceof E,`Cubic control1 should be a Vector2: ${this._control1}`),assert&&assert(this._control1.isFinite(),`Cubic control1 should be finite: ${this._control1.toString()}`),assert&&assert(this._control2 instanceof E,`Cubic control2 should be a Vector2: ${this._control2}`),assert&&assert(this._control2.isFinite(),`Cubic control2 should be finite: ${this._control2.toString()}`),assert&&assert(this._end instanceof E,`Cubic end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Cubic end should be finite: ${this._end.toString()}`),this._startTangent=null,this._endTangent=null,this._r=null,this._s=null,this._tCusp=null,this._tDeterminant=null,this._tInflection1=null,this._tInflection2=null,this._quadratics=null,this._xExtremaT=null,this._yExtremaT=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAt(0).normalized()),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAt(1).normalized()),this._endTangent}get endTangent(){return this.getEndTangent()}getR(){return this._r===null&&(this._r=this._control1.minus(this._start).normalized()),this._r}get r(){return this.getR()}getS(){return this._s===null&&(this._s=this.getR().perpendicular),this._s}get s(){return this.getS()}getTCusp(){return this._tCusp===null&&this.computeCuspInfo(),assert&&assert(this._tCusp!==null),this._tCusp}get tCusp(){return this.getTCusp()}getTDeterminant(){return this._tDeterminant===null&&this.computeCuspInfo(),assert&&assert(this._tDeterminant!==null),this._tDeterminant}get tDeterminant(){return this.getTDeterminant()}getTInflection1(){return this._tInflection1===null&&this.computeCuspInfo(),assert&&assert(this._tInflection1!==null),this._tInflection1}get tInflection1(){return this.getTInflection1()}getTInflection2(){return this._tInflection2===null&&this.computeCuspInfo(),assert&&assert(this._tInflection2!==null),this._tInflection2}get tInflection2(){return this.getTInflection2()}getQuadratics(){return this._quadratics===null&&this.computeCuspSegments(),assert&&assert(this._quadratics!==null),this._quadratics}getXExtremaT(){return this._xExtremaT===null&&(this._xExtremaT=ht.extremaT(this._start.x,this._control1.x,this._control2.x,this._end.x)),this._xExtremaT}get xExtremaT(){return this.getXExtremaT()}getYExtremaT(){return this._yExtremaT===null&&(this._yExtremaT=ht.extremaT(this._start.y,this._control1.y,this._control2.y,this._end.y)),this._yExtremaT}get yExtremaT(){return this.getYExtremaT()}getBounds(){return this._bounds===null&&(this._bounds=ut.NOTHING,this._bounds=this._bounds.withPoint(this._start),this._bounds=this._bounds.withPoint(this._end),_.each(this.getXExtremaT(),t=>{t>=0&&t<=1&&(this._bounds=this._bounds.withPoint(this.positionAt(t)))}),_.each(this.getYExtremaT(),t=>{t>=0&&t<=1&&(this._bounds=this._bounds.withPoint(this.positionAt(t)))}),this.hasCusp()&&(this._bounds=this._bounds.withPoint(this.positionAt(this.getTCusp())))),this._bounds}get bounds(){return this.getBounds()}computeCuspInfo(){const t=this._start.times(-1).plus(this._control1.times(3)).plus(this._control2.times(-3)).plus(this._end),e=this._start.times(3).plus(this._control1.times(-6)).plus(this._control2.times(3)),s=this._start.times(-3).plus(this._control1.times(3)),n=t.perpendicular,r=e.perpendicular,a=n.dot(e);if(this._tCusp=-.5*(n.dot(s)/a),this._tDeterminant=this._tCusp*this._tCusp-1/3*(r.dot(s)/a),this._tDeterminant>=0){const l=Math.sqrt(this._tDeterminant);this._tInflection1=this._tCusp-l,this._tInflection2=this._tCusp+l}else this._tInflection1=NaN,this._tInflection2=NaN}computeCuspSegments(){if(this.hasCusp()){this._quadratics=[];const t=this.getTCusp();if(t===0)this._quadratics.push(new nt(this.start,this.control2,this.end));else if(t===1)this._quadratics.push(new nt(this.start,this.control1,this.end));else{const e=this.subdivided(t);this._quadratics.push(new nt(e[0].start,e[0].control1,e[0].end)),this._quadratics.push(new nt(e[1].start,e[1].control2,e[1].end))}}else this._quadratics=null}getNondegenerateSegments(){const t=this._start,e=this._control1,s=this._control2,n=this._end,r=this.degreeReduced(1e-9);if(t.equals(n)&&t.equals(e)&&t.equals(s))return[];if(this.hasCusp())return _.flatten(this.getQuadratics().map(a=>a.getNondegenerateSegments()));if(r)return r.getNondegenerateSegments();if(De(t,e,n)&&De(t,s,n)&&!t.equalsEpsilon(n,1e-7)){const a=this.getXExtremaT().concat(this.getYExtremaT()).sort().map(h=>this.positionAt(h)),l=[];let o=t;a.length&&(l.push(new F(t,a[0])),o=a[0]);for(let h=1;h<a.length;h++)l.push(new F(a[h-1],a[h])),o=a[h];return l.push(new F(o,n)),_.flatten(l.map(h=>h.getNondegenerateSegments()))}else return[this]}hasCusp(){const t=this.getTCusp();return t>=0&&t<=1&&this.tangentAt(t).magnitude<1e-7}toRS(t){const e=t.minus(this._start);return new E(e.dot(this.getR()),e.dot(this.getS()))}offsetTo(t,e){const n=[],r=[];for(let a=0;a<32;a++){let l=a/31;e&&(l=1-l),n.push(this.positionAt(l).plus(this.tangentAt(l).perpendicular.normalized().times(t))),a>0&&r.push(new F(n[a-1],n[a]))}return r}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`C ${H(this._control1.x)} ${H(this._control1.y)} ${H(this._control2.x)} ${H(this._control2.y)} ${H(this._end.x)} ${H(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=this.getXExtremaT().concat(this.getYExtremaT()),e=[];return _.each(t,s=>{s>1e-10&&s<1-1e-10&&_.every(e,r=>Math.abs(s-r)>1e-10)&&e.push(s)}),e.sort()}intersection(t){const e=[],s=Bt.rotation2(-t.direction.angle).timesMatrix(Bt.translation(-t.position.x,-t.position.y)),n=s.timesVector2(this._start),r=s.timesVector2(this._control1),a=s.timesVector2(this._control2),l=s.timesVector2(this._end),o=-n.y+3*r.y-3*a.y+l.y,h=3*n.y-6*r.y+3*a.y,d=-3*n.y+3*r.y,p=n.y,A=Ns(o,h,d,p);return _.each(A,b=>{if(b>=0&&b<=1){const S=this.positionAt(b),P=this.tangentAt(b).normalized(),w=P.perpendicular,x=S.minus(t.position);if(x.dot(t.direction)>0){const v=w.dot(t.direction)>0?w.negated():w,T=t.direction.perpendicular.dot(P)<0?1:-1;e.push(new zt(x.magnitude,S,v,T,b))}}}),e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,n=>{e+=n.wind}),e}writeToContext(t){t.bezierCurveTo(this._control1.x,this._control1.y,this._control2.x,this._control2.y,this._end.x,this._end.y)}transformed(t){return new ht(t.timesVector2(this._start),t.timesVector2(this._control1),t.timesVector2(this._control2),t.timesVector2(this._end))}degreeReduced(t){t=t||0;const e=de.set(this._control1).multiplyScalar(3).subtract(this._start).divideScalar(2),s=Ls.set(this._control2).multiplyScalar(3).subtract(this._end).divideScalar(2);return Hs.set(e).subtract(s).magnitude<=t?new nt(this._start,e.average(s),this._end):null}getSignedAreaFragment(){return 1/20*(this._start.x*(6*this._control1.y+3*this._control2.y+this._end.y)+this._control1.x*(-6*this._start.y+3*this._control2.y+3*this._end.y)+this._control2.x*(-3*this._start.y-3*this._control1.y+6*this._end.y)+this._end.x*(-this._start.y-3*this._control1.y-6*this._control2.y))}reversed(){return new ht(this._end,this._control2,this._control1,this._start)}getSelfIntersection(){const t=this.getInteriorExtremaTs(),e=[0].concat(t).concat([1]),s=this.subdivisions(t);if(s.length<3)return null;for(let n=0;n<s.length;n++){const r=s[n];for(let a=n+1;a<s.length;a++){const l=s[a],o=Kt.intersect(r,l);if(assert&&assert(o.length<2),o.length){const h=o[0];if(h.aT>1e-7&&h.aT<1-1e-7&&h.bT>1e-7&&h.bT<1-1e-7){const d=e[n]+h.aT*(e[n+1]-e[n]),p=e[a]+h.bT*(e[a+1]-e[a]);return new vt(h.point,d,p)}}}}return null}serialize(){return{type:"Cubic",startX:this._start.x,startY:this._start.y,control1X:this._control1.x,control1Y:this._control1.y,control2X:this._control2.x,control2Y:this._control2.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof ht?ht.getOverlaps(this,t):null}static deserialize(t){return assert&&assert(t.type==="Cubic"),new ht(new E(t.startX,t.startY),new E(t.control1X,t.control1Y),new E(t.control2X,t.control2Y),new E(t.endX,t.endY))}static extremaT(t,e,s,n){if(t===e&&t===s&&t===n)return[];const r=-3*t+9*e-9*s+3*n,a=6*t-12*e+6*s,l=-3*t+3*e;return _.filter(Bs(r,a,l),xe)}static getOverlaps(t,e,s=1e-6){const n=[],r=t._start.x,a=-3*t._start.x+3*t._control1.x,l=3*t._start.x-6*t._control1.x+3*t._control2.x,o=-1*t._start.x+3*t._control1.x-3*t._control2.x+t._end.x,h=t._start.y,d=-3*t._start.y+3*t._control1.y,p=3*t._start.y-6*t._control1.y+3*t._control2.y,A=-1*t._start.y+3*t._control1.y-3*t._control2.y+t._end.y,b=e._start.x,S=-3*e._start.x+3*e._control1.x,P=3*e._start.x-6*e._control1.x+3*e._control2.x,w=-1*e._start.x+3*e._control1.x-3*e._control2.x+e._end.x,x=e._start.y,v=-3*e._start.y+3*e._control1.y,T=3*e._start.y-6*e._control1.y+3*e._control2.y,M=-1*e._start.y+3*e._control1.y-3*e._control2.y+e._end.y,$=Math.abs(Math.max(t._start.x,t._control1.x,t._control2.x,t._end.x,t._start.x,t._control1.x,t._control2.x,t._end.x)-Math.min(t._start.x,t._control1.x,t._control2.x,t._end.x,t._start.x,t._control1.x,t._control2.x,t._end.x)),B=Math.abs(Math.max(t._start.y,t._control1.y,t._control2.y,t._end.y,t._start.y,t._control1.y,t._control2.y,t._end.y)-Math.min(t._start.y,t._control1.y,t._control2.y,t._end.y,t._start.y,t._control1.y,t._control2.y,t._end.y)),N=rt.polynomialGetOverlapCubic(r,a,l,o,b,S,P,w),W=rt.polynomialGetOverlapCubic(h,d,p,A,x,v,T,M);let k;if($>B?k=N===null||N===!0?W:N:k=W===null||W===!0?N:W,k===null||k===!0)return n;const q=k.a,L=k.b,tt=q*q,Pt=q*q*q,U=L*L,at=L*L*L,At=2*q*L,ot=3*q*U,ft=3*tt*L,st=b+L*S+U*P+at*w-r,et=q*S+At*P+ot*w-a,J=tt*P+ft*w-l,It=Pt*w-o,Y=x+L*v+U*T+at*M-h,ct=q*v+At*T+ot*M-d,dt=tt*T+ft*M-p,pt=Pt*M-A,St=O.solveQuadraticRootsReal(3*It,2*J,et),Tt=O.solveQuadraticRootsReal(3*pt,2*dt,ct),Et=_.uniq([0,1].concat(St!==null?St.filter(xe):[])),Nt=_.uniq([0,1].concat(Tt!==null?Tt.filter(xe):[]));for(let Lt=0;Lt<Et.length;Lt++){const Rt=Et[Lt];if(Math.abs(((It*Rt+J)*Rt+et)*Rt+st)>s)return n}for(let Lt=0;Lt<Nt.length;Lt++){const Rt=Nt[Lt];if(Math.abs(((pt*Rt+dt)*Rt+ct)*Rt+Y)>s)return n}const V=L,ce=q+L;return V>1&&ce>1||V<0&&ce<0?n:[new Gt(q,L)]}}ht.prototype.degree=3;Q.register("Cubic",ht);const Vt=Math.PI*2;class D extends rt{constructor(t,e,s,n,r){super(),this._center=t,this._radius=e,this._startAngle=s,this._endAngle=n,this._anticlockwise=r,this.invalidate()}setCenter(t){return assert&&assert(t.isFinite(),`Arc center should be finite: ${t.toString()}`),this._center.equals(t)||(this._center=t,this.invalidate()),this}set center(t){this.setCenter(t)}get center(){return this.getCenter()}getCenter(){return this._center}setRadius(t){return assert&&assert(isFinite(t),`Arc radius should be a finite number: ${t}`),this._radius!==t&&(this._radius=t,this.invalidate()),this}set radius(t){this.setRadius(t)}get radius(){return this.getRadius()}getRadius(){return this._radius}setStartAngle(t){return assert&&assert(isFinite(t),`Arc startAngle should be a finite number: ${t}`),this._startAngle!==t&&(this._startAngle=t,this.invalidate()),this}set startAngle(t){this.setStartAngle(t)}get startAngle(){return this.getStartAngle()}getStartAngle(){return this._startAngle}setEndAngle(t){return assert&&assert(isFinite(t),`Arc endAngle should be a finite number: ${t}`),this._endAngle!==t&&(this._endAngle=t,this.invalidate()),this}set endAngle(t){this.setEndAngle(t)}get endAngle(){return this.getEndAngle()}getEndAngle(){return this._endAngle}setAnticlockwise(t){return this._anticlockwise!==t&&(this._anticlockwise=t,this.invalidate()),this}set anticlockwise(t){this.setAnticlockwise(t)}get anticlockwise(){return this.getAnticlockwise()}getAnticlockwise(){return this._anticlockwise}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this.positionAtAngle(this.angleAt(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.tangentAtAngle(this.angleAt(t))}curvatureAt(t){return assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),(this._anticlockwise?-1:1)/this._radius}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.angleAt(0),s=this.angleAt(t),n=this.angleAt(1);return[new D(this._center,this._radius,e,s,this._anticlockwise),new D(this._center,this._radius,s,n,this._anticlockwise)]}invalidate(){this._start=null,this._end=null,this._startTangent=null,this._endTangent=null,this._actualEndAngle=null,this._isFullPerimeter=null,this._angleDifference=null,this._bounds=null,this._svgPathFragment=null,assert&&assert(this._center instanceof E,"Arc center should be a Vector2"),assert&&assert(this._center.isFinite(),"Arc center should be finite (not NaN or infinite)"),assert&&assert(typeof this._radius=="number",`Arc radius should be a number: ${this._radius}`),assert&&assert(isFinite(this._radius),`Arc radius should be a finite number: ${this._radius}`),assert&&assert(typeof this._startAngle=="number",`Arc startAngle should be a number: ${this._startAngle}`),assert&&assert(isFinite(this._startAngle),`Arc startAngle should be a finite number: ${this._startAngle}`),assert&&assert(typeof this._endAngle=="number",`Arc endAngle should be a number: ${this._endAngle}`),assert&&assert(isFinite(this._endAngle),`Arc endAngle should be a finite number: ${this._endAngle}`),assert&&assert(typeof this._anticlockwise=="boolean",`Arc anticlockwise should be a boolean: ${this._anticlockwise}`),this._radius<0&&(this._radius=-this._radius,this._startAngle+=Math.PI,this._endAngle+=Math.PI),assert&&assert(!(!this.anticlockwise&&this._endAngle-this._startAngle<=-Math.PI*2||this.anticlockwise&&this._startAngle-this._endAngle<=-Math.PI*2),"Not handling arcs with start/end angles that show differences in-between browser handling"),assert&&assert(!(!this.anticlockwise&&this._endAngle-this._startAngle>Math.PI*2||this.anticlockwise&&this._startAngle-this._endAngle>Math.PI*2),"Not handling arcs with start/end angles that show differences in-between browser handling"),this.invalidationEmitter.emit()}getStart(){return this._start===null&&(this._start=this.positionAtAngle(this._startAngle)),this._start}get start(){return this.getStart()}getEnd(){return this._end===null&&(this._end=this.positionAtAngle(this._endAngle)),this._end}get end(){return this.getEnd()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAtAngle(this._startAngle)),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAtAngle(this._endAngle)),this._endTangent}get endTangent(){return this.getEndTangent()}getActualEndAngle(){return this._actualEndAngle===null&&(this._actualEndAngle=D.computeActualEndAngle(this._startAngle,this._endAngle,this._anticlockwise)),this._actualEndAngle}get actualEndAngle(){return this.getActualEndAngle()}getIsFullPerimeter(){return this._isFullPerimeter===null&&(this._isFullPerimeter=!this._anticlockwise&&this._endAngle-this._startAngle>=Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>=Math.PI*2),this._isFullPerimeter}get isFullPerimeter(){return this.getIsFullPerimeter()}getAngleDifference(){return this._angleDifference===null&&(this._angleDifference=this._anticlockwise?this._startAngle-this._endAngle:this._endAngle-this._startAngle,this._angleDifference<0&&(this._angleDifference+=Math.PI*2),assert&&assert(this._angleDifference>=0)),this._angleDifference}get angleDifference(){return this.getAngleDifference()}getBounds(){return this._bounds===null&&(this._bounds=ut.NOTHING.copy().withPoint(this.getStart()).withPoint(this.getEnd()),this._startAngle!==this._endAngle&&(this.includeBoundsAtAngle(0),this.includeBoundsAtAngle(Math.PI/2),this.includeBoundsAtAngle(Math.PI),this.includeBoundsAtAngle(3*Math.PI/2))),this._bounds}get bounds(){return this.getBounds()}getNondegenerateSegments(){return this._radius<=0||this._startAngle===this._endAngle?[]:[this]}includeBoundsAtAngle(t){this.containsAngle(t)&&(this._bounds=this._bounds.withPoint(this._center.plus(E.createPolar(this._radius,t))))}mapAngle(t){return Math.abs(O.moduloBetweenDown(t-this._startAngle,-Math.PI,Math.PI))<1e-8?this._startAngle:Math.abs(O.moduloBetweenDown(t-this.getActualEndAngle(),-Math.PI,Math.PI))<1e-8?this.getActualEndAngle():this._startAngle>this.getActualEndAngle()?O.moduloBetweenUp(t,this._startAngle-2*Math.PI,this._startAngle):O.moduloBetweenDown(t,this._startAngle,this._startAngle+2*Math.PI)}tAtAngle(t){const e=(this.mapAngle(t)-this._startAngle)/(this.getActualEndAngle()-this._startAngle);return assert&&assert(e>=0&&e<=1,`tAtAngle out of range: ${e}`),e}angleAt(t){return this._startAngle+(this.getActualEndAngle()-this._startAngle)*t}positionAtAngle(t){return this._center.plus(E.createPolar(this._radius,t))}tangentAtAngle(t){const e=E.createPolar(1,t);return this._anticlockwise?e.perpendicular:e.perpendicular.negated()}containsAngle(t){const e=this._anticlockwise?t-this._endAngle:t-this._startAngle;return O.moduloBetweenDown(e,0,Math.PI*2)<=this.angleDifference}getSVGPathFragment(){let t;if(assert&&(t=this._svgPathFragment,this._svgPathFragment=null),!this._svgPathFragment){const s=this._anticlockwise?"0":"1";let n;if(this.angleDifference<Math.PI*2-.01)n=this.angleDifference<Math.PI?"0":"1",this._svgPathFragment=`A ${H(this._radius)} ${H(this._radius)} 0 ${n} ${s} ${H(this.end.x)} ${H(this.end.y)}`;else{const r=(this._startAngle+this._endAngle)/2,a=this._center.plus(E.createPolar(this._radius,r));n="0";const l=`A ${H(this._radius)} ${H(this._radius)} 0 ${n} ${s} ${H(a.x)} ${H(a.y)}`,o=`A ${H(this._radius)} ${H(this._radius)} 0 ${n} ${s} ${H(this.end.x)} ${H(this.end.y)}`;this._svgPathFragment=`${l} ${o}`}}return assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return[new D(this._center,this._radius+(this._anticlockwise?1:-1)*t/2,this._startAngle,this._endAngle,this._anticlockwise)]}strokeRight(t){return[new D(this._center,this._radius+(this._anticlockwise?-1:1)*t/2,this._endAngle,this._startAngle,!this._anticlockwise)]}getInteriorExtremaTs(){const t=[];return _.each([0,Math.PI/2,Math.PI,3*Math.PI/2],e=>{if(this.containsAngle(e)){const s=this.tAtAngle(e),n=1e-10;s>n&&s<1-n&&t.push(s)}}),t.sort()}intersection(t){const e=[],n=t.position.minus(this._center),r=t.direction.dot(n),a=n.magnitudeSquared,l=4*r*r-4*(a-this._radius*this._radius);if(l<0)return e;const o=t.direction.dot(this._center)-t.direction.dot(t.position),h=Math.sqrt(l)/2,d=o-h,p=o+h;if(p<0)return e;const A=t.pointAtDistance(p),b=A.minus(this._center).normalized(),S=b.angle;if(d<0)this.containsAngle(S)&&e.push(new zt(p,A,b.negated(),this._anticlockwise?-1:1,this.tAtAngle(S)));else{const P=t.pointAtDistance(d),w=P.minus(this._center).normalized(),x=w.angle;this.containsAngle(x)&&e.push(new zt(d,P,w,this._anticlockwise?1:-1,this.tAtAngle(x))),this.containsAngle(S)&&e.push(new zt(p,A,b.negated(),this._anticlockwise?-1:1,this.tAtAngle(S)))}return e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,n=>{e+=n.wind}),e}writeToContext(t){t.arc(this._center.x,this._center.y,this._radius,this._startAngle,this._endAngle,this._anticlockwise)}transformed(t){const e=t.timesVector2(E.createPolar(1,this._startAngle)).minus(t.timesVector2(E.ZERO)).angle;let s=t.timesVector2(E.createPolar(1,this._endAngle)).minus(t.timesVector2(E.ZERO)).angle;const n=t.getDeterminant()>=0?this._anticlockwise:!this._anticlockwise;Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(s=n?e-Math.PI*2:e+Math.PI*2);const r=t.getScaleVector();if(r.x!==r.y){const a=r.x*this._radius,l=r.y*this._radius;return new lt(t.timesVector2(this._center),a,l,0,e,s,n)}else{const a=r.x*this._radius;return new D(t.timesVector2(this._center),a,e,s,n)}}getSignedAreaFragment(){const t=this._startAngle,e=this.getActualEndAngle();return .5*this._radius*(this._radius*(e-t)+this._center.x*(Math.sin(e)-Math.sin(t))-this._center.y*(Math.cos(e)-Math.cos(t)))}reversed(){return new D(this._center,this._radius,this._endAngle,this._startAngle,!this._anticlockwise)}getArcLength(){return this.getAngleDifference()*this._radius}toPiecewiseLinearOrArcSegments(){return[this]}serialize(){return{type:"Arc",centerX:this._center.x,centerY:this._center.y,radius:this._radius,startAngle:this._startAngle,endAngle:this._endAngle,anticlockwise:this._anticlockwise}}getOverlaps(t,e=1e-6){return t instanceof D?D.getOverlaps(this,t):null}getConicMatrix(){const t=this.center.x,e=this.center.y,s=1,n=0,r=1,a=-2*t,l=-2*e,o=t*t+e*e-this.radius*this.radius;return Bt.rowMajor(s,n/2,a/2,n/2,r,l/2,a/2,l/2,o)}static deserialize(t){return assert&&assert(t.type==="Arc"),new D(new E(t.centerX,t.centerY),t.radius,t.startAngle,t.endAngle,t.anticlockwise)}static computeActualEndAngle(t,e,s){return s?t>e?e:t<e?e-2*Math.PI:t:t<e?e:t>e?e+Math.PI*2:t}static getPartialOverlap(t,e,s,n,r){assert&&assert(t>0&&t<=Vt+1e-10),assert&&assert(e>=0&&e<Vt+1e-10),assert&&assert(s>=0&&s<=Vt+1e-10),assert&&assert(n>=0&&n<=1),assert&&assert(r>=0&&r<=1);const a=s<e,l=a?s:e,o=a?e:s,h=l,d=Math.min(t,o);return d<h+1e-8?[]:[Gt.createLinear(O.clamp(O.linear(0,t,0,1,h),0,1),O.clamp(O.linear(e,s,n,r,h),0,1),O.clamp(O.linear(0,t,0,1,d),0,1),O.clamp(O.linear(e,s,n,r,d),0,1))]}static getAngularOverlaps(t,e,s,n){assert&&assert(isFinite(t)),assert&&assert(isFinite(e)),assert&&assert(isFinite(s)),assert&&assert(isFinite(n));let r=e-t;const a=r<0?-1:1;r*=a;const l=O.moduloBetweenDown(a*(s-t),0,Vt),o=a*(n-s)+l;let h;return o<-1e-10?(h=-l/(o-l),D.getPartialOverlap(r,l,0,0,h).concat(D.getPartialOverlap(r,Vt,o+Vt,h,1))):o>Vt+1e-10?(h=(Vt-l)/(o-l),D.getPartialOverlap(r,l,Vt,0,h).concat(D.getPartialOverlap(r,0,o-Vt,h,1))):D.getPartialOverlap(r,l,o,0,1)}static getOverlaps(t,e){return t._center.distance(e._center)>1e-4||Math.abs(t._radius-e._radius)>1e-4?[]:D.getAngularOverlaps(t._startAngle,t.getActualEndAngle(),e._startAngle,e.getActualEndAngle())}static getCircleIntersectionPoint(t,e,s,n){assert&&assert(isFinite(e)&&e>=0),assert&&assert(isFinite(n)&&n>=0);const r=s.minus(t),a=r.magnitude;let l=[];if(!(a<1e-10||a>e+n+1e-10))if(a>e+n-1e-10)l=[t.blend(s,e/a)];else{const o=.5*(a*a-n*n+e*e)/a,h=a*a-n*n+e*e,d=4*a*a*e*e-h*h,p=t.blend(s,o/a);if(d>=1e-10){const A=Math.sqrt(d)/a/2,b=r.perpendicular.setMagnitude(A);l=[p.plus(b),p.minus(b)]}else d>-1e-10&&(l=[p])}return assert&&l.forEach(o=>{assert(Math.abs(o.distance(t)-e)<1e-8),assert(Math.abs(o.distance(s)-n)<1e-8)}),l}static intersect(t,e){const n=[];if(t._center.equalsEpsilon(e._center,1e-7)&&Math.abs(t._radius-e._radius)<1e-7){const r=t.positionAt(0),a=t.positionAt(1),l=e.positionAt(0),o=e.positionAt(1);r.equalsEpsilon(l,1e-7)&&n.push(new vt(r.average(l),0,0)),r.equalsEpsilon(o,1e-7)&&n.push(new vt(r.average(o),0,1)),a.equalsEpsilon(l,1e-7)&&n.push(new vt(a.average(l),1,0)),a.equalsEpsilon(o,1e-7)&&n.push(new vt(a.average(o),1,1))}else{const r=D.getCircleIntersectionPoint(t._center,t._radius,e._center,e._radius);for(let a=0;a<r.length;a++){const l=r[a],o=l.minus(t._center).angle,h=l.minus(e._center).angle;t.containsAngle(o)&&e.containsAngle(h)&&n.push(new vt(l,t.tAtAngle(o),e.tAtAngle(h)))}}return n}static createFromPoints(t,e,s){const n=O.circleCenterFromPoints(t,e,s);if(n===null)return new F(t,s);{const r=t.minus(n),a=e.minus(n),l=s.minus(n),o=r.angle,h=a.angle,d=l.angle,p=(r.magnitude+a.magnitude+l.magnitude)/3,A=new D(n,p,o,d,!1);return A.containsAngle(h)?A:new D(n,p,o,d,!0)}}}Q.register("Arc",D);const Os=O.toDegrees,ks=Bt.rowMajor(1,0,0,0,1,0,0,0,-1);class lt extends rt{constructor(t,e,s,n,r,a,l){super(),this._center=t,this._radiusX=e,this._radiusY=s,this._rotation=n,this._startAngle=r,this._endAngle=a,this._anticlockwise=l,this.invalidate()}setCenter(t){return assert&&assert(t.isFinite(),`EllipticalArc center should be finite: ${t.toString()}`),this._center.equals(t)||(this._center=t,this.invalidate()),this}set center(t){this.setCenter(t)}get center(){return this.getCenter()}getCenter(){return this._center}setRadiusX(t){return assert&&assert(isFinite(t),`EllipticalArc radiusX should be a finite number: ${t}`),this._radiusX!==t&&(this._radiusX=t,this.invalidate()),this}set radiusX(t){this.setRadiusX(t)}get radiusX(){return this.getRadiusX()}getRadiusX(){return this._radiusX}setRadiusY(t){return assert&&assert(isFinite(t),`EllipticalArc radiusY should be a finite number: ${t}`),this._radiusY!==t&&(this._radiusY=t,this.invalidate()),this}set radiusY(t){this.setRadiusY(t)}get radiusY(){return this.getRadiusY()}getRadiusY(){return this._radiusY}setRotation(t){return assert&&assert(isFinite(t),`EllipticalArc rotation should be a finite number: ${t}`),this._rotation!==t&&(this._rotation=t,this.invalidate()),this}set rotation(t){this.setRotation(t)}get rotation(){return this.getRotation()}getRotation(){return this._rotation}setStartAngle(t){return assert&&assert(isFinite(t),`EllipticalArc startAngle should be a finite number: ${t}`),this._startAngle!==t&&(this._startAngle=t,this.invalidate()),this}set startAngle(t){this.setStartAngle(t)}get startAngle(){return this.getStartAngle()}getStartAngle(){return this._startAngle}setEndAngle(t){return assert&&assert(isFinite(t),`EllipticalArc endAngle should be a finite number: ${t}`),this._endAngle!==t&&(this._endAngle=t,this.invalidate()),this}set endAngle(t){this.setEndAngle(t)}get endAngle(){return this.getEndAngle()}getEndAngle(){return this._endAngle}setAnticlockwise(t){return this._anticlockwise!==t&&(this._anticlockwise=t,this.invalidate()),this}set anticlockwise(t){this.setAnticlockwise(t)}get anticlockwise(){return this.getAnticlockwise()}getAnticlockwise(){return this._anticlockwise}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this.positionAtAngle(this.angleAt(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.tangentAtAngle(this.angleAt(t))}curvatureAt(t){assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1");const e=this.angleAt(t),s=this._radiusX*Math.sin(e),n=this._radiusY*Math.cos(e),r=Math.pow(n*n+s*s,3/2);return(this._anticlockwise?-1:1)*this._radiusX*this._radiusY/r}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.angleAt(0),s=this.angleAt(t),n=this.angleAt(1);return[new lt(this._center,this._radiusX,this._radiusY,this._rotation,e,s,this._anticlockwise),new lt(this._center,this._radiusX,this._radiusY,this._rotation,s,n,this._anticlockwise)]}invalidate(){if(assert&&assert(this._center instanceof E,"Arc center should be a Vector2"),assert&&assert(this._center.isFinite(),"Arc center should be finite (not NaN or infinite)"),assert&&assert(typeof this._radiusX=="number",`Arc radiusX should be a number: ${this._radiusX}`),assert&&assert(isFinite(this._radiusX),`Arc radiusX should be a finite number: ${this._radiusX}`),assert&&assert(typeof this._radiusY=="number",`Arc radiusY should be a number: ${this._radiusY}`),assert&&assert(isFinite(this._radiusY),`Arc radiusY should be a finite number: ${this._radiusY}`),assert&&assert(typeof this._rotation=="number",`Arc rotation should be a number: ${this._rotation}`),assert&&assert(isFinite(this._rotation),`Arc rotation should be a finite number: ${this._rotation}`),assert&&assert(typeof this._startAngle=="number",`Arc startAngle should be a number: ${this._startAngle}`),assert&&assert(isFinite(this._startAngle),`Arc startAngle should be a finite number: ${this._startAngle}`),assert&&assert(typeof this._endAngle=="number",`Arc endAngle should be a number: ${this._endAngle}`),assert&&assert(isFinite(this._endAngle),`Arc endAngle should be a finite number: ${this._endAngle}`),assert&&assert(typeof this._anticlockwise=="boolean",`Arc anticlockwise should be a boolean: ${this._anticlockwise}`),this._unitTransform=null,this._start=null,this._end=null,this._startTangent=null,this._endTangent=null,this._actualEndAngle=null,this._isFullPerimeter=null,this._angleDifference=null,this._unitArcSegment=null,this._bounds=null,this._svgPathFragment=null,this._radiusX<0&&(this._radiusX=-this._radiusX,this._startAngle=Math.PI-this._startAngle,this._endAngle=Math.PI-this._endAngle,this._anticlockwise=!this._anticlockwise),this._radiusY<0&&(this._radiusY=-this._radiusY,this._startAngle=-this._startAngle,this._endAngle=-this._endAngle,this._anticlockwise=!this._anticlockwise),this._radiusX<this._radiusY){this._rotation+=Math.PI/2,this._startAngle-=Math.PI/2,this._endAngle-=Math.PI/2;const t=this._radiusX;this._radiusX=this._radiusY,this._radiusY=t}if(this._radiusX<this._radiusY)throw new Error("Not verified to work if radiusX < radiusY");assert&&assert(!(!this._anticlockwise&&this._endAngle-this._startAngle<=-Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle<=-Math.PI*2),"Not handling elliptical arcs with start/end angles that show differences in-between browser handling"),assert&&assert(!(!this._anticlockwise&&this._endAngle-this._startAngle>Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>Math.PI*2),"Not handling elliptical arcs with start/end angles that show differences in-between browser handling"),this.invalidationEmitter.emit()}getUnitTransform(){return this._unitTransform===null&&(this._unitTransform=lt.computeUnitTransform(this._center,this._radiusX,this._radiusY,this._rotation)),this._unitTransform}get unitTransform(){return this.getUnitTransform()}getStart(){return this._start===null&&(this._start=this.positionAtAngle(this._startAngle)),this._start}get start(){return this.getStart()}getEnd(){return this._end===null&&(this._end=this.positionAtAngle(this._endAngle)),this._end}get end(){return this.getEnd()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAtAngle(this._startAngle)),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAtAngle(this._endAngle)),this._endTangent}get endTangent(){return this.getEndTangent()}getActualEndAngle(){return this._actualEndAngle===null&&(this._actualEndAngle=D.computeActualEndAngle(this._startAngle,this._endAngle,this._anticlockwise)),this._actualEndAngle}get actualEndAngle(){return this.getActualEndAngle()}getIsFullPerimeter(){return this._isFullPerimeter===null&&(this._isFullPerimeter=!this._anticlockwise&&this._endAngle-this._startAngle>=Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>=Math.PI*2),this._isFullPerimeter}get isFullPerimeter(){return this.getIsFullPerimeter()}getAngleDifference(){return this._angleDifference===null&&(this._angleDifference=this._anticlockwise?this._startAngle-this._endAngle:this._endAngle-this._startAngle,this._angleDifference<0&&(this._angleDifference+=Math.PI*2),assert&&assert(this._angleDifference>=0)),this._angleDifference}get angleDifference(){return this.getAngleDifference()}getUnitArcSegment(){return this._unitArcSegment===null&&(this._unitArcSegment=new D(E.ZERO,1,this._startAngle,this._endAngle,this._anticlockwise)),this._unitArcSegment}get unitArcSegment(){return this.getUnitArcSegment()}getBounds(){if(this._bounds===null&&(this._bounds=ut.NOTHING.withPoint(this.getStart()).withPoint(this.getEnd()),this._startAngle!==this._endAngle)){const t=Math.atan(-(this._radiusY/this._radiusX)*Math.tan(this._rotation)),e=Math.atan(this._radiusY/this._radiusX/Math.tan(this._rotation));this.possibleExtremaAngles=[t,t+Math.PI,e,e+Math.PI],_.each(this.possibleExtremaAngles,this.includeBoundsAtAngle.bind(this))}return this._bounds}get bounds(){return this.getBounds()}getNondegenerateSegments(){if(this._radiusX<=0||this._radiusY<=0||this._startAngle===this._endAngle)return[];if(this._radiusX===this._radiusY){const t=this._startAngle+this._rotation;let e=this._endAngle+this._rotation;return Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(e=this._anticlockwise?t-Math.PI*2:t+Math.PI*2),[new D(this._center,this._radiusX,t,e,this._anticlockwise)]}else return[this]}includeBoundsAtAngle(t){this.unitArcSegment.containsAngle(t)&&(this._bounds=this._bounds.withPoint(this.positionAtAngle(t)))}mapAngle(t){return Math.abs(O.moduloBetweenDown(t-this._startAngle,-Math.PI,Math.PI))<1e-8?this._startAngle:Math.abs(O.moduloBetweenDown(t-this.getActualEndAngle(),-Math.PI,Math.PI))<1e-8?this.getActualEndAngle():this._startAngle>this.getActualEndAngle()?O.moduloBetweenUp(t,this._startAngle-2*Math.PI,this._startAngle):O.moduloBetweenDown(t,this._startAngle,this._startAngle+2*Math.PI)}tAtAngle(t){return(this.mapAngle(t)-this._startAngle)/(this.getActualEndAngle()-this._startAngle)}angleAt(t){return this._startAngle+(this.getActualEndAngle()-this._startAngle)*t}positionAtAngle(t){return this.getUnitTransform().transformPosition2(E.createPolar(1,t))}tangentAtAngle(t){const e=this.getUnitTransform().transformNormal2(E.createPolar(1,t));return this._anticlockwise?e.perpendicular:e.perpendicular.negated()}offsetTo(t,e){const n=[],r=[];for(let a=0;a<32;a++){let l=a/31;e&&(l=1-l);const o=this.angleAt(l);n.push(this.positionAtAngle(o).plus(this.tangentAtAngle(o).perpendicular.normalized().times(t))),a>0&&r.push(new F(n[a-1],n[a]))}return r}getSVGPathFragment(){let t;if(assert&&(t=this._svgPathFragment,this._svgPathFragment=null),!this._svgPathFragment){const s=this._anticlockwise?"0":"1";let n;const r=Os(this._rotation);if(this.getAngleDifference()<Math.PI*2-.01)n=this.getAngleDifference()<Math.PI?"0":"1",this._svgPathFragment=`A ${H(this._radiusX)} ${H(this._radiusY)} ${r} ${n} ${s} ${H(this.getEnd().x)} ${H(this.getEnd().y)}`;else{const a=(this._startAngle+this._endAngle)/2,l=this.positionAtAngle(a);n="0";const o=`A ${H(this._radiusX)} ${H(this._radiusY)} ${r} ${n} ${s} ${H(l.x)} ${H(l.y)}`,h=`A ${H(this._radiusX)} ${H(this._radiusY)} ${r} ${n} ${s} ${H(this.getEnd().x)} ${H(this.getEnd().y)}`;this._svgPathFragment=`${o} ${h}`}}return assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=[];return _.each(this.possibleExtremaAngles,e=>{if(this.unitArcSegment.containsAngle(e)){const s=this.tAtAngle(e),n=1e-10;s>n&&s<1-n&&t.push(s)}}),t.sort()}intersection(t){const e=this.getUnitTransform(),s=e.inverseRay2(t),n=this.getUnitArcSegment().intersection(s);return _.map(n,r=>{const a=e.transformPosition2(r.point),l=t.position.distance(a),o=e.inverseNormal2(r.normal);return new zt(l,a,o,r.wind,r.t)})}windingIntersection(t){const e=this.getUnitTransform().inverseRay2(t);return this.getUnitArcSegment().windingIntersection(e)}writeToContext(t){t.ellipse?t.ellipse(this._center.x,this._center.y,this._radiusX,this._radiusY,this._rotation,this._startAngle,this._endAngle,this._anticlockwise):(this.getUnitTransform().getMatrix().canvasAppendTransform(t),t.arc(0,0,1,this._startAngle,this._endAngle,this._anticlockwise),this.getUnitTransform().getInverse().canvasAppendTransform(t))}transformed(t){const e=t.timesVector2(E.createPolar(this._radiusX,this._rotation)).minus(t.timesVector2(E.ZERO)),s=t.timesVector2(E.createPolar(this._radiusY,this._rotation+Math.PI/2)).minus(t.timesVector2(E.ZERO)),n=e.angle,r=e.magnitude,a=s.magnitude,l=t.getDeterminant()<0,o=l?!this._anticlockwise:this._anticlockwise,h=l?-this._startAngle:this._startAngle;let d=l?-this._endAngle:this._endAngle;return Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(d=o?h-Math.PI*2:h+Math.PI*2),new lt(t.timesVector2(this._center),r,a,n,h,d,o)}getSignedAreaFragment(){const t=this._startAngle,e=this.getActualEndAngle(),s=Math.sin(t),n=Math.sin(e),r=Math.cos(t),a=Math.cos(e);return .5*(this._radiusX*this._radiusY*(e-t)+Math.cos(this._rotation)*(this._radiusX*this._center.y*(r-a)+this._radiusY*this._center.x*(n-s))+Math.sin(this._rotation)*(this._radiusX*this._center.x*(a-r)+this._radiusY*this._center.y*(n-s)))}reversed(){return new lt(this._center,this._radiusX,this._radiusY,this._rotation,this._endAngle,this._startAngle,!this._anticlockwise)}serialize(){return{type:"EllipticalArc",centerX:this._center.x,centerY:this._center.y,radiusX:this._radiusX,radiusY:this._radiusY,rotation:this._rotation,startAngle:this._startAngle,endAngle:this._endAngle,anticlockwise:this._anticlockwise}}getOverlaps(t,e=1e-6){return t instanceof lt?lt.getOverlaps(this,t):null}getConicMatrix(){const e=lt.computeUnitMatrix(this._center,this._radiusX,this._radiusY,this._rotation).inverted();return e.transposed().multiplyMatrix(ks).multiplyMatrix(e)}static deserialize(t){return assert&&assert(t.type==="EllipticalArc"),new lt(new E(t.centerX,t.centerY),t.radiusX,t.radiusY,t.rotation,t.startAngle,t.endAngle,t.anticlockwise)}static getOverlapType(t,e,s=1e-4){if(t._center.distance(e._center)<s){const n=Math.abs(t._radiusX-e._radiusX)<s&&Math.abs(t._radiusY-e._radiusY)<s,r=Math.abs(t._radiusX-e._radiusY)<s&&Math.abs(t._radiusY-e._radiusX)<s;if(n&&Math.abs(O.moduloBetweenDown(t._rotation-e._rotation+Math.PI/2,0,Math.PI)-Math.PI/2)<s)return Wt.MATCHING_OVERLAP;if(r&&Math.abs(O.moduloBetweenDown(t._rotation-e._rotation,0,Math.PI)-Math.PI/2)<s)return Wt.OPPOSITE_OVERLAP}return Wt.NONE}static getOverlaps(t,e){return lt.getOverlapType(t,e)===Wt.NONE?[]:D.getAngularOverlaps(t._startAngle+t._rotation,t.getActualEndAngle()+t._rotation,e._startAngle+e._rotation,e.getActualEndAngle()+e._rotation)}static intersect(t,e,s=1e-10){if(lt.getOverlapType(t,e,s)===Wt.NONE)return Kt.intersect(t,e);{const r=[],a=t.positionAt(0),l=t.positionAt(1),o=e.positionAt(0),h=e.positionAt(1);return a.equalsEpsilon(o,s)&&r.push(new vt(a.average(o),0,0)),a.equalsEpsilon(h,s)&&r.push(new vt(a.average(h),0,1)),l.equalsEpsilon(o,s)&&r.push(new vt(l.average(o),1,0)),l.equalsEpsilon(h,s)&&r.push(new vt(l.average(h),1,1)),r}}static computeUnitMatrix(t,e,s,n){return Bt.translationFromVector(t).timesMatrix(Bt.rotation2(n)).timesMatrix(Bt.scaling(e,s))}static computeUnitTransform(t,e,s,n){return new Qe(lt.computeUnitMatrix(t,e,s,n))}}const $t=class $t extends ds{};$t.MATCHING_OVERLAP=new $t,$t.OPPOSITE_OVERLAP=new $t,$t.NONE=new $t,$t.enumeration=new gs($t);let Wt=$t;Q.register("EllipticalArc",lt);class bt{constructor(t,e,s){if(this.segments=[],this.invalidatedEmitter=new Fe,this._bounds=null,this._strokedSubpaths=null,this._strokedSubpathsComputed=!1,this._strokedStyles=null,this._invalidatingPoints=!1,this.points=e||(t&&t.length?_.map(t,n=>n.start).concat(t[t.length-1].end):[]),this.closed=!!s,this._invalidateListener=this.invalidate.bind(this),t)for(let n=0;n<t.length;n++)_.each(t[n].getNondegenerateSegments(),r=>{this.addSegmentDirectly(r)})}getBounds(){if(this._bounds===null){const t=ut.NOTHING.copy();_.each(this.segments,e=>{t.includeBounds(e.getBounds())}),this._bounds=t}return this._bounds}get bounds(){return this.getBounds()}getArcLength(t,e,s){let n=0;for(let r=0;r<this.segments.length;r++)n+=this.segments[r].getArcLength(t,e,s);return n}copy(){return new bt(this.segments.slice(0),this.points.slice(0),this.closed)}invalidatePoints(){this._invalidatingPoints=!0;const t=this.segments.length;for(let e=0;e<t;e++)this.segments[e].invalidate();this._invalidatingPoints=!1,this.invalidate()}invalidate(){this._invalidatingPoints||(this._bounds=null,this._strokedSubpathsComputed=!1,this.invalidatedEmitter.emit())}addPoint(t){return this.points.push(t),this}addSegmentDirectly(t){return assert&&assert(t.start.isFinite(),"Segment start is infinite"),assert&&assert(t.end.isFinite(),"Segment end is infinite"),assert&&assert(t.startTangent.isFinite(),"Segment startTangent is infinite"),assert&&assert(t.endTangent.isFinite(),"Segment endTangent is infinite"),assert&&assert(t.bounds.isEmpty()||t.bounds.isFinite(),"Segment bounds is infinite and non-empty"),this.segments.push(t),t.invalidationEmitter.addListener(this._invalidateListener),this}addSegment(t){const s=t.getNondegenerateSegments().length;for(let n=0;n<s;n++)this.addSegmentDirectly(t);return this.invalidate(),this}addClosingSegment(){if(this.hasClosingSegment()){const t=this.getClosingSegment();this.addSegmentDirectly(t),this.invalidate(),this.addPoint(this.getFirstPoint()),this.closed=!0}}close(){this.closed=!0,this.addClosingSegment()}getLength(){return this.points.length}getFirstPoint(){return assert&&assert(this.points.length),_.first(this.points)}getLastPoint(){return assert&&assert(this.points.length),_.last(this.points)}getFirstSegment(){return assert&&assert(this.segments.length),_.first(this.segments)}getLastSegment(){return assert&&assert(this.segments.length),_.last(this.segments)}getFillSegments(){const t=this.segments.slice();return this.hasClosingSegment()&&t.push(this.getClosingSegment()),t}isDrawable(){return this.segments.length>0}isClosed(){return this.closed}hasClosingSegment(){return!this.getFirstPoint().equalsEpsilon(this.getLastPoint(),1e-9)}getClosingSegment(){return assert&&assert(this.hasClosingSegment(),"Implicit closing segment unnecessary on a fully closed path"),new F(this.getLastPoint(),this.getFirstPoint())}getClosestPoints(t){return rt.filterClosestToPointResult(_.flatten(this.segments.map(e=>e.getClosestPoints(t))))}writeToContext(t){if(this.isDrawable()){const e=this.getFirstSegment().start;t.moveTo(e.x,e.y);let s=this.segments.length;this.closed&&s>=2&&this.segments[s-1]instanceof F&&s--;for(let n=0;n<s;n++)this.segments[n].writeToContext(t);this.closed&&t.closePath()}}toPiecewiseLinear(t){return assert&&assert(!t.pointMap,"For use with pointMap, please use nonlinearTransformed"),new bt(_.flatten(_.map(this.segments,e=>e.toPiecewiseLinearSegments(t))),void 0,this.closed)}transformed(t){return new bt(_.map(this.segments,e=>e.transformed(t)),_.map(this.points,e=>t.timesVector2(e)),this.closed)}nonlinearTransformed(t){return new bt(_.flatten(_.map(this.segments,e=>t.methodName&&e[t.methodName]?e[t.methodName](t):e.toPiecewiseLinearSegments(t))),void 0,this.closed)}getBoundsWithTransform(t){const e=ut.NOTHING.copy(),s=this.segments.length;for(let n=0;n<s;n++)e.includeBounds(this.segments[n].getBoundsWithTransform(t));return e}offset(t){if(!this.isDrawable())return new bt([],void 0,this.closed);if(t===0)return new bt(this.segments.slice(),void 0,this.closed);let e;const s=this.segments.slice(),n=[];for(e=0;e<s.length;e++)n.push(s[e].strokeLeft(2*t));let r=[];for(e=0;e<s.length;e++){if(this.closed||e>0){const a=(e>0?e:s.length)-1,l=s[e].start,o=s[a].endTangent,h=s[e].startTangent,d=o.perpendicular.negated().times(t).angle,p=h.perpendicular.negated().times(t).angle,A=o.perpendicular.dot(h)>0;r.push(new D(l,Math.abs(t),d,p,A))}r=r.concat(n[e])}return new bt(r,void 0,this.closed)}stroked(t){if(!this.isDrawable())return[];if(t===void 0&&(t=new ve),assert&&assert(!this._strokedSubpathsComputed||this._strokedStyles&&this._strokedSubpaths),this._strokedSubpathsComputed&&this._strokedStyles.equals(t))return this._strokedSubpaths;const e=t.lineWidth;let s,n=[],r=[];const a=this.getFirstSegment(),l=this.getLastSegment(),o=b=>{n=n.concat(b)},h=b=>{r=r.concat(b)},d=l.end.equals(a.start),p=d?null:new F(this.segments[this.segments.length-1].end,this.segments[0].start);for(s=0;s<this.segments.length;s++)s>0&&o(t.leftJoin(this.segments[s].start,this.segments[s-1].endTangent,this.segments[s].startTangent)),o(this.segments[s].strokeLeft(e));for(s=this.segments.length-1;s>=0;s--)s<this.segments.length-1&&h(t.rightJoin(this.segments[s].end,this.segments[s].endTangent,this.segments[s+1].startTangent)),h(this.segments[s].strokeRight(e));let A;return this.closed?(d?(o(t.leftJoin(l.end,l.endTangent,a.startTangent)),h(t.rightJoin(l.end,l.endTangent,a.startTangent))):(o(t.leftJoin(p.start,l.endTangent,p.startTangent)),o(p.strokeLeft(e)),o(t.leftJoin(p.end,p.endTangent,a.startTangent)),h(t.rightJoin(p.end,p.endTangent,a.startTangent)),h(p.strokeRight(e)),h(t.rightJoin(p.start,l.endTangent,p.startTangent))),A=[new bt(n,void 0,!0),new bt(r,void 0,!0)]):A=[new bt(n.concat(t.cap(l.end,l.endTangent)).concat(r).concat(t.cap(a.start,a.startTangent.negated())),void 0,!0)],this._strokedSubpaths=A,this._strokedSubpathsComputed=!0,this._strokedStyles=t.copy(),A}dashed(t,e,s,n){const r=(o,h)=>{const d=o[o.length-1].concat(h[0]),p=o.slice(0,o.length-1).concat([d]).concat(h.slice(1));return assert&&assert(p.length===o.length+h.length-1),p},a=(o,h)=>{if(!o.hasRightFilled||!h.hasLeftFilled)return!1;const d=_.last(_.last(o.segmentArrays)),p=h.segmentArrays[0][0];return d.end.distance(p.start)<1e-5},l=[];for(let o=0;o<this.segments.length;o++){const h=this.segments[o],d=h.getDashValues(t,e,s,n);l.push(d),e+=d.arcLength;const p=[0].concat(d.values).concat([1]),A=d.initiallyInside;d.hasLeftFilled=A,d.hasRightFilled=p.length%2===0?A:!A,d.segmentArrays=[];for(let b=A?0:1;b<p.length-1;b+=2)p[b]!==p[b+1]&&d.segmentArrays.push([h.slice(p[b],p[b+1])])}for(let o=l.length-1;o>=1;o--){const h=l[o-1],d=l[o];a(h,d)&&l.splice(o-1,2,{segmentArrays:r(h.segmentArrays,d.segmentArrays),hasLeftFilled:h.hasLeftFilled,hasRightFilled:d.hasRightFilled})}if(l.length>1&&a(l[l.length-1],l[0])){const o=l.pop(),h=l.shift();l.push({segmentArrays:r(o.segmentArrays,h.segmentArrays),hasLeftFilled:o.hasLeftFilled,hasRightFilled:h.hasRightFilled})}return this.closed&&l.length===1&&l[0].segmentArrays.length===1&&l[0].hasLeftFilled&&l[0].hasRightFilled?[new bt(l[0].segmentArrays[0],void 0,!0)]:_.flatten(l.map(o=>o.segmentArrays)).map(o=>new bt(o))}serialize(){return{type:"Subpath",segments:this.segments.map(t=>t.serialize()),points:this.points.map(t=>({x:t.x,y:t.y})),closed:this.closed}}static deserialize(t){return assert&&assert(t.type==="Subpath"),new bt(t.segments.map(rt.deserialize),t.points.map(e=>new E(e.x,e.y)),t.closed)}}Q.register("Subpath",bt);const yt=bt,ge=Math.random,K=(u,t)=>new E(u,t),ze=(u,t,e,s)=>e.copy().subtract(u).multiplyScalar((1-s)/6).add(t),j=class j{constructor(t,e){if(this.subpaths=[],this._invalidatingPoints=!1,this._immutable=!1,this.invalidatedEmitter=new Fe,this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=null,this._bounds=e?e.copy():null,this.resetControlPoints(),this._invalidateListener=this.invalidate.bind(this),typeof t=="object")for(let s=0;s<t.length;s++)this.addSubpath(t[s]);t&&typeof t!="object"&&_.each(Fs.parse(t),s=>{assert&&assert(j.prototype[s.cmd]!==void 0,`method ${s.cmd} from parsed SVG does not exist`),this[s.cmd].apply(this,s.args)}),this.invalidate()}resetControlPoints(){this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=null}setQuadraticControlPoint(t){this.lastQuadraticControlPoint=t,this.lastCubicControlPoint=null}setCubicControlPoint(t){this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=t}moveTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.moveToPoint(K(t,e))}moveToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.moveToPointRelative(K(t,e))}moveToPointRelative(t){return this.moveToPoint(this.getRelativePoint().plus(t))}moveToPoint(t){return this.addSubpath(new yt().addPoint(t)),this.resetControlPoints(),this}lineTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.lineToPoint(K(t,e))}lineToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.lineToPointRelative(K(t,e))}lineToPointRelative(t){return this.lineToPoint(this.getRelativePoint().plus(t))}lineToPoint(t){if(this.hasSubpaths()){const e=this.getLastSubpath().getLastPoint(),s=t,n=new F(e,s);this.getLastSubpath().addPoint(s),this.addSegmentAndBounds(n)}else this.ensure(t);return this.resetControlPoints(),this}horizontalLineTo(t){return this.lineTo(t,this.getRelativePoint().y)}horizontalLineToRelative(t){return this.lineToRelative(t,0)}verticalLineTo(t){return this.lineTo(this.getRelativePoint().x,t)}verticalLineToRelative(t){return this.lineToRelative(0,t)}zigZagTo(t,e,s,n,r){return this.zigZagToPoint(new E(t,e),s,n,r)}zigZagToPoint(t,e,s,n){assert&&assert(Number.isInteger(s),`numberZigZags must be an integer: ${s}`),this.ensure(t);const r=this.getLastPoint(),a=t.minus(r),l=a.normalized(),o=l.perpendicular.times(e);let h;n?h=a.magnitude/(s+.5):h=a.magnitude/s;for(let d=0;d<s;d++){const p=l.times(d*h).plus(r),A=p.plus(l.times(h/4)).plus(o),b=p.plus(l.times(3*h/4)).minus(o);this.lineToPoint(A),this.lineToPoint(b)}if(n){const p=l.times(s*h).plus(r).plus(l.times(h/4)).plus(o);this.lineToPoint(p)}return this.lineToPoint(t)}quadraticCurveTo(t,e,s,n){return assert&&assert(isFinite(t),`cpx must be a finite number: ${t}`),assert&&assert(isFinite(e),`cpy must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(n),`y must be a finite number: ${n}`),this.quadraticCurveToPoint(K(t,e),K(s,n))}quadraticCurveToRelative(t,e,s,n){return assert&&assert(isFinite(t),`cpx must be a finite number: ${t}`),assert&&assert(isFinite(e),`cpy must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(n),`y must be a finite number: ${n}`),this.quadraticCurveToPointRelative(K(t,e),K(s,n))}quadraticCurveToPointRelative(t,e){const s=this.getRelativePoint();return this.quadraticCurveToPoint(s.plus(t),s.plus(e))}smoothQuadraticCurveTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.quadraticCurveToPoint(this.getSmoothQuadraticControlPoint(),K(t,e))}smoothQuadraticCurveToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.quadraticCurveToPoint(this.getSmoothQuadraticControlPoint(),K(t,e).plus(this.getRelativePoint()))}quadraticCurveToPoint(t,e){this.ensure(t);const s=this.getLastSubpath().getLastPoint(),n=new nt(s,t,e);this.getLastSubpath().addPoint(e);const r=n.getNondegenerateSegments();return _.each(r,a=>{this.addSegmentAndBounds(a)}),this.setQuadraticControlPoint(t),this}cubicCurveTo(t,e,s,n,r,a){return assert&&assert(isFinite(t),`cp1x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp1y must be a finite number: ${e}`),assert&&assert(isFinite(s),`cp2x must be a finite number: ${s}`),assert&&assert(isFinite(n),`cp2y must be a finite number: ${n}`),assert&&assert(isFinite(r),`x must be a finite number: ${r}`),assert&&assert(isFinite(a),`y must be a finite number: ${a}`),this.cubicCurveToPoint(K(t,e),K(s,n),K(r,a))}cubicCurveToRelative(t,e,s,n,r,a){return assert&&assert(isFinite(t),`cp1x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp1y must be a finite number: ${e}`),assert&&assert(isFinite(s),`cp2x must be a finite number: ${s}`),assert&&assert(isFinite(n),`cp2y must be a finite number: ${n}`),assert&&assert(isFinite(r),`x must be a finite number: ${r}`),assert&&assert(isFinite(a),`y must be a finite number: ${a}`),this.cubicCurveToPointRelative(K(t,e),K(s,n),K(r,a))}cubicCurveToPointRelative(t,e,s){const n=this.getRelativePoint();return this.cubicCurveToPoint(n.plus(t),n.plus(e),n.plus(s))}smoothCubicCurveTo(t,e,s,n){return assert&&assert(isFinite(t),`cp2x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp2y must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(n),`y must be a finite number: ${n}`),this.cubicCurveToPoint(this.getSmoothCubicControlPoint(),K(t,e),K(s,n))}smoothCubicCurveToRelative(t,e,s,n){return assert&&assert(isFinite(t),`cp2x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp2y must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(n),`y must be a finite number: ${n}`),this.cubicCurveToPoint(this.getSmoothCubicControlPoint(),K(t,e).plus(this.getRelativePoint()),K(s,n).plus(this.getRelativePoint()))}cubicCurveToPoint(t,e,s){this.ensure(t);const n=this.getLastSubpath().getLastPoint(),a=new ht(n,t,e,s).getNondegenerateSegments();return _.each(a,l=>{this.addSegmentAndBounds(l)}),this.getLastSubpath().addPoint(s),this.setCubicControlPoint(e),this}arc(t,e,s,n,r,a){return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.arcPoint(K(t,e),s,n,r,a)}arcPoint(t,e,s,n,r){r===void 0&&(r=!1);const a=new D(t,e,s,n,r),l=a.getStart(),o=a.getEnd();return this.hasSubpaths()&&this.getLastSubpath().getLength()>0&&!l.equals(this.getLastSubpath().getLastPoint())&&this.addSegmentAndBounds(new F(this.getLastSubpath().getLastPoint(),l)),this.hasSubpaths()||this.addSubpath(new yt),this.getLastSubpath().addPoint(l),this.getLastSubpath().addPoint(o),this.addSegmentAndBounds(a),this.resetControlPoints(),this}ellipticalArc(t,e,s,n,r,a,l,o){return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.ellipticalArcPoint(K(t,e),s,n,r,a,l,o)}ellipticalArcPoint(t,e,s,n,r,a,l){l===void 0&&(l=!1);const o=new lt(t,e,s,n,r,a,l),h=o.start,d=o.end;return this.hasSubpaths()&&this.getLastSubpath().getLength()>0&&!h.equals(this.getLastSubpath().getLastPoint())&&this.addSegmentAndBounds(new F(this.getLastSubpath().getLastPoint(),h)),this.hasSubpaths()||this.addSubpath(new yt),this.getLastSubpath().addPoint(h),this.getLastSubpath().addPoint(d),this.addSegmentAndBounds(o),this.resetControlPoints(),this}close(){if(this.hasSubpaths()){const t=this.getLastSubpath(),e=new yt;t.close(),this.addSubpath(e),e.addPoint(t.getFirstPoint())}return this.resetControlPoints(),this}newSubpath(){return this.addSubpath(new yt),this.resetControlPoints(),this}makeImmutable(){return this._immutable=!0,this.notifyInvalidationListeners(),this}isImmutable(){return this._immutable}ellipticalArcToRelative(t,e,s,n,r,a,l){const o=this.getRelativePoint();return this.ellipticalArcTo(t,e,s,n,r,a+o.x,l+o.y)}ellipticalArcTo(t,e,s,n,r,a,l){const o=new E(a,l);this.ensure(o);const h=this.getLastSubpath().getLastPoint();this.getLastSubpath().addPoint(o),t<0&&(t*=-1),e<0&&(e*=-1);let d=t*t,p=e*e;const A=h.minus(o).dividedScalar(2).rotated(-s),b=A.x*A.x,S=A.y*A.y;let P=new E(t*A.y/e,-e*A.x/t);const w=b/d+S/p;w>1&&(t*=Math.sqrt(w),e*=Math.sqrt(w),d=t*t,p=e*e,P=new E(t*A.y/e,-e*A.x/t)),P.multiplyScalar(Math.sqrt(Math.max(0,(d*p-d*S-p*b)/(d*S+p*b)))),n===r&&P.multiplyScalar(-1);const x=h.blend(o,.5).plus(P.rotated(s)),v=(k,q)=>(k.x*q.y-k.y*q.x>0?1:-1)*k.angleBetween(q),T=new E((A.x-P.x)/t,(A.y-P.y)/e),M=new E((-A.x-P.x)/t,(-A.y-P.y)/e),$=v(E.X_UNIT,T);let B=v(T,M)%(Math.PI*2);!r&&B>0&&(B-=Math.PI*2),r&&B<0&&(B+=Math.PI*2);const W=new lt(x,t,e,s,$,$+B,!r).getNondegenerateSegments();return _.each(W,k=>{this.addSegmentAndBounds(k)}),this}circle(t,e,s){if(typeof t=="object"){const n=t;return s=e,this.arcPoint(n,s,0,Math.PI*2,!1).close()}else return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.arcPoint(K(t,e),s,0,Math.PI*2,!1).close()}ellipse(t,e,s,n,r){if(typeof t=="object"){const a=t;return r=n,n=s,s=e,this.ellipticalArcPoint(a,s,n,r||0,0,Math.PI*2,!1).close()}else return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.ellipticalArcPoint(K(t,e),s,n,r||0,0,Math.PI*2,!1).close()}rect(t,e,s,n){assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),assert&&assert(isFinite(s),`width must be a finite number: ${s}`),assert&&assert(isFinite(n),`height must be a finite number: ${n}`);const r=new yt;return this.addSubpath(r),r.addPoint(K(t,e)),r.addPoint(K(t+s,e)),r.addPoint(K(t+s,e+n)),r.addPoint(K(t,e+n)),this.addSegmentAndBounds(new F(r.points[0],r.points[1])),this.addSegmentAndBounds(new F(r.points[1],r.points[2])),this.addSegmentAndBounds(new F(r.points[2],r.points[3])),r.close(),this.addSubpath(new yt),this.getLastSubpath().addPoint(K(t,e)),assert&&assert(!isNaN(this.bounds.getX())),this.resetControlPoints(),this}roundRect(t,e,s,n,r,a){const l=t+r,o=t+s-r,h=e+a,d=e+n-a;return r===a?this.arc(o,h,r,-Math.PI/2,0,!1).arc(o,d,r,0,Math.PI/2,!1).arc(l,d,r,Math.PI/2,Math.PI,!1).arc(l,h,r,Math.PI,Math.PI*3/2,!1).close():this.ellipticalArc(o,h,r,a,0,-Math.PI/2,0,!1).ellipticalArc(o,d,r,a,0,0,Math.PI/2,!1).ellipticalArc(l,d,r,a,0,Math.PI/2,Math.PI,!1).ellipticalArc(l,h,r,a,0,Math.PI,Math.PI*3/2,!1).close(),this}polygon(t){const e=t.length;if(e>0){this.moveToPoint(t[0]);for(let s=1;s<e;s++)this.lineToPoint(t[s])}return this.close()}cardinalSpline(t,e){const s=Ee()({tension:0,isClosedLineSegments:!1},e);assert&&assert(s.tension<1&&s.tension>-1," the tension goes from -1 to 1 ");const n=t.length,r=s.isClosedLineSegments?n:n-1;for(let a=0;a<r;a++){let l;a===0&&!s.isClosedLineSegments?l=[t[0],t[0],t[1],t[2]]:a===r-1&&!s.isClosedLineSegments?l=[t[a-1],t[a],t[a+1],t[a+1]]:l=[t[(a-1+n)%n],t[a%n],t[(a+1)%n],t[(a+2)%n]];const o=[l[1],ze(l[0],l[1],l[2],s.tension),ze(l[3],l[2],l[1],s.tension),l[2]];a===0&&(this.ensure(o[0]),this.getLastSubpath().addPoint(o[0])),this.cubicCurveToPoint(o[1],o[2],o[3])}return this}copy(){return new j(_.map(this.subpaths,t=>t.copy()),this.bounds)}writeToContext(t){const e=this.subpaths.length;for(let s=0;s<e;s++)this.subpaths[s].writeToContext(t)}getSVGPath(){let t="";const e=this.subpaths.length;for(let s=0;s<e;s++){const n=this.subpaths[s];if(n.isDrawable()){const r=n.segments[0].start;t+=`M ${H(r.x)} ${H(r.y)} `;for(let a=0;a<n.segments.length;a++)t+=`${n.segments[a].getSVGPathFragment()} `;n.isClosed()&&(t+="Z ")}}return t}getSVGPathWithSafariWorkaround(){let t="";const e=this.subpaths.length;for(let s=0;s<e;s++){const n=this.subpaths[s];if(n.isDrawable()){const r=n.segments[0].start;t+=`M ${H(r.x)} ${H(r.y)} `;for(let a=0;a<n.segments.length;a++){const l=n.segments[a];if(l instanceof nt){const o=l.start,h=l.control,d=l.end,p=(o.x+h.x)/2,A=(o.y+h.y)/2,b=(h.x+d.x)/2,S=(h.y+d.y)/2,P=(p+b)/2,w=(A+S)/2;t+=`Q ${H(p)} ${H(A)} ${H(P)} ${H(w)} `,t+=`Q ${H(b)} ${H(S)} ${H(d.x)} ${H(d.y)} `}else t+=`${n.segments[a].getSVGPathFragment()} `}n.isClosed()&&(t+="Z ")}}return t}transformed(t){const e=_.map(this.subpaths,n=>n.transformed(t)),s=_.reduce(e,(n,r)=>n.union(r.bounds),ut.NOTHING);return new j(e,s)}nonlinearTransformed(t){const e=He({minLevels:0,maxLevels:7,distanceEpsilon:.16,curveEpsilon:t&&t.includeCurvature?.002:null},t),s=_.map(this.subpaths,r=>r.nonlinearTransformed(e)),n=_.reduce(s,(r,a)=>r.union(a.bounds),ut.NOTHING);return new j(s,n)}polarToCartesian(t){return this.nonlinearTransformed(He({pointMap:e=>E.createPolar(e.y,e.x),methodName:"polarToCartesian"},t))}toPiecewiseLinear(t){return assert&&assert(!t||!t.pointMap,"No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments"),assert&&assert(!t||!t.methodName,"No methodName for toPiecewiseLinear allowed, since it could create non-linear segments"),this.nonlinearTransformed(t)}containsPoint(t){const e=E.X_UNIT.copy();let s=0;for(;s<5&&(s++,_.some(this.subpaths,r=>_.some(r.segments,a=>{const l=a.start.minus(t),o=l.magnitude;return o!==0?(l.divideScalar(o),l.subtract(e),l.magnitudeSquared<1e-9):!1})));)e.rotate(fs.nextDouble());return this.windingIntersection(new qt(t,e))!==0}intersection(t){let e=[];const s=this.subpaths.length;for(let n=0;n<s;n++){const r=this.subpaths[n];if(r.isDrawable()){const a=r.segments.length;for(let l=0;l<a;l++){const o=r.segments[l];e=e.concat(o.intersection(t))}r.hasClosingSegment()&&(e=e.concat(r.getClosingSegment().intersection(t)))}}return _.sortBy(e,n=>n.distance)}interiorIntersectsLineSegment(t,e){const s=t.blend(e,.5);if(this.containsPoint(s))return!0;const n=e.minus(t),r=n.magnitude;if(r===0)return!1;n.normalize();const a=this.intersection(new qt(t,n));for(let l=0;l<a.length;l++)if(a[l].distance<=r)return!0;return!1}windingIntersection(t){let e=0;const s=this.subpaths.length;for(let n=0;n<s;n++){const r=this.subpaths[n];if(r.isDrawable()){const a=r.segments.length;for(let l=0;l<a;l++)e+=r.segments[l].windingIntersection(t);r.hasClosingSegment()&&(e+=r.getClosingSegment().windingIntersection(t))}}return e}intersectsBounds(t){if(this.bounds.intersection(t).equals(this.bounds))return!0;const e=new qt(new E(t.minX,t.minY),new E(1,0)),s=new qt(new E(t.minX,t.minY),new E(0,1)),n=new qt(new E(t.maxX,t.maxY),new E(-1,0)),r=new qt(new E(t.maxX,t.maxY),new E(0,-1));let a,l;const o=this.intersection(e).concat(this.intersection(n));for(l=0;l<o.length;l++)if(a=o[l].point,a.x>=t.minX&&a.x<=t.maxX)return!0;const h=this.intersection(s).concat(this.intersection(r));for(l=0;l<h.length;l++)if(a=h[l].point,a.y>=t.minY&&a.y<=t.maxY)return!0;return!1}getStrokedShape(t){let e=[];const s=ut.NOTHING.copy();let n=this.subpaths.length;for(let r=0;r<n;r++){const l=this.subpaths[r].stroked(t);e=e.concat(l)}n=e.length;for(let r=0;r<n;r++)s.includeBounds(e[r].bounds);return new j(e,s)}getOffsetShape(t){const e=[],s=ut.NOTHING.copy();let n=this.subpaths.length;for(let r=0;r<n;r++)e.push(this.subpaths[r].offset(t));n=e.length;for(let r=0;r<n;r++)s.includeBounds(e[r].bounds);return new j(e,s)}getDashedShape(t,e,s){const n=Ee()({distanceEpsilon:1e-10,curveEpsilon:1e-8},s);return new j(_.flatten(this.subpaths.map(r=>r.dashed(t,e,n.distanceEpsilon,n.curveEpsilon))))}getBounds(){if(this._bounds===null){const t=ut.NOTHING.copy();_.each(this.subpaths,e=>{t.includeBounds(e.getBounds())}),this._bounds=t}return this._bounds}get bounds(){return this.getBounds()}getStrokedBounds(t){let e=!0;for(let s=0;s<this.subpaths.length;s++){const n=this.subpaths[s];if(n.isDrawable()&&!n.isClosed()){e=!1;break}for(let r=0;r<n.segments.length;r++)if(!n.segments[r].areStrokedBoundsDilated()){e=!1;break}}if(e)return this.bounds.dilated(t.lineWidth/2);{const s=this.bounds.copy();for(let n=0;n<this.subpaths.length;n++){const r=this.subpaths[n].stroked(t);for(let a=0;a<r.length;a++)s.includeBounds(r[a].bounds)}return s}}getSimplifiedAreaShape(){return Ct.simplifyNonZero(this)}getBoundsWithTransform(t,e){const s=ut.NOTHING.copy(),n=this.subpaths.length;for(let r=0;r<n;r++){const a=this.subpaths[r];s.includeBounds(a.getBoundsWithTransform(t))}return e&&s.includeBounds(this.getStrokedShape(e).getBoundsWithTransform(t)),s}getApproximateArea(t){const e=this.bounds.minX,s=this.bounds.minY,n=this.bounds.width,r=this.bounds.height,a=n*r;let l=0;const o=new E(0,0);for(let h=0;h<t;h++)o.x=e+ge()*n,o.y=s+ge()*r,this.containsPoint(o)&&l++;return a*l/t}getNonoverlappingArea(){return Math.abs(_.sum(this.subpaths.map(t=>_.sum(t.getFillSegments().map(e=>e.getSignedAreaFragment())))))}getArea(){return this.getSimplifiedAreaShape().getNonoverlappingArea()}getApproximateCentroid(t){const e=this.bounds.minX,s=this.bounds.minY,n=this.bounds.width,r=this.bounds.height;let a=0;const l=new E(0,0),o=new E(0,0);for(let h=0;h<t;h++)o.x=e+ge()*n,o.y=s+ge()*r,this.containsPoint(o)&&(l.add(o),a++);return l.dividedScalar(a)}getClosestPoints(t){return rt.filterClosestToPointResult(_.flatten(this.subpaths.map(e=>e.getClosestPoints(t))))}getClosestPoint(t){return this.getClosestPoints(t)[0].closestPoint}invalidatePoints(){this._invalidatingPoints=!0;const t=this.subpaths.length;for(let e=0;e<t;e++)this.subpaths[e].invalidatePoints();this._invalidatingPoints=!1,this.invalidate()}toString(){return`new phet.kite.Shape( '${this.getSVGPath()}' )`}invalidate(){assert&&assert(!this._immutable,"Attempt to modify an immutable Shape"),this._invalidatingPoints||(this._bounds=null,this.notifyInvalidationListeners())}notifyInvalidationListeners(){this.invalidatedEmitter.emit()}addSegmentAndBounds(t){this.getLastSubpath().addSegment(t),this.invalidate()}ensure(t){this.hasSubpaths()||(this.addSubpath(new yt),this.getLastSubpath().addPoint(t))}addSubpath(t){return this.subpaths.push(t),t.invalidatedEmitter.addListener(this._invalidateListener),this.invalidate(),this}hasSubpaths(){return this.subpaths.length>0}getLastSubpath(){return assert&&assert(this.hasSubpaths(),"We should have a subpath if this is called"),_.last(this.subpaths)}getLastPoint(){return assert&&assert(this.hasSubpaths(),"We should have a subpath if this is called"),assert&&assert(this.getLastSubpath().getLastPoint(),"We should have a last point"),this.getLastSubpath().getLastPoint()}getLastSegment(){if(!this.hasSubpaths())return null;const t=this.getLastSubpath();return t.isDrawable()?t.getLastSegment():null}getSmoothQuadraticControlPoint(){const t=this.getLastPoint();return this.lastQuadraticControlPoint?t.plus(t.minus(this.lastQuadraticControlPoint)):t}getSmoothCubicControlPoint(){const t=this.getLastPoint();return this.lastCubicControlPoint?t.plus(t.minus(this.lastCubicControlPoint)):t}getRelativePoint(){let t=E.ZERO;if(this.hasSubpaths()){const e=this.getLastSubpath();e.points.length&&(t=e.getLastPoint())}return t}shapeUnion(t){return Ct.binaryResult(this,t,Ct.BINARY_NONZERO_UNION)}shapeIntersection(t){return Ct.binaryResult(this,t,Ct.BINARY_NONZERO_INTERSECTION)}shapeDifference(t){return Ct.binaryResult(this,t,Ct.BINARY_NONZERO_DIFFERENCE)}shapeXor(t){return Ct.binaryResult(this,t,Ct.BINARY_NONZERO_XOR)}shapeClip(t,e){return Ct.clipShape(t,this,e)}getArcLength(t,e,s){let n=0;for(let r=0;r<this.subpaths.length;r++)n+=this.subpaths[r].getArcLength(t,e,s);return n}serialize(){return{type:"Shape",subpaths:this.subpaths.map(t=>t.serialize())}}static deserialize(t){return assert&&assert(t.type==="Shape"),new j(t.subpaths.map(yt.deserialize))}static rectangle(t,e,s,n){return new j().rect(t,e,s,n)}static roundRect(t,e,s,n,r,a){return new j().roundRect(t,e,s,n,r,a)}static roundedRectangleWithRadii(t,e,s,n,r){let a=r&&r.topLeft||0,l=r&&r.topRight||0,o=r&&r.bottomLeft||0,h=r&&r.bottomRight||0;assert&&assert(isFinite(t),"Non-finite x"),assert&&assert(isFinite(e),"Non-finite y"),assert&&assert(s>=0&&isFinite(s),"Negative or non-finite width"),assert&&assert(n>=0&&isFinite(n),"Negative or non-finite height"),assert&&assert(a>=0&&isFinite(a),"Invalid topLeft"),assert&&assert(l>=0&&isFinite(l),"Invalid topRight"),assert&&assert(o>=0&&isFinite(o),"Invalid bottomLeft"),assert&&assert(h>=0&&isFinite(h),"Invalid bottomRight");const d=a+l;d>s&&d>0&&(a=a/d*s,l=l/d*s);const p=o+h;p>s&&p>0&&(o=o/p*s,h=h/p*s);const A=a+o;A>n&&A>0&&(a=a/A*n,o=o/A*n);const b=l+h;b>n&&b>0&&(l=l/b*n,h=h/b*n),assert&&assert(a+l<=s,"Corner overlap on top edge"),assert&&assert(o+h<=s,"Corner overlap on bottom edge"),assert&&assert(a+o<=n,"Corner overlap on left edge"),assert&&assert(l+h<=n,"Corner overlap on right edge");const S=new j,P=t+s,w=e+n;return h>0?S.arc(P-h,w-h,h,0,Math.PI/2,!1):S.moveTo(P,w),o>0?S.arc(t+o,w-o,o,Math.PI/2,Math.PI,!1):S.lineTo(t,w),a>0?S.arc(t+a,e+a,a,Math.PI,3*Math.PI/2,!1):S.lineTo(t,e),l>0?S.arc(P-l,e+l,l,3*Math.PI/2,2*Math.PI,!1):S.lineTo(P,e),S.close(),S}static boundsOffsetWithRadii(t,e,s){const n=t.withOffsets(e.left,e.top,e.right,e.bottom);return j.roundedRectangleWithRadii(n.minX,n.minY,n.width,n.height,s)}static polygon(t){return new j().polygon(t)}static bounds(t){return new j().rect(t.minX,t.minY,t.maxX-t.minX,t.maxY-t.minY)}static lineSegment(t,e,s,n){return typeof t=="number"?new j().moveTo(t,e).lineTo(s,n):new j().moveToPoint(t).lineToPoint(e)}static regularPolygon(t,e){const s=new j;return _.each(_.range(t),n=>{const r=E.createPolar(e,2*Math.PI*n/t);n===0?s.moveToPoint(r):s.lineToPoint(r)}),s.close()}static circle(t,e,s){return e===void 0?new j().circle(0,0,t):new j().circle(t,e,s)}static ellipse(t,e,s,n,r){return n===void 0?new j().ellipse(0,0,t,e,s):new j().ellipse(t,e,s,n,r)}static arc(t,e,s,n,r,a){return new j().arc(t,e,s,n,r,a)}static union(t){return Ct.unionNonZero(t)}static intersection(t){return Ct.intersectionNonZero(t)}static xor(t){return Ct.xorNonZero(t)}static segments(t,e){if(assert)for(let s=1;s<t.length;s++)assert(t[s-1].end.equalsEpsilon(t[s].start,1e-6),"Mismatched start/end");return new j([new yt(t,void 0,!!e)])}};j.rect=j.rectangle,j.roundRectangle=j.roundRect;let pe=j;Q.register("Shape",pe);const qs=pe;let Ds=0;const se=class se{constructor(t,e){this.id=++Ds,this.initialize(t,e)}initialize(t,e){return assert&&assert(t instanceof Q.Edge),assert&&assert(typeof e=="boolean"),this.edge=t,this.face=null,this.isReversed=e,this.signedAreaFragment=t.signedAreaFragment*(e?-1:1),this.startVertex=null,this.endVertex=null,this.sortVector=this.sortVector||new E(0,0),this.data=null,this.updateReferences(),this}serialize(){return{type:"HalfEdge",id:this.id,edge:this.edge.id,face:this.face===null?null:this.face.id,isReversed:this.isReversed,signedAreaFragment:this.signedAreaFragment,startVertex:this.startVertex===null?null:this.startVertex.id,endVertex:this.endVertex===null?null:this.endVertex.id,sortVector:E.Vector2IO.toStateObject(this.sortVector),data:this.data}}dispose(){this.edge=null,this.face=null,this.startVertex=null,this.endVertex=null,this.data=null,this.freeToPool()}getNext(t){for(let e=1;;e++){let s=this.endVertex.incidentHalfEdges.indexOf(this)-e;s<0&&(s+=this.endVertex.incidentHalfEdges.length);const n=this.endVertex.incidentHalfEdges[s].getReversed();if(!(t&&!t(n.edge)))return assert&&assert(this.endVertex===n.startVertex),n}}updateReferences(){this.startVertex=this.isReversed?this.edge.endVertex:this.edge.startVertex,this.endVertex=this.isReversed?this.edge.startVertex:this.edge.endVertex,assert&&assert(this.startVertex),assert&&assert(this.endVertex)}getEndTangent(){return this.isReversed?this.edge.segment.startTangent:this.edge.segment.endTangent.negated()}getEndCurvature(){return this.isReversed?-this.edge.segment.curvatureAt(0):this.edge.segment.curvatureAt(1)}getReversed(){return this.isReversed?this.edge.forwardHalf:this.edge.reversedHalf}getDirectionalSegment(){return this.isReversed?this.edge.segment.reversed():this.edge.segment}freeToPool(){se.pool.freeToPool(this)}};z(se,"pool",new Yt(se));let oe=se;Q.register("HalfEdge",oe);function _t(u){if(assert&&assert(!u||Array.isArray(u),"cleanArray either takes an Array"),u){for(;u.length;)u.pop();return u}else return[]}Z.register("cleanArray",_t);let zs=0;const Ut=class Ut{constructor(t){this.id=++zs,this.initialize(t)}initialize(t){return assert&&assert(t instanceof E),this.point=t,this.incidentHalfEdges=_t(this.incidentHalfEdges),this.visited=!1,this.visitIndex=0,this.lowIndex=0,this.data=null,this.internalData={},this}serialize(){return{type:"Vertex",id:this.id,point:E.Vector2IO.toStateObject(this.point),incidentHalfEdges:this.incidentHalfEdges.map(t=>t.id),visited:this.visited,visitIndex:this.visitIndex,lowIndex:this.lowIndex}}dispose(){this.point=E.ZERO,_t(this.incidentHalfEdges),this.freeToPool()}sortEdges(){const t=[];for(let n=0;n<this.incidentHalfEdges.length;n++){const r=this.incidentHalfEdges[n];t.push(r.sortVector.setXY(r.getEndTangent().angle,r.getEndCurvature()))}const e=-Math.PI+1e-4;let s=!1;for(;!s;){s=!0;for(let n=0;n<t.length;n++)t[n].x<e&&(s=!1);if(!s)for(let n=0;n<t.length;n++){const r=t[n];r.x-=1.62594024516,r.x<-Math.PI-1e-4&&(r.x+=Math.PI*2)}}this.incidentHalfEdges.sort(Ut.edgeComparison)}static edgeComparison(t,e){const s=t.sortVector.x,n=e.sortVector.x;if(Math.abs(s-n)>1e-5||s!==n&&t.edge.segment instanceof F&&e.edge.segment instanceof F)return s<n?-1:1;{const r=t.sortVector.y,a=e.sortVector.y;if(Math.abs(r-a)>1e-5)return r<a?1:-1;{const o=t.getDirectionalSegment().subdivided(.999)[1].curvatureAt(0),h=e.getDirectionalSegment().subdivided(.999)[1].curvatureAt(0);return o<h?1:-1}}}freeToPool(){Ut.pool.freeToPool(this)}};z(Ut,"pool",new Yt(Ut));let xt=Ut;Q.register("Vertex",xt);let Xs=0;const ne=class ne{constructor(t,e,s){this.id=++Xs,this.initialize(t,e,s)}initialize(t,e,s){return assert&&assert(t instanceof rt),assert&&assert(e instanceof xt),assert&&assert(s instanceof xt),assert&&assert(t.start.distance(e.point)<.001),assert&&assert(t.end.distance(s.point)<.001),this.segment=t,this.startVertex=e,this.endVertex=s,this.signedAreaFragment=t.getSignedAreaFragment(),this.forwardHalf=oe.pool.create(this,!1),this.reversedHalf=oe.pool.create(this,!0),this.visited=!1,this.data=null,this.internalData={},this}serialize(){return{type:"Edge",id:this.id,segment:this.segment.serialize(),startVertex:this.startVertex===null?null:this.startVertex.id,endVertex:this.endVertex===null?null:this.endVertex.id,signedAreaFragment:this.signedAreaFragment,forwardHalf:this.forwardHalf.serialize(),reversedHalf:this.reversedHalf.serialize(),visited:this.visited,data:this.data}}dispose(){this.segment=null,this.startVertex=null,this.endVertex=null,this.forwardHalf.dispose(),this.reversedHalf.dispose(),this.forwardHalf=null,this.reversedHalf=null,this.data=null,this.freeToPool()}getOtherVertex(t){return assert&&assert(t===this.startVertex||t===this.endVertex),this.startVertex===t?this.endVertex:this.startVertex}updateReferences(){this.forwardHalf.updateReferences(),this.reversedHalf.updateReferences(),assert&&assert(!(this.segment instanceof F)||this.startVertex!==this.endVertex,"No line segments for same vertices")}freeToPool(){ne.pool.freeToPool(this)}};z(ne,"pool",new Yt(ne));let gt=ne;Q.register("Edge",gt);let Ys=0;const ie=class ie{constructor(t){this.id=++Ys,this.initialize(t)}initialize(t){return assert&&assert(t===null||t.isInner()),this.boundary=t,this.holes=_t(this.holes),this.windingMap=null,this.filled=null,t&&this.addBoundaryFaceReferences(t),this}serialize(){return{type:"Face",id:this.id,boundary:this.boundary===null?null:this.boundary.id,holes:this.holes.map(t=>t.id),windingMap:this.windingMap,filled:this.filled}}dispose(){this.boundary=null,_t(this.holes),this.windingMap=null,this.filled=null,this.freeToPool()}addBoundaryFaceReferences(t){for(let e=0;e<t.halfEdges.length;e++)assert&&assert(t.halfEdges[e].face===null),t.halfEdges[e].face=this}recursivelyAddHoles(t){assert&&assert(!t.isInner()),this.holes.push(t),this.addBoundaryFaceReferences(t);for(let e=0;e<t.childBoundaries.length;e++)this.recursivelyAddHoles(t.childBoundaries[e])}freeToPool(){ie.pool.freeToPool(this)}};z(ie,"pool",new Yt(ie));let Jt=ie;Q.register("Face",Jt);let Ws=0;const re=class re{constructor(t,e){this.id=++Ws,this.initialize(t,e)}initialize(t,e){return assert&&assert(typeof t=="number"),assert&&assert(typeof e=="boolean"),this.shapeId=t,this.closed=e,this.halfEdges=_t(this.halfEdges),this}serialize(){return{type:"Loop",id:this.id,shapeId:this.shapeId,closed:this.closed,halfEdges:this.halfEdges.map(t=>t.id)}}toSubpath(){const t=[];for(let e=0;e<this.halfEdges.length;e++)t.push(this.halfEdges[e].getDirectionalSegment());return new yt(t,void 0,this.closed)}dispose(){_t(this.halfEdges),this.freeToPool()}freeToPool(){re.pool.freeToPool(this)}};z(re,"pool",new Yt(re));let he=re;Q.register("Loop",he);let Qs=0;const ae=class ae{constructor(t){this.id=++Qs,this.initialize(t)}initialize(t){return this.halfEdges=t,this.signedArea=this.computeSignedArea(),this.bounds=this.computeBounds(),this.childBoundaries=_t(this.childBoundaries),this}serialize(){return{type:"Boundary",id:this.id,halfEdges:this.halfEdges.map(t=>t.id),signedArea:this.signedArea,bounds:ut.Bounds2IO.toStateObject(this.bounds),childBoundaries:this.childBoundaries.map(t=>t.id)}}dispose(){this.halfEdges=[],_t(this.childBoundaries),this.freeToPool()}isInner(){return this.signedArea>0}computeSignedArea(){let t=0;for(let e=0;e<this.halfEdges.length;e++)t+=this.halfEdges[e].signedAreaFragment;return t}computeBounds(){const t=ut.NOTHING.copy();for(let e=0;e<this.halfEdges.length;e++)t.includeBounds(this.halfEdges[e].edge.segment.getBounds());return t}computeExtremePoint(t){assert&&assert(this.halfEdges.length>0,"There is no extreme point if we have no edges");const e=[];for(let n=0;n<this.halfEdges.length;n++)e.push(this.halfEdges[n].edge.segment.transformed(t.getMatrix()));const s=ut.NOTHING.copy();for(let n=0;n<e.length;n++)s.includeBounds(e[n].getBounds());for(let n=0;n<e.length;n++){const r=e[n];if(r.getBounds().top===s.top){let a=new E(0,Number.POSITIVE_INFINITY);const l=[0,1].concat(r.getInteriorExtremaTs());for(let o=0;o<l.length;o++){const h=r.positionAt(l[o]);h.y<a.y&&(a=h)}return t.inversePosition2(a)}}throw new Error("Should not reach here if we have segments")}computeExtremeRay(t){const e=this.computeExtremePoint(t),s=t.inverseDelta2(new E(0,-1)).normalized();return new qt(e.plus(s.timesScalar(1e-4)),s)}hasHalfEdge(t){for(let e=0;e<this.halfEdges.length;e++)if(this.halfEdges[e]===t)return!0;return!1}toSubpath(){const t=[];for(let e=0;e<this.halfEdges.length;e++)t.push(this.halfEdges[e].getDirectionalSegment());return new yt(t,null,!0)}freeToPool(){ae.pool.freeToPool(this)}};z(ae,"pool",new Yt(ae));let ue=ae;Q.register("Boundary",ue);const mt=class mt{constructor(t,e,s,n,r,a,l,o,h,d){this.initialize(t,e,s,n,r,a,l,o,h,d)}initialize(t,e,s,n,r,a,l,o,h,d){return this.a=t,this.b=e,this.atMin=s,this.atMax=n,this.btMin=r,this.btMax=a,this.aMin=l,this.aMax=o,this.bMin=h,this.bMax=d,this}pushSubdivisions(t){const e=this,s=(e.atMax+e.atMin)/2,n=(e.btMax+e.btMin)/2;if(s===this.atMin||s===this.atMax||n===this.btMin||n===this.btMax){t.push(this);return}const r=e.a.positionAt(s),a=e.b.positionAt(n);mt.boxIntersects(e.aMin,r,e.bMin,a)&&t.push(mt.pool.create(e.a,e.b,e.atMin,s,e.btMin,n,e.aMin,r,e.bMin,a)),mt.boxIntersects(r,e.aMax,e.bMin,a)&&t.push(mt.pool.create(e.a,e.b,s,e.atMax,e.btMin,n,r,e.aMax,e.bMin,a)),mt.boxIntersects(e.aMin,r,a,e.bMax)&&t.push(mt.pool.create(e.a,e.b,e.atMin,s,n,e.btMax,e.aMin,r,a,e.bMax)),mt.boxIntersects(r,e.aMax,a,e.bMax)&&t.push(mt.pool.create(e.a,e.b,s,e.atMax,n,e.btMax,r,e.aMax,a,e.bMax)),this.freeToPool()}distance(t){const e=this.atMin-t.atMin,s=this.atMax-t.atMax,n=this.btMin-t.btMin,r=this.btMax-t.btMax;return e*e+s*s+n*n+r*r}clean(){this.a=null,this.b=null,this.aMin=null,this.aMax=null,this.bMin=null,this.bMax=null}static intersect(t,e){if(!t.bounds.intersectsBounds(e.bounds))return[];const s=mt.getIntersectionRanges(t,e),n=[];for(let a=0;a<s.length;a++){const l=s[a];let o=!1;t:for(let h=0;h<n.length;h++){const d=n[h];for(let p=0;p<d.length;p++){const A=d[p];if(l.distance(A)<1e-13){d.push(l),o=!0;break t}}}o||n.push([l])}const r=[];for(let a=0;a<n.length;a++){const l=n[a];let o=0,h=0;for(let A=0;A<l.length;A++)o+=l[A].atMin+l[A].atMax,h+=l[A].btMin+l[A].btMax;o/=2*l.length,h/=2*l.length;const d=t.positionAt(o),p=e.positionAt(h);assert&&assert(d.distance(p)<1e-10),r.push(new vt(d.average(p),o,h))}for(let a=0;a<s.length;a++)s[a].freeToPool();return mt.cleanPool(),r}static getIntersectionRanges(t,e){const s=t.getInteriorExtremaTs(),n=e.getInteriorExtremaTs(),r=_.zip([0].concat(s),s.concat([1])),a=_.zip([0].concat(n),n.concat([1]));let l=[];for(let o=0;o<r.length;o++)for(let h=0;h<a.length;h++){const d=r[o][0],p=r[o][1],A=a[h][0],b=a[h][1],S=t.positionAt(d),P=t.positionAt(p),w=e.positionAt(A),x=e.positionAt(b);mt.boxIntersects(S,P,w,x)&&l.push(mt.pool.create(t,e,d,p,A,b,S,P,w,x))}for(let o=0;o<50;o++){const h=[];for(let d=l.length-1;d>=0;d--)l[d].pushSubdivisions(h);l=h}return l}static boxIntersects(t,e,s,n){const r=Math.max(Math.min(t.x,e.x),Math.min(s.x,n.x)),a=Math.max(Math.min(t.y,e.y),Math.min(s.y,n.y)),l=Math.min(Math.max(t.x,e.x),Math.max(s.x,n.x)),o=Math.min(Math.max(t.y,e.y),Math.max(s.y,n.y));return l-r>=0&&o-a>=0}static cleanPool(){mt.pool.forEach(t=>t.clean())}freeToPool(){mt.pool.freeToPool(this)}};mt.pool=new Yt(mt);let Kt=mt;Q.register("BoundsIntersection",Kt);let Gs=1;const Xe=[];class $e{constructor(t=1e-6){this.rootNode=Te.pool.create(this,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),this.rootNode.isBlack=!0,this.epsilon=t,this.items=new Set}query(t,e){const s=Gs++;return this.rootNode?this.rootNode.query(t,this.getMinX(t,this.epsilon),this.getMaxX(t,this.epsilon),s,e):!1}addItem(t){const e=this.getMinX(t,this.epsilon),s=this.getMaxX(t,this.epsilon);this.rootNode.split(e,this),this.rootNode.split(s,this),this.rootNode.addItem(t,e,s),this.items.add(t)}removeItem(t){this.rootNode.removeItem(t,this.getMinX(t,this.epsilon),this.getMaxX(t,this.epsilon)),this.items.delete(t)}audit(){this.rootNode.audit(this.epsilon,this.items,[])}toString(){let t=0,e="";return function s(n){e+=`${_.repeat("  ",t)}${n.toString()}
`,t++,n.hasChildren()&&(s(n.left),s(n.right)),t--}(this.rootNode),e}}const Qt=class Qt{constructor(t,e,s){this.items=[],this.initialize(t,e,s)}initialize(t,e,s){return this.min=e,this.max=s,this.splitValue=null,this.left=null,this.right=null,this.parent=null,this.tree=t,this.isBlack=!1,_t(this.items),this}contains(t){return t>=this.min&&t<=this.max}hasChildren(){return this.splitValue!==null}query(t,e,s,n,r){var l,o;let a=!1;if(this.min<=s&&this.max>=e){for(let h=0;h<this.items.length;h++){const d=this.items[h];if((!((l=d.internalData)!=null&&l.segmentId)||((o=d.internalData)==null?void 0:o.segmentId)<n)&&(d.internalData.segmentId=n,a=r(d),a))return!0}this.hasChildren()&&(a||(a=this.left.query(t,e,s,n,r)),a||(a=this.right.query(t,e,s,n,r)))}return a}swapChild(t,e){assert&&assert(this.left===t||this.right===t),this.left===t?this.left=e:this.right=e}hasChild(t){return this.left===t||this.right===t}otherChild(t){return assert&&assert(this.hasChild(t)),this.left===t?this.right:this.left}leftRotate(t){if(assert&&assert(this.hasChildren()&&this.right.hasChildren()),this.right.hasChildren()){const e=this.right,s=this.left,n=e.left,r=e.right;e.parent=this.parent,this.parent?this.parent.swapChild(this,e):t.rootNode=e,this.parent=e,n.parent=this,e.left=this,this.left=s,this.right=n,this.max=n.max,this.splitValue=s.max,e.min=this.min,e.splitValue=this.max;const a=_t(Xe);a.push(...this.items),_t(this.items);for(let l=s.items.length-1;l>=0;l--){const o=s.items[l],h=n.items.indexOf(o);h>=0&&(s.items.splice(l,1),n.items.splice(h,1),this.items.push(o))}n.items.push(...e.items),r.items.push(...e.items),_t(e.items),e.items.push(...a)}}rightRotate(t){assert&&assert(this.hasChildren()&&this.left.hasChildren());const e=this.left,s=this.right,n=e.left,r=e.right;e.parent=this.parent,this.parent?this.parent.swapChild(this,e):t.rootNode=e,this.parent=e,r.parent=this,e.right=this,this.left=r,this.right=s,this.min=r.min,this.splitValue=s.min,e.max=this.max,e.splitValue=this.min;const a=_t(Xe);a.push(...this.items),_t(this.items);for(let l=s.items.length-1;l>=0;l--){const o=s.items[l],h=r.items.indexOf(o);h>=0&&(s.items.splice(l,1),r.items.splice(h,1),this.items.push(o))}n.items.push(...e.items),r.items.push(...e.items),_t(e.items),e.items.push(...a)}fixRedBlack(t){if(assert&&assert(!this.isBlack),!this.parent)this.isBlack=!0;else{const e=this.parent;if(!e.isBlack){const s=e.parent,n=s.otherChild(e);n.isBlack?e===s.left?this===e.right?(e.leftRotate(t),e.parent.isBlack=!0,e.parent.parent.isBlack=!1,e.parent.parent.rightRotate(t)):(e.isBlack=!0,s.isBlack=!1,s.rightRotate(t)):this===e.left?(e.rightRotate(t),e.parent.isBlack=!0,e.parent.parent.isBlack=!1,e.parent.parent.leftRotate(t)):(e.isBlack=!0,s.isBlack=!1,s.leftRotate(t)):(e.isBlack=!0,n.isBlack=!0,s.isBlack=!1,s.fixRedBlack(t))}}}split(t,e){if(assert&&assert(this.contains(t)),!(t===this.min||t===this.max))if(this.hasChildren())this.splitValue!==t&&(t>this.splitValue?this.right:this.left).split(t,e);else{this.splitValue=t;const s=Qt.pool.create(this.tree,this.min,t);s.parent=this,this.left=s;const n=Qt.pool.create(this.tree,t,this.max);if(n.parent=this,this.right=n,!this.isBlack&&this.parent){const r=this.parent,a=r.otherChild(this);a.isBlack?(this===r.left?(r.rightRotate(e),s.isBlack=!0):(r.leftRotate(e),n.isBlack=!0),this.fixRedBlack(e)):(this.isBlack=!0,a.isBlack=!0,r.isBlack=!1,r.fixRedBlack(e))}}}addItem(t,e,s){this.min>s||this.max<e||(this.min>=e&&this.max<=s?this.items.push(t):this.hasChildren()&&(this.left.addItem(t,e,s),this.right.addItem(t,e,s)))}removeItem(t,e,s){this.min>s||this.max<e||(this.min>=e&&this.max<=s?(assert&&assert(this.items.includes(t)),kt(this.items,t)):this.hasChildren()&&(this.left.removeItem(t,e,s),this.right.removeItem(t,e,s)))}audit(t,e,s=[]){if(assert){for(const n of s)assert(!this.items.includes(n));for(const n of this.items)assert(this.tree.getMinX(n,t)<=this.min),assert(this.tree.getMaxX(n,t)>=this.max);for(const n of s)this.tree.getMinX(n,t)<=this.min&&this.tree.getMaxX(n,t)>=this.max&&assert(e.has(n)||this.items.includes(n));if(assert(this.hasChildren()===(this.left!==null)),assert(this.hasChildren()===(this.right!==null)),assert(this.hasChildren()===(this.splitValue!==null)),assert(this.min<this.max),this.parent&&(assert(this.parent.hasChild(this)),assert(this.isBlack||this.parent.isBlack)),this.hasChildren()){assert(this.left.parent===this),assert(this.right.parent===this),assert(this.min===this.left.min),assert(this.max===this.right.max),assert(this.splitValue===this.left.max),assert(this.splitValue===this.right.min);for(const r of this.left.items)assert(!this.right.items.includes(r),"We shouldn't have two children with the same item");const n=[...s,...this.items];this.left.audit(t,e,n),this.right.audit(t,e,n)}}}toString(){return`[${this.min} ${this.max}] split:${this.splitValue} ${this.isBlack?"black":"red"} ${this.items}`}freeToPool(){Qt.pool.freeToPool(this)}};Qt.pool=new Yt(Qt);let Te=Qt;Q.register("SegmentTree",$e);class Ce extends $e{getMinX(t,e){return t.segment.bounds.left-e}getMaxX(t,e){return t.segment.bounds.right+e}}Q.register("EdgeSegmentTree",Ce);class Ue extends $e{getMinX(t,e){return t.point.x-e}getMaxX(t,e){return t.point.x+e}}Q.register("VertexSegmentTree",Ue);let Zs=0,ye=0;const me=1e-5,Ye=.1*me,We=.01*me,fe=1e-6;class wt{constructor(){this.vertices=[],this.edges=[],this.innerBoundaries=[],this.outerBoundaries=[],this.boundaries=[],this.shapeIds=[],this.loops=[],this.unboundedFace=Jt.pool.create(null),this.faces=[this.unboundedFace]}serialize(){return{type:"Graph",vertices:this.vertices.map(t=>t.serialize()),edges:this.edges.map(t=>t.serialize()),boundaries:this.boundaries.map(t=>t.serialize()),innerBoundaries:this.innerBoundaries.map(t=>t.id),outerBoundaries:this.outerBoundaries.map(t=>t.id),shapeIds:this.shapeIds,loops:this.loops.map(t=>t.serialize()),unboundedFace:this.unboundedFace.id,faces:this.faces.map(t=>t.serialize())}}static deserialize(t){const e=new wt,s={},n={},r={},a={},l={},o={};return e.vertices=t.vertices.map(h=>{const d=new xt(E.Vector2IO.fromStateObject(h.point));return s[h.id]=d,d.visited=h.visited,d.visitIndex=h.visitIndex,d.lowIndex=h.lowIndex,d}),e.edges=t.edges.map(h=>{const d=new gt(rt.deserialize(h.segment),s[h.startVertex],s[h.endVertex]);n[h.id]=d,d.signedAreaFragment=h.signedAreaFragment;const p=(A,b)=>{r[b.id]=A,A.isReversed=b.isReversed,A.signedAreaFragment=b.signedAreaFragment,A.startVertex=s[b.startVertex.id],A.endVertex=s[b.endVertex.id],A.sortVector=E.Vector2IO.fromStateObject(b.sortVector),A.data=b.data};return p(d.forwardHalf,h.forwardHalf),p(d.reversedHalf,h.reversedHalf),d.visited=h.visited,d.data=h.data,d}),t.vertices.forEach((h,d)=>{const p=e.vertices[d];p.incidentHalfEdges=h.incidentHalfEdges.map(A=>r[A])}),e.boundaries=t.boundaries.map(h=>{const d=ue.pool.create(h.halfEdges.map(p=>r[p]));return a[h.id]=d,d.signedArea=h.signedArea,d.bounds=ut.Bounds2IO.fromStateObject(h.bounds),d}),t.boundaries.forEach((h,d)=>{const p=e.boundaries[d];p.childBoundaries=h.childBoundaries.map(A=>a[A])}),e.innerBoundaries=t.innerBoundaries.map(h=>a[h]),e.outerBoundaries=t.outerBoundaries.map(h=>a[h]),e.shapeIds=t.shapeIds,e.loops=t.loops.map(h=>{const d=new he(h.shapeId,h.closed);return l[h.id]=d,d.halfEdges=h.halfEdges.map(p=>r[p]),d}),e.faces=t.faces.map((h,d)=>{const p=d===0?e.unboundedFace:new Jt(a[h.boundary]);return o[h.id]=p,p.holes=h.holes.map(A=>a[A]),p.windingMap=h.windingMap,p.filled=h.filled,p}),t.edges.forEach((h,d)=>{const p=e.edges[d];p.forwardHalf.face=h.forwardHalf.face===null?null:o[h.forwardHalf.face],p.reversedHalf.face=h.reversedHalf.face===null?null:o[h.reversedHalf.face]}),e}addShape(t,e,s){for(let n=0;n<e.subpaths.length;n++)this.addSubpath(t,e.subpaths[n],s)}addSubpath(t,e,s){if(assert&&assert(typeof t=="number"),assert&&assert(e instanceof yt),s=Se({ensureClosed:!0},s),this.shapeIds.indexOf(t)<0&&this.shapeIds.push(t),e.segments.length===0)return;const n=e.closed||s.ensureClosed,r=s.ensureClosed?e.getFillSegments():e.segments;let a;const l=[];for(a=0;a<r.length;a++){let h=a-1;h<0&&(h=r.length-1);let d=r[h].end;const p=r[a].start;!n&&a===0&&(d=p),p.equals(d)?l.push(xt.pool.create(p)):(assert&&assert(p.distance(d)<1e-5,"Inaccurate start/end points"),l.push(xt.pool.create(p.average(d))))}n||l.push(xt.pool.create(r[r.length-1].end));const o=he.pool.create(t,n);for(a=0;a<r.length;a++){let h=a+1;n&&h===r.length&&(h=0);const d=gt.pool.create(r[a],l[a],l[h]);o.halfEdges.push(d.forwardHalf),this.addEdge(d)}this.loops.push(o),this.vertices.push(...l)}computeSimplifiedFaces(){this.eliminateOverlap(),this.eliminateSelfIntersection(),this.eliminateIntersection(),this.collapseVertices(),this.removeBridges(),this.removeLowOrderVertices(),this.orderVertexEdges(),this.extractFaces(),this.computeBoundaryTree(),this.computeWindingMap()}computeFaceInclusion(t){for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.filled=t(s.windingMap)}}createFilledSubGraph(){const t=new wt,e={};for(let s=0;s<this.edges.length;s++){const n=this.edges[s];if(n.forwardHalf.face.filled!==n.reversedHalf.face.filled){if(!e[n.startVertex.id]){const l=xt.pool.create(n.startVertex.point);t.vertices.push(l),e[n.startVertex.id]=l}if(!e[n.endVertex.id]){const l=xt.pool.create(n.endVertex.point);t.vertices.push(l),e[n.endVertex.id]=l}const r=e[n.startVertex.id],a=e[n.endVertex.id];t.addEdge(gt.pool.create(n.segment,r,a))}}return t.collapseAdjacentEdges(),t.orderVertexEdges(),t.extractFaces(),t.computeBoundaryTree(),t.fillAlternatingFaces(),t}facesToShape(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];if(s.filled){t.push(s.boundary.toSubpath());for(let n=0;n<s.holes.length;n++)t.push(s.holes[n].toSubpath())}}return new Q.Shape(t)}dispose(){for(;this.boundaries.length;)this.boundaries.pop().dispose();for(_t(this.innerBoundaries),_t(this.outerBoundaries);this.loops.length;)this.loops.pop().dispose();for(;this.faces.length;)this.faces.pop().dispose();for(;this.vertices.length;)this.vertices.pop().dispose();for(;this.edges.length;)this.edges.pop().dispose()}addEdge(t){assert&&assert(t instanceof gt),assert&&assert(!_.includes(t.startVertex.incidentHalfEdges,t.reversedHalf),"Should not already be connected"),assert&&assert(!_.includes(t.endVertex.incidentHalfEdges,t.forwardHalf),"Should not already be connected"),this.edges.push(t),t.startVertex.incidentHalfEdges.push(t.reversedHalf),t.endVertex.incidentHalfEdges.push(t.forwardHalf)}removeEdge(t){assert&&assert(t instanceof gt),kt(this.edges,t),kt(t.startVertex.incidentHalfEdges,t.reversedHalf),kt(t.endVertex.incidentHalfEdges,t.forwardHalf)}replaceEdgeInLoops(t,e){const s=[];for(let n=0;n<e.length;n++)s.push(e[e.length-1-n].getReversed());for(let n=0;n<this.loops.length;n++){const r=this.loops[n];for(let a=r.halfEdges.length-1;a>=0;a--){const l=r.halfEdges[a];if(l.edge===t){const o=l===t.forwardHalf?e:s;Array.prototype.splice.apply(r.halfEdges,[a,1].concat(o))}}}}collapseAdjacentEdges(){let t=!0;for(;t;){t=!1;for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];if(s.incidentHalfEdges.length===2){const n=s.incidentHalfEdges[0].edge,r=s.incidentHalfEdges[1].edge;let a=n.segment,l=r.segment;const o=n.getOtherVertex(s),h=r.getOtherVertex(s);if(assert&&assert(this.loops.length===0),n.startVertex===s&&(a=a.reversed()),r.endVertex===s&&(l=l.reversed()),a instanceof F&&l instanceof F&&a.tangentAt(0).normalized().distance(l.tangentAt(0).normalized())<1e-6){this.removeEdge(n),this.removeEdge(r),n.dispose(),r.dispose(),kt(this.vertices,s),s.dispose();const d=new F(o.point,h.point);this.addEdge(new gt(d,o,h)),t=!0;break}}}}}eliminateOverlap(){const e=new window.FlatQueue,s=new Ce(1e-4),n=ye++,r=o=>{const h=o.segment.bounds;e.push({start:!0,edge:o},h.minY-1e-4),e.push({start:!1,edge:o},h.maxY+1e-4)},a=o=>{o.internalData.removedId=n};for(let o=0;o<this.edges.length;o++)r(this.edges[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.edge;if(h.internalData.removedId!==n)if(o.start){let d=!1,p,A;if(s.query(h,b=>{const S=h.segment.getOverlaps(b.segment);if(S!==null&&S.length)for(let P=0;P<S.length;P++){const w=S[P];if(Math.abs(w.t1-w.t0)>1e-5&&Math.abs(w.qt1-w.qt0)>1e-5)return A=this.splitOverlap(h,b,w),d=!0,p=b,!0}return!1}),d){s.removeItem(p),a(p),a(h);for(let b=0;b<A.length;b++)r(A[b]);l.push(h),l.push(p)}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose()}splitOverlap(t,e,s){const n=[],r=t.segment,a=e.segment;this.removeEdge(t),this.removeEdge(e);let l=s.t0,o=s.t1,h=s.qt0,d=s.qt1;l<1e-5&&(l=0),o>1-1e-5&&(o=1),h<1e-5&&(h=0),d>1-1e-5&&(d=1);const p=l>0?r.subdivided(l)[0]:null,A=h>0?a.subdivided(h)[0]:null,b=o<1?r.subdivided(o)[1]:null,S=d<1?a.subdivided(d)[1]:null;let P=r;l>0&&(P=P.subdivided(l)[1]),o<1&&(P=P.subdivided(O.linear(l,1,0,1,o))[0]);let w;p&&A?(w=xt.pool.create(P.start),this.vertices.push(w)):p?w=s.a>0?e.startVertex:e.endVertex:w=t.startVertex;let x;b&&S?(x=xt.pool.create(P.end),this.vertices.push(x)):b?x=s.a>0?e.endVertex:e.startVertex:x=t.endVertex;const v=gt.pool.create(P,w,x);n.push(v);let T,M,$,B;p&&(T=gt.pool.create(p,t.startVertex,w),n.push(T)),b&&(M=gt.pool.create(b,x,t.endVertex),n.push(M)),A&&($=gt.pool.create(A,e.startVertex,s.a>0?w:x),n.push($)),S&&(B=gt.pool.create(S,s.a>0?x:w,e.endVertex),n.push(B));for(let L=0;L<n.length;L++)this.addEdge(n[L]);const N=(p?[T]:[]).concat([v]).concat(b?[M]:[]),W=(A?[$]:[]).concat([v]).concat(S?[B]:[]),k=[],q=[];for(let L=0;L<N.length;L++)k.push(N[L].forwardHalf);for(let L=0;L<W.length;L++){const tt=W[L]!==v||s.a>0;q.push(tt?W[L].forwardHalf:W[L].reversedHalf)}return this.replaceEdgeInLoops(t,k),this.replaceEdgeInLoops(e,q),n}eliminateSelfIntersection(){assert&&assert(this.boundaries.length===0,"Only handles simpler level primitive splitting right now");for(let t=this.edges.length-1;t>=0;t--){const e=this.edges[t],s=e.segment;if(s instanceof ht){const n=s.getSelfIntersection();if(n){assert&&assert(n.aT<n.bT);const r=s.subdivisions([n.aT,n.bT]),a=xt.pool.create(n.point);this.vertices.push(a);const l=gt.pool.create(r[0],e.startVertex,a),o=gt.pool.create(r[1],a,a),h=gt.pool.create(r[2],a,e.endVertex);this.removeEdge(e),this.addEdge(l),this.addEdge(o),this.addEdge(h),this.replaceEdgeInLoops(e,[l.forwardHalf,o.forwardHalf,h.forwardHalf]),e.dispose()}}}}eliminateIntersection(){const e=new window.FlatQueue,s=new Ce(1e-4),n=ye++,r=o=>{const h=o.segment.bounds;e.push({start:!0,edge:o},h.minY-1e-4),e.push({start:!1,edge:o},h.maxY+1e-4)},a=o=>{o.internalData.removedId=n};for(let o=0;o<this.edges.length;o++)r(this.edges[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.edge;if(h.internalData.removedId!==n)if(o.start){let d=!1,p,A,b;if(s.query(h,S=>{const P=h.segment,w=S.segment;let x=rt.intersect(P,w);if(x=x.filter(v=>{const T=v.point;return wt.isInternal(T,v.aT,P,Ye,fe)||wt.isInternal(T,v.bT,w,Ye,fe)}),x.length){const v=x[0],T=this.simpleSplit(h,S,v.aT,v.bT,v.point);if(T)return d=!0,p=S,A=T.addedEdges,b=T.removedEdges,!0}return!1}),d){b.includes(h)?(a(h),l.push(h)):s.addItem(h),b.includes(p)&&(s.removeItem(p),a(p),l.push(p));for(let S=0;S<A.length;S++)r(A[S])}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose()}simpleSplit(t,e,s,n,r){const a=wt.isInternal(r,s,t.segment,We,fe),l=wt.isInternal(r,n,e.segment,We,fe);let o=null;a?l?(o=xt.pool.create(r),this.vertices.push(o)):o=n<.5?e.startVertex:e.endVertex:o=s<.5?t.startVertex:t.endVertex;let h=!1;const d=[],p=[];return a&&o!==t.startVertex&&o!==t.endVertex&&(d.push(...this.splitEdge(t,s,o)),p.push(t),h=!0),l&&o!==e.startVertex&&o!==e.endVertex&&(d.push(...this.splitEdge(e,n,o)),p.push(e),h=!0),h?{addedEdges:d,removedEdges:p}:null}splitEdge(t,e,s){assert&&assert(this.boundaries.length===0,"Only handles simpler level primitive splitting right now"),assert&&assert(t.startVertex!==s),assert&&assert(t.endVertex!==s);const n=t.segment.subdivided(e);assert&&assert(n.length===2);const r=gt.pool.create(n[0],t.startVertex,s),a=gt.pool.create(n[1],s,t.endVertex);return this.removeEdge(t),this.addEdge(r),this.addEdge(a),this.replaceEdgeInLoops(t,[r.forwardHalf,a.forwardHalf]),[r,a]}collapseVertices(){assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.startVertex))),assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.endVertex)));const t=10*me,e=new window.FlatQueue,s=new Ue(t),n=ye++,r=o=>{e.push({start:!0,vertex:o},o.point.y-t),e.push({start:!1,vertex:o},o.point.y+t)},a=o=>{o.internalData.removedId=n};for(let o=0;o<this.vertices.length;o++)r(this.vertices[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.vertex;if(h.internalData.removedId!==n)if(o.start){let d=!1,p,A;if(s.query(h,b=>{const S=h.point.distance(b.point);if(S<me){const P=xt.pool.create(S===0?h.point:h.point.average(b.point));this.vertices.push(P),kt(this.vertices,h),kt(this.vertices,b);for(let w=this.edges.length-1;w>=0;w--){const x=this.edges[w],v=x.startVertex===h||x.startVertex===b,T=x.endVertex===h||x.endVertex===b;if(v&&T){if((x.segment.bounds.width>1e-5||x.segment.bounds.height>1e-5)&&(x.segment instanceof ht||x.segment instanceof D||x.segment instanceof lt)){const M=gt.pool.create(x.segment,P,P);this.addEdge(M),this.replaceEdgeInLoops(x,[M.forwardHalf])}else this.replaceEdgeInLoops(x,[]);this.removeEdge(x),x.dispose()}else v?(x.startVertex=P,P.incidentHalfEdges.push(x.reversedHalf),x.updateReferences()):T&&(x.endVertex=P,P.incidentHalfEdges.push(x.forwardHalf),x.updateReferences())}return A=[P],d=!0,p=b,!0}return!1}),d){s.removeItem(p),a(p),a(h);for(let b=0;b<A.length;b++)r(A[b]);l.push(h),l.push(p)}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose();assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.startVertex))),assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.endVertex)))}markBridges(t,e){e.visited=!0,e.visitIndex=e.lowIndex=Zs++;for(let s=0;s<e.incidentHalfEdges.length;s++){const n=e.incidentHalfEdges[s].edge,r=e.incidentHalfEdges[s].startVertex;r.visited?n.visited||(e.lowIndex=Math.min(e.lowIndex,r.visitIndex)):(n.visited=!0,r.parent=e,this.markBridges(t,r),e.lowIndex=Math.min(e.lowIndex,r.lowIndex),r.lowIndex>e.visitIndex&&t.push(n))}}removeBridges(){const t=[];for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];s.visited||this.markBridges(t,s)}for(let e=0;e<t.length;e++){const s=t[e];this.removeEdge(s),this.replaceEdgeInLoops(s,[]),s.dispose()}}removeLowOrderVertices(){assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.startVertex))),assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.endVertex)));let t=!0;for(;t;){t=!1;for(let e=this.vertices.length-1;e>=0;e--){const s=this.vertices[e];if(s.incidentHalfEdges.length<2){for(let n=0;n<s.incidentHalfEdges.length;n++){const r=s.incidentHalfEdges[n].edge;this.removeEdge(r),this.replaceEdgeInLoops(r,[]),r.dispose()}this.vertices.splice(e,1),s.dispose(),t=!0;break}}}assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.startVertex))),assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.endVertex)))}orderVertexEdges(){for(let t=0;t<this.vertices.length;t++)this.vertices[t].sortEdges()}extractFaces(){const t=[];for(let e=0;e<this.edges.length;e++)t.push(this.edges[e].forwardHalf),t.push(this.edges[e].reversedHalf);for(;t.length;){const e=[];let s=t[0];const n=s;for(;s&&(kt(t,s),e.push(s),s=s.getNext(),s!==n););const r=ue.pool.create(e);(r.signedArea>0?this.innerBoundaries:this.outerBoundaries).push(r),this.boundaries.push(r)}for(let e=0;e<this.innerBoundaries.length;e++)this.faces.push(Jt.pool.create(this.innerBoundaries[e]))}computeBoundaryTree(){const t=[],e=new Qe(Bt.rotation2(1.5729657));for(let s=0;s<this.outerBoundaries.length;s++){const n=this.outerBoundaries[s],r=n.computeExtremeRay(e);let a=null,l=Number.POSITIVE_INFINITY,o=!1;for(let h=0;h<this.edges.length;h++){const d=this.edges[h],p=d.segment.intersection(r);for(let A=0;A<p.length;A++){const b=p[A];b.distance<l&&(a=d,l=b.distance,o=b.wind)}}if(a===null)t.push(n);else{const d=o<0?a.reversedHalf:a.forwardHalf;this.getBoundaryOfHalfEdge(d).childBoundaries.push(n)}}t.forEach(this.unboundedFace.recursivelyAddHoles.bind(this.unboundedFace));for(let s=0;s<this.faces.length;s++){const n=this.faces[s];n.boundary!==null&&n.boundary.childBoundaries.forEach(n.recursivelyAddHoles.bind(n))}}computeWindingMap(){const t=this.edges.slice(),e={};for(let s=0;s<this.shapeIds.length;s++)e[this.shapeIds[s]]=0;for(this.unboundedFace.windingMap=e;t.length;)for(let s=t.length-1;s>=0;s--){const n=t[s],r=n.forwardHalf,a=n.reversedHalf,l=r.face,o=a.face;assert&&assert(l!==o);const h=l.windingMap!==null,d=o.windingMap!==null;if(h&&d){if(t.splice(s,1),assert)for(let p=0;p<this.shapeIds.length;p++){const A=this.shapeIds[p];assert(l.windingMap[A]-o.windingMap[A]===this.computeDifferential(n,A))}}else{if(!h&&!d)continue;{const p=h?l:o,A=h?o:l,b={};for(let S=0;S<this.shapeIds.length;S++){const P=this.shapeIds[S],w=this.computeDifferential(n,P);b[P]=p.windingMap[P]+w*(h?-1:1)}A.windingMap=b}}}}computeDifferential(t,e){let s=0;for(let n=0;n<this.loops.length;n++){const r=this.loops[n];if(assert&&assert(r.closed,"This is only defined to work for closed loops"),r.shapeId===e)for(let a=0;a<r.halfEdges.length;a++){const l=r.halfEdges[a];l===t.forwardHalf?s++:l===t.reversedHalf&&s--}}return s}fillAlternatingFaces(){let t=0;for(let e=0;e<this.faces.length;e++)this.faces[e].filled=null,t++;for(this.unboundedFace.filled=!1,t--;t;)for(let e=0;e<this.edges.length;e++){const s=this.edges[e],n=s.forwardHalf.face,r=s.reversedHalf.face,a=n.filled===null,l=r.filled===null;a&&!l?(n.filled=!r.filled,t--):!a&&l&&(r.filled=!n.filled,t--)}}getBoundaryOfHalfEdge(t){for(let e=0;e<this.boundaries.length;e++){const s=this.boundaries[e];if(s.hasHalfEdge(t))return s}throw new Error("Could not find boundary")}static isInternal(t,e,s,n,r){return e>r&&e<1-r&&t.distance(s.start)>n&&t.distance(s.end)>n}static BINARY_NONZERO_UNION(t){return t[0]!==0||t[1]!==0}static BINARY_NONZERO_INTERSECTION(t){return t[0]!==0&&t[1]!==0}static BINARY_NONZERO_DIFFERENCE(t){return t[0]!==0&&t[1]===0}static BINARY_NONZERO_XOR(t){return(t[0]!==0^t[1]!==0)===1}static binaryResult(t,e,s){const n=new wt;n.addShape(0,t),n.addShape(1,e),n.computeSimplifiedFaces(),n.computeFaceInclusion(s);const r=n.createFilledSubGraph(),a=r.facesToShape();return n.dispose(),r.dispose(),a}static unionNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{for(let a=0;a<t.length;a++)if(r[a]!==0)return!0;return!1});const s=e.createFilledSubGraph(),n=s.facesToShape();return e.dispose(),s.dispose(),n}static intersectionNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{for(let a=0;a<t.length;a++)if(r[a]===0)return!1;return!0});const s=e.createFilledSubGraph(),n=s.facesToShape();return e.dispose(),s.dispose(),n}static xorNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{let a=!1;for(let l=0;l<t.length;l++)r[l]!==0&&(a=!a);return a});const s=e.createFilledSubGraph(),n=s.facesToShape();return e.dispose(),s.dispose(),n}static simplifyNonZero(t){const e=new wt;e.addShape(0,t),e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>r[0]!==0);const s=e.createFilledSubGraph(),n=s.facesToShape();return e.dispose(),s.dispose(),n}static clipShape(t,e,s){let n,r,a;s=Se({includeExterior:!1,includeBoundary:!0,includeInterior:!0},s);const h=wt.simplifyNonZero(t),d=new wt;for(d.addShape(0,e,{ensureClosed:!1}),d.addShape(1,h),d.eliminateOverlap(),d.eliminateSelfIntersection(),d.eliminateIntersection(),d.collapseVertices(),n=0;n<d.loops.length;n++)if(a=d.loops[n],a.shapeId===1)for(r=0;r<a.halfEdges.length;r++)a.halfEdges[r].edge.data=!0;const p=[];for(n=0;n<d.loops.length;n++)if(a=d.loops[n],a.shapeId===0){let A=[];for(r=0;r<a.halfEdges.length;r++){const b=a.halfEdges[r];(b.edge.data?s.includeBoundary:h.containsPoint(b.edge.segment.positionAt(.5))?s.includeInterior:s.includeExterior)?A.push(b.getDirectionalSegment()):A.length&&(p.push(new yt(A,void 0,a.closed)),A=[])}A.length&&p.push(new yt(A,void 0,a.closed))}return d.dispose(),new Q.Shape(p)}}Q.register("Graph",wt);const Ct=wt;function Us(u){return u.replace(/\u202a|\u202b|\u202c/g,"")}Z.register("stripEmbeddingMarks",Us);function Js(u,t,e,s,n){assert&&assert(Array.isArray(u)&&_.uniq(u).length===u.length,"a is not an array of unique items"),assert&&assert(Array.isArray(t)&&_.uniq(t).length===t.length,"b is not an array of unique items"),e=e||[],s=s||[],n=n||[],assert&&assert(Array.isArray(e)&&e.length===0),assert&&assert(Array.isArray(s)&&s.length===0),assert&&assert(Array.isArray(n)&&n.length===0),Array.prototype.push.apply(e,u),Array.prototype.push.apply(s,t);t:for(let r=0;r<e.length;r++){const a=e[r];for(let l=0;l<s.length;l++){const o=s[l];if(a===o){if(n.push(a),e.splice(r,1),s.splice(l,1),l=0,r===e.length)break t;r-=1}}}return e}Z.register("arrayDifference",Js);function Ks(u){const t=new Map;return e=>{if(t.has(e))return t.get(e);{const s=u(e);return t.set(e,s),s}}}Z.register("memoize",Ks);const js=(u,t)=>{assert&&u&&t.forEach(e=>{assert&&assert(Object.getOwnPropertyDescriptor(u,e)||_.some(ps(u.constructor).map(s=>Object.getOwnPropertyDescriptor(s.prototype,e))),`property not defined: ${e}`)})};Z.register("assertHasProperties",js);function tn(u){return u.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;")}Z.register("escapeHTML",tn);function en(u,...t){return _.each(t,e=>{if(e)for(const s in e){const n=Object.getOwnPropertyDescriptor(e,s);n&&(typeof n.get=="function"||e[s]!==void 0)&&Object.defineProperty(u,s,n)}}),u}Z.register("extendDefined",en);function sn(u,t,e){assert&&assert(u),assert&&assert(Array.isArray(t)),e&&(assert&&assert(Object.getPrototypeOf(e)===Object.prototype,"Extra prototype on options object is a code smell"),_.each(t,s=>{assert&&assert(!e.hasOwnProperty(s)||e[s]!==void 0,`Undefined not allowed for key: ${s}`),e[s]!==void 0&&(u[s]=e[s])}))}Z.register("mutate",sn);class Ae{constructor(t,e){this._map=new Map,this._enumeration=t,this._values=t.enumeration.values,this._values.forEach(s=>{assert&&assert(!this._map.has(s),"Enumeration key override problem"),this._map.set(s,e(s))})}get(t){return assert&&assert(this._values.includes(t)),assert&&assert(this._map.has(t)),this._map.get(t)}set(t,e){assert&&assert(this._values.includes(t)),this._map.set(t,e)}map(t){return new Ae(this._enumeration,e=>t(this.get(e),e))}forEach(t){this._values.forEach(e=>t(this.get(e),e))}values(){return this._values.map(t=>this.get(t))}}Z.register("EnumerationMap",Ae);class ee extends Ae{constructor(t,e){super(Ft,s=>s===Ft.HORIZONTAL?t:e)}get horizontal(){return this.get(Ft.HORIZONTAL)}set horizontal(t){this.set(Ft.HORIZONTAL,t)}get vertical(){return this.get(Ft.VERTICAL)}set vertical(t){this.set(Ft.VERTICAL,t)}with(t,e){return new ee(t===Ft.HORIZONTAL?e:this.horizontal,t===Ft.VERTICAL?e:this.vertical)}static create(t){return new ee(t(Ft.HORIZONTAL),t(Ft.VERTICAL))}map(t){return new ee(t(this.horizontal,Ft.HORIZONTAL),t(this.vertical,Ft.VERTICAL))}}Z.register("OrientationPair",ee);class nn{constructor(){this.pendingLocks=[],this.loadComplete=!1,this.listeners=[]}reset(){this.loadComplete=!1}addListener(t){this.listeners.push(t)}proceedIfReady(){this.pendingLocks.length===0&&(assert&&assert(!this.loadComplete,"cannot complete load twice"),this.loadComplete=!0,this.listeners.forEach(t=>t()))}createLock(t){return assert&&assert(!this.loadComplete,"Cannot create more locks after load-step has completed"),this.pendingLocks.push(t),()=>{assert&&assert(this.pendingLocks.includes(t),"invalid lock"),kt(this.pendingLocks,t),this.proceedIfReady()}}}const Je=new nn;Z.register("asyncLoader",Je);function rn(u){const t=[];return u(e=>{t.push(e)}),t}Z.register("collect",rn);function Ie(u){if(Array.isArray(u))return u.map(Ie);if(typeof u!="object"||u===null)return u;const t={};return Object.keys(u).sort().forEach(e=>{const s=u[e];t[e]=Ie(s)}),t}Z.register("copyWithSortedKeys",Ie);function an(u,t,e){const s=[];function n(r,a){return a.forEach((l,o)=>{s.push(o),r===1?e(l,...s):n(r-1,l),s.pop()})}return n(u,t)}Z.register("dimensionForEach",an);function ln(u,t,e){const s=[];function n(r,a){return a.map((l,o)=>{s.push(o);const h=r===1?e(l,...s):n(r-1,l);return s.pop(),h})}return n(u,t)}Z.register("dimensionMap",ln);const le=class le{constructor(t,e){this.eventModel=t,this.eventCallback=e,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period}step(t){for(;t>=this.timeBeforeNextEvent;)t-=this.timeBeforeNextEvent,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period,this.eventCallback(t);this.timeBeforeNextEvent-=t}getRatio(){return(this.period-this.timeBeforeNextEvent)/this.period}};le.ConstantEventModel=class{constructor(e){this.rate=e,assert&&assert(e>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){return 1/this.rate}},le.UniformEventModel=class{constructor(e,s){this.rate=e,this.pseudoRandomNumberSource=s,assert&&assert(e>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const e=this.pseudoRandomNumberSource();return assert&&assert(e>=0&&e<1,`Our uniform random number is outside of its expected range with a value of ${e}`),e*2/this.rate}},le.PoissonEventModel=class{constructor(e,s){this.rate=e,this.pseudoRandomNumberSource=s,assert&&assert(e>0,"We need to have a strictly positive poisson rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const e=this.pseudoRandomNumberSource();return assert&&assert(e>=0&&e<1,`Our uniform random number is outside of its expected range with a value of ${e}`),-Math.log(e)/this.rate}};let Me=le;Z.register("EventTimer",Me);const Ke=u=>{assert&&assert(u.trim()===u,"path must be trimmed");const t=_.get(window,u);return t!==void 0?t:null};Z.register("getGlobal",Ke);const on=u=>{assert&&assert(u.split(".").length>1,"path must have multiple parts"),assert&&assert(u.trim()===u,"path must be trimmed");const t=u.split("."),e=t.pop(),s=_.get(window,t);return s?s[e].bind(s):null};Z.register("gracefulBind",on);function hn(u){return u}Z.register("identity",hn);function un(u,t){assert&&assert(Array.isArray(u));const e=[],s=u.length*2-1;for(let n=0;n<s;n++)n%2===0?e.push(u[n/2]):e.push(t((n-1)/2));return e}Z.register("interleave",un);function cn(u){const t=typeof u=="string"?{src:u}:u,e=t.src,s=t.callback,n=t.async===void 0?!0:t.async,r=t.cacheBust===void 0?!1:t.cacheBust;let a=!1;const l=document.createElement("script");l.type="text/javascript",l.async=n,l.onload=l.onreadystatechange=function(){const h=this.readyState;h&&h!=="complete"&&h!=="loaded"||a||(a=!0,s&&s())},l.src=e+(r?`?random=${Math.random().toFixed(10)}`:"");const o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(l,o)}Z.register("loadScript",cn);function dn(u){phet.log&&phet.log(`${u}: ${JSON.stringify(Ke(u),null,2)}`)}Z.register("logGlobal",dn);class gn{constructor(t,e,s){this.width=t,this.height=e,this.url=s,this.img=new Image;const n=Je.createLock(this.img);this.img.onload=n,this.img.src=this.url,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height;const r=this.canvas.getContext("2d");this.updateCanvas=()=>{this.img.complete&&(typeof this.img.naturalWidth>"u"||this.img.naturalWidth>0)&&(r.drawImage(this.img,0,0),delete this.updateCanvas)}}}Z.register("MipmapElement",gn);function fn(u){const t=[],e=u.length;if(e>1)for(let s=0;s<e-1;s++){const n=u[s];for(let r=s+1;r<e;r++)t.push([n,u[r]])}return t}Z.register("pairs",fn);function pn(u,t){assert&&assert(Array.isArray(u));const e=[],s=[],n=u.length;for(let r=0;r<n;r++)t(u[r])?e.push(u[r]):s.push(u[r]);return[e,s]}Z.register("partition",pn);const mn={GRAVITATIONAL_CONSTANT:66743e-15,GRAVITY_ON_EARTH:9.81};Z.register("PhysicalConstants",mn);function _n(u){return assert&&assert(u!==void 0,"Required field is undefined."),u}Z.register("required",_n);const Pe={};function vn(u,t,e){const s=Pe;let n=s,r=s;return u.hasOwnProperty(t)&&(n=u[t]),u.hasOwnProperty(e)&&(r=u[e]),n!==Pe?u[e]=n:delete u[e],r!==Pe?u[t]=r:delete u[t],u}Z.register("swapObjectKeys",vn);const Xt=window._,R=(u,...t)=>window.assert(u,...t),it=()=>!!window.assert;class An{constructor(t,e){z(this,"incomingHalfEdges");z(this,"outgoingHalfEdges");z(this,"edges");z(this,"faces");this.logicalCoordinates=t,this.viewCoordinates=e,it()&&R(t),it()&&R(e)}getHalfEdgeTo(t){const e=this.outgoingHalfEdges.find(s=>s.end===t);return it()&&R(e),e}getHalfEdgeFrom(t){const e=this.incomingHalfEdges.find(s=>s.start===t);return it()&&R(e),e}getEdgeTo(t){const e=this.edges.find(s=>s.start===t||s.end===t);return it()&&R(e),e}}class bn{constructor(t,e){z(this,"halfEdges");z(this,"edges");z(this,"vertices");this.logicalCoordinates=t,this.viewCoordinates=e,it()&&R(t),it()&&R(e)}}class wn{constructor(t,e){z(this,"forwardHalf");z(this,"reversedHalf");z(this,"forwardFace");z(this,"reversedFace");z(this,"vertices");z(this,"faces");this.start=t,this.end=e,it()&&R(t),it()&&R(e)}getOtherVertex(t){return it()&&R(t===this.start||t===this.end,"vertex must be one of the two vertices of this edge"),t===this.start?this.end:this.start}getOtherFace(t){return it()&&R(t===this.forwardFace||t===this.reversedFace,"face must be one of the two faces of this edge"),t===this.forwardFace?this.reversedFace:this.forwardFace}}class xn{constructor(t,e,s){z(this,"edge");z(this,"reversed");z(this,"next");z(this,"previous");z(this,"face",null);this.start=t,this.end=e,this.isReversed=s,it()&&R(t),it()&&R(e)}}const _e=u=>{let t=0;for(let e=0;e<u.length;e++){const s=u[e],n=u[(e+1)%u.length];t+=(n.x+s.x)*(n.y-s.y)}return .5*t},yn=u=>Math.abs(_e(u)),Pn=u=>{const t=_e(u);if(t===0)return u.reduce((n,r)=>n.plus(r),new E(0,0)).timesScalar(1/u.length);let e=0,s=0;for(let n=0;n<u.length;n++){const r=u[n],a=u[(n+1)%u.length],l=r.x*(2*r.y+a.y)+a.x*(r.y+2*a.y);e+=(r.x-a.x)*l,s+=(a.y-r.y)*l}return new E(e,s).timesScalar(1/(6*t))},$n=(u,t)=>{let e=0;for(let s=0;s<u.length;s++){const n=u[s],r=u[(s+1)%u.length],a=t[s],l=t[(s+1)%u.length];e+=(r.x+n.x)*(l.y-a.y)+(l.x-a.x)*(r.y-n.y)}return .5*e},je=(u,t)=>{const e=u.faces.map(a=>yn(a.vertices.map(l=>l.viewCoordinates))),s=t(e),n=u.vertices.map(a=>({logicalCoordinates:a.logicalCoordinates,viewCoordinates:a.viewCoordinates.timesScalar(s)})),r=new Map(n.map((a,l)=>[u.vertices[l],a]));return{vertices:n,faces:u.faces.map(a=>({logicalCoordinates:a.logicalCoordinates,vertices:a.vertices.map(l=>r.get(l))}))}},Sn=(u,t)=>je(u,e=>Math.sqrt(t/(Xt.sum(e)/e.length))),Bn=(u,t)=>je(u,e=>Math.sqrt(t/Math.min(...e)));class En{constructor(t,e){this.start=t,this.end=e}isCanonicalHalfEdge(){return this.start.x<this.end.x||this.start.x===this.end.x&&this.start.y<this.end.y}}class Tn{constructor(){z(this,"identifiers",[]);z(this,"canonicalIdentifiers",[]);z(this,"map",new Map)}add(t,e){if(it()&&R(t.x!==e.x||t.y!==e.y),this.lookupAttempt(t,e)!==null)return;const s=(n,r)=>{let a;this.map.has(n)?a=this.map.get(n):(a=new Map,this.map.set(n,a));const l=new En(n,r);a.set(r,l),this.identifiers.push(l),l.isCanonicalHalfEdge()&&this.canonicalIdentifiers.push(l)};s(t,e),s(e,t)}getAdjacentLocations(t){const e=this.map.get(t);return e?Array.from(e.keys()):[]}lookupAttempt(t,e){const s=this.map.get(t);return s?s.get(e)??null:null}lookup(t,e){const s=this.lookupAttempt(t,e);return it()&&R(s),s}lookupCanonical(t,e){const s=this.lookup(t,e);return s.isCanonicalHalfEdge()?s:this.lookup(e,t)}}const ts=u=>{const t=u.vertices;let e=u.faces;e=e.map(v=>_e(v.vertices.map(T=>T.viewCoordinates))>0?v:{logicalCoordinates:v.logicalCoordinates,vertices:v.vertices.slice().reverse()});const s=new Tn;e.forEach(v=>{for(let T=0;T<v.vertices.length;T++){const M=v.vertices[T].logicalCoordinates,$=v.vertices[(T+1)%v.vertices.length].logicalCoordinates;s.add(M,$)}});const n=new Map,r=new Map,a=new Map,l=new Map,o=v=>n.get(v)??null,h=v=>r.get(v)??null,d=(v,T)=>{const M=s.lookup(v,T);return l.get(M)??null},p=t.map(v=>new An(v.logicalCoordinates,v.viewCoordinates));p.forEach(v=>n.set(v.logicalCoordinates,v));const A=e.map(v=>new bn(v.logicalCoordinates,Pn(v.vertices.map(T=>T.viewCoordinates))));A.forEach(v=>r.set(v.logicalCoordinates,v));const b=s.canonicalIdentifiers.map(v=>new wn(o(v.start),o(v.end)));b.forEach(v=>a.set(s.lookupCanonical(v.start.logicalCoordinates,v.end.logicalCoordinates),v));const S=s.identifiers.map(v=>new xn(o(v.start),o(v.end),!v.isCanonicalHalfEdge()));S.forEach(v=>l.set(s.lookup(v.start.logicalCoordinates,v.end.logicalCoordinates),v)),b.forEach(v=>{const T=d(v.start.logicalCoordinates,v.end.logicalCoordinates),M=d(v.end.logicalCoordinates,v.start.logicalCoordinates);it()&&R(T),it()&&R(M),T.edge=v,M.edge=v,T.reversed=M,M.reversed=T,v.forwardHalf=T,v.reversedHalf=M,v.vertices=[v.start,v.end]}),e.forEach(v=>{const T=h(v.logicalCoordinates),M=v.vertices.map(N=>o(N.logicalCoordinates)),$=[],B=[];for(let N=0;N<M.length;N++){const W=v.vertices[N].logicalCoordinates,k=v.vertices[(N+1)%M.length].logicalCoordinates,q=v.vertices[(N+2)%M.length].logicalCoordinates,L=d(W,k);L.face=T;const tt=d(k,q);L.next=tt,tt.previous=L,B.push(L),$.push(L.edge)}T.halfEdges=B,T.edges=$,T.vertices=M}),S.forEach(v=>{v.face===void 0&&(v.face=null)}),b.forEach(v=>{v.forwardFace=v.forwardHalf.face,v.reversedFace=v.reversedHalf.face,v.faces=[v.forwardFace,v.reversedFace].filter(T=>T!==null)});const P=new Set(S.filter(v=>v.face===null)),w=[],x=[];for(;P.size;){const v=P.values().next().value;P.delete(v);const T=B=>{it()&&R(B.face===null);const N=B.end.logicalCoordinates,q=s.getAdjacentLocations(N).filter(L=>L!==B.start.logicalCoordinates).map(L=>d(N,L)).filter(L=>L.face===null);return it()&&R(q.length===1),q[0]},M=[v];let $=T(v);for(v.next=$,$.previous=v;$!==v;){M.push($),P.delete($);const B=$;$=T($),B.next=$,$.previous=B}_e(M.map(B=>B.start.viewCoordinates))<0?w.push(M):x.push(M)}return it()&&R(w.length===1),p.forEach(v=>{const T=s.getAdjacentLocations(v.logicalCoordinates),M=d(T[0],v.logicalCoordinates);let $=M;const B=[M];for(;$.reversed.previous!==M;)it()&&R($.reversed.previous),$=$.reversed.previous,B.push($);v.incomingHalfEdges=B,v.outgoingHalfEdges=B.map(N=>N.reversed),v.edges=B.map(N=>N.edge),v.faces=B.map(N=>N.face).filter(N=>N!==null)}),{edges:b,vertices:p,faces:A,halfEdges:S,outerBoundary:w[0],innerBoundaries:x}};class es{constructor(t){z(this,"edges");z(this,"vertices");z(this,"faces");z(this,"halfEdges");z(this,"outerBoundary");z(this,"innerBoundaries");this.boardDescriptor=t,this.edges=t.edges,this.vertices=t.vertices,this.faces=t.faces,this.halfEdges=t.halfEdges,this.outerBoundary=t.outerBoundary,this.innerBoundaries=t.innerBoundaries}}const ss=u=>{it()&&(u.edges.forEach(t=>{const e=t.forwardHalf,s=t.reversedHalf;R(e.edge===t),R(s.edge===t),R(!e.isReversed),R(s.isReversed),R(e.reversed===s),R(s.reversed===e),R(e.start===t.start),R(e.end===t.end),R(s.start===t.end),R(s.end===t.start),R(e.next.previous===e),R(e.previous.next===e),R(s.next.previous===s),R(s.previous.next===s),R(e.next!==e),R(e.previous!==e),R(s.next!==s),R(s.previous!==s),R(e.next.face===e.face),R(e.previous.face===e.face),R(s.next.face===s.face),R(s.previous.face===s.face),R(e.face===t.forwardFace),R(s.face===t.reversedFace)}),u.vertices.forEach(t=>{t.incomingHalfEdges.forEach(n=>{R(n.end===t)}),t.outgoingHalfEdges.forEach(n=>{R(n.start===t)});const e=n=>t.incomingHalfEdges[(n+t.incomingHalfEdges.length)%t.incomingHalfEdges.length],s=n=>t.outgoingHalfEdges[(n+t.outgoingHalfEdges.length)%t.outgoingHalfEdges.length];Xt.range(0,t.incomingHalfEdges.length).forEach(n=>{const r=e(n),a=s(n);R(r.reversed===a),R(r.next===s(n-1)),R(a.previous===e(n+1))}),t.edges.forEach(n=>{R(n.start===t||n.end===t),R(t.incomingHalfEdges.includes(n.forwardHalf)||t.outgoingHalfEdges.includes(n.forwardHalf)),R(t.incomingHalfEdges.includes(n.reversedHalf)||t.outgoingHalfEdges.includes(n.reversedHalf)),n.forwardFace&&(R(n.forwardFace.vertices.includes(t)),R(t.faces.includes(n.forwardFace))),n.reversedFace&&(R(n.reversedFace.vertices.includes(t)),R(t.faces.includes(n.reversedFace)))}),t.faces.forEach(n=>{R(n.vertices.includes(t))})}))};class Nn extends es{constructor(e,s,n,r=0){let a,l;n?(a=new E(Math.sqrt(3),0).timesScalar(s),l=new E(Math.sqrt(3)/2,3/2).timesScalar(s)):(a=new E(3/2,Math.sqrt(3)/2).timesScalar(s),l=new E(0,Math.sqrt(3)).timesScalar(s));const o=[new E(1,0),new E(1,-1),new E(0,-1),new E(-1,0),new E(-1,1),new E(0,1)],h=Xt.range(0,6).map(w=>o[w].plus(o[(w+1)%6])),d=w=>h.map(x=>x.plus(w.timesScalar(3))),p=(w,x)=>(Math.abs(w.x-x.x)+Math.abs(w.x+w.y-x.x-x.y)+Math.abs(w.y-x.y))/2,A=[];for(let w=-e;w<=e;w++)for(let x=Math.max(-e,-w-e);x<=Math.min(e,-w+e);x++){const v=new E(w,x);p(v,new E(0,0))>=r&&A.push(v)}const S=Xt.uniqWith(A.flatMap(d),(w,x)=>w.equals(x)).map(w=>({logicalCoordinates:w,viewCoordinates:a.timesScalar(w.x).plus(l.timesScalar(w.y)).timesScalar(1/3)})),P=A.map(w=>({logicalCoordinates:w,vertices:d(w).map(x=>{const v=S.find(T=>T.logicalCoordinates.equals(x));return it()&&R(v),v})}));super(ts(Sn({vertices:S,faces:P},s)));z(this,"isHexagonal",!0);this.radius=e,this.scale=s,this.isPointyTop=n,this.holeRadius=r,it()&&ss(this)}static enumeratePointyFaceCoordinates(e){const s=[];for(let n=-e;n<=e;n++)for(let r=Math.max(-e,-n-e);r<=Math.min(e,-n+e);r++)s.push(new E(r,n));return s}}class Ln extends es{constructor(e,s){const n=[],r=new Map,a=(o,h)=>{const d=`${o},${h}`;if(!r.has(d)){const p={logicalCoordinates:new E(o,h),viewCoordinates:new E(o,h)};n.push(p),r.set(d,p)}return r.get(d)},l=Xt.range(0,s).flatMap(o=>Xt.range(0,e).map(h=>({logicalCoordinates:new E(h,o),vertices:[a(h,o),a(h+1,o),a(h+1,o+1),a(h,o+1)]})));super(ts({vertices:n,faces:l}));z(this,"isSquare",!0);this.width=e,this.height=s,it()&&ss(this)}}const Hn=(u,t)=>{const e=Xt.sortBy(u),s=[];let n=[];for(let a=0;a<e.length;a++){const l=e[a];n.length===0||Math.abs(n[n.length-1]-l)<=t?n.push(l):(s.push(n),n=[l])}n.length>0&&s.push(n);const r=new Map;return s.forEach(a=>{const l=Xt.sum(a)/a.length;a.forEach(o=>r.set(o,l))}),r};export{tn as A,xn as B,sn as C,bs as D,Bn as E,Ct as G,Nn as H,ve as L,ee as O,qs as S,Xt as _,wn as a,bn as b,An as c,es as d,it as e,R as f,Pn as g,_e as h,$n as i,Ln as j,ts as k,Hn as l,Js as m,Je as n,js as o,_s as p,on as q,Ke as r,vn as s,ms as t,vs as u,ss as v,Us as w,_t as x,Ks as y,en as z};
