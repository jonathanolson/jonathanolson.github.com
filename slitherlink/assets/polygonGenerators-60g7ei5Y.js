import{N as D,F as A,P as F}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{k as x,R as E,V as u}from"./UnivariatePolynomial-CzQEP6td.js";import{_ as b,S as k,L as B,e as R,f as M,G as I,I as N,J as H,K as W,M as G,N as L,O as p,Q as X,R as Y,T as $,U as J,V as Q,W as U,X as _,Y as j,Z as z,$ as K,a0 as Z,a1 as ee,a2 as se,a3 as le,a4 as re,a5 as te,a6 as ae,a7 as ie,a8 as de,a9 as ce,aa as pe}from"./patternBoards-7WmHeiIn.js";import{N as ge,E as oe}from"./DisplayEmbedding-_katxJlX.js";import{c as C}from"./Theme-CMAJrJpo.js";import{C as ue}from"./BasicPuzzle-B1djSMlq.js";import{D as P,F as q,M as V,H as he}from"./SATSolver-CcH7PLXT.js";import{S as w}from"./SlitherQueryParameters-CBL8UsTw.js";class Me extends D{constructor(c,e,g,i=null){let l;const h=s=>new k().moveToPoint(s.start.viewCoordinates).lineToPoint(s.end.viewCoordinates).getStrokedShape(new B({lineWidth:.2,lineCap:"round"})).getStrokedShape(new B({lineWidth:.02})),r=(s,t)=>new F(h(s),{fill:t}),f=[];if(e.type==="ForcedLine")l=[r(e.whiteEdge,"red"),r(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")l=[r(e.whiteEdge,"red"),...e.redEdges.map(s=>r(s,"blue"))];else if(e.type==="JointToRed")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.blackEdges.map(s=>r(s,"blue"))];else if(e.type==="FaceSatisfied")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.blackEdges.map(s=>r(s,"blue"))];else if(e.type==="FaceAntiSatisfied")l=[...e.whiteEdges.map(s=>r(s,"red")),...e.redEdges.map(s=>r(s,"blue"))];else if(e.type==="ForcedSolveLoop")l=[...e.regionEdges.map(s=>r(s,"blue")),...e.pathEdges.map(s=>r(s,"red"))];else if(e.type==="PrematureForcedLoop")l=[...e.regionEdges.map(s=>r(s,"blue")),...e.pathEdges.map(s=>r(s,"red"))];else if(e.type==="CompletingEdgesAfterSolve")l=[...e.whiteEdges.map(s=>r(s,"red"))];else if(e.type==="FaceColoringBlackEdge")l=[r(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")l=[r(e.edge,"red")];else if(e.type==="FaceColorToBlack")l=[r(e.edge,"red")];else if(e.type==="FaceColorToRed")l=[r(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")l=[...e.face.edges.map(s=>r(s,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")l=[...e.balancedPairs.flatMap((s,t)=>{const a=["green","blue","black"][t%3],o=["magenta","orange","yellow"][t%3];return[...s[0].map(y=>r(y,a)),...s[1].map(y=>r(y,o))]})],e.type==="FaceColorMatchToRed"?l.push(...e.matchingEdges.map(s=>r(s,"red"))):e.type==="FaceColorMatchToBlack"?l.push(...e.matchingEdges.map(s=>r(s,"red"))):e.type==="FaceColorBalance"&&(l.push(...e.matchingEdges.map(s=>r(s,"orange"))),l.push(...e.oppositeEdges.map(s=>r(s,"red"))));else if(e.type==="DoubleMinusOneFaces")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")l=[e.sector.edge,e.sector.next.edge].map(s=>r(s,"red"));else if(e.type==="ForcedSector"){const s=[...e.toRedEdges,...e.toBlackEdges];l=[e.sector.edge,e.sector.next.edge].map(t=>r(t,s.includes(t)?"red":"blue"))}else if(e.type==="StaticFaceSectors")l=b.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="VertexState")l=e.vertex.edges.map(s=>r(s,"blue"));else if(e.type==="VertexStateToEdge")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="VertexStateToSector")l=b.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")l=b.uniq([...e.facesA,...e.facesB].flatMap(s=>s.edges)).map(s=>r(s,"red"));else if(e.type==="FaceState")l=e.face.edges.map(s=>r(s,"red"));else if(e.type==="FaceStateToEdge")l=[...e.toBlackEdges.map(s=>r(s,"red")),...e.toRedEdges.map(s=>r(s,"red"))];else if(e.type==="FaceStateToSector")l=b.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>r(s,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const s=new Set([...e.facesA,...e.facesB].flatMap(a=>a.edges)),t=e.face.edges.filter(a=>!s.has(a));l=[...[...s].map(a=>r(a,"red")),...t.map(a=>r(a,"blue"))]}else if(e.type==="FaceStateToVertexState")l=e.face.edges.filter(t=>e.vertices.includes(t.start)||e.vertices.includes(t.end)).map(t=>r(t,"red"));else if(e.type==="Pattern"){if(l=[],i){const s=ge.getDisplayEmbedding(e.rule.patternBoard,e.boardPatternBoard,e.boardPatternBoard.board,e.embedding),t=.5+.05,a=.15,o=s.expandedBounds.top+a-(i.top+t),y=i.bottom-t-(s.expandedBounds.bottom-a),n=new oe(e.rule,s,{maxWidth:i.width-2*t,maxHeight:Math.max(o,y),inputListeners:[new A({fire:()=>{console.log(e.rule.getBinaryIdentifier());const m=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");m&&m.focus()}})],cursor:"pointer"});o>y?n.centerBottom=s.expandedBounds.centerTop.plusXY(0,-a):n.centerTop=s.expandedBounds.centerBottom.plusXY(0,a),n.left<i.left+t&&(n.left=i.left+t),n.right>i.right-t&&(n.right=i.right-t);{const m=s.tightBounds.dilated(.21),T=.3;l.push(new F(k.roundRectangle(m.x,m.y,m.width,m.height,T,T),{stroke:C.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const m=s.tightBounds.dilated(.21),T=.3;l.push(new F(k.roundRectangle(m.x,m.y,m.width,m.height,T,T),{stroke:C.blackLineColorProperty,lineWidth:.13,pickable:!1}))}l.push(n)}}else l=[],console.log(`unknown type: ${e.type}`);super({children:l,pickable:e.type==="Pattern"?null:!1}),this.board=c,this.annotation=e,this.style=g,this.disposeEmitter.addListener(()=>f.forEach(s=>s()))}}let S=null,v=0;const ve=()=>{if(S&&(v++,v>5)){const d=S;S=null,d(null)}},fe=async function(d){return new Promise((c,e)=>{S=c,v=0,w.debugSleep&&console.log("sleep start"),setTimeout(()=>{w.debugSleep&&console.log("sleep end"),S===c&&(S=null,c(null)),w.debugSleep&&console.log("resolved")},d)})};class me extends Error{constructor(){super("Interrupted")}}const O=async function(d,c){if(await fe(d),w.debugSleep&&console.log("after sleep before interrupt check"),c.value)throw new me},Be=async(d,c,e)=>{let g=0;for(;g++<100;){const i=ue.fromFaces(d,()=>null),l=x.shuffle(d.faces);let h=-1,r=[];const f=s=>{try{return r=q(d,s,{maxIterations:1e4,failOnMultipleSolutions:!0}),r.length}catch(t){if(t instanceof V)return 2;if(t instanceof he)return 0;throw t}};for(const s of l){w.debugSleep&&console.log("going to sleep"),c&&await O(0,c),w.debugSleep&&console.log("finished sleep, generating next!");let t=x.shuffle(b.range(0,s.edges.length));t[0]===0&&(t=x.shuffle(t));for(const a of t){const o=i.createDelta();if(o.setFaceValue(s,a),h=f(o),h>=1){o.apply(i),e&&e.emit(d.faces.indexOf(s),a);break}}if(h===1)break}if(h===1)return P(d,i,r[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},Ce=async(d,c=()=>!0,e,g)=>{const i=d.board,l=d.cleanState.clone(),h=x.shuffle(i.faces),r=f=>{try{return q(i,f,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(s){if(s instanceof V)return!0;throw s}};R()&&M(!r(l),"Initial state has multiple solutions"),R()&&M(c(i,l.clone()),"Initial state is not easy enough");for(const f of h){e&&await O(0,e);const s=l.getFaceValue(f);if(s===null){g&&g.emit(i.faces.indexOf(f),null);continue}const t=l.createDelta();t.setFaceValue(f,null),!r(t)&&c(i,t.clone())?(t.apply(l),g&&g.emit(i.faces.indexOf(f),null)):g&&g.emit(i.faces.indexOf(f),s)}return P(d.board,l,d.blackEdges)},ne={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new E(2,50)},height:{label:"Height",type:"integer",range:new E(2,50)}},defaultParameterValues:{width:6,height:10},generate:d=>{const c=d.width,e=d.height;return b.range(0,e).flatMap(g=>b.range(0,c).map(i=>[new u(i,g),new u(i+1,g),new u(i+1,g+1),new u(i,g+1)]))}},ye={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new E(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new E(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:d=>{const c=d.radius,e=d.isPointyTop,g=d.holeRadius;let i,l;e?(i=new u(Math.sqrt(3),0),l=new u(Math.sqrt(3)/2,3/2)):(i=new u(3/2,Math.sqrt(3)/2),l=new u(0,Math.sqrt(3)));const h=[new u(1,0),new u(1,-1),new u(0,-1),new u(-1,0),new u(-1,1),new u(0,1)],r=b.range(0,6).map(a=>h[a].plus(h[(a+1)%6])),f=a=>r.map(o=>o.plus(a.timesScalar(3))),s=(a,o)=>(Math.abs(a.x-o.x)+Math.abs(a.x+a.y-o.x-o.y)+Math.abs(a.y-o.y))/2,t=[];for(let a=-c;a<=c;a++)for(let o=Math.max(-c,-a-c);o<=Math.min(c,-a+c);o++){const y=new u(a,o);s(y,new u(0,0))>=g&&t.push(f(y).map(n=>i.timesScalar(n.x).plus(l.timesScalar(n.y)).timesScalar(1/3)))}return t}},be={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:d=>{const c={6:I,10:N,11:H,13:W,14:G,20:L}[d.radius];R()&&M(c);const e=.01,g=c.thinShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(h=>h.timesScalar(e)));return[...c.thickShape.subpaths.filter(l=>l.segments.length).map(l=>l.points.slice(0,-1).map(h=>h.timesScalar(e))),...g]}},Pe=[ne,p(X,{width:8,height:8}),ye,p(Y,{width:8,height:8,squareRegion:!0}),p($,{width:5,height:6,squareRegion:!0}),p(J,{width:6,height:5}),p(Q,{width:9,height:9}),p(U,{width:9,height:9}),p(_,{width:7,height:8}),p(j),p(z),p(K),p(Z,{squareRegion:!0}),p(ee),p(se),p(le,{width:9,height:9}),p(re),p(te,{width:9,height:9}),p(ae),p(ie),p(de,{width:6,height:8,squareRegion:!0}),p(ce),p(pe),be];export{Me as A,Ce as a,Be as g,O as i,Pe as p,fe as s,ve as w};
