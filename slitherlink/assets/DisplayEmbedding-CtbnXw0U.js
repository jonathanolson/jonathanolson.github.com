var ot=Object.defineProperty;var rt=(d,r,e)=>r in d?ot(d,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[r]=e;var b=(d,r,e)=>(rt(d,typeof r!="symbol"?r+"":r,e),e);import{T as n,P as te,E as Ye,d as Xe,o as le,c as je,D as st,V as D,h as ue,C as it,B as Ce}from"./UnivariatePolynomial-1rLpyqfN.js";import{c as I,h as x,B as J,F as Pe,N as L,P as R,M as ce,l as nt,L as Ue,C as Ne,m as ze,T as _e,G as at,R as lt,H as qe}from"./PhetioControlledVisibilityProperty-B_Gl7maC.js";import{E as H,F as ie,S as v,V as ct,B as ke,C as dt}from"./BasicPuzzle-BvzExADk.js";import{b as pt,L as ht,a as ut,c as ft,P as Je}from"./TextPushButton-BlKBVbG9.js";import{h as Fe,S as T,L as Ee,_ as be,G as gt,e as B,f as M,m as Ze,k as mt,d as wt}from"./getCoordinateClusteredMap-Bd_wM-c0.js";import{e as Ct,f as Pt,g as xe,K as yt,h as Oe,i as St,j as vt,v as Ae,k as Et,m as Be,w as bt,n as U,q as Vt,x as Tt,y as Lt,z as Nt,J as z,H as kt,F as Ft,B as xt,D as Ot,c as j,P as At,Q as fe,u as Bt,s as Mt,r as It}from"./Theme-Bm_Rw3jP.js";import{b as Rt,c as Ht,d as Dt,T as Wt,W as Yt,a0 as Xt,C as Q,a5 as jt,M as Ut,N as zt,P as _t,Q as qt,e as Jt,Z as Ve,U as Zt,i as Gt,a6 as Kt,F as $t,g as pe,a as Qt}from"./autoSolver-Bsgd1vdv.js";import{A as eo}from"./ShadedSphereNode-DjM1OiL_.js";import{d as to,B as oo,R as ro,S as so,a as io,b as no,c as ao,F as lo}from"./SectorOnlyOneFeature-B6gNVzOk.js";import{c as co}from"./getPeriodicTilingGenerator-zRiID_iR.js";const Ge=(d,r,e,t)=>(o,s,h)=>{const i=[new Rt(o,s),new Ht(o,s)];return(d||r||e||t)&&(i.push(new Dt(o,s)),(r||e||t)&&(i.push(new Wt(o,s)),(e||t)&&(i.push(new Yt(o,s)),t&&i.push(new Xt(o,s))))),new Q(i)},po={edgesVisibleProperty:Ct,edgesHaveColorsProperty:Pt,faceColorsVisibleProperty:xe,faceColorThresholdProperty:yt,sectorsVisibleProperty:Oe,sectorsNextToEdgesVisibleProperty:St,sectorsTrivialVisibleProperty:vt,vertexStateVisibleProperty:Ae,allVertexStateVisibleProperty:Et,faceStateVisibleProperty:Be,whiteLineVisibleProperty:bt,redLineVisibleProperty:U,verticesVisibleProperty:Vt,smallVertexProperty:Tt,redXsVisibleProperty:Lt,redXsAlignedProperty:Nt,faceValueStyleProperty:z,redLineStyleProperty:kt,vertexStyleProperty:Ft,joinedLinesJoinProperty:xt,joinedLinesCapProperty:Ot,safeSolverFactoryProperty:new I([xe,Oe,Ae,Be],(d,r,e,t)=>Ge(d,r,e,t)),autoSolverFactoryProperty:jt,theme:j},Z=(d,r,e,t,o)=>{const s=Ge(d,r,e,t);return{faceColorsVisibleProperty:new J(d),sectorsVisibleProperty:new J(r),vertexStateVisibleProperty:new J(e),faceStateVisibleProperty:new J(t),safeSolverFactoryProperty:new te(s),autoSolverFactoryProperty:o?new I([o],h=>(i,l,p)=>new Q([s(i,l,p),h(i,l,p)])):new te(s)}},oe=new I([Ut,zt],(d,r)=>(e,t,o)=>new Q([new _t(e,t,{solveJointToRed:!0,solveForcedLineToBlack:d,solveAlmostEmptyToRed:!0},o?void 0:[]),new qt(e,t,{solveToRed:!0,solveToBlack:d},o?void 0:[]),...r?[new Jt(e,t,{solveToRed:!0,solveToBlack:d,resolveAllRegions:!1},o?void 0:[])]:[]])),ho=new I([oe],d=>(r,e,t)=>new Q([d(r,e,t),new Ve(r,e,{solveToRed:!0,solveToBlack:!0})])),Ke=new I([oe],d=>(r,e,t)=>new Q([d(r,e,t),new Zt(r,e,t?void 0:[])])),uo=new I([Ke],d=>(r,e,t)=>new Q([d(r,e,t),new Ve(r,e,{solveToRed:!0,solveToBlack:!0})])),fo=d=>({...Z(!0,!1,!1,!1,oe),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),go=d=>({...Z(!0,!1,!1,!1,ho),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),mo=d=>({...Z(!0,!1,!1,!1,new te((r,e,t)=>new Q([new Ve(r,e,{solveToRed:!0,solveToBlack:!0},t?void 0:[])]))),theme:d,edgesVisibleProperty:new n(!1),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),wo=d=>({...Z(!1,!1,!1,!1,oe),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:U,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),Co=d=>({...Z(!0,!0,!1,!1,Ke),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Po=d=>({...Z(!0,!0,!1,!1,uo),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),yo=d=>({...Z(!0,!1,!0,!1,oe),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),So=d=>({...Z(!0,!1,!1,!0,oe),theme:d,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:z,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),vo=fo(j),Eo=go(j),bo=mo(j),$e=wo(j),Vo=Co(j),To=Po(j),Lo=yo(j),No=So(j),ye={basicLines:vo,basicFaceColoring:Eo,pureFaceColor:bo,classic:$e,basicSectors:Vo,sectorsWithColors:To,vertexState:Lo,faceState:No,custom:po},Me=$e,ko=d=>({edgesVisibleProperty:new x(d,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new x(d,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new x(d,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new x(d,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new x(d,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new x(d,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new x(d,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new x(d,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new x(d,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new x(d,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new x(d,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new x(d,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new x(d,{derive:"verticesVisibleProperty"}),smallVertexProperty:new x(d,{derive:"smallVertexProperty"}),redXsVisibleProperty:new x(d,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new x(d,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new x(d,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new x(d,{derive:"redLineStyleProperty"}),vertexStyleProperty:new x(d,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new x(d,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new x(d,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new x(d,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new x(d,{derive:"autoSolverFactoryProperty"}),theme:At(new I([d],r=>r.theme))}),Fo=new pt("puzzleStyle",{serialize:d=>Object.keys(ye).find(r=>ye[r]===d),deserialize:d=>d?ye[d]??Me:Me}),K=ko(Fo),pr=new ht("showPuzzleStyleProperty",!0),O=class O extends Ye{constructor(r){super(),this.isEnabledProperty=r}};b(O,"EDGE_STATE",new O(new J(!0))),b(O,"EDGE_STATE_REVERSED",new O(new J(!0))),b(O,"FACE_COLOR_MATCH",new O(K.faceColorsVisibleProperty)),b(O,"FACE_COLOR_OPPOSITE",new O(K.faceColorsVisibleProperty)),b(O,"SECTOR_STATE",new O(K.sectorsVisibleProperty)),b(O,"VERTEX_STATE",new O(K.vertexStateVisibleProperty)),b(O,"FACE_STATE",new O(K.faceStateVisibleProperty)),b(O,"FACE_VALUE",new O(new J(!1))),b(O,"DELETE_FACE",new O(new J(!1))),b(O,"enumeration",new Xe(O));let W=O;const G=new ut("editModeProperty",W.EDGE_STATE);let Se=null;const Ie=d=>{d||(G.value=W.EDGE_STATE)};G.link(d=>{Se&&Se.isEnabledProperty.unlink(Ie),Se=d,d.isEnabledProperty.link(Ie)});const hr=d=>{d.isEnabledProperty.value&&(G.value=d)},xo=new I([G],d=>d===W.EDGE_STATE||d===W.EDGE_STATE_REVERSED),Qe=new I([G],d=>d===W.FACE_COLOR_MATCH||d===W.FACE_COLOR_OPPOSITE),Oo=new I([G],d=>d===W.SECTOR_STATE),Ao=new I([G],d=>d===W.VERTEX_STATE),Bo=new I([G,Qe],(d,r)=>r||d===W.FACE_STATE||d===W.FACE_VALUE||d===W.DELETE_FACE),ge=(d,r,e,t)=>{const o=new Pe({mouseButton:0,fire:i=>{var l;return e&&e(d,(l=i.domEvent)!=null&&l.shiftKey?2:0)}}),s=new Pe({mouseButton:2,fire:i=>{var l;return e&&e(d,(l=i.domEvent)!=null&&l.shiftKey?0:2)}}),h=new Pe({mouseButton:1,fire:i=>e&&e(d,1)});r.addInputListener(o),r.addInputListener(s),r.addInputListener(h),r.cursor="pointer",o.isHighlightedProperty.lazyLink(i=>{t&&t(d,i)}),r.disposeEmitter.addListener(()=>{o.dispose(),s.dispose(),h.dispose()})};class me extends L{constructor(r,e,t,o){const s=le()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},o);super({pickableProperty:Qe}),this.outerBoundary=r,this.innerBoundaries=e,this.style=t,!s.noninteractive&&ge(null,this,s.facePressListener,s.faceHoverListener);const h=r.map(P=>P.start.viewCoordinates),i=s.useBackgroundOffsetStroke,l=s.backgroundOffsetDistance,a=Fe(h)>0?-l:l,c=P=>{const u=new gt;u.addShape(0,P),u.computeSimplifiedFaces(),u.computeFaceInclusion(S=>S[0]>0);const m=u.createFilledSubGraph(),w=m.facesToShape();return u.dispose(),m.dispose(),w},C=me.getOffsetBackgroundShape(r,i,l),g=e.map(P=>{const u=P.map(w=>w.start.viewCoordinates),m=T.polygon(u);if(i)return c(m.getOffsetShape(a));{const S=m.getStrokedShape(new Ee({lineWidth:2*l})).subpaths.map(f=>new T([f]));return c(be.minBy(S,f=>f.getArea()))}});this.children=[new R(C,{fill:t.theme.puzzleBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...g.map(P=>new R(P,{fill:t.theme.playAreaBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(r,e,t){const o=r.map(l=>l.start.viewCoordinates),s=T.polygon(o),i=Fe(o)>0?-t:t;if(e)return s.getOffsetShape(i).getSimplifiedAreaShape();{const l=s.getStrokedShape(new Ee({lineWidth:2*t})),p=l.subpaths.map(a=>new T([a]));try{return l.bounds.width===9.718028227819117?T.bounds(l.bounds):be.maxBy(p,a=>a.getArea()).getSimplifiedAreaShape()}catch{return T.bounds(l.bounds)}}}}const re=.03,se=.05,Mo=T.circle(re).makeImmutable(),Io=T.circle(se).makeImmutable(),Ro=T.rect(-re,-re,2*re,2*re).makeImmutable(),Ho=T.rect(-se,-se,2*se,2*se).makeImmutable();class Do extends L{constructor(r,e,t,o){super(),this.vertex=r;const s=new I([e,o.verticesVisibleProperty],(p,a)=>a&&r.edges.every(c=>p.getEdgeState(c)!==H.BLACK));this.disposeEmitter.addListener(()=>s.dispose());const h=new R(null,{translation:r.viewCoordinates,fill:o.theme.vertexColorProperty,visibleProperty:s});this.addChild(h);const i=ce.multilink([o.vertexStyleProperty,o.smallVertexProperty],(p,a)=>{p==="round"?h.shape=a?Mo:Io:p==="square"?h.shape=a?Ro:Ho:B()&&M(!1,`unhandled vertex style: ${p}`)});this.disposeEmitter.addListener(()=>i.dispose());const l=p=>{this.visible=!p};t.link(l),this.disposeEmitter.addListener(()=>t.unlink(l))}}class Wo extends L{constructor(r,e,t,o){const s=le()({textOptions:{font:fe,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},o);super({}),this.face=r;const h=T.polygon(r.vertices.map(p=>p.viewCoordinates));this.mouseArea=h,this.touchArea=h,!s.noninteractive&&ge(r,this,s.facePressListener,s.faceHoverListener);const i=new nt("",je({subScale:.7},s==null?void 0:s.textOptions)),l=ce.multilink([e,t.faceValueStyleProperty,t.theme.faceValueColorProperty,t.theme.faceValueCompletedColorProperty,t.theme.faceValueErrorColorProperty,t.theme.faceValueRatioColorProperty,t.faceStateVisibleProperty],(p,a,c,C,g,P,u)=>{const m=p.getFaceValue(r);this.visible=!u;let w,S,f=!1,y=!1;if(m===null)w="",S=null;else{let N=0,V=0;for(const F of r.edges){const k=p.getEdgeState(F);k===H.BLACK?N++:k===H.WHITE&&V++}if(a==="static"||m===0)w=`${m}`;else if(a==="remaining")w=`${m-N}`,f=N>0;else if(a==="ratio")m-N===0?w="0":(w=`${m-N}<sub style="color: ${P.toCSS()};">/<sub>${V}</sub></sub>`,y=!0),f=N>0;else throw new Error(`unhandled faceValueStyle: ${a}`);N<m?S=c:N===m?S=C:S=g}i.string=w,i.fill=S,i.maxWidth=y?.8:.9,i.maxHeight=y?.8:.9,i.center=r.viewCoordinates,this.children=[i]});this.disposeEmitter.addListener(()=>l.dispose())}}const q=.07,Yo=new T().moveTo(-q,-q).lineTo(q,q).moveTo(-q,q).lineTo(q,-q).makeImmutable();class Xo extends L{constructor(r,e,t,o,s){super({}),this.edge=r;const h=new I([e],f=>f.getEdgeState(r));this.disposeEmitter.addListener(()=>h.dispose());const i=r.start.viewCoordinates,l=r.end.viewCoordinates,p=i.average(l),a=new I([t,o.redXsVisibleProperty],(f,y)=>!f&&y);this.disposeEmitter.addListener(()=>a.dispose());const c=new R(Yo,{stroke:o.theme.xColorProperty,lineWidth:.025,center:p,visibleProperty:a}),C=f=>{c.rotation=f?l.minus(i).getAngle():0};o.redXsAlignedProperty.link(C),this.disposeEmitter.addListener(()=>o.redXsAlignedProperty.unlink(C));const g=new I([t,o.whiteLineVisibleProperty],(f,y)=>!f&&y);this.disposeEmitter.addListener(()=>g.dispose());const P=new Ue(i.x,i.y,l.x,l.y,{lineWidth:.02,stroke:o.theme.whiteLineColorProperty,visibleProperty:g}),u=new I([t,o.redLineVisibleProperty],(f,y)=>y);this.disposeEmitter.addListener(()=>u.dispose());const m=new R(null,{lineWidth:.02,stroke:o.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:u}),w=f=>{f==="middle"?m.shape=new T().moveToPoint(p.blend(i,.35)).lineToPoint(p.blend(l,.35)).makeImmutable():f==="gap"?m.shape=new T().moveToPoint(i).lineToPoint(i.blend(p,.35)).moveToPoint(l.blend(p,.35)).lineToPoint(l).makeImmutable():f==="full"?m.shape=new T().moveToPoint(i).lineToPoint(l).makeImmutable():B()&&M(!1,`Unknown red line style: ${f}`)};o.redLineStyleProperty.link(w),this.disposeEmitter.addListener(()=>o.redLineStyleProperty.unlink(w));const S=s==null?void 0:s.edgePressListener;if(S){const f=new T;if(r.faces.length===2)f.polygon([i,r.faces[0].viewCoordinates,l,r.faces[1].viewCoordinates]);else{B()&&M(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const y=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;B()&&M(y.previous.face===null),B()&&M(y.next.face===null);const N=y.start.viewCoordinates,V=y.end.viewCoordinates,F=y.previous.start.viewCoordinates,k=y.next.end.viewCoordinates,E=(Te,de,et)=>{const Le=de.minus(Te).normalized(),tt=et.minus(de).normalized();let _=Le.minus(tt);return _.getMagnitude()<1e-6?_=Le.getPerpendicular():_=_.normalized(),st.triangleAreaSigned(Te,de,de.plus(_))<0&&(_=_.negated()),_},A=E(F,N,V),we=E(N,V,k);f.polygon([N,r.faces[0].viewCoordinates,V,V.plus(we.times(s.backgroundOffsetDistance)),N.plus(A.times(s.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=f,!s.noninteractive&&ge(r,this,S,s.edgeHoverListener)}h.link(f=>{f===H.WHITE?this.children=[P]:f===H.BLACK?this.children=[]:this.children=[m,c]})}}class jo extends L{constructor(e,t,o){super({pickable:!1,visibleProperty:o.edgesVisibleProperty});b(this,"simpleRegionNodeMap",new Map);b(this,"regionIdMap",new Map);b(this,"weirdEdgeNodeMap",new Map);b(this,"regionContainer",new L);b(this,"weirdEdgeContainer",new L);b(this,"adjacentFacesMap",new Map);this.board=e,this.style=o,e.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(l=>l.getOtherFace(i)).filter(l=>l!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],t.value.getSimpleRegions().forEach(i=>this.addRegion(i)),t.value.getWeirdEdges().forEach(i=>this.addWeirdEdge(i)),this.updateHues();const s=(i,l)=>{const p=l.getSimpleRegions(),a=i.getSimpleRegions(),c=l.getWeirdEdges(),C=i.getWeirdEdges(),g=[],P=[];Ze(p,a,g,P,[]);const m=new Set(g);for(const w of P)if(this.regionIdMap.has(w.id)){const S=this.regionIdMap.get(w.id);this.replaceRegion(S,w),m.delete(S)}else this.addRegion(w);for(const w of m)this.removeRegion(w);for(const w of c)C.includes(w)||this.removeWeirdEdge(w);for(const w of C)c.includes(w)||this.addWeirdEdge(w);(P.length||g.length)&&this.updateHues()};t.lazyLink(s),this.disposeEmitter.addListener(()=>t.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const h=()=>this.updateHues();o.theme.simpleRegionHueLUTProperty.link(h),o.edgesHaveColorsProperty.lazyLink(h),this.disposeEmitter.addListener(()=>{o.theme.simpleRegionHueLUTProperty.unlink(h),o.edgesHaveColorsProperty.unlink(h)})}addRegion(e){const t=new ee(e,this.style);this.simpleRegionNodeMap.set(e,t),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(t)}replaceRegion(e,t){B()&&M(e.id===t.id);const o=this.simpleRegionNodeMap.get(e);o.updateRegion(t),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(t,o),this.regionIdMap.delete(e.id),this.regionIdMap.set(t.id,t)}removeRegion(e){const t=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(t),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),t.dispose()}addWeirdEdge(e){const t=e.start.viewCoordinates,o=e.end.viewCoordinates,s=new Ue(t.x,t.y,o.x,o.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){const t=this.weirdEdgeNodeMap.get(e);this.weirdEdgeContainer.removeChild(t),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const t=new D(0,0),o=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(1,0)},s=new Map,h=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const c=new Set;for(const g of a.simpleRegion.edges)for(const P of g.faces)c.add(P);const C=new Set;for(const g of c){C.add(g);for(const P of this.adjacentFacesMap.get(g))C.add(P)}for(const g of C){const P=s.get(g);if(P.length)for(const u of P){let m=!1;for(const w of h)if(w.a===u&&w.b===a){w.weight++,m=!0;break}m||h.push({a:u,b:a,weight:1})}P.push(a)}}const i=new Map;for(const a of e)i.set(a,D.ZERO.copy());const l=(a,c,C)=>{const g=i.get(a),P=i.get(c),u=a.hueVector.dot(c.hueVector),m=t.set(c.hueVector).subtract(a.hueVector);if(m.magnitude>1e-9){m.normalize();const w=.3,S=C*((Math.max(w,u)-w)/(1-w))**3;m.multiplyScalar(S),g.subtract(m),P.add(m)}};let p=1;for(let a=0;a<100;a++){p*=.99;for(const c of e)i.get(c).setXY(0,0);for(const c of h){const C=c.a,g=c.b,P=c.weight;l(C,g,P)}if(e.length<8)for(let c=0;c<e.length;c++){const C=e[c];for(let g=c+1;g<e.length;g++)l(C,e[g],.2)}for(const c of e){const C=i.get(c);C.multiplyScalar(p/c.edgeCount),c.hueVector.add(C),i.get(c).setXY(0,0)}o()}for(const a of e)a.updateHue()}}class ee extends R{constructor(e,t){const o=D.createPolar(1,ue.nextDoubleBetween(0,2*Math.PI));super(ee.toShape(e),{stroke:ee.hueVectorToPaint(o,t),lineWidth:.1,lineCap:"square",lineJoin:"round"});b(this,"hueVector");b(this,"edgeCount");this.simpleRegion=e,this.style=t,this.hueVector=o,this.edgeCount=e.edges.length;const s=i=>{this.lineJoin=i};t.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>t.joinedLinesJoinProperty.unlink(s));const h=i=>{this.lineCap=i};t.joinedLinesCapProperty.link(h),this.disposeEmitter.addListener(()=>t.joinedLinesCapProperty.unlink(h))}updateHue(){this.stroke=ee.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=ee.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,t){const o=t.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return B()&&M(s>=0&&s<o.length),t.edgesHaveColorsProperty.value?o[s]:t.theme.blackLineColorProperty}static toShape(e){const t=new T;let o=!0;for(const s of e.halfEdges)o&&(o=!1,t.moveToPoint(s.start.viewCoordinates)),t.lineToPoint(s.end.viewCoordinates);return e.isSolved&&t.close(),t.makeImmutable()}}class Uo extends L{constructor(e,t,o){const s=new L;super({pickable:!1,children:[s]});b(this,"faceColorNodeMap",new Map);b(this,"faceColorIdMap",new Map);b(this,"adjacentFacesMap",new Map);b(this,"faceColorNodeContainer");b(this,"dualColorViews",new Set);this.board=e,this.stateProperty=t,this.style=o,this.faceColorNodeContainer=s,e.faces.forEach(p=>{this.adjacentFacesMap.set(p,p.edges.map(a=>a.getOtherFace(p)).filter(a=>a!==null))});{const p=t.value.getFaceColors();for(const a of p)this.addFaceColor(a,t.value.getFacesWithColor(a));this.addDualColorViews(t.value,p)}this.updateHues();let h=t.value.clone();const i=p=>{const a=h;h=p.clone();const c=a.getFaceColors(),C=p.getFaceColors(),g=[],P=[],u=[];Ze(c,C,g,P,u);const m=new Set(g),w=this.removeInvalidDualColorViews(p),S=[...w];for(const f of P)if(w.add(f),this.faceColorIdMap.has(f.id)){const y=this.faceColorIdMap.get(f.id);this.replaceFaceColor(y,f,p.getFacesWithColor(f)),m.delete(y)}else this.addFaceColor(f,p.getFacesWithColor(f));for(const f of u)this.updateFaceColor(f,p.getFacesWithColor(f));for(const f of m)w.delete(f),this.removeFaceColor(f);this.addDualColorViews(p,[...w]),(P.length||g.length||S.length)&&this.updateHues()};t.lazyLink(i),this.disposeEmitter.addListener(()=>t.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const l=()=>this.updateHues();o.theme.faceColorBasicHueLUTProperty.lazyLink(l),o.theme.faceColorLightHueLUTProperty.lazyLink(l),o.theme.faceColorDarkHueLUTProperty.lazyLink(l),o.theme.faceColorInsideColorProperty.lazyLink(l),o.theme.faceColorOutsideColorProperty.lazyLink(l),o.theme.faceColorDefaultColorProperty.lazyLink(l),o.faceColorThresholdProperty.lazyLink(l),this.updateHues(),this.disposeEmitter.addListener(()=>{o.theme.faceColorBasicHueLUTProperty.unlink(l),o.theme.faceColorLightHueLUTProperty.unlink(l),o.theme.faceColorDarkHueLUTProperty.unlink(l),o.theme.faceColorInsideColorProperty.unlink(l),o.theme.faceColorOutsideColorProperty.unlink(l),o.theme.faceColorDefaultColorProperty.unlink(l),o.faceColorThresholdProperty.unlink(l)})}addFaceColor(e,t){const o=new ne(e,t,this.style);this.faceColorNodeMap.set(e,o),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(o)}replaceFaceColor(e,t,o){B()&&M(e.id===t.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(t,o),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(t,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(t.id,t)}updateFaceColor(e,t){const o=this.faceColorNodeMap.get(e);let s=o.faces.length!==t.length;if(!s)for(let h=0;h<t.length;h++){const i=o.faces[h],l=t[h];if(i!==l){s=!0;break}}s&&o.updateFaceColor(e,t)}removeFaceColor(e){const t=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(t),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),t.dispose()}addDualColorViews(e,t){const o=new Set(t);for(;o.size;){const s=o.values().next().value;o.delete(s);const h=this.faceColorNodeMap.get(s);B()&&M(h);const i=e.getOppositeFaceColor(s);if(i){B()&&M(o.has(i)),o.delete(i);const l=this.faceColorNodeMap.get(i);B()&&M(l),this.dualColorViews.add(new Re([h,l],this.style))}else this.dualColorViews.add(new Re([h],this.style))}}removeInvalidDualColorViews(e){const t=new Set,o=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,o)){for(const h of s.colorNodes)t.add(h.faceColor);this.dualColorViews.delete(s),s.dispose()}return t}updateHues(){const e=[...this.dualColorViews].filter(t=>t.colorNodes[0].faceColor.colorState!==ie.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:t.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const t=new D(0,0),o=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(ue.nextDouble()-.5,ue.nextDouble()-.5).normalize()},s=new Map,h=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const c=new Set;for(const g of a.faces)c.add(g);const C=new Set;for(const g of c){C.add(g);for(const P of this.adjacentFacesMap.get(g))C.add(P)}for(const g of C){const P=s.get(g);if(P){if(P.length)for(const u of P){let m=!1;for(const w of h)if(w.a===u&&w.b===a){w.weight++,m=!0;break}m||h.push({a:u,b:a,weight:1})}P.push(a)}}}const i=new Map;for(const a of e)i.set(a,D.ZERO.copy());const l=(a,c,C)=>{const g=i.get(a),P=i.get(c),u=a.hueVector.dot(c.hueVector),m=t.set(c.hueVector).subtract(a.hueVector);m.magnitudeSquared>1e-11&&m.normalize();const w=.2,S=Math.abs(u),f=C*((Math.max(w,S)-w)/(1-w))**3;m.multiplyScalar(f),g.subtract(m),P.add(m)};let p=1;for(let a=0;a<100;a++){p*=.99;for(const c of e)i.get(c).setXY(0,0);for(const c of h){const C=c.a,g=c.b,P=c.weight;l(C,g,P)}if(e.length<8)for(let c=0;c<e.length;c++){const C=e[c];for(let g=c+1;g<e.length;g++)l(C,e[g],.2)}for(const c of e){const C=i.get(c);C.multiplyScalar(p/c.faceCount),c.hueVector.add(C),i.get(c).setXY(0,0)}o()}}for(const t of this.dualColorViews)t.updateHue()}}const X=class X extends Ye{};b(X,"BASIC",new X),b(X,"PRIMARY",new X),b(X,"SECONDARY",new X),b(X,"enumeration",new Xe(X));let Y=X;class Re{constructor(r,e){b(this,"hueVector");b(this,"faceCount");if(this.colorNodes=r,this.style=e,B()&&M(r.length===1||r.length===2),this.faceCount=be.sum(this.colorNodes.map(t=>t.faceCount)),r.forEach(t=>{t.dualColorView=this}),r.length===1)r[0].type=Y.BASIC,this.hueVector=r[0].hueVector.copy();else{const t=r[0].faceCount>r[1].faceCount?r[0]:r[1],o=t===r[0]?r[1]:r[0];let s;t.type===Y.PRIMARY?s=t:o.type===Y.PRIMARY||t.type===Y.SECONDARY?s=o:(o.type,Y.SECONDARY,s=t);const h=s===t?o:t;this.hueVector=t.hueVector.copy(),s.type=Y.PRIMARY,h.type=Y.SECONDARY}}get faces(){return this.colorNodes.flatMap(r=>r.faces)}isStillValidInState(r,e){for(const t of this.colorNodes)if(!e.has(t.faceColor))return!1;return this.colorNodes.length===1?r.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:r.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const r of this.colorNodes)r.hueVector.set(this.hueVector),r.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const r of this.colorNodes)r.dualColorView=null}}class ne extends R{constructor(e,t,o){const s=D.createPolar(1,ue.nextDoubleBetween(0,2*Math.PI));super(ne.toShape(t));b(this,"hueVector");b(this,"faceCount");b(this,"dualColorView",null);b(this,"type",Y.BASIC);this.faceColor=e,this.faces=t,this.style=o,this.hueVector=s,this.faceCount=t.length}updateHue(e){e||this.faceColor.colorState!==ie.UNDECIDED?this.fill=ne.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,t){const o=t.length-this.faceCount;this.faceColor=e,this.faces=t,this.shape=ne.toShape(t),this.faceCount=t.length,this.dualColorView&&(this.dualColorView.faceCount+=o)}static hueVectorToPaint(e,t,o,s){const h=o===Y.BASIC?s.theme.faceColorBasicHueLUTProperty.value:o===Y.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,i=(Math.round(e.getAngle()*180/Math.PI)+360)%360;B()&&M(i>=0&&i<h.length);const l=h[i];if(t===ie.UNDECIDED)return l;{const a=(t===ie.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,c=a.alpha,C=new Ne(l);return new Ne((1-c)*C.red+c*a.red,(1-c)*C.green+c*a.green,(1-c)*C.blue+c*a.blue).toCSS()}}static toShape(e){const t=new T;for(const o of e)t.polygon(o.vertices.map(s=>s.viewCoordinates));return t.makeImmutable()}}const He=[.02,.02],zo=new Map([[v.NONE,[]],[v.ONLY_ZERO,[]],[v.ONLY_ONE,[]],[v.ONLY_TWO,[]],[v.NOT_ZERO,He],[v.NOT_ONE,[]],[v.NOT_TWO,He],[v.ANY,[]]]),ve=.2,De=.02,ae=class ae extends L{constructor(r,e,t,o){super(),this.sector=r;const s=ae.getSectorBaseShape(r,o.backgroundOffsetDistance);this.mouseArea=s,this.touchArea=s,!o.noninteractive&&ge(r,this,o.sectorPressListener,o.sectorHoverListener);const h=p=>{const a=r.start.viewCoordinates,c=r.end.viewCoordinates,C=r.next.end.viewCoordinates,g=a.minus(c),P=C.minus(c),u=g.normalized(),m=P.normalized(),w=m.minus(u).angle+Math.PI/2,S=g.angle;let f=P.angle;f<S&&(f+=2*Math.PI);const y=D.createPolar(.2,w),N=(F,k)=>(F.moveToPoint(u.timesScalar(k)),F.arcPoint(D.ZERO,k,S,f,!0),F),V=(F,k,E)=>(F.moveTo(k.x+E,k.y),F.circle(k,E),F);if(p===v.NONE)return new T().moveTo(y.x-.05,y.y-.05).lineTo(y.x+.05,y.y+.05).moveTo(y.x-.05,y.y+.05).lineTo(y.x+.05,y.y-.05).makeImmutable();if(p===v.ONLY_ZERO)return V(new T,y,.05).makeImmutable();if(p===v.ONLY_TWO)return new T().moveToPoint(u.timesScalar(.1).plus(y.timesScalar(.7))).lineToPoint(y.timesScalar(.7)).lineToPoint(m.timesScalar(.1).plus(y.timesScalar(.7))).makeImmutable();if(p===v.ONLY_ONE||p===v.NOT_TWO)return N(new T,ve).makeImmutable();if(p===v.NOT_ZERO||p===v.NOT_ONE)return N(N(new T,ve+De),ve-De).makeImmutable();if(p===v.ANY)return V(V(V(new T,y,.05),y,.03),y,.01).makeImmutable();throw new Error("Unhandled sector state")},i=new R(null,{translation:r.end.viewCoordinates,lineWidth:.01,lineCap:"butt",visibleProperty:t.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>i.dispose()),this.addChild(i);const l=ce.multilink([e,t.sectorsNextToEdgesVisibleProperty,t.sectorsTrivialVisibleProperty],(p,a,c)=>{const C=p.getEdgeState(r.edge),g=p.getEdgeState(r.next.edge),P=p.getSectorState(r);let u=null,m=null,w=[],S=.01;if(a||C===H.WHITE&&g===H.WHITE){let f=v.trivialStates.includes(P);if(P===v.NOT_ONE){const y=r.end.edges.filter(V=>p.getEdgeState(V)===H.BLACK),N=r.end.edges.filter(V=>p.getEdgeState(V)===H.WHITE);y.length===0&&N.length===2&&(f=!0)}(c||!f)&&(u=h(P)??null,m=ae.getStrokeFromStyle(P,t)??null,w=zo.get(P)??[],w.length&&(S=.015))}i.shape=u,i.stroke=m,i.lineDash=w,i.lineWidth=S});this.disposeEmitter.addListener(()=>l.dispose())}static getSectorBaseShape(r,e){const t=r.start.viewCoordinates,o=r.end.viewCoordinates,s=r.next.end.viewCoordinates,h=t.minus(o),i=s.minus(o),l=h.normalized(),a=i.normalized().minus(l).angle+Math.PI/2,c=r.face?r.face.viewCoordinates:D.createPolar(e,a).plus(o),C=t.average(o),g=s.average(o);return T.polygon([C,o,g,c]).makeImmutable()}static getSectorArcShape(r,e){const t=r.start.viewCoordinates,o=r.end.viewCoordinates,s=r.next.end.viewCoordinates,h=t.minus(o),i=s.minus(o),l=h.normalized(),p=h.angle;let a=i.angle;return a<p&&(a+=2*Math.PI),new T().moveToPoint(o).lineToPoint(l.timesScalar(e).plus(o)).arcPoint(o,e,p,a,!0).close().makeImmutable()}static getStrokeFromStyle(r,e){return r===v.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:r===v.NOT_ZERO?e.theme.sectorNotZeroColorProperty:r===v.NOT_ONE?e.theme.sectorNotOneColorProperty:r===v.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}};b(ae,"nameMap",new Map([[v.NONE,"Invalid"],[v.ONLY_ZERO,"No Lines"],[v.ONLY_ONE,"Only One Line"],[v.ONLY_TWO,"Both Lines"],[v.NOT_ZERO,"At Least One Line"],[v.NOT_ONE,"Zero or Two Lines"],[v.NOT_TWO,"Less Than Two Lines"],[v.ANY,"Any Lines"]]));let $=ae;class _o extends L{constructor(r,e,t,o){super({pickable:!1}),this.vertex=r;const s=.12,i=r.edges.map(u=>u.getOtherVertex(r).viewCoordinates.minus(r.viewCoordinates).normalized()).map(u=>u.times(s)),p=T.polygon(it.grahamScan([D.ZERO,...i],!1)).getOffsetShape(-.05),a=new R(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),c=new R(p,{translation:r.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[a,...i.map(u=>new ze({radius:.02,translation:u,fill:o.theme.vertexStatePointProperty}))]});let C=null;const g=ce.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(u,m,w)=>{const S=()=>{this.children=[]};if(!m){S();return}const f=u.getVertexState(r);if(!w){let y=!1,N=!1;const V=new Set;for(const k of r.edges){const E=u.getEdgeState(k);y=y||E===H.BLACK,N=N||E===H.WHITE,E===H.WHITE&&V.add(k)}if(y||!N){S();return}if(ct.fromLookup(r,(k,E)=>V.has(k)&&V.has(E),!0).equals(f)){S();return}}if(!C||!C.equals(f)){C=f;const y=new T;for(const N of f.getAllowedPairs()){const V=F=>F.getOtherVertex(r).viewCoordinates.minus(r.viewCoordinates).normalized().times(s);y.moveToPoint(V(N[0])),y.lineToPoint(V(N[1]))}f.allowsEmpty()&&(y.moveTo(.03,0),y.circle(D.ZERO,.03),y.close()),y.makeImmutable(),a.shape=y}this.children=[c]});this.disposeEmitter.addListener(()=>g.dispose());const P=u=>{this.visible=!u};t.link(P),this.disposeEmitter.addListener(()=>t.unlink(P))}}class qo extends _e{constructor(r,e){const t=le()({font:Bt,fill:j.uiForegroundColorProperty},e);super(r,t)}}class Jo extends L{constructor(r,e,t,o){super({translation:r.viewCoordinates}),this.face=r;const s=ce.multilink([e,o.faceStateVisibleProperty],(i,l)=>{if(this.children=[],l){const p=i.getFaceState(r),a=p.possibilityCount===0||p.possibilityCount>9;let c;const C=p.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(a)c=new qo(p.possibilityCount,{font:fe,maxWidth:.4,maxHeight:.4});else{const g=new Set(r.vertices);c=new at({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(p.possibilityCount)),children:p.getAllowedCombinations().map(P=>{const u=new L,m=new Set(P.map(f=>f.start)),w=new Set(P.map(f=>f.end)),S=f=>f.minus(r.viewCoordinates);if(u.addChild(new R(T.polygon(r.vertices.map(f=>S(f.viewCoordinates))),{stroke:C,lineWidth:.03,opacity:.2})),m.size){const f=new T;if(P.length===r.edges.length)f.polygon(r.vertices.map(y=>S(y.viewCoordinates)));else{const y=new Set(P);for(;y.size;){const N=[...g].find(k=>[...y].filter(E=>E.start===k||E.end===k).length===1);B()&&M(N);let V=N,F=[...y].find(k=>k.start===V||k.end===V)??null;for(f.moveToPoint(S(V.viewCoordinates));F;)y.delete(F),V=F.getOtherVertex(V),f.lineToPoint(S(V.viewCoordinates)),F=[...y].find(k=>k.start===V||k.end===V)??null}}u.addChild(new R(f,{stroke:C,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const f of r.vertices)!m.has(f)&&!w.has(f)&&u.addChild(new ze(.1,{fill:C,translation:S(f.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}c.center=D.ZERO,this.addChild(c)}});this.disposeEmitter.addListener(()=>s.dispose());const h=i=>{this.visible=!i};t.link(h),this.disposeEmitter.addListener(()=>t.unlink(h))}}const Zo=new Ee({lineWidth:.2,lineCap:"round",lineJoin:"round"});class Go extends L{constructor(r,e,t){let o;if(Mt.value)if(r.type==="edge-state"){const s=new T().moveToPoint(r.edge.start.viewCoordinates).lineToPoint(r.edge.end.viewCoordinates);o=[new R(s.getStrokedShape(Zo),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(r.type==="face-color")if(r.face){const s=T.polygon(r.face.vertices.map(i=>i.viewCoordinates));o=[new R(s.getOffsetShape(-.1),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else o=[];else if(r.type==="sector"){const s=$.getSectorArcShape(r.sector,.5);o=[new R(s.getOffsetShape(.05),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else o=[];else o=[];super({children:o}),this.hoverHighlight=r}}class Ko extends L{constructor(r,e,t,o){let s=[];try{let h=new T;for(const l of r.faces)h.polygon(l.vertices.map(p=>p.viewCoordinates));if(r.faceColor.colorState===ie.OUTSIDE)try{const l=T.polygon(e.outerBoundary.map(c=>c.start.viewCoordinates)),a=me.getOffsetBackgroundShape(e.outerBoundary,o.useBackgroundOffsetStroke,o.backgroundOffsetDistance).shapeDifference(l);h=h.shapeUnion(a)}catch(l){console.error(l)}const i=new R(h.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:t.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(i)}catch(h){console.error(h)}super({children:s}),this.selectedFaceColorHighlight=r}}class $o extends L{constructor(r,e,t,o){const s=[],h=[],i=r.sector,l=r.currentState,p=$.getSectorArcShape(i,.5),a=new R(p.getOffsetShape(.05),{stroke:t.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(a);const c=[];if(l===v.ANY&&(c.push(v.NOT_ZERO),c.push(v.NOT_ONE),c.push(v.NOT_TWO)),l.one&&l!==v.ONLY_ONE&&c.push(v.ONLY_ONE),c.length){const C=c.map(u=>{const m=$.getStrokeFromStyle(u,t);return new ft({accessibleName:$.nameMap.get(u),content:new lt(0,0,25,25),listener:()=>{o.sectorSetListener&&o.sectorSetListener(i,u)},buttonAppearanceStrategy:It,baseColor:m,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});h.push(...C);const g=new Je(new qe({children:C,spacing:10}),{xMargin:10,yMargin:10,fill:t.theme.uiBackgroundColorProperty,stroke:t.theme.uiForegroundColorProperty,scale:.01});h.push(g);const P=.1;s.push(g),g.centerBottom=a.centerTop.plusXY(0,-.15),g.top<e.top+P&&(g.centerTop=a.centerBottom.plusXY(0,.15)),g.left<e.left+P&&(g.left=e.left+P),g.right>e.right-P&&(g.right=e.right-P)}super({children:s}),this.selectedSectorEdit=r,this.disposeEmitter.addListener(()=>{h.forEach(C=>C.dispose())})}}class We extends L{constructor(e,t){const o=le()({textOptions:{font:fe,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new te(null),selectedFaceColorHighlightProperty:new te(null),selectedSectorEditProperty:new te(null),style:K,noninteractive:!1},t),s=o.style,h=new L({visibleProperty:s.faceColorsVisibleProperty}),i=new L({pickableProperty:Bo}),l=new L({pickableProperty:Oo}),p=new L({pickableProperty:xo}),a=new L({pickableProperty:Ao}),c=new L,C=new L({pickable:!1}),g=new L({pickable:!1}),P=new L({pickable:null}),u=new L({pickable:!1}),m=new L({pickable:!1}),w=new L,S=new I([e.stateProperty],E=>{if(E.getWeirdEdges().length||E.hasInvalidFaceColors())return!1;const A=E.getSimpleRegions();return A.length===1&&A[0].isSolved});h.addChild(new Uo(e.board,e.stateProperty,s)),e.board.faces.forEach(E=>{i.addChild(new Wo(E,e.stateProperty,s,o)),g.addChild(new Jo(E,e.stateProperty,S,s))});const f=new me(e.board.outerBoundary,e.board.innerBoundaries,s,o),y=E=>{E?e.board.vertices.forEach(A=>{a.addChild(new Do(A,e.stateProperty,S,s))}):a.children.forEach(A=>A.dispose())};s.verticesVisibleProperty.link(y);const N=E=>{E?e.board.vertices.forEach(A=>{C.addChild(new _o(A,e.stateProperty,S,s))}):C.children.forEach(A=>A.dispose())};s.vertexStateVisibleProperty.link(N),e.board.edges.forEach(E=>{p.addChild(new Xo(E,e.stateProperty,S,s,o))}),e.board.halfEdges.forEach(E=>{l.addChild(new $(E,e.stateProperty,s,o))}),c.addChild(new jo(e.board,e.stateProperty,s));super(je({children:[f,h,i,l,p,a,c,C,g,P,u,m,w]},o));b(this,"annotationContainer");b(this,"backgroundNode");this.puzzle=e,this.annotationContainer=P;const V=E=>{m.children.forEach(A=>A.dispose()),E&&m.addChild(new Go(E,o.backgroundOffsetDistance,s))};o.hoverHighlightProperty.link(V),this.disposeEmitter.addListener(()=>o.hoverHighlightProperty.unlink(V));const F=E=>{u.children.forEach(A=>A.dispose()),E&&u.addChild(new Ko(E,e.board,s,o))};o.selectedFaceColorHighlightProperty.link(F),this.disposeEmitter.addListener(()=>o.selectedFaceColorHighlightProperty.unlink(F));const k=E=>{w.children.forEach(A=>A.dispose()),E&&w.addChild(new $o(E,f,s,o))};o.selectedSectorEditProperty.link(k),this.disposeEmitter.addListener(()=>o.selectedSectorEditProperty.unlink(k)),this.disposeEmitter.addListener(()=>{s.verticesVisibleProperty.unlink(y),s.vertexStateVisibleProperty.unlink(N),[h,i,p,a,c,C,g,l].forEach(A=>{A.children.forEach(we=>we.dispose()),A.dispose()}),S.dispose(),f.dispose()}),this.backgroundNode=f}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class ur extends L{constructor(r,e,t){const o=le()({style:K},t),s=e.getEmbeddedCompleteData(r.inputFeatureSet),h=e.getEmbeddedCompleteData(r.outputFeatureSet),i=new We(new ke(e.smallBoard,s),{noninteractive:!0,style:o.style}),l=new We(new ke(e.smallBoard,h),{noninteractive:!0,style:o.style}),p=r.highlander?new L({children:e.getEmbeddedQuestionFaces(r.inputFeatureSet).map(w=>new _e("?",{font:fe,maxWidth:.9,maxHeight:.9,opacity:.5,fill:r.highlander?o.style.theme.faceValueColorProperty:o.style.theme.faceValueCompletedColorProperty,center:w.viewCoordinates}))}):new L,c=e.tightBounds.dilated(.5),C=.5,g=T.roundRectangle(c.x,c.y,c.width,c.height,C,C),P=new L({children:[i,p],clipArea:g,localBounds:c}),u=new L({children:[l,p],clipArea:g,localBounds:c}),m=new Je(new qe({spacing:.2,children:[P,new eo(0,0,20,0,{fill:o.style.theme.uiForegroundColorProperty,stroke:o.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),u]}),{cornerRadius:C*1.2,xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:o.style.theme.patternAnnotationBackgroundColorProperty});o.children=[m],super(o),this.rule=r,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{i.dispose(),l.dispose()})}}const Qo=(d,r)=>{Gt(Kt,d,r,!0)};class he{constructor(r,e,t,o,s,h,i,l,p,a){this.sourcePatternBoard=r,this.boardPatternBoard=e,this.largeBoard=t,this.embedding=o,this.smallBoard=s,this.toSmallFaceMap=h,this.toSmallEdgeMap=i,this.toSmallSectorMap=l,this.tightBounds=p,this.expandedBounds=a}mapFace(r){const e=this.embedding.mapFace(r),t=this.boardPatternBoard.getFace(e);if(t){const o=this.toSmallFaceMap.get(t);return B()&&M(o),o}else return null}mapEdge(r){return(r.isExit?this.embedding.mapExitEdges(r):[this.embedding.mapNonExitEdge(r)]).map(o=>this.boardPatternBoard.getEdge(o)).map(o=>{const s=this.toSmallEdgeMap.get(o);return B()&&M(s),s})}mapSector(r){const e=this.embedding.mapSector(r),t=this.boardPatternBoard.getSector(e),o=this.toSmallSectorMap.get(t);return B()&&M(o),o}getEmbeddedQuestionFaces(r){const e=new Set;for(const t of r.patternBoard.faces)if(r.getFaceValue(t)!==void 0){const o=this.mapFace(t);o&&e.add(o)}return this.smallBoard.faces.filter(t=>!e.has(t))}getEmbeddedCompleteData(r){const e=dt.empty(this.smallBoard);for(const t of r.getFeaturesArray())if(t instanceof to)t.value!==null&&e.setFaceValue(this.mapFace(t.face),t.value);else if(t instanceof oo)this.mapEdge(t.edge).forEach(o=>e.setEdgeState(o,H.BLACK));else if(t instanceof ro)this.mapEdge(t.edge).forEach(o=>e.setEdgeState(o,H.RED));else if(t instanceof so)e.setSectorState(this.mapSector(t.sector),v.NOT_ZERO);else if(t instanceof io)e.setSectorState(this.mapSector(t.sector),v.NOT_ONE);else if(t instanceof no)e.setSectorState(this.mapSector(t.sector),v.NOT_TWO);else if(t instanceof ao)e.setSectorState(this.mapSector(t.sector),v.ONLY_ONE);else if(t instanceof lo){const o=(h,i)=>{const l=this.mapFace(h),p=this.mapFace(i),a=l?e.getFaceColor(l):e.getOutsideColor(),c=p?e.getFaceColor(p):e.getOutsideColor();new $t(pe(e,a),pe(e,c)).apply(e)},s=(h,i)=>{const l=this.mapFace(h),p=this.mapFace(i),a=l?e.getFaceColor(l):e.getOutsideColor(),c=p?e.getFaceColor(p):e.getOutsideColor();new Qt(pe(e,a),pe(e,c)).apply(e)};for(let h=1;h<t.primaryFaces.length;h++)o(t.primaryFaces[h-1],t.primaryFaces[h]);for(let h=1;h<t.secondaryFaces.length;h++)o(t.secondaryFaces[h-1],t.secondaryFaces[h]);t.secondaryFaces.length&&s(t.primaryFaces[0],t.secondaryFaces[0])}else throw new Error(`unhandled feature: ${t}`);return Qo(this.smallBoard,e),e}static getEmbeddingBounds(r,e,t){const o=Ce.NOTHING.copy(),s=i=>{o.addPoint(e.getVertex(t.mapVertex(i)).viewCoordinates)};r.vertices.forEach(s);const h=i=>{const l=e.getFace(t.mapFace(i));l&&l.vertices.forEach(p=>o.addPoint(p.viewCoordinates))};return r.faces.forEach(h),r.edges.forEach(i=>{let l;i.isExit?l=t.mapExitEdges(i).map(p=>e.getEdge(p)):l=[e.getEdge(t.mapNonExitEdge(i))],l.forEach(p=>{o.addPoint(p.start.viewCoordinates),o.addPoint(p.end.viewCoordinates)})}),o}static findBestEmbedding(r,e,t){const o=co(r,e);if(o.length===0)return null;const s=Ce.NOTHING.copy();t.vertices.forEach(p=>s.addPoint(p.viewCoordinates));const h=s.center;let i=null,l=Number.POSITIVE_INFINITY;for(let p=0;p<o.length;p++){const a=o[p],C=he.getEmbeddingBounds(r,e,a).center,g=h.distance(C);g<l&&(l=g,i=a)}return i}static getDisplayEmbedding(r,e,t,o){const s=he.getEmbeddingBounds(r,e,o),h=s.dilated(.5),i=t.faces.filter(u=>{const m=Ce.NOTHING.copy();return u.vertices.forEach(w=>m.addPoint(w.viewCoordinates)),h.intersectsBounds(m)}),l=t.vertices.filter(u=>u.faces.some(m=>i.includes(m))),p=mt({vertices:l.map(u=>({logicalCoordinates:u.logicalCoordinates,viewCoordinates:u.viewCoordinates})),faces:i.map(u=>({logicalCoordinates:u.logicalCoordinates,vertices:u.vertices.map(m=>({logicalCoordinates:m.logicalCoordinates,viewCoordinates:m.viewCoordinates}))}))}),a=new wt(p),c=1e-6,C=new Map(i.map((u,m)=>{const w=a.faces.find(S=>S.viewCoordinates.equalsEpsilon(u.viewCoordinates,c));return B()&&M(w),[u,w]})),g=new Map(t.edges.map(u=>{const m=a.edges.find(w=>w.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c)&&w.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c)||w.start.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c)&&w.end.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c))??null;return m?[u,m]:null}).filter(u=>u!==null)),P=new Map(t.halfEdges.map(u=>{const m=a.halfEdges.find(w=>w.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c)&&w.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c))??null;return m?[u,m]:null}).filter(u=>u!==null));return B()&&M(o),new he(r,e,t,o,a,C,g,P,s,h)}}export{he as D,ur as E,Jo as F,We as P,qo as U,_o as V,fo as a,go as b,mo as c,Po as d,K as e,G as f,wo as g,ge as h,Bo as i,W as j,vo as k,Eo as l,bo as m,$e as n,Vo as o,Fo as p,To as q,No as r,Qo as s,po as t,pr as u,Lo as v,hr as w,ko as x};
