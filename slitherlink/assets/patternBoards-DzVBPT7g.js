var is=Object.defineProperty;var os=(t,a,e)=>a in t?is(t,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[a]=e;var C=(t,a,e)=>os(t,typeof a!="symbol"?a+"":a,e);import{z as R,ad as ls,O as at,f as hs,V as s,R as qa,B as Fe}from"./Vector2Property-CFyCN_2h.js";function cs(t){if(assert&&assert(!t||Array.isArray(t),"cleanArray either takes an Array"),t){for(;t.length;)t.pop();return t}else return[]}R.register("cleanArray",cs);function fs(t,a){if(t[a]!==void 0)return a;if(a=a.charAt(0).toUpperCase()+a.slice(1),t[`moz${a}`]!==void 0)return`moz${a}`;if(t[`Moz${a}`]!==void 0)return`Moz${a}`;if(t[`webkit${a}`]!==void 0)return`webkit${a}`;if(t[`ms${a}`]!==void 0)return`ms${a}`;if(t[`o${a}`]!==void 0)return`o${a}`}R.register("detectPrefix",fs);const D=navigator.userAgent;function He(t){return wn()===t}function ba(){return!!(self.phet&&phet.chipper&&phet.chipper.queryParameters&&phet.chipper.queryParameters["phet-app"]||(D.match(/(iPod|iPhone|iPad)/)||navigator.platform==="MacIntel"&&navigator.maxTouchPoints>=2)&&D.match(/AppleWebKit/))}function wn(){let t=-1,a=null;return navigator.appName==="Microsoft Internet Explorer"?(a=new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})"),a.exec(D)!==null&&(t=parseFloat(RegExp.$1))):navigator.appName==="Netscape"&&(a=new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"),a.exec(D)!==null&&(t=parseFloat(RegExp.$1))),t}const ds={firefox:D.toLowerCase().includes("firefox"),mobileSafari:ba(),safari5:!!(D.match(/Version\/5\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari6:!!(D.match(/Version\/6\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari7:!!(D.match(/Version\/7\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari10:!!(D.match(/Version\/10\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari11:!!(D.match(/Version\/11\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari9:!!(D.match(/Version\/9\./)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),safari:ba()||!!(D.match(/Version\//)&&D.match(/Safari\//)&&D.match(/AppleWebKit/)),ie:wn()!==-1,ie9:He(9),ie10:He(10),ie11:He(11),android:D.indexOf("Android")>0,edge:!!D.match(/Edge\//),chromium:/chrom(e|ium)/.test(D.toLowerCase())&&!D.match(/Edge\//),chromeOS:D.indexOf("CrOS")>0,mac:navigator.platform.includes("Mac")};R.register("platform",ds);function us(t,a){if(t[`on${a}`]!==void 0)return a;if(t[`onmoz${a}`]!==void 0)return`moz${a}`;if(t[`onMoz${a}`]!==void 0)return`Moz${a}`;if(t[`onwebkit${a}`]!==void 0)return`webkit${a}`;if(t[`onms${a}`]!==void 0)return`ms${a}`;if(t[`ono${a}`]!==void 0)return`o${a}`}R.register("detectPrefixEvent",us);function gs(t){return t.replace(/\u202a|\u202b|\u202c/g,"")}R.register("stripEmbeddingMarks",gs);function ws(t,a,e,n,r){assert&&assert(Array.isArray(t)&&_.uniq(t).length===t.length,"a is not an array of unique items"),assert&&assert(Array.isArray(a)&&_.uniq(a).length===a.length,"b is not an array of unique items"),e=e||[],n=n||[],r=r||[],assert&&assert(Array.isArray(e)&&e.length===0),assert&&assert(Array.isArray(n)&&n.length===0),assert&&assert(Array.isArray(r)&&r.length===0),Array.prototype.push.apply(e,t),Array.prototype.push.apply(n,a);t:for(let i=0;i<e.length;i++){const h=e[i];for(let o=0;o<n.length;o++){const f=n[o];if(h===f){if(r.push(h),e.splice(i,1),n.splice(o,1),o=0,i===e.length)break t;i-=1}}}return e}R.register("arrayDifference",ws);function ps(t){const a=new Map;return e=>{if(a.has(e))return a.get(e);{const n=t(e);return a.set(e,n),n}}}R.register("memoize",ps);const xs=(t,a)=>{assert&&t&&a.forEach(e=>{assert&&assert(Object.getOwnPropertyDescriptor(t,e)||_.some(ls(t.constructor).map(n=>Object.getOwnPropertyDescriptor(n.prototype,e))),`property not defined: ${e}`)})};R.register("assertHasProperties",xs);function Ms(t){return t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;").replace(/ /g,"&nbsp;")}R.register("escapeHTML",Ms);function ms(t,...a){return _.each(a,e=>{if(e)for(const n in e){const r=Object.getOwnPropertyDescriptor(e,n);r&&(typeof r.get=="function"||e[n]!==void 0)&&Object.defineProperty(t,n,r)}}),t}R.register("extendDefined",ms);function Es(t,a,e){assert&&assert(t),assert&&assert(Array.isArray(a)),e&&(assert&&assert(Object.getPrototypeOf(e)===Object.prototype,"Extra prototype on options object is a code smell"),_.each(a,n=>{assert&&assert(!e.hasOwnProperty(n)||e[n]!==void 0,`Undefined not allowed for key: ${n}`),e[n]!==void 0&&(t[n]=e[n])}))}R.register("mutate",Es);class Te{constructor(a,e){this._map=new Map,this._enumeration=a,this._values=a.enumeration.values,this._values.forEach(n=>{assert&&assert(!this._map.has(n),"Enumeration key override problem"),this._map.set(n,e(n))})}get(a){return assert&&assert(this._values.includes(a)),assert&&assert(this._map.has(a)),this._map.get(a)}set(a,e){assert&&assert(this._values.includes(a)),this._map.set(a,e)}map(a){return new Te(this._enumeration,e=>a(this.get(e),e))}forEach(a){this._values.forEach(e=>a(this.get(e),e))}values(){return this._values.map(a=>this.get(a))}}R.register("EnumerationMap",Te);class ae extends Te{constructor(a,e){super(at,n=>n===at.HORIZONTAL?a:e)}get horizontal(){return this.get(at.HORIZONTAL)}set horizontal(a){this.set(at.HORIZONTAL,a)}get vertical(){return this.get(at.VERTICAL)}set vertical(a){this.set(at.VERTICAL,a)}with(a,e){return new ae(a===at.HORIZONTAL?e:this.horizontal,a===at.VERTICAL?e:this.vertical)}static create(a){return new ae(a(at.HORIZONTAL),a(at.VERTICAL))}map(a){return new ae(a(this.horizontal,at.HORIZONTAL),a(this.vertical,at.VERTICAL))}}R.register("OrientationPair",ae);class vs{constructor(){this.pendingLocks=[],this.loadComplete=!1,this.listeners=[]}reset(){this.loadComplete=!1}addListener(a){this.listeners.push(a)}proceedIfReady(){this.pendingLocks.length===0&&(assert&&assert(!this.loadComplete,"cannot complete load twice"),this.loadComplete=!0,this.listeners.forEach(a=>a()))}createLock(a){return assert&&assert(!this.loadComplete,"Cannot create more locks after load-step has completed"),this.pendingLocks.push(a),()=>{assert&&assert(this.pendingLocks.includes(a),"invalid lock"),hs(this.pendingLocks,a),this.proceedIfReady()}}}const pn=new vs;R.register("asyncLoader",pn);const De={};function qs(t,a,e){const n=De;let r=n,i=n;return t.hasOwnProperty(a)&&(r=t[a]),t.hasOwnProperty(e)&&(i=t[e]),r!==De?t[e]=r:delete t[e],i!==De?t[a]=i:delete t[a],t}R.register("swapObjectKeys",qs);const xn=t=>{assert&&assert(t.trim()===t,"path must be trimmed");const a=_.get(self,t);return a!==void 0?a:null};R.register("getGlobal",xn);const bs=t=>{assert&&assert(t.split(".").length>1,"path must have multiple parts"),assert&&assert(t.trim()===t,"path must be trimmed");const a=t.split("."),e=a.pop(),n=_.get(self,a);return n?n[e].bind(n):null};R.register("gracefulBind",bs);const F=self._,w=(t,...a)=>self.assert(t,...a),q=()=>!!self.assert;class Lt{constructor(a,e,n,r,i,h,o){C(this,"isAutomorphism");C(this,"isIdentityAutomorphism");C(this,"vertexInverseMap");C(this,"edgeInverseMap");C(this,"sectorInverseMap");C(this,"faceInverseMap");this.sourcePatternBoard=a,this.targetPatternBoard=e,this.vertexMap=n,this.nonExitEdgeMap=r,this.exitEdgeMap=i,this.sectorMap=h,this.faceMap=o,this.isAutomorphism=a===e,this.isAutomorphism&&(this.vertexInverseMap=new Map(Array.from(n).map(([f,l])=>[l,f])),this.sectorInverseMap=new Map(Array.from(h).map(([f,l])=>[l,f])),this.faceInverseMap=new Map(Array.from(o).map(([f,l])=>[l,f])),this.edgeInverseMap=new Map([...Array.from(r).map(([f,l])=>[l,f]),...Array.from(i).map(([f,l])=>(q()&&w(l.length===1),[l[0],f]))])),this.isIdentityAutomorphism=this.computeIsIdentityAutomorphism()}static fromMaps(a,e,n,r,i,h,o){return new Lt(a,e,n,r,i,h,o)}getVertexMap(){return this.vertexMap}getNonExitEdgeMap(){return this.nonExitEdgeMap}getExitEdgeMap(){return this.exitEdgeMap}getSectorMap(){return this.sectorMap}getFaceMap(){return this.faceMap}mapVertex(a){const e=this.vertexMap.get(a);return q()&&w(e),e}mapNonExitEdge(a){const e=this.nonExitEdgeMap.get(a);return q()&&w(e),e}mapExitEdges(a){const e=this.exitEdgeMap.get(a);return q()&&w(e),e}mapSector(a){const e=this.sectorMap.get(a);return q()&&w(e),e}mapFace(a){const e=this.faceMap.get(a);return q()&&w(e),e}inverseMapVertex(a){const e=this.vertexInverseMap.get(a);return q()&&w(e),e}inverseMapEdge(a){const e=this.edgeInverseMap.get(a);return q()&&w(e),e}inverseMapSector(a){const e=this.sectorInverseMap.get(a);return q()&&w(e),e}inverseMapFace(a){const e=this.faceInverseMap.get(a);return q()&&w(e),e}equals(a){return this.vertexMap.size===a.vertexMap.size&&this.nonExitEdgeMap.size===a.nonExitEdgeMap.size&&this.exitEdgeMap.size===a.exitEdgeMap.size&&this.sectorMap.size===a.sectorMap.size&&this.faceMap.size===a.faceMap.size&&Array.from(this.vertexMap).every(([e,n])=>a.vertexMap.get(e)===n)&&Array.from(this.nonExitEdgeMap).every(([e,n])=>a.nonExitEdgeMap.get(e)===n)&&Array.from(this.exitEdgeMap).every(([e,n])=>a.exitEdgeMap.get(e)===n)&&Array.from(this.sectorMap).every(([e,n])=>a.sectorMap.get(e)===n)&&Array.from(this.faceMap).every(([e,n])=>a.faceMap.get(e)===n)}toString(){return`Embedding(
  vertexMap: ${[...this.vertexMap].map(a=>`${a[0].index} ${a[0].isExit?"->":"=>"} ${a[1].index}`).join(", ")}
  nonExitEdgeMap: ${[...this.nonExitEdgeMap].map(a=>`${a[0].index} => ${a[1].index}`).join(", ")}
  exitEdgeMap: ${[...this.exitEdgeMap].map(a=>`${a[0].index} => [${a[1].map(e=>e.index).join(", ")}]`).join(", ")}
  sectorMap: ${[...this.sectorMap].map(a=>`${a[0].index} => ${a[1].index}`).join(", ")}
  faceMap: ${[...this.faceMap].map(a=>`${a[0].index} ${a[0].isExit?"->":"=>"} ${a[1].index}`).join(", ")}
)`}computeIsIdentityAutomorphism(){if(this.sourcePatternBoard!==this.targetPatternBoard)return!1;for(const a of this.vertexMap.keys())if(this.vertexMap.get(a)!==a)return!1;for(const a of this.nonExitEdgeMap.keys())if(this.nonExitEdgeMap.get(a)!==a)return!1;for(const a of this.exitEdgeMap.keys())if(this.exitEdgeMap.get(a).length!==1||this.exitEdgeMap.get(a)[0]!==a)return!1;for(const a of this.sectorMap.keys())if(this.sectorMap.get(a)!==a)return!1;for(const a of this.faceMap.keys())if(this.faceMap.get(a)!==a)return!1;return!0}serialize(){return{vertexMapping:this.sourcePatternBoard.vertices.map(a=>(q()&&w(this.vertexMap.has(a)),this.vertexMap.get(a).index)),edgeMapping:this.sourcePatternBoard.edges.map(a=>a.isExit?(q()&&w(this.exitEdgeMap.has(a)),this.exitEdgeMap.get(a).map(e=>e.index)):(q()&&w(this.nonExitEdgeMap.has(a)),this.nonExitEdgeMap.get(a).index)),sectorMapping:this.sourcePatternBoard.sectors.map(a=>(q()&&w(this.sectorMap.has(a)),this.sectorMap.get(a).index)),faceMapping:this.sourcePatternBoard.faces.map(a=>(q()&&w(this.faceMap.has(a)),this.faceMap.get(a).index))}}static deserialize(a,e,n){return new Lt(a,e,new Map(a.vertices.map(r=>[r,e.vertices[n.vertexMapping[r.index]]])),new Map(a.edges.filter(r=>!r.isExit).map(r=>[r,e.edges[n.edgeMapping[r.index]]])),new Map(a.edges.filter(r=>r.isExit).map(r=>[r,n.edgeMapping[r.index].map(i=>e.edges[i])])),new Map(a.sectors.map(r=>[r,e.sectors[n.sectorMapping[r.index]]])),new Map(a.faces.map(r=>[r,e.faces[n.faceMapping[r.index]]])))}}const _s=(t,a,e=!1)=>{if(t.faces.filter(i=>!i.isExit).length>a.faces.filter(i=>!i.isExit).length||t.sectors.length>a.sectors.length||t.edges.filter(i=>!i.isExit).length>a.edges.filter(i=>!i.isExit).length||t.vertices.length>a.vertices.length)return[];const n=[],r=t.faces.filter(i=>!i.isExit);if(r.length){const i=r[0],h=[i],o=[],f=[],l=new Set(r.slice(1)),c=new Set(i.edges),E=new Set(i.vertices);for(;l.size;){const d=F.maxBy([...l],p=>{let k=0;for(const M of p.edges)c.has(M)&&(k+=5);for(const M of p.vertices)E.has(M)&&(k+=1);return k});q()&&w(d),h.push(d),o.push(F.findIndex(d.edges,p=>c.has(p))),f.push(F.findIndex(d.vertices,p=>E.has(p))),l.delete(d);for(const p of d.edges)c.add(p);for(const p of d.vertices)E.add(p)}const u=(d,p,k)=>{if(d.edges.length!==p.edges.length)return!1;for(let M=0;M<d.edges.length;M++){const y=d.edges[M],g=p.edges[k.mapEdgeIndex(M)];q()&&w(y.faces.includes(d)),q()&&w(g.faces.includes(p));const m=y.faces[0]===d?y.faces[1]:y.faces[0];if(!m.isExit){const x=g.faces[0]===p?g.faces[1]:g.faces[0];if(x.isExit||m.edges.length!==x.edges.length)return!1}}return!0};for(const d of a.faces)if(!d.isExit&&d.edges.length===i.edges.length)for(const p of Pt.allForOrder(d.edges.length)){if(!u(i,d,p))continue;const k=new Map,M=new Map,y=new Map,g=new Map,m=new Map;k.set(i,p),M.set(i,d),y.set(d,i);for(let A=0;A<i.vertices.length;A++){const T=i.vertices[A],v=d.vertices[p.mapVertexIndex(A)];g.set(T,v),m.set(v,T)}const x=(A,T,v,I,B,S)=>{if(q()&&w(B.size===S.size),A===h.length){q()&&w(B.size===t.vertices.length);const b=new Map,P=new Set;for(const[O,L]of v){const Z=T.get(O);for(let J=0;J<O.edges.length;J++){const et=O.edges[J],j=L.edges[Z.mapEdgeIndex(J)];q()&&b.has(et)&&w(b.get(et)===j),b.set(et,j),P.add(j)}}q()&&w(b.size===t.edges.filter(O=>!O.isExit).length);const mt=new Map;for(const O of t.edges.filter(L=>L.isExit)){const L=O.exitVertex;q()&&w(L);const Z=B.get(L);q()&&w(Z),mt.set(O,Z.edges.filter(J=>!P.has(J)))}for(const O of t.faces.filter(L=>L.isExit)){const L=O.edges[0];q()&&w(L&&O.edges.length===1);const Z=b.get(L),J=L.faces[0]===O?L.faces[1]:L.faces[0],et=v.get(J),j=Z.faces[0]===et?Z.faces[1]:Z.faces[0];q()&&w(j),v.set(O,j)}const V=new Map;for(const O of t.sectors){const L=O.face,Z=v.get(L);q()&&w(Z);const J=O.edges[0],et=O.edges[1],j=b.get(J),gt=b.get(et);q()&&w(j&&gt);const W=Z.sectors.find(ht=>ht.edges.includes(j)&&ht.edges.includes(gt));q()&&w(W),V.set(O,W)}if(n.push(Lt.fromMaps(t,a,B,b,mt,V,v)),e)return}else{const b=h[A],P=o[A-1],mt=f[A-1];if(P>=0){const V=b.edges[P],O=V.vertices[0],L=V.vertices[1],Z=B.get(O),J=B.get(L),et=V.faces[0]===b?V.faces[1]:V.faces[0],j=v.get(et);q()&&w(j);const gt=j.edges.find(Bt=>Bt.vertices.includes(Z)&&Bt.vertices.includes(J));q()&&w(gt);const W=gt.faces[0]===j?gt.faces[1]:gt.faces[0];if(W.isExit||I.has(W))return;const ht=b.vertices.indexOf(O),Et=b.vertices.indexOf(L),wt=W.vertices.indexOf(Z),Dt=W.vertices.indexOf(J),Xt=(ht+1)%b.vertices.length===Et,Me=(wt+1)%W.vertices.length===Dt,At=Xt===Me?1:-1,kt=(wt-ht*At+b.vertices.length)%b.vertices.length,it=new Pt(b.vertices.length,kt,At);if(q()&&w(it.mapVertexIndex(ht)===wt),q()&&w(it.mapVertexIndex(Et)===Dt),!u(b,W,it)||(v.set(b,W),I.set(W,b),v.size!==I.size))return;for(let Bt=0;Bt<b.vertices.length;Bt++){const Kt=b.vertices[Bt],Qt=W.vertices[it.mapVertexIndex(Bt)];if(B.has(Kt)){if(B.get(Kt)!==Qt)return}else B.set(Kt,Qt);if(S.has(Qt)){if(S.get(Qt)!==Kt)return}else S.set(Qt,Kt);q()&&w(B.size===S.size)}if(T.set(b,it),x(A+1,T,v,I,B,S),e&&n.length)return}else{q()&&w(mt>=0,"If this is not satisfied, we have disconnected components OR orderedFaces order is bad");const V=b.vertices[mt],O=B.get(V),L=O.faces.filter(Z=>!Z.isExit&&!I.has(Z));for(const Z of L){const J=b.vertices.indexOf(V),et=Z.vertices.indexOf(O);q()&&w(J>=0),q()&&w(et>=0);for(const j of[1,-1]){const gt=(et-J*j+b.vertices.length)%b.vertices.length,W=new Pt(b.vertices.length,gt,j);if(!u(b,Z,W))continue;let ht=!0;const Et=new Map(B),wt=new Map(S);for(let At=0;At<b.vertices.length;At++){const kt=b.vertices[At],it=Z.vertices[W.mapVertexIndex(At)];if(Et.has(kt)){if(Et.get(kt)!==it){ht=!1;break}}else Et.set(kt,it);if(wt.has(it)){if(wt.get(it)!==kt){ht=!1;break}}else wt.set(it,kt);q()&&w(Et.size===wt.size)}if(!ht)continue;const Dt=new Map(v),Xt=new Map(I);if(Dt.set(b,Z),Xt.set(Z,b),Dt.size!==Xt.size)continue;const Me=new Map(T);if(Me.set(b,W),x(A+1,Me,Dt,Xt,Et,wt),e&&n.length)return}}}}};if(x(1,k,M,y,g,m),e&&n.length)return n}}else if(t.vertices.length===1){const i=t.vertices[0];q()&&w(i.edges.length===t.edges.length);const h=i.edges.filter(c=>!c.isExit),o=i.edges.filter(c=>!c.isExit).length,f=i.isExit,l=F.range(0,o).map(c=>{const E=h[c],u=h.slice(0,c+1);return i.sectors.filter(d=>d.edges.includes(E)&&d.edges.every(p=>u.includes(p)))});if(q()&&w(l.flat().length===i.sectors.length),q()&&!i.isExit){w(i.sectors.length===o);for(let c=0;c<o;c++){const E=i.edges[c],u=i.edges[(c+1)%o],d=i.sectors[c],p=i.faces[c];w(d.edges.includes(E)),w(d.edges.includes(u)),w(d.face===p)}}for(const c of a.vertices){if(f){if(c.edges.length<o||c.sectors.length<i.sectors.length)continue}else{if(c.isExit||c.edges.length!==o)continue;q()&&w(c.sectors.length===o)}const E=new Map([[i,c]]),u=(d,p,k,M)=>{if(d===o){q()&&w(p.size===h.length),q()&&w(k.size===t.sectors.length);const y=f?new Map([[i.exitEdge,c.edges.filter(m=>!M.has(m))]]):new Map,g=new Map([...k.keys()].map(m=>[m.face,k.get(m).face]));if(i.sectors.length===0)for(const[m,x]of p){const A=m.faces[0],T=m.faces[1];q()&&w(A.isExit&&T.isExit),g.set(A,x.faces[0]),g.set(T,x.faces[1])}else if(f){for(const m of t.faces.filter(x=>x.isExit))if(m.edges.length===1){const x=m.edges[0];q()&&w(x&&m.edges.length===1);const A=p.get(x);q()&&w(A);const T=x.faces[0]===m?x.faces[1]:x.faces[0],v=g.get(T);q()&&w(v);const I=A.faces[0]===v?A.faces[1]:A.faces[0];q()&&w(I),g.set(m,I)}}else for(const m of t.sectors){const x=m.face,T=k.get(m).face;g.set(x,T)}if(n.push(Lt.fromMaps(t,a,E,p,y,k,g)),e)return}else{const y=h[d],g=l[d];for(const m of c.edges){if(m.isExit||M.has(m))continue;const x=[];let A=!0;for(const T of g){const v=T.edges[0],I=T.edges[1],B=v===y?m:p.get(v),S=I===y?m:p.get(I);q()&&w(B&&S);const b=c.sectors.find(P=>P.edges.includes(B)&&P.edges.includes(S)&&(o>2||!x.includes(P)))??null;if(b)x.push(b);else{A=!1;break}}if(A){const T=new Map(p);T.set(y,m);const v=new Map(k);for(let B=0;B<g.length;B++)v.set(g[B],x[B]);const I=new Set(M);I.add(m),u(d+1,T,v,I)}}}};u(0,new Map,new Map,new Set)}}else if(t.vertices.length===0&&t.edges.length===1){const i=t.edges[0];for(const h of a.edges.filter(o=>!o.isExit))if(n.push(Lt.fromMaps(t,a,new Map,new Map([[i,h]]),new Map,new Map,new Map([[i.faces[0],h.faces[0]],[i.faces[1],h.faces[1]]]))),e)return n}else throw new Error("pattern search not implemented generally yet");return q()&&t===a&&w(n.filter(i=>i.isIdentityAutomorphism).length===1),n};class Pt{constructor(a,e,n){this.edgeCount=a,this.offset=e,this.direction=n,q()&&w(n===1||n===-1)}mapVertexIndex(a){return(this.offset+a*this.direction+this.edgeCount)%this.edgeCount}mapEdgeIndex(a){return this.direction===1?(this.offset+a)%this.edgeCount:(this.offset-a-1+2*this.edgeCount)%this.edgeCount}toString(){return`FaceMapping( edgeCount=${this.edgeCount}, offset=${this.offset}, direction=${this.direction} )`}toDetailedString(a,e){return`FaceMapping( vertices: ${F.range(0,this.edgeCount).map(n=>`${a.vertices[n].index} => ${e.vertices[this.mapVertexIndex(n)].index}`).join(", ")}, edges: ${F.range(0,this.edgeCount).map(n=>{const r=a.edges[n],i=e.edges[this.mapEdgeIndex(n)];return`#${r.index} (${r.vertices.map(h=>h.index).join(",")}) => #${i.index} (${i.vertices.map(h=>h.index).join(",")})`}).join(", ")} )`}static allForOrder(a){return[...F.range(0,a).map(e=>new Pt(a,e,1)),...F.range(0,a).map(e=>new Pt(a,e,-1))]}}const _a=new WeakMap,ya=(t,a)=>{q()&&w(t),q()&&w(a);let e=_a.get(t)??null;e||(e=new WeakMap,_a.set(t,e));let n=e.get(a)??null;return n||(n=_s(t,a),e.set(a,n)),n};function ys(t){const a=[];return t(e=>{a.push(e)}),a}R.register("collect",ys);function ta(t){if(Array.isArray(t))return t.map(ta);if(typeof t!="object"||t===null)return t;const a={};return Object.keys(t).sort().forEach(e=>{const n=t[e];a[e]=ta(n)}),a}R.register("copyWithSortedKeys",ta);function As(t,a,e){const n=[];function r(i,h){return h.forEach((o,f)=>{n.push(f),i===1?e(o,...n):r(i-1,o),n.pop()})}return r(t,a)}R.register("dimensionForEach",As);function ks(t,a,e){const n=[];function r(i,h){return h.map((o,f)=>{n.push(f);const l=i===1?e(o,...n):r(i-1,o);return n.pop(),l})}return r(t,a)}R.register("dimensionMap",ks);class Bs{constructor(a,e){this.eventModel=a,this.eventCallback=e,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period}step(a){for(;a>=this.timeBeforeNextEvent;)a-=this.timeBeforeNextEvent,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period,this.eventCallback(a);this.timeBeforeNextEvent-=a}getRatio(){return(this.period-this.timeBeforeNextEvent)/this.period}}class Ss{constructor(a){this.rate=a,assert&&assert(a>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){return 1/this.rate}}class Ts{constructor(a,e){this.rate=a,this.pseudoRandomNumberSource=e,assert&&assert(a>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const a=this.pseudoRandomNumberSource();return assert&&assert(a>=0&&a<1,`Our uniform random number is outside of its expected range with a value of ${a}`),a*2/this.rate}}class Cs{constructor(a,e){this.rate=a,this.pseudoRandomNumberSource=e,assert&&assert(a>0,"We need to have a strictly positive poisson rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const a=this.pseudoRandomNumberSource();return assert&&assert(a>=0&&a<1,`Our uniform random number is outside of its expected range with a value of ${a}`),-Math.log(a)/this.rate}}R.register("PoissonEventModel",Cs);R.register("UniformEventModel",Ts);R.register("ConstantEventModel",Ss);R.register("EventTimer",Bs);function Is(t){return t}R.register("identity",Is);function zs(t,a){assert&&assert(Array.isArray(t));const e=[],n=t.length*2-1;for(let r=0;r<n;r++)r%2===0?e.push(t[r/2]):e.push(a((r-1)/2));return e}R.register("interleave",zs);function Rs(t){const a=typeof t=="string"?{src:t}:t,e=a.src,n=a.callback,r=a.async===void 0?!0:a.async,i=a.cacheBust===void 0?!1:a.cacheBust;let h=!1;const o=document.createElement("script");o.type="text/javascript",o.async=r,o.onload=o.onreadystatechange=function(){const l=this.readyState;l&&l!=="complete"&&l!=="loaded"||h||(h=!0,n&&n())},o.src=e+(i?`?random=${Math.random().toFixed(10)}`:"");const f=document.getElementsByTagName("script")[0];f.parentNode.insertBefore(o,f)}R.register("loadScript",Rs);function Fs(t){phet.log&&phet.log(`${t}: ${JSON.stringify(xn(t),null,2)}`)}R.register("logGlobal",Fs);class Hs{constructor(a,e,n){this.width=a,this.height=e,this.url=n,this.img=new Image;const r=pn.createLock(this.img);this.img.onload=r,this.img.src=this.url,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height;const i=this.canvas.getContext("2d");this.updateCanvas=()=>{this.img.complete&&(typeof this.img.naturalWidth>"u"||this.img.naturalWidth>0)&&(i.drawImage(this.img,0,0),delete this.updateCanvas)}}}R.register("MipmapElement",Hs);function Ds(t){const a=[],e=t.length;if(e>1)for(let n=0;n<e-1;n++){const r=t[n];for(let i=n+1;i<e;i++)a.push([r,t[i]])}return a}R.register("pairs",Ds);function Os(t,a){assert&&assert(Array.isArray(t));const e=[],n=[],r=t.length;for(let i=0;i<r;i++)a(t[i])?e.push(t[i]):n.push(t[i]);return[e,n]}R.register("partition",Os);const Ns={GRAVITATIONAL_CONSTANT:66743e-15,GRAVITY_ON_EARTH:9.81};R.register("PhysicalConstants",Ns);function Zs(t){return assert&&assert(t!==void 0,"Required field is undefined."),t}R.register("required",Zs);const Xl={name:"Square Tiling",basisA:new s(1,0),basisB:new s(0,1),polygons:[[new s(0,0),new s(0,1),new s(1,1),new s(1,0)]],translation:new s(1,1)},Kl={name:"Hexagonal Tiling",basisA:new s(1,0),basisB:new s(.5,Math.sqrt(3)/2),polygons:[[new s(0,1/Math.sqrt(3)),new s(.5,Math.sqrt(3)/2),new s(1,1/Math.sqrt(3)),new s(1,0),new s(.5,-(1/(2*Math.sqrt(3)))),new s(0,0)]],translation:new s(3/2,Math.sqrt(3)/2)},Ls={name:"Triangular",basisA:new s(1,0),basisB:new s(.5,Math.sqrt(3)/2),polygons:[[new s(0,0),new s(1,0),new s(.5,Math.sqrt(3)/2)],[new s(.5,Math.sqrt(3)/2),new s(3/2,Math.sqrt(3)/2),new s(1,0)]],translation:new s(3/2,Math.sqrt(3)/2)},Ps={name:"Trihexagonal",basisA:new s(2,0),basisB:new s(1,Math.sqrt(3)),polygons:[[new s(1/2,Math.sqrt(3)/2),new s(1,0),new s(1/2,-(Math.sqrt(3)/2)),new s(-1/2,-(Math.sqrt(3)/2)),new s(-1,0),new s(-1/2,Math.sqrt(3)/2)],[new s(1/2,Math.sqrt(3)/2),new s(1,0),new s(3/2,Math.sqrt(3)/2)],[new s(1/2,-(Math.sqrt(3)/2)),new s(1,0),new s(3/2,-(Math.sqrt(3)/2))]],translation:new s(3,Math.sqrt(3))},Gs={name:"Rhombitrihexagonal",basisA:new s(.5*(3+Math.sqrt(3)),.5*(1+Math.sqrt(3))),basisB:new s(.5*(3+Math.sqrt(3)),.5*(-1-Math.sqrt(3))),polygons:[[new s(1/2,Math.sqrt(3)/2),new s(1,0),new s(1/2,-(Math.sqrt(3)/2)),new s(-1/2,-(Math.sqrt(3)/2)),new s(-1,0),new s(-1/2,Math.sqrt(3)/2)],[new s(1/2*(1+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2,-(Math.sqrt(3)/2)),new s(1,0),new s(1/2*(2+Math.sqrt(3)),-1/2)],[new s(1+Math.sqrt(3)/2,1/2),new s(1,0),new s(1+Math.sqrt(3)/2,-1/2)],[new s(1+Math.sqrt(3)/2,1/2),new s(1,0),new s(1/2,Math.sqrt(3)/2),new s(1/2*(1+Math.sqrt(3)),1/2*(1+Math.sqrt(3)))],[new s(1/2,1/2*(2+Math.sqrt(3))),new s(1/2,Math.sqrt(3)/2),new s(1/2*(1+Math.sqrt(3)),1/2*(1+Math.sqrt(3)))],[new s(1/2,1/2*(2+Math.sqrt(3))),new s(1/2,Math.sqrt(3)/2),new s(-1/2,Math.sqrt(3)/2),new s(-1/2,1/2*(2+Math.sqrt(3)))]],translation:new s(3+Math.sqrt(3),.5*(-1-Math.sqrt(3))+.5*(1+Math.sqrt(3)))},Ql={name:"Truncated Square",basisA:new s(2+Math.sqrt(2),0),basisB:new s(.5*(2+Math.sqrt(2)),1+1/Math.sqrt(2)),polygons:[[new s(.5,.5*(1+Math.sqrt(2))),new s(.5*(1+Math.sqrt(2)),.5),new s(.5*(1+Math.sqrt(2)),-.5),new s(.5,.5*(-1-Math.sqrt(2))),new s(-.5,.5*(-1-Math.sqrt(2))),new s(.5*(-1-Math.sqrt(2)),-.5),new s(.5*(-1-Math.sqrt(2)),.5),new s(-.5,.5*(1+Math.sqrt(2)))],[new s(.5*(1+Math.sqrt(2)),.5),new s(.5*(1+Math.sqrt(2)),-.5),new s(3/2+1/Math.sqrt(2),-.5),new s(3/2+1/Math.sqrt(2),.5)]],translation:new s(2+Math.sqrt(2)+.5*(2+Math.sqrt(2)),1+1/Math.sqrt(2))},Us={name:"Snub Square",basisA:new s(1/2*(1+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),basisB:new s(1/2*(-1-Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),polygons:[[new s(1/2,0),new s(0,-(Math.sqrt(3)/2)),new s(-(1/2),0)],[new s(1/2,0),new s(0,Math.sqrt(3)/2),new s(-(1/2),0)],[new s(1/2*(1+Math.sqrt(3)),1/2),new s(1/2,0),new s(0,Math.sqrt(3)/2),new s(Math.sqrt(3)/2,1/2*(1+Math.sqrt(3)))],[new s(Math.sqrt(3)/2,1/2*(1+Math.sqrt(3))),new s(0,Math.sqrt(3)/2),new s(0,1/2*(2+Math.sqrt(3)))],[new s(-(Math.sqrt(3)/2),1/2*(1+Math.sqrt(3))),new s(0,Math.sqrt(3)/2),new s(0,1/2*(2+Math.sqrt(3)))],[new s(1/2*(-1-Math.sqrt(3)),1/2),new s(-(1/2),0),new s(0,Math.sqrt(3)/2),new s(-(Math.sqrt(3)/2),1/2*(1+Math.sqrt(3)))]],translation:new s(1/2*(-1-Math.sqrt(3))+1/2*(1+Math.sqrt(3)),-1-Math.sqrt(3))},$l={name:"Truncated Hexagonal",basisA:new s(2+Math.sqrt(3),0),basisB:new s(.5*(2+Math.sqrt(3)),3/2+Math.sqrt(3)),polygons:[[new s(1/2,1/2*(2+Math.sqrt(3))),new s(1/2*(1+Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(1/2*(2+Math.sqrt(3)),1/2),new s(1/2*(2+Math.sqrt(3)),-(1/2)),new s(1/2*(1+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2,1/2*(-2-Math.sqrt(3))),new s(-(1/2),1/2*(-2-Math.sqrt(3))),new s(1/2*(-1-Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2*(-2-Math.sqrt(3)),-(1/2)),new s(1/2*(-2-Math.sqrt(3)),1/2),new s(1/2*(-1-Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(-(1/2),1/2*(2+Math.sqrt(3)))],[new s(1/2*(1+Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(1/2*(3+Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(1/2*(2+Math.sqrt(3)),1/2)],[new s(1/2*(1+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2*(3+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2*(2+Math.sqrt(3)),-(1/2))]],translation:new s(2+Math.sqrt(3)+.5*(2+Math.sqrt(3)),3/2+Math.sqrt(3))},Ys={name:"Elongated Triangular",basisA:new s(1,0),basisB:new s(.5,.5*(2+Math.sqrt(3))),polygons:[[new s(-(1/2),-(1/2)),new s(-(1/2),1/2),new s(1/2,1/2),new s(1/2,-(1/2))],[new s(1/2,1/2),new s(0,1/2*(1+Math.sqrt(3))),new s(-(1/2),1/2)],[new s(1/2,-(1/2)),new s(0,1/2*(-1-Math.sqrt(3))),new s(-(1/2),-(1/2))]],translation:new s(3/2,.5*(2+Math.sqrt(3)))},th={name:"Great Rhombitrihexagonal",basisA:new s(3+Math.sqrt(3),0),basisB:new s(.5*(3+Math.sqrt(3)),1.5*(1+Math.sqrt(3))),polygons:[[new s(1/2,1/2*(2+Math.sqrt(3))),new s(1/2*(1+Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(1/2*(2+Math.sqrt(3)),1/2),new s(1/2*(2+Math.sqrt(3)),-(1/2)),new s(1/2*(1+Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2,1/2*(-2-Math.sqrt(3))),new s(-(1/2),1/2*(-2-Math.sqrt(3))),new s(1/2*(-1-Math.sqrt(3)),1/2*(-1-Math.sqrt(3))),new s(1/2*(-2-Math.sqrt(3)),-(1/2)),new s(1/2*(-2-Math.sqrt(3)),1/2),new s(1/2*(-1-Math.sqrt(3)),1/2*(1+Math.sqrt(3))),new s(-(1/2),1/2*(2+Math.sqrt(3)))],[new s(1,1+Math.sqrt(3)),new s(.5*(2+Math.sqrt(3)),.5*(1+2*Math.sqrt(3))),new s(.5*(1+Math.sqrt(3)),.5*(1+Math.sqrt(3))),new s(.5,.5*(2+Math.sqrt(3)))],[new s(.5*(1+Math.sqrt(3)),.5*(1+Math.sqrt(3))),new s(.5*(2+Math.sqrt(3)),.5),new s(1+.5*(2+Math.sqrt(3)),.5),new s(.5*(5+Math.sqrt(3)),.5*(1+Math.sqrt(3))),new s(.5*(4+Math.sqrt(3)),.5*(1+2*Math.sqrt(3))),new s(.5*(2+Math.sqrt(3)),.5*(1+2*Math.sqrt(3)))],[new s(1+.5*(2+Math.sqrt(3)),.5),new s(1+.5*(2+Math.sqrt(3)),-(1/2)),new s(.5*(2+Math.sqrt(3)),-(1/2)),new s(.5*(2+Math.sqrt(3)),.5)],[new s(.5*(1+Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(.5*(2+Math.sqrt(3)),-(1/2)),new s(1+.5*(2+Math.sqrt(3)),-(1/2)),new s(.5*(5+Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(.5*(4+Math.sqrt(3)),.5*(-1-2*Math.sqrt(3))),new s(.5*(2+Math.sqrt(3)),.5*(-1-2*Math.sqrt(3)))],[new s(.5*(2+Math.sqrt(3)),.5*(-1-2*Math.sqrt(3))),new s(1,-1-Math.sqrt(3)),new s(.5,.5*(-2-Math.sqrt(3))),new s(.5*(1+Math.sqrt(3)),.5*(-1-Math.sqrt(3)))]],translation:new s(3+Math.sqrt(3)+.5*(3+Math.sqrt(3)),1.5*(1+Math.sqrt(3)))},eh={name:"Snub Hexagonal",basisA:new s(5/2,-Math.sqrt(3)/2),basisB:new s(-1/2,3*Math.sqrt(3)/2),polygons:[[new s(1/2,Math.sqrt(3)/2),new s(1,0),new s(1/2,-(Math.sqrt(3)/2)),new s(-(1/2),-(Math.sqrt(3)/2)),new s(-1,0),new s(-(1/2),Math.sqrt(3)/2)],[new s(-1,0),new s(-3/2,-(Math.sqrt(3)/2)),new s(-2,0)],[new s(-(1/2),-(Math.sqrt(3)/2)),new s(-1,0),new s(-3/2,-(Math.sqrt(3)/2))],[new s(1/2,Math.sqrt(3)/2),new s(1,0),new s(3/2,Math.sqrt(3)/2)],[new s(1,0),new s(3/2,Math.sqrt(3)/2),new s(2,0)],[new s(-1,0),new s(-(1/2),Math.sqrt(3)/2),new s(-(3/2),Math.sqrt(3)/2)],[new s(1/2,-(Math.sqrt(3)/2)),new s(-(1/2),-(Math.sqrt(3)/2)),new s(0,-Math.sqrt(3))],[new s(1,0),new s(1/2,-(Math.sqrt(3)/2)),new s(3/2,-(Math.sqrt(3)/2))],[new s(-(1/2),Math.sqrt(3)/2),new s(1/2,Math.sqrt(3)/2),new s(0,Math.sqrt(3))]],translation:new s(2,Math.sqrt(3))},Vs={name:"Rhombille",basisA:new s(2,0),basisB:new s(1,Math.sqrt(3)),polygons:[[new s(5,5/Math.sqrt(3)),new s(4,2*Math.sqrt(3)),new s(5,7/Math.sqrt(3)),new s(6,2*Math.sqrt(3))],[new s(5,5/Math.sqrt(3)),new s(6,2*Math.sqrt(3)),new s(6,4/Math.sqrt(3)),new s(5,Math.sqrt(3))],[new s(5,5/Math.sqrt(3)),new s(5,Math.sqrt(3)),new s(4,4/Math.sqrt(3)),new s(4,2*Math.sqrt(3))]],translation:new s(3,Math.sqrt(3))},Js={name:"Deltoidal Trihexagonal",basisA:new s(.5*(3+Math.sqrt(3)),.5*(1+Math.sqrt(3))),basisB:new s(.5*(3+Math.sqrt(3)),.5*(-1-Math.sqrt(3))),polygons:[[new s(1/3*(12+4*Math.sqrt(3)),0),new s(1/4*(15+5*Math.sqrt(3)),.25*(-1-Math.sqrt(3))),new s(3+Math.sqrt(3),0),new s(1/4*(15+5*Math.sqrt(3)),.25*(1+Math.sqrt(3)))],[new s(1/3*(12+4*Math.sqrt(3)),0),new s(1/4*(15+5*Math.sqrt(3)),.25*(1+Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(1+Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),0)],[new s(1/3*(12+4*Math.sqrt(3)),0),new s(.5*(9+3*Math.sqrt(3)),0),new s(.5*(9+3*Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(1/4*(15+5*Math.sqrt(3)),.25*(-1-Math.sqrt(3)))],[new s(1/3*(15+5*Math.sqrt(3)),0),new s(.5*(9+3*Math.sqrt(3)),0),new s(.5*(9+3*Math.sqrt(3)),.5*(1+Math.sqrt(3))),new s(1/4*(21+7*Math.sqrt(3)),.25*(1+Math.sqrt(3)))],[new s(1/3*(15+5*Math.sqrt(3)),0),new s(1/4*(21+7*Math.sqrt(3)),.25*(1+Math.sqrt(3))),new s(6+2*Math.sqrt(3),0),new s(1/4*(21+7*Math.sqrt(3)),.25*(-1-Math.sqrt(3)))],[new s(1/3*(15+5*Math.sqrt(3)),0),new s(1/4*(21+7*Math.sqrt(3)),.25*(-1-Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),0)]],translation:new s(3+Math.sqrt(3),.5*(-1-Math.sqrt(3))+.5*(1+Math.sqrt(3)))},ah={name:"Tetrakis Square",basisA:new s(2+Math.sqrt(2),0),basisB:new s(.5*(2+Math.sqrt(2)),1+1/Math.sqrt(2)),polygons:[[new s(4+2*Math.sqrt(2),.5*(2+Math.sqrt(2))),new s(4+2*Math.sqrt(2),2+Math.sqrt(2)),new s(.5*(10+5*Math.sqrt(2)),.5*(2+Math.sqrt(2)))],[new s(.5*(10+5*Math.sqrt(2)),2+Math.sqrt(2)),new s(.5*(10+5*Math.sqrt(2)),.5*(2+Math.sqrt(2))),new s(4+2*Math.sqrt(2),2+Math.sqrt(2))],[new s(.5*(10+5*Math.sqrt(2)),2+Math.sqrt(2)),new s(6+3*Math.sqrt(2),2+Math.sqrt(2)),new s(.5*(10+5*Math.sqrt(2)),.5*(2+Math.sqrt(2)))],[new s(6+3*Math.sqrt(2),2+Math.sqrt(2)),new s(6+3*Math.sqrt(2),.5*(2+Math.sqrt(2))),new s(.5*(10+5*Math.sqrt(2)),.5*(2+Math.sqrt(2)))]],translation:new s(2+Math.sqrt(2)+.5*(2+Math.sqrt(2)),1+1/Math.sqrt(2))},js={name:"Cairo Pentagonal",basisA:new s(.5*(1+Math.sqrt(3)),.5*(-1-Math.sqrt(3))),basisB:new s(.5*(-1-Math.sqrt(3)),.5*(-1-Math.sqrt(3))),polygons:[[new s(0,1/6*(-6-5*Math.sqrt(3))),new s(.25*(-1-Math.sqrt(3)),.25*(-3-3*Math.sqrt(3))),new s(-1/(2*Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(1/(2*Math.sqrt(3)),.5*(-1-Math.sqrt(3))),new s(.25*(1+Math.sqrt(3)),.25*(-3-3*Math.sqrt(3)))],[new s(0,1/6*(-6-5*Math.sqrt(3))),new s(.25*(1+Math.sqrt(3)),.25*(-3-3*Math.sqrt(3))),new s(1/6*(3+2*Math.sqrt(3)),-1-Math.sqrt(3)),new s(.25*(1+Math.sqrt(3)),.25*(-5-5*Math.sqrt(3))),new s(0,1/6*(-6-7*Math.sqrt(3)))],[new s(0,1/6*(-6-7*Math.sqrt(3))),new s(.25*(-1-Math.sqrt(3)),.25*(-5-5*Math.sqrt(3))),new s(1/6*(-3-2*Math.sqrt(3)),-1-Math.sqrt(3)),new s(.25*(-1-Math.sqrt(3)),.25*(-3-3*Math.sqrt(3))),new s(0,1/6*(-6-5*Math.sqrt(3)))],[new s(0,1/6*(-6-7*Math.sqrt(3))),new s(.25*(1+Math.sqrt(3)),.25*(-5-5*Math.sqrt(3))),new s(1/(2*Math.sqrt(3)),.5*(-3-3*Math.sqrt(3))),new s(-1/(2*Math.sqrt(3)),.5*(-3-3*Math.sqrt(3))),new s(.25*(-1-Math.sqrt(3)),.25*(-5-5*Math.sqrt(3)))]],translation:new s(.5*(-1-Math.sqrt(3))+.5*(1+Math.sqrt(3)),-1-Math.sqrt(3))},nh={name:"Triakis Triangular",basisA:new s(2+Math.sqrt(3),0),basisB:new s(.5*(2+Math.sqrt(3)),1.5+Math.sqrt(3)),polygons:[[new s(4+2*Math.sqrt(3),1/3*(6+4*Math.sqrt(3))),new s(.5*(10+5*Math.sqrt(3)),.5*(3+2*Math.sqrt(3))),new s(.5*(6+3*Math.sqrt(3)),.5*(3+2*Math.sqrt(3)))],[new s(4+2*Math.sqrt(3),1/3*(6+4*Math.sqrt(3))),new s(.5*(6+3*Math.sqrt(3)),.5*(3+2*Math.sqrt(3))),new s(4+2*Math.sqrt(3),3+2*Math.sqrt(3))],[new s(4+2*Math.sqrt(3),1/3*(6+4*Math.sqrt(3))),new s(4+2*Math.sqrt(3),3+2*Math.sqrt(3)),new s(.5*(10+5*Math.sqrt(3)),.5*(3+2*Math.sqrt(3)))],[new s(.5*(10+5*Math.sqrt(3)),1/6*(15+10*Math.sqrt(3))),new s(.5*(10+5*Math.sqrt(3)),.5*(3+2*Math.sqrt(3))),new s(4+2*Math.sqrt(3),3+2*Math.sqrt(3))],[new s(.5*(10+5*Math.sqrt(3)),1/6*(15+10*Math.sqrt(3))),new s(4+2*Math.sqrt(3),3+2*Math.sqrt(3)),new s(6+3*Math.sqrt(3),3+2*Math.sqrt(3))],[new s(.5*(10+5*Math.sqrt(3)),1/6*(15+10*Math.sqrt(3))),new s(6+3*Math.sqrt(3),3+2*Math.sqrt(3)),new s(.5*(10+5*Math.sqrt(3)),.5*(3+2*Math.sqrt(3)))]],translation:new s(2+Math.sqrt(3)+.5*(2+Math.sqrt(3)),1.5+Math.sqrt(3))},Ws={name:"Prismatic Pentagonal",basisA:new s(1,0),basisB:new s(.5,.5*(2+Math.sqrt(3))),polygons:[[new s(2,1/6*(9+5*Math.sqrt(3))),new s(2.5,1/6*(9+4*Math.sqrt(3))),new s(2.5,.5*(2+Math.sqrt(3))),new s(1.5,.5*(2+Math.sqrt(3))),new s(1.5,1/6*(9+4*Math.sqrt(3)))],[new s(2.5,1/6*(9+4*Math.sqrt(3))),new s(2,1/6*(9+5*Math.sqrt(3))),new s(2,2+Math.sqrt(3)),new s(3,2+Math.sqrt(3)),new s(3,1/6*(9+5*Math.sqrt(3)))]],translation:new s(1.5,.5*(2+Math.sqrt(3)))},sh={name:"Bisected Hexagonal",basisA:new s(3+Math.sqrt(3),0),basisB:new s(.5*(3+Math.sqrt(3)),1.5*(1+Math.sqrt(3))),polygons:[[new s(6+2*Math.sqrt(3),.5*(3+3*Math.sqrt(3))),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3)),new s(.5*(15+5*Math.sqrt(3)),.5*(3+3*Math.sqrt(3)))],[new s(6+2*Math.sqrt(3),.5*(3+3*Math.sqrt(3))),new s(.5*(15+5*Math.sqrt(3)),.5*(3+3*Math.sqrt(3))),new s(6+2*Math.sqrt(3),1+Math.sqrt(3))],[new s(6+2*Math.sqrt(3),.5*(3+3*Math.sqrt(3))),new s(6+2*Math.sqrt(3),1+Math.sqrt(3)),new s(.5*(9+3*Math.sqrt(3)),.5*(3+3*Math.sqrt(3)))],[new s(6+2*Math.sqrt(3),.5*(3+3*Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(3+3*Math.sqrt(3))),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3))],[new s(.25*(21+7*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3)),new s(.5*(9+3*Math.sqrt(3)),.5*(3+3*Math.sqrt(3)))],[new s(.25*(21+7*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(3+3*Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(5+5*Math.sqrt(3)))],[new s(.25*(21+7*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(.5*(9+3*Math.sqrt(3)),.5*(5+5*Math.sqrt(3))),new s(6+2*Math.sqrt(3),3+3*Math.sqrt(3))],[new s(.25*(21+7*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(6+2*Math.sqrt(3),3+3*Math.sqrt(3)),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3))],[new s(.25*(27+9*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3)),new s(6+2*Math.sqrt(3),3+3*Math.sqrt(3))],[new s(.25*(27+9*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(6+2*Math.sqrt(3),3+3*Math.sqrt(3)),new s(.5*(15+5*Math.sqrt(3)),.5*(5+5*Math.sqrt(3)))],[new s(.25*(27+9*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(.5*(15+5*Math.sqrt(3)),.5*(5+5*Math.sqrt(3))),new s(.5*(15+5*Math.sqrt(3)),.5*(3+3*Math.sqrt(3)))],[new s(.25*(27+9*Math.sqrt(3)),.25*(9+9*Math.sqrt(3))),new s(.5*(15+5*Math.sqrt(3)),.5*(3+3*Math.sqrt(3))),new s(6+2*Math.sqrt(3),2+2*Math.sqrt(3))]],translation:new s(3+Math.sqrt(3)+.5*(3+Math.sqrt(3)),1.5*(1+Math.sqrt(3)))},Xs={name:"Floret Pentagonal",basisA:new s(2.5,-Math.sqrt(3)/2),basisB:new s(-.5,3*Math.sqrt(3)/2),polygons:[[new s(2,Math.sqrt(3)),new s(3,4/Math.sqrt(3)),new s(3.5,7/(2*Math.sqrt(3))),new s(3.5,5/(2*Math.sqrt(3))),new s(3,2/Math.sqrt(3))],[new s(2,Math.sqrt(3)),new s(3,2/Math.sqrt(3)),new s(3,1/Math.sqrt(3)),new s(2.5,1/(2*Math.sqrt(3))),new s(2,1/Math.sqrt(3))],[new s(2,Math.sqrt(3)),new s(2,1/Math.sqrt(3)),new s(1.5,1/(2*Math.sqrt(3))),new s(1,1/Math.sqrt(3)),new s(1,2/Math.sqrt(3))],[new s(2,Math.sqrt(3)),new s(1,2/Math.sqrt(3)),new s(.5,5/(2*Math.sqrt(3))),new s(.5,7/(2*Math.sqrt(3))),new s(1,4/Math.sqrt(3))],[new s(2,Math.sqrt(3)),new s(1,4/Math.sqrt(3)),new s(1,5/Math.sqrt(3)),new s(1.5,11/(2*Math.sqrt(3))),new s(2,5/Math.sqrt(3))],[new s(2,Math.sqrt(3)),new s(2,5/Math.sqrt(3)),new s(2.5,11/(2*Math.sqrt(3))),new s(3,5/Math.sqrt(3)),new s(3,4/Math.sqrt(3))]],translation:new s(2,Math.sqrt(3))},Ks={name:"Portugal",basisA:new s(2,2),basisB:new s(-2,2),polygons:[[new s(0,0),new s(1,0),new s(2,1),new s(2,2),new s(1,2),new s(0,1)],[new s(2,2),new s(3,2),new s(4,1),new s(4,0),new s(3,0),new s(2,1)],[new s(1,0),new s(2,1),new s(3,0),new s(2,-1)]],translation:new s(0,4)},rh={name:"Trihex and Hex",basisA:new s(2,0),basisB:new s(1,Math.sqrt(3)),polygons:[[new s(-1,0),new s(-1,1/Math.sqrt(3)),new s(-.5,Math.sqrt(3)/2),new s(0,1/Math.sqrt(3)),new s(.5,Math.sqrt(3)/2),new s(1,1/Math.sqrt(3)),new s(1,0),new s(.5,-1/(2*Math.sqrt(3))),new s(.5,-Math.sqrt(3)/2),new s(0,-2/Math.sqrt(3)),new s(-.5,-Math.sqrt(3)/2),new s(-.5,-1/(2*Math.sqrt(3)))],[new s(-.5,5/(2*Math.sqrt(3))),new s(0,Math.sqrt(3)),new s(.5,5/(2*Math.sqrt(3))),new s(.5,Math.sqrt(3)/2),new s(0,1/Math.sqrt(3)),new s(-.5,Math.sqrt(3)/2)]],translation:new s(3,Math.sqrt(3))};class ca{constructor(a){C(this,"edges");C(this,"vertices");C(this,"faces");C(this,"halfEdges");C(this,"outerBoundary");C(this,"innerBoundaries");this.boardDescriptor=a,this.edges=a.edges,this.vertices=a.vertices,this.faces=a.faces,this.halfEdges=a.halfEdges,this.outerBoundary=a.outerBoundary,this.innerBoundaries=a.innerBoundaries}}class Qs{constructor(a,e){C(this,"forwardHalf");C(this,"reversedHalf");C(this,"forwardFace");C(this,"reversedFace");C(this,"vertices");C(this,"faces");this.start=a,this.end=e,q()&&w(a),q()&&w(e)}getOtherVertex(a){return q()&&w(a===this.start||a===this.end,"vertex must be one of the two vertices of this edge"),a===this.start?this.end:this.start}getOtherFace(a){return q()&&w(a===this.forwardFace||a===this.reversedFace,"face must be one of the two faces of this edge"),a===this.forwardFace?this.reversedFace:this.forwardFace}}class $s{constructor(a,e){C(this,"halfEdges");C(this,"edges");C(this,"vertices");this.logicalCoordinates=a,this.viewCoordinates=e,q()&&w(a),q()&&w(e)}}class tr{constructor(a,e,n){C(this,"edge");C(this,"reversed");C(this,"next");C(this,"previous");C(this,"face",null);this.start=a,this.end=e,this.isReversed=n,q()&&w(a),q()&&w(e)}}class er{constructor(a,e){C(this,"incomingHalfEdges");C(this,"outgoingHalfEdges");C(this,"edges");C(this,"faces");this.logicalCoordinates=a,this.viewCoordinates=e,q()&&w(a),q()&&w(e)}getHalfEdgeTo(a){const e=this.outgoingHalfEdges.find(n=>n.end===a);return q()&&w(e),e}getHalfEdgeFrom(a){const e=this.incomingHalfEdges.find(n=>n.start===a);return q()&&w(e),e}getEdgeTo(a){const e=this.edges.find(n=>n.start===a||n.end===a);return q()&&w(e),e}}const Ae=t=>{let a=0;for(let e=0;e<t.length;e++){const n=t[e],r=t[(e+1)%t.length];a+=(r.x+n.x)*(r.y-n.y)}return .5*a},ar=t=>Math.abs(Ae(t)),Mn=t=>{const a=Ae(t);if(a===0)return t.reduce((r,i)=>r.plus(i),new s(0,0)).timesScalar(1/t.length);let e=0,n=0;for(let r=0;r<t.length;r++){const i=t[r],h=t[(r+1)%t.length],o=i.x*(2*i.y+h.y)+h.x*(i.y+2*h.y);e+=(i.x-h.x)*o,n+=(h.y-i.y)*o}return new s(e,n).timesScalar(1/(6*a))},ih=(t,a)=>{let e=0;for(let n=0;n<t.length;n++){const r=t[n],i=t[(n+1)%t.length],h=a[n],o=a[(n+1)%t.length];e+=(i.x+r.x)*(o.y-h.y)+(o.x-h.x)*(i.y-r.y)}return .5*e},mn=(t,a)=>{const e=t.faces.map(h=>ar(h.vertices.map(o=>o.viewCoordinates))),n=a(e),r=t.vertices.map(h=>({logicalCoordinates:h.logicalCoordinates,viewCoordinates:h.viewCoordinates.timesScalar(n)})),i=new Map(r.map((h,o)=>[t.vertices[o],h]));return{vertices:r,faces:t.faces.map(h=>({logicalCoordinates:h.logicalCoordinates,vertices:h.vertices.map(o=>i.get(o))}))}},nr=(t,a)=>mn(t,e=>Math.sqrt(a/(F.sum(e)/e.length))),sr=(t,a)=>mn(t,e=>Math.sqrt(a/Math.min(...e)));class rr{constructor(a,e){this.start=a,this.end=e}isCanonicalHalfEdge(){return this.start.x<this.end.x||this.start.x===this.end.x&&this.start.y<this.end.y}}class ir{constructor(){C(this,"identifiers",[]);C(this,"canonicalIdentifiers",[]);C(this,"map",new Map)}add(a,e){if(q()&&w(a.x!==e.x||a.y!==e.y),this.lookupAttempt(a,e)!==null)return;const n=(r,i)=>{let h;this.map.has(r)?h=this.map.get(r):(h=new Map,this.map.set(r,h));const o=new rr(r,i);h.set(i,o),this.identifiers.push(o),o.isCanonicalHalfEdge()&&this.canonicalIdentifiers.push(o)};n(a,e),n(e,a)}getAdjacentLocations(a){const e=this.map.get(a);return e?Array.from(e.keys()):[]}lookupAttempt(a,e){const n=this.map.get(a);return n?n.get(e)??null:null}lookup(a,e){const n=this.lookupAttempt(a,e);return q()&&w(n),n}lookupCanonical(a,e){const n=this.lookup(a,e);return n.isCanonicalHalfEdge()?n:this.lookup(e,a)}}const fa=t=>{const a=t.vertices;let e=t.faces;e=e.map(g=>Ae(g.vertices.map(m=>m.viewCoordinates))>0?g:{logicalCoordinates:g.logicalCoordinates,vertices:g.vertices.slice().reverse()});const n=new ir;e.forEach(g=>{for(let m=0;m<g.vertices.length;m++){const x=g.vertices[m].logicalCoordinates,A=g.vertices[(m+1)%g.vertices.length].logicalCoordinates;n.add(x,A)}});const r=new Map,i=new Map,h=new Map,o=new Map,f=g=>r.get(g)??null,l=g=>i.get(g)??null,c=(g,m)=>{const x=n.lookup(g,m);return o.get(x)??null},E=a.map(g=>new er(g.logicalCoordinates,g.viewCoordinates));E.forEach(g=>r.set(g.logicalCoordinates,g));const u=e.map(g=>new $s(g.logicalCoordinates,Mn(g.vertices.map(m=>m.viewCoordinates))));u.forEach(g=>i.set(g.logicalCoordinates,g));const d=n.canonicalIdentifiers.map(g=>new Qs(f(g.start),f(g.end)));d.forEach(g=>h.set(n.lookupCanonical(g.start.logicalCoordinates,g.end.logicalCoordinates),g));const p=n.identifiers.map(g=>new tr(f(g.start),f(g.end),!g.isCanonicalHalfEdge()));p.forEach(g=>o.set(n.lookup(g.start.logicalCoordinates,g.end.logicalCoordinates),g)),d.forEach(g=>{const m=c(g.start.logicalCoordinates,g.end.logicalCoordinates),x=c(g.end.logicalCoordinates,g.start.logicalCoordinates);q()&&w(m),q()&&w(x),m.edge=g,x.edge=g,m.reversed=x,x.reversed=m,g.forwardHalf=m,g.reversedHalf=x,g.vertices=[g.start,g.end]}),e.forEach(g=>{const m=l(g.logicalCoordinates),x=g.vertices.map(v=>f(v.logicalCoordinates)),A=[],T=[];for(let v=0;v<x.length;v++){const I=g.vertices[v].logicalCoordinates,B=g.vertices[(v+1)%x.length].logicalCoordinates,S=g.vertices[(v+2)%x.length].logicalCoordinates,b=c(I,B);b.face=m;const P=c(B,S);b.next=P,P.previous=b,T.push(b),A.push(b.edge)}m.halfEdges=T,m.edges=A,m.vertices=x}),p.forEach(g=>{g.face===void 0&&(g.face=null)}),d.forEach(g=>{g.forwardFace=g.forwardHalf.face,g.reversedFace=g.reversedHalf.face,g.faces=[g.forwardFace,g.reversedFace].filter(m=>m!==null)});const k=new Set(p.filter(g=>g.face===null)),M=[],y=[];for(;k.size;){const g=k.values().next().value;k.delete(g);const m=T=>{q()&&w(T.face===null);const v=T.end.logicalCoordinates,S=n.getAdjacentLocations(v).filter(b=>b!==T.start.logicalCoordinates).map(b=>c(v,b)).filter(b=>b.face===null);return q()&&w(S.length===1),S[0]},x=[g];let A=m(g);for(g.next=A,A.previous=g;A!==g;){x.push(A),k.delete(A);const T=A;A=m(A),T.next=A,A.previous=T}Ae(x.map(T=>T.start.viewCoordinates))<0?M.push(x):y.push(x)}return q()&&w(M.length===1),E.forEach(g=>{const m=n.getAdjacentLocations(g.logicalCoordinates),x=c(m[0],g.logicalCoordinates);let A=x;const T=[x];for(;A.reversed.previous!==x;)q()&&w(A.reversed.previous),A=A.reversed.previous,T.push(A);g.incomingHalfEdges=T,g.outgoingHalfEdges=T.map(v=>v.reversed),g.edges=T.map(v=>v.edge),g.faces=T.map(v=>v.face).filter(v=>v!==null)}),{edges:d,vertices:E,faces:u,halfEdges:p,outerBoundary:M[0],innerBoundaries:y}},Aa=(t,a)=>{const e=F.sortBy(t),n=[];let r=[];for(let h=0;h<e.length;h++){const o=e[h];r.length===0||Math.abs(r[r.length-1]-o)<=a?r.push(o):(n.push(r),r=[o])}r.length>0&&n.push(r);const i=new Map;return n.forEach(h=>{const o=F.sum(h)/h.length;h.forEach(f=>i.set(f,o))}),i};class or extends ca{constructor(a,e){const n=a.flatMap(E=>E.map(u=>u.x)),r=a.flatMap(E=>E.map(u=>u.y)),i=Aa(n,1e-4),h=Aa(r,1e-4),o=[],f=new Map,l=E=>{const u=i.get(E.x),d=h.get(E.y);q()&&w(u!==void 0&&d!==void 0);const p=`${u},${d}`;if(!f.has(p)){const k={logicalCoordinates:new s(0,f.size),viewCoordinates:new s(u,d).timesScalar(e)};f.set(p,k),o.push(k)}return f.get(p)},c=a.map((E,u)=>({logicalCoordinates:new s(u,0),vertices:E.map(l)}));super(fa(sr({vertices:o,faces:c},e))),this.polygons=a,this.scale=e}}const Oe=new Map;class da extends or{constructor(a,e){const n=a.generate(e);super(n,a.scale??1),this.generator=a,this.parameters=e}static get(a,e){const n=a.name+"/"+JSON.stringify(e);return Oe.has(n)||Oe.set(n,new da(a,e)),Oe.get(n)}}const ot=(t,a)=>({name:t.name,parameters:{width:{label:"Width",type:"integer",range:new qa(2,50)},height:{label:"Height",type:"integer",range:new qa(2,50)},squareRegion:{label:"Square",type:"boolean"}},defaultParameterValues:{width:(a==null?void 0:a.width)??10,height:(a==null?void 0:a.height)??10,squareRegion:(a==null?void 0:a.squareRegion)??!1},scale:t.scale,generate:e=>{const n=t.polygons,r=t.basisA,i=t.basisB,h=[],o=new Fe(-e.width/2,-e.height/2,e.width/2,e.height/2),f=Fe.NOTHING.copy();n.forEach(p=>{p.forEach(k=>{f.addPoint(k)})});const l=Math.max(Math.abs(o.minX),Math.abs(o.maxX),Math.abs(o.minY),Math.abs(o.maxY))*20,c=Fe.NOTHING.copy(),E=new s(0,0),u=new s(0,0),d=new s(0,0);return F.range(-l,l).forEach(p=>{E.set(r).multiplyScalar(p),F.range(-l,l).forEach(k=>{u.set(i).multiplyScalar(k),d.set(E).add(u),c.set(f).shift(d),o.intersectsBounds(c)&&n.forEach(M=>{const y=M.map(A=>A.plus(d)),g=Mn(y),m=g.x*2/e.width,x=g.y*2/e.height;if(e.squareRegion){if(Math.abs(m)>=1||Math.abs(x)>=1-1e-6)return}else if(Math.sqrt(m*m+x*x)>=1-1e-6)return;h.push(y)})})}),h}}),En=t=>{q()&&(t.edges.forEach(a=>{const e=a.forwardHalf,n=a.reversedHalf;w(e.edge===a),w(n.edge===a),w(!e.isReversed),w(n.isReversed),w(e.reversed===n),w(n.reversed===e),w(e.start===a.start),w(e.end===a.end),w(n.start===a.end),w(n.end===a.start),w(e.next.previous===e),w(e.previous.next===e),w(n.next.previous===n),w(n.previous.next===n),w(e.next!==e),w(e.previous!==e),w(n.next!==n),w(n.previous!==n),w(e.next.face===e.face),w(e.previous.face===e.face),w(n.next.face===n.face),w(n.previous.face===n.face),w(e.face===a.forwardFace),w(n.face===a.reversedFace)}),t.vertices.forEach(a=>{a.incomingHalfEdges.forEach(r=>{w(r.end===a)}),a.outgoingHalfEdges.forEach(r=>{w(r.start===a)});const e=r=>a.incomingHalfEdges[(r+a.incomingHalfEdges.length)%a.incomingHalfEdges.length],n=r=>a.outgoingHalfEdges[(r+a.outgoingHalfEdges.length)%a.outgoingHalfEdges.length];F.range(0,a.incomingHalfEdges.length).forEach(r=>{const i=e(r),h=n(r);w(i.reversed===h),w(i.next===n(r-1)),w(h.previous===e(r+1))}),a.edges.forEach(r=>{w(r.start===a||r.end===a),w(a.incomingHalfEdges.includes(r.forwardHalf)||a.outgoingHalfEdges.includes(r.forwardHalf)),w(a.incomingHalfEdges.includes(r.reversedHalf)||a.outgoingHalfEdges.includes(r.reversedHalf)),r.forwardFace&&(w(r.forwardFace.vertices.includes(a)),w(a.faces.includes(r.forwardFace))),r.reversedFace&&(w(r.reversedFace.vertices.includes(a)),w(a.faces.includes(r.reversedFace)))}),a.faces.forEach(r=>{w(r.vertices.includes(a))})}))};class lr extends ca{constructor(e,n,r,i=0){let h,o;r?(h=new s(Math.sqrt(3),0).timesScalar(n),o=new s(Math.sqrt(3)/2,3/2).timesScalar(n)):(h=new s(3/2,Math.sqrt(3)/2).timesScalar(n),o=new s(0,Math.sqrt(3)).timesScalar(n));const f=[new s(1,0),new s(1,-1),new s(0,-1),new s(-1,0),new s(-1,1),new s(0,1)],l=F.range(0,6).map(M=>f[M].plus(f[(M+1)%6])),c=M=>l.map(y=>y.plus(M.timesScalar(3))),E=(M,y)=>(Math.abs(M.x-y.x)+Math.abs(M.x+M.y-y.x-y.y)+Math.abs(M.y-y.y))/2,u=[];for(let M=-e;M<=e;M++)for(let y=Math.max(-e,-M-e);y<=Math.min(e,-M+e);y++){const g=new s(M,y);E(g,new s(0,0))>=i&&u.push(g)}const p=F.uniqWith(u.flatMap(c),(M,y)=>M.equals(y)).map(M=>({logicalCoordinates:M,viewCoordinates:h.timesScalar(M.x).plus(o.timesScalar(M.y)).timesScalar(1/3)})),k=u.map(M=>({logicalCoordinates:M,vertices:c(M).map(y=>{const g=p.find(m=>m.logicalCoordinates.equals(y));return q()&&w(g),g})}));super(fa(nr({vertices:p,faces:k},n)));C(this,"isHexagonal",!0);this.radius=e,this.scale=n,this.isPointyTop=r,this.holeRadius=i,q()&&En(this)}static enumeratePointyFaceCoordinates(e){const n=[];for(let r=-e;r<=e;r++)for(let i=Math.max(-e,-r-e);i<=Math.min(e,-r+e);i++)n.push(new s(i,r));return n}}class hr extends ca{constructor(e,n){const r=[],i=new Map,h=(f,l)=>{const c=`${f},${l}`;if(!i.has(c)){const E={logicalCoordinates:new s(f,l),viewCoordinates:new s(f,l)};r.push(E),i.set(c,E)}return i.get(c)},o=F.range(0,n).flatMap(f=>F.range(0,e).map(l=>({logicalCoordinates:new s(l,f),vertices:[h(l,f),h(l+1,f),h(l+1,f+1),h(l,f+1)]})));super(fa({vertices:r,faces:o}));C(this,"isSquare",!0);this.width=e,this.height=n,q()&&En(this)}}/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */const cr=4,ka=0,Ba=1,fr=2;function Jt(t){let a=t.length;for(;--a>=0;)t[a]=0}const dr=0,vn=1,ur=2,gr=3,wr=258,ua=29,ge=256,ie=ge+1+ua,Gt=30,ga=19,qn=2*ie+1,St=15,Ne=16,pr=7,wa=256,bn=16,_n=17,yn=18,ea=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),_e=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),xr=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),An=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Mr=512,xt=new Array((ie+2)*2);Jt(xt);const ne=new Array(Gt*2);Jt(ne);const oe=new Array(Mr);Jt(oe);const le=new Array(wr-gr+1);Jt(le);const pa=new Array(ua);Jt(pa);const ke=new Array(Gt);Jt(ke);function Ze(t,a,e,n,r){this.static_tree=t,this.extra_bits=a,this.extra_base=e,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}let kn,Bn,Sn;function Le(t,a){this.dyn_tree=t,this.max_code=0,this.stat_desc=a}const Tn=t=>t<256?oe[t]:oe[256+(t>>>7)],he=(t,a)=>{t.pending_buf[t.pending++]=a&255,t.pending_buf[t.pending++]=a>>>8&255},K=(t,a,e)=>{t.bi_valid>Ne-e?(t.bi_buf|=a<<t.bi_valid&65535,he(t,t.bi_buf),t.bi_buf=a>>Ne-t.bi_valid,t.bi_valid+=e-Ne):(t.bi_buf|=a<<t.bi_valid&65535,t.bi_valid+=e)},ft=(t,a,e)=>{K(t,e[a*2],e[a*2+1])},Cn=(t,a)=>{let e=0;do e|=t&1,t>>>=1,e<<=1;while(--a>0);return e>>>1},mr=t=>{t.bi_valid===16?(he(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=t.bi_buf&255,t.bi_buf>>=8,t.bi_valid-=8)},Er=(t,a)=>{const e=a.dyn_tree,n=a.max_code,r=a.stat_desc.static_tree,i=a.stat_desc.has_stree,h=a.stat_desc.extra_bits,o=a.stat_desc.extra_base,f=a.stat_desc.max_length;let l,c,E,u,d,p,k=0;for(u=0;u<=St;u++)t.bl_count[u]=0;for(e[t.heap[t.heap_max]*2+1]=0,l=t.heap_max+1;l<qn;l++)c=t.heap[l],u=e[e[c*2+1]*2+1]+1,u>f&&(u=f,k++),e[c*2+1]=u,!(c>n)&&(t.bl_count[u]++,d=0,c>=o&&(d=h[c-o]),p=e[c*2],t.opt_len+=p*(u+d),i&&(t.static_len+=p*(r[c*2+1]+d)));if(k!==0){do{for(u=f-1;t.bl_count[u]===0;)u--;t.bl_count[u]--,t.bl_count[u+1]+=2,t.bl_count[f]--,k-=2}while(k>0);for(u=f;u!==0;u--)for(c=t.bl_count[u];c!==0;)E=t.heap[--l],!(E>n)&&(e[E*2+1]!==u&&(t.opt_len+=(u-e[E*2+1])*e[E*2],e[E*2+1]=u),c--)}},In=(t,a,e)=>{const n=new Array(St+1);let r=0,i,h;for(i=1;i<=St;i++)r=r+e[i-1]<<1,n[i]=r;for(h=0;h<=a;h++){let o=t[h*2+1];o!==0&&(t[h*2]=Cn(n[o]++,o))}},vr=()=>{let t,a,e,n,r;const i=new Array(St+1);for(e=0,n=0;n<ua-1;n++)for(pa[n]=e,t=0;t<1<<ea[n];t++)le[e++]=n;for(le[e-1]=n,r=0,n=0;n<16;n++)for(ke[n]=r,t=0;t<1<<_e[n];t++)oe[r++]=n;for(r>>=7;n<Gt;n++)for(ke[n]=r<<7,t=0;t<1<<_e[n]-7;t++)oe[256+r++]=n;for(a=0;a<=St;a++)i[a]=0;for(t=0;t<=143;)xt[t*2+1]=8,t++,i[8]++;for(;t<=255;)xt[t*2+1]=9,t++,i[9]++;for(;t<=279;)xt[t*2+1]=7,t++,i[7]++;for(;t<=287;)xt[t*2+1]=8,t++,i[8]++;for(In(xt,ie+1,i),t=0;t<Gt;t++)ne[t*2+1]=5,ne[t*2]=Cn(t,5);kn=new Ze(xt,ea,ge+1,ie,St),Bn=new Ze(ne,_e,0,Gt,St),Sn=new Ze(new Array(0),xr,0,ga,pr)},zn=t=>{let a;for(a=0;a<ie;a++)t.dyn_ltree[a*2]=0;for(a=0;a<Gt;a++)t.dyn_dtree[a*2]=0;for(a=0;a<ga;a++)t.bl_tree[a*2]=0;t.dyn_ltree[wa*2]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},Rn=t=>{t.bi_valid>8?he(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},Sa=(t,a,e,n)=>{const r=a*2,i=e*2;return t[r]<t[i]||t[r]===t[i]&&n[a]<=n[e]},Pe=(t,a,e)=>{const n=t.heap[e];let r=e<<1;for(;r<=t.heap_len&&(r<t.heap_len&&Sa(a,t.heap[r+1],t.heap[r],t.depth)&&r++,!Sa(a,n,t.heap[r],t.depth));)t.heap[e]=t.heap[r],e=r,r<<=1;t.heap[e]=n},Ta=(t,a,e)=>{let n,r,i=0,h,o;if(t.sym_next!==0)do n=t.pending_buf[t.sym_buf+i++]&255,n+=(t.pending_buf[t.sym_buf+i++]&255)<<8,r=t.pending_buf[t.sym_buf+i++],n===0?ft(t,r,a):(h=le[r],ft(t,h+ge+1,a),o=ea[h],o!==0&&(r-=pa[h],K(t,r,o)),n--,h=Tn(n),ft(t,h,e),o=_e[h],o!==0&&(n-=ke[h],K(t,n,o)));while(i<t.sym_next);ft(t,wa,a)},aa=(t,a)=>{const e=a.dyn_tree,n=a.stat_desc.static_tree,r=a.stat_desc.has_stree,i=a.stat_desc.elems;let h,o,f=-1,l;for(t.heap_len=0,t.heap_max=qn,h=0;h<i;h++)e[h*2]!==0?(t.heap[++t.heap_len]=f=h,t.depth[h]=0):e[h*2+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=f<2?++f:0,e[l*2]=1,t.depth[l]=0,t.opt_len--,r&&(t.static_len-=n[l*2+1]);for(a.max_code=f,h=t.heap_len>>1;h>=1;h--)Pe(t,e,h);l=i;do h=t.heap[1],t.heap[1]=t.heap[t.heap_len--],Pe(t,e,1),o=t.heap[1],t.heap[--t.heap_max]=h,t.heap[--t.heap_max]=o,e[l*2]=e[h*2]+e[o*2],t.depth[l]=(t.depth[h]>=t.depth[o]?t.depth[h]:t.depth[o])+1,e[h*2+1]=e[o*2+1]=l,t.heap[1]=l++,Pe(t,e,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],Er(t,a),In(e,f,t.bl_count)},Ca=(t,a,e)=>{let n,r=-1,i,h=a[0*2+1],o=0,f=7,l=4;for(h===0&&(f=138,l=3),a[(e+1)*2+1]=65535,n=0;n<=e;n++)i=h,h=a[(n+1)*2+1],!(++o<f&&i===h)&&(o<l?t.bl_tree[i*2]+=o:i!==0?(i!==r&&t.bl_tree[i*2]++,t.bl_tree[bn*2]++):o<=10?t.bl_tree[_n*2]++:t.bl_tree[yn*2]++,o=0,r=i,h===0?(f=138,l=3):i===h?(f=6,l=3):(f=7,l=4))},Ia=(t,a,e)=>{let n,r=-1,i,h=a[0*2+1],o=0,f=7,l=4;for(h===0&&(f=138,l=3),n=0;n<=e;n++)if(i=h,h=a[(n+1)*2+1],!(++o<f&&i===h)){if(o<l)do ft(t,i,t.bl_tree);while(--o!==0);else i!==0?(i!==r&&(ft(t,i,t.bl_tree),o--),ft(t,bn,t.bl_tree),K(t,o-3,2)):o<=10?(ft(t,_n,t.bl_tree),K(t,o-3,3)):(ft(t,yn,t.bl_tree),K(t,o-11,7));o=0,r=i,h===0?(f=138,l=3):i===h?(f=6,l=3):(f=7,l=4)}},qr=t=>{let a;for(Ca(t,t.dyn_ltree,t.l_desc.max_code),Ca(t,t.dyn_dtree,t.d_desc.max_code),aa(t,t.bl_desc),a=ga-1;a>=3&&t.bl_tree[An[a]*2+1]===0;a--);return t.opt_len+=3*(a+1)+5+5+4,a},br=(t,a,e,n)=>{let r;for(K(t,a-257,5),K(t,e-1,5),K(t,n-4,4),r=0;r<n;r++)K(t,t.bl_tree[An[r]*2+1],3);Ia(t,t.dyn_ltree,a-1),Ia(t,t.dyn_dtree,e-1)},_r=t=>{let a=4093624447,e;for(e=0;e<=31;e++,a>>>=1)if(a&1&&t.dyn_ltree[e*2]!==0)return ka;if(t.dyn_ltree[9*2]!==0||t.dyn_ltree[10*2]!==0||t.dyn_ltree[13*2]!==0)return Ba;for(e=32;e<ge;e++)if(t.dyn_ltree[e*2]!==0)return Ba;return ka};let za=!1;const yr=t=>{za||(vr(),za=!0),t.l_desc=new Le(t.dyn_ltree,kn),t.d_desc=new Le(t.dyn_dtree,Bn),t.bl_desc=new Le(t.bl_tree,Sn),t.bi_buf=0,t.bi_valid=0,zn(t)},Fn=(t,a,e,n)=>{K(t,(dr<<1)+(n?1:0),3),Rn(t),he(t,e),he(t,~e),e&&t.pending_buf.set(t.window.subarray(a,a+e),t.pending),t.pending+=e},Ar=t=>{K(t,vn<<1,3),ft(t,wa,xt),mr(t)},kr=(t,a,e,n)=>{let r,i,h=0;t.level>0?(t.strm.data_type===fr&&(t.strm.data_type=_r(t)),aa(t,t.l_desc),aa(t,t.d_desc),h=qr(t),r=t.opt_len+3+7>>>3,i=t.static_len+3+7>>>3,i<=r&&(r=i)):r=i=e+5,e+4<=r&&a!==-1?Fn(t,a,e,n):t.strategy===cr||i===r?(K(t,(vn<<1)+(n?1:0),3),Ta(t,xt,ne)):(K(t,(ur<<1)+(n?1:0),3),br(t,t.l_desc.max_code+1,t.d_desc.max_code+1,h+1),Ta(t,t.dyn_ltree,t.dyn_dtree)),zn(t),n&&Rn(t)},Br=(t,a,e)=>(t.pending_buf[t.sym_buf+t.sym_next++]=a,t.pending_buf[t.sym_buf+t.sym_next++]=a>>8,t.pending_buf[t.sym_buf+t.sym_next++]=e,a===0?t.dyn_ltree[e*2]++:(t.matches++,a--,t.dyn_ltree[(le[e]+ge+1)*2]++,t.dyn_dtree[Tn(a)*2]++),t.sym_next===t.sym_end);var Sr=yr,Tr=Fn,Cr=kr,Ir=Br,zr=Ar,Rr={_tr_init:Sr,_tr_stored_block:Tr,_tr_flush_block:Cr,_tr_tally:Ir,_tr_align:zr};const Fr=(t,a,e,n)=>{let r=t&65535|0,i=t>>>16&65535|0,h=0;for(;e!==0;){h=e>2e3?2e3:e,e-=h;do r=r+a[n++]|0,i=i+r|0;while(--h);r%=65521,i%=65521}return r|i<<16|0};var ce=Fr;const Hr=()=>{let t,a=[];for(var e=0;e<256;e++){t=e;for(var n=0;n<8;n++)t=t&1?3988292384^t>>>1:t>>>1;a[e]=t}return a},Dr=new Uint32Array(Hr()),Or=(t,a,e,n)=>{const r=Dr,i=n+e;t^=-1;for(let h=n;h<i;h++)t=t>>>8^r[(t^a[h])&255];return t^-1};var G=Or,It={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Ft={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:Nr,_tr_stored_block:na,_tr_flush_block:Zr,_tr_tally:bt,_tr_align:Lr}=Rr,{Z_NO_FLUSH:_t,Z_PARTIAL_FLUSH:Pr,Z_FULL_FLUSH:Gr,Z_FINISH:st,Z_BLOCK:Ra,Z_OK:U,Z_STREAM_END:Fa,Z_STREAM_ERROR:dt,Z_DATA_ERROR:Ur,Z_BUF_ERROR:Ge,Z_DEFAULT_COMPRESSION:Yr,Z_FILTERED:Vr,Z_HUFFMAN_ONLY:me,Z_RLE:Jr,Z_FIXED:jr,Z_DEFAULT_STRATEGY:Wr,Z_UNKNOWN:Xr,Z_DEFLATED:Ce}=Ft,Kr=9,Qr=15,$r=8,ti=29,ei=256,sa=ei+1+ti,ai=30,ni=19,si=2*sa+1,ri=15,z=3,qt=258,ut=qt+z+1,ii=32,Ut=42,xa=57,ra=69,ia=73,oa=91,la=103,Tt=113,te=666,X=1,jt=2,zt=3,Wt=4,oi=3,Ct=(t,a)=>(t.msg=It[a],a),Ha=t=>t*2-(t>4?9:0),vt=t=>{let a=t.length;for(;--a>=0;)t[a]=0},li=t=>{let a,e,n,r=t.w_size;a=t.hash_size,n=a;do e=t.head[--n],t.head[n]=e>=r?e-r:0;while(--a);a=r,n=a;do e=t.prev[--n],t.prev[n]=e>=r?e-r:0;while(--a)};let hi=(t,a,e)=>(a<<t.hash_shift^e)&t.hash_mask,yt=hi;const Q=t=>{const a=t.state;let e=a.pending;e>t.avail_out&&(e=t.avail_out),e!==0&&(t.output.set(a.pending_buf.subarray(a.pending_out,a.pending_out+e),t.next_out),t.next_out+=e,a.pending_out+=e,t.total_out+=e,t.avail_out-=e,a.pending-=e,a.pending===0&&(a.pending_out=0))},$=(t,a)=>{Zr(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,a),t.block_start=t.strstart,Q(t.strm)},H=(t,a)=>{t.pending_buf[t.pending++]=a},$t=(t,a)=>{t.pending_buf[t.pending++]=a>>>8&255,t.pending_buf[t.pending++]=a&255},ha=(t,a,e,n)=>{let r=t.avail_in;return r>n&&(r=n),r===0?0:(t.avail_in-=r,a.set(t.input.subarray(t.next_in,t.next_in+r),e),t.state.wrap===1?t.adler=ce(t.adler,a,r,e):t.state.wrap===2&&(t.adler=G(t.adler,a,r,e)),t.next_in+=r,t.total_in+=r,r)},Hn=(t,a)=>{let e=t.max_chain_length,n=t.strstart,r,i,h=t.prev_length,o=t.nice_match;const f=t.strstart>t.w_size-ut?t.strstart-(t.w_size-ut):0,l=t.window,c=t.w_mask,E=t.prev,u=t.strstart+qt;let d=l[n+h-1],p=l[n+h];t.prev_length>=t.good_match&&(e>>=2),o>t.lookahead&&(o=t.lookahead);do if(r=a,!(l[r+h]!==p||l[r+h-1]!==d||l[r]!==l[n]||l[++r]!==l[n+1])){n+=2,r++;do;while(l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&l[++n]===l[++r]&&n<u);if(i=qt-(u-n),n=u-qt,i>h){if(t.match_start=a,h=i,i>=o)break;d=l[n+h-1],p=l[n+h]}}while((a=E[a&c])>f&&--e!==0);return h<=t.lookahead?h:t.lookahead},Yt=t=>{const a=t.w_size;let e,n,r;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=a+(a-ut)&&(t.window.set(t.window.subarray(a,a+a-n),0),t.match_start-=a,t.strstart-=a,t.block_start-=a,t.insert>t.strstart&&(t.insert=t.strstart),li(t),n+=a),t.strm.avail_in===0)break;if(e=ha(t.strm,t.window,t.strstart+t.lookahead,n),t.lookahead+=e,t.lookahead+t.insert>=z)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=yt(t,t.ins_h,t.window[r+1]);t.insert&&(t.ins_h=yt(t,t.ins_h,t.window[r+z-1]),t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<z)););}while(t.lookahead<ut&&t.strm.avail_in!==0)},Dn=(t,a)=>{let e=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,n,r,i,h=0,o=t.strm.avail_in;do{if(n=65535,i=t.bi_valid+42>>3,t.strm.avail_out<i||(i=t.strm.avail_out-i,r=t.strstart-t.block_start,n>r+t.strm.avail_in&&(n=r+t.strm.avail_in),n>i&&(n=i),n<e&&(n===0&&a!==st||a===_t||n!==r+t.strm.avail_in)))break;h=a===st&&n===r+t.strm.avail_in?1:0,na(t,0,0,h),t.pending_buf[t.pending-4]=n,t.pending_buf[t.pending-3]=n>>8,t.pending_buf[t.pending-2]=~n,t.pending_buf[t.pending-1]=~n>>8,Q(t.strm),r&&(r>n&&(r=n),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+r),t.strm.next_out),t.strm.next_out+=r,t.strm.avail_out-=r,t.strm.total_out+=r,t.block_start+=r,n-=r),n&&(ha(t.strm,t.strm.output,t.strm.next_out,n),t.strm.next_out+=n,t.strm.avail_out-=n,t.strm.total_out+=n)}while(h===0);return o-=t.strm.avail_in,o&&(o>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=o&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-o,t.strm.next_in),t.strstart),t.strstart+=o,t.insert+=o>t.w_size-t.insert?t.w_size-t.insert:o),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),h?Wt:a!==_t&&a!==st&&t.strm.avail_in===0&&t.strstart===t.block_start?jt:(i=t.window_size-t.strstart,t.strm.avail_in>i&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,i+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),i>t.strm.avail_in&&(i=t.strm.avail_in),i&&(ha(t.strm,t.window,t.strstart,i),t.strstart+=i,t.insert+=i>t.w_size-t.insert?t.w_size-t.insert:i),t.high_water<t.strstart&&(t.high_water=t.strstart),i=t.bi_valid+42>>3,i=t.pending_buf_size-i>65535?65535:t.pending_buf_size-i,e=i>t.w_size?t.w_size:i,r=t.strstart-t.block_start,(r>=e||(r||a===st)&&a!==_t&&t.strm.avail_in===0&&r<=i)&&(n=r>i?i:r,h=a===st&&t.strm.avail_in===0&&n===r?1:0,na(t,t.block_start,n,h),t.block_start+=n,Q(t.strm)),h?zt:X)},Ue=(t,a)=>{let e,n;for(;;){if(t.lookahead<ut){if(Yt(t),t.lookahead<ut&&a===_t)return X;if(t.lookahead===0)break}if(e=0,t.lookahead>=z&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+z-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),e!==0&&t.strstart-e<=t.w_size-ut&&(t.match_length=Hn(t,e)),t.match_length>=z)if(n=bt(t,t.strstart-t.match_start,t.match_length-z),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=z){t.match_length--;do t.strstart++,t.ins_h=yt(t,t.ins_h,t.window[t.strstart+z-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(--t.match_length!==0);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=yt(t,t.ins_h,t.window[t.strstart+1]);else n=bt(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&($(t,!1),t.strm.avail_out===0))return X}return t.insert=t.strstart<z-1?t.strstart:z-1,a===st?($(t,!0),t.strm.avail_out===0?zt:Wt):t.sym_next&&($(t,!1),t.strm.avail_out===0)?X:jt},Ot=(t,a)=>{let e,n,r;for(;;){if(t.lookahead<ut){if(Yt(t),t.lookahead<ut&&a===_t)return X;if(t.lookahead===0)break}if(e=0,t.lookahead>=z&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+z-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=z-1,e!==0&&t.prev_length<t.max_lazy_match&&t.strstart-e<=t.w_size-ut&&(t.match_length=Hn(t,e),t.match_length<=5&&(t.strategy===Vr||t.match_length===z&&t.strstart-t.match_start>4096)&&(t.match_length=z-1)),t.prev_length>=z&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-z,n=bt(t,t.strstart-1-t.prev_match,t.prev_length-z),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=r&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+z-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(--t.prev_length!==0);if(t.match_available=0,t.match_length=z-1,t.strstart++,n&&($(t,!1),t.strm.avail_out===0))return X}else if(t.match_available){if(n=bt(t,0,t.window[t.strstart-1]),n&&$(t,!1),t.strstart++,t.lookahead--,t.strm.avail_out===0)return X}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=bt(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<z-1?t.strstart:z-1,a===st?($(t,!0),t.strm.avail_out===0?zt:Wt):t.sym_next&&($(t,!1),t.strm.avail_out===0)?X:jt},ci=(t,a)=>{let e,n,r,i;const h=t.window;for(;;){if(t.lookahead<=qt){if(Yt(t),t.lookahead<=qt&&a===_t)return X;if(t.lookahead===0)break}if(t.match_length=0,t.lookahead>=z&&t.strstart>0&&(r=t.strstart-1,n=h[r],n===h[++r]&&n===h[++r]&&n===h[++r])){i=t.strstart+qt;do;while(n===h[++r]&&n===h[++r]&&n===h[++r]&&n===h[++r]&&n===h[++r]&&n===h[++r]&&n===h[++r]&&n===h[++r]&&r<i);t.match_length=qt-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=z?(e=bt(t,1,t.match_length-z),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(e=bt(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),e&&($(t,!1),t.strm.avail_out===0))return X}return t.insert=0,a===st?($(t,!0),t.strm.avail_out===0?zt:Wt):t.sym_next&&($(t,!1),t.strm.avail_out===0)?X:jt},fi=(t,a)=>{let e;for(;;){if(t.lookahead===0&&(Yt(t),t.lookahead===0)){if(a===_t)return X;break}if(t.match_length=0,e=bt(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,e&&($(t,!1),t.strm.avail_out===0))return X}return t.insert=0,a===st?($(t,!0),t.strm.avail_out===0?zt:Wt):t.sym_next&&($(t,!1),t.strm.avail_out===0)?X:jt};function ct(t,a,e,n,r){this.good_length=t,this.max_lazy=a,this.nice_length=e,this.max_chain=n,this.func=r}const ee=[new ct(0,0,0,0,Dn),new ct(4,4,8,4,Ue),new ct(4,5,16,8,Ue),new ct(4,6,32,32,Ue),new ct(4,4,16,16,Ot),new ct(8,16,32,32,Ot),new ct(8,16,128,128,Ot),new ct(8,32,128,256,Ot),new ct(32,128,258,1024,Ot),new ct(32,258,258,4096,Ot)],di=t=>{t.window_size=2*t.w_size,vt(t.head),t.max_lazy_match=ee[t.level].max_lazy,t.good_match=ee[t.level].good_length,t.nice_match=ee[t.level].nice_length,t.max_chain_length=ee[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=z-1,t.match_available=0,t.ins_h=0};function ui(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Ce,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(si*2),this.dyn_dtree=new Uint16Array((2*ai+1)*2),this.bl_tree=new Uint16Array((2*ni+1)*2),vt(this.dyn_ltree),vt(this.dyn_dtree),vt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(ri+1),this.heap=new Uint16Array(2*sa+1),vt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*sa+1),vt(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const we=t=>{if(!t)return 1;const a=t.state;return!a||a.strm!==t||a.status!==Ut&&a.status!==xa&&a.status!==ra&&a.status!==ia&&a.status!==oa&&a.status!==la&&a.status!==Tt&&a.status!==te?1:0},On=t=>{if(we(t))return Ct(t,dt);t.total_in=t.total_out=0,t.data_type=Xr;const a=t.state;return a.pending=0,a.pending_out=0,a.wrap<0&&(a.wrap=-a.wrap),a.status=a.wrap===2?xa:a.wrap?Ut:Tt,t.adler=a.wrap===2?0:1,a.last_flush=-2,Nr(a),U},Nn=t=>{const a=On(t);return a===U&&di(t.state),a},gi=(t,a)=>we(t)||t.state.wrap!==2?dt:(t.state.gzhead=a,U),Zn=(t,a,e,n,r,i)=>{if(!t)return dt;let h=1;if(a===Yr&&(a=6),n<0?(h=0,n=-n):n>15&&(h=2,n-=16),r<1||r>Kr||e!==Ce||n<8||n>15||a<0||a>9||i<0||i>jr||n===8&&h!==1)return Ct(t,dt);n===8&&(n=9);const o=new ui;return t.state=o,o.strm=t,o.status=Ut,o.wrap=h,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=r+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+z-1)/z),o.window=new Uint8Array(o.w_size*2),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<r+6,o.pending_buf_size=o.lit_bufsize*4,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=(o.lit_bufsize-1)*3,o.level=a,o.strategy=i,o.method=e,Nn(t)},wi=(t,a)=>Zn(t,a,Ce,Qr,$r,Wr),pi=(t,a)=>{if(we(t)||a>Ra||a<0)return t?Ct(t,dt):dt;const e=t.state;if(!t.output||t.avail_in!==0&&!t.input||e.status===te&&a!==st)return Ct(t,t.avail_out===0?Ge:dt);const n=e.last_flush;if(e.last_flush=a,e.pending!==0){if(Q(t),t.avail_out===0)return e.last_flush=-1,U}else if(t.avail_in===0&&Ha(a)<=Ha(n)&&a!==st)return Ct(t,Ge);if(e.status===te&&t.avail_in!==0)return Ct(t,Ge);if(e.status===Ut&&e.wrap===0&&(e.status=Tt),e.status===Ut){let r=Ce+(e.w_bits-8<<4)<<8,i=-1;if(e.strategy>=me||e.level<2?i=0:e.level<6?i=1:e.level===6?i=2:i=3,r|=i<<6,e.strstart!==0&&(r|=ii),r+=31-r%31,$t(e,r),e.strstart!==0&&($t(e,t.adler>>>16),$t(e,t.adler&65535)),t.adler=1,e.status=Tt,Q(t),e.pending!==0)return e.last_flush=-1,U}if(e.status===xa){if(t.adler=0,H(e,31),H(e,139),H(e,8),e.gzhead)H(e,(e.gzhead.text?1:0)+(e.gzhead.hcrc?2:0)+(e.gzhead.extra?4:0)+(e.gzhead.name?8:0)+(e.gzhead.comment?16:0)),H(e,e.gzhead.time&255),H(e,e.gzhead.time>>8&255),H(e,e.gzhead.time>>16&255),H(e,e.gzhead.time>>24&255),H(e,e.level===9?2:e.strategy>=me||e.level<2?4:0),H(e,e.gzhead.os&255),e.gzhead.extra&&e.gzhead.extra.length&&(H(e,e.gzhead.extra.length&255),H(e,e.gzhead.extra.length>>8&255)),e.gzhead.hcrc&&(t.adler=G(t.adler,e.pending_buf,e.pending,0)),e.gzindex=0,e.status=ra;else if(H(e,0),H(e,0),H(e,0),H(e,0),H(e,0),H(e,e.level===9?2:e.strategy>=me||e.level<2?4:0),H(e,oi),e.status=Tt,Q(t),e.pending!==0)return e.last_flush=-1,U}if(e.status===ra){if(e.gzhead.extra){let r=e.pending,i=(e.gzhead.extra.length&65535)-e.gzindex;for(;e.pending+i>e.pending_buf_size;){let o=e.pending_buf_size-e.pending;if(e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex,e.gzindex+o),e.pending),e.pending=e.pending_buf_size,e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r)),e.gzindex+=o,Q(t),e.pending!==0)return e.last_flush=-1,U;r=0,i-=o}let h=new Uint8Array(e.gzhead.extra);e.pending_buf.set(h.subarray(e.gzindex,e.gzindex+i),e.pending),e.pending+=i,e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r)),e.gzindex=0}e.status=ia}if(e.status===ia){if(e.gzhead.name){let r=e.pending,i;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r)),Q(t),e.pending!==0)return e.last_flush=-1,U;r=0}e.gzindex<e.gzhead.name.length?i=e.gzhead.name.charCodeAt(e.gzindex++)&255:i=0,H(e,i)}while(i!==0);e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r)),e.gzindex=0}e.status=oa}if(e.status===oa){if(e.gzhead.comment){let r=e.pending,i;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r)),Q(t),e.pending!==0)return e.last_flush=-1,U;r=0}e.gzindex<e.gzhead.comment.length?i=e.gzhead.comment.charCodeAt(e.gzindex++)&255:i=0,H(e,i)}while(i!==0);e.gzhead.hcrc&&e.pending>r&&(t.adler=G(t.adler,e.pending_buf,e.pending-r,r))}e.status=la}if(e.status===la){if(e.gzhead.hcrc){if(e.pending+2>e.pending_buf_size&&(Q(t),e.pending!==0))return e.last_flush=-1,U;H(e,t.adler&255),H(e,t.adler>>8&255),t.adler=0}if(e.status=Tt,Q(t),e.pending!==0)return e.last_flush=-1,U}if(t.avail_in!==0||e.lookahead!==0||a!==_t&&e.status!==te){let r=e.level===0?Dn(e,a):e.strategy===me?fi(e,a):e.strategy===Jr?ci(e,a):ee[e.level].func(e,a);if((r===zt||r===Wt)&&(e.status=te),r===X||r===zt)return t.avail_out===0&&(e.last_flush=-1),U;if(r===jt&&(a===Pr?Lr(e):a!==Ra&&(na(e,0,0,!1),a===Gr&&(vt(e.head),e.lookahead===0&&(e.strstart=0,e.block_start=0,e.insert=0))),Q(t),t.avail_out===0))return e.last_flush=-1,U}return a!==st?U:e.wrap<=0?Fa:(e.wrap===2?(H(e,t.adler&255),H(e,t.adler>>8&255),H(e,t.adler>>16&255),H(e,t.adler>>24&255),H(e,t.total_in&255),H(e,t.total_in>>8&255),H(e,t.total_in>>16&255),H(e,t.total_in>>24&255)):($t(e,t.adler>>>16),$t(e,t.adler&65535)),Q(t),e.wrap>0&&(e.wrap=-e.wrap),e.pending!==0?U:Fa)},xi=t=>{if(we(t))return dt;const a=t.state.status;return t.state=null,a===Tt?Ct(t,Ur):U},Mi=(t,a)=>{let e=a.length;if(we(t))return dt;const n=t.state,r=n.wrap;if(r===2||r===1&&n.status!==Ut||n.lookahead)return dt;if(r===1&&(t.adler=ce(t.adler,a,e,0)),n.wrap=0,e>=n.w_size){r===0&&(vt(n.head),n.strstart=0,n.block_start=0,n.insert=0);let f=new Uint8Array(n.w_size);f.set(a.subarray(e-n.w_size,e),0),a=f,e=n.w_size}const i=t.avail_in,h=t.next_in,o=t.input;for(t.avail_in=e,t.next_in=0,t.input=a,Yt(n);n.lookahead>=z;){let f=n.strstart,l=n.lookahead-(z-1);do n.ins_h=yt(n,n.ins_h,n.window[f+z-1]),n.prev[f&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=f,f++;while(--l);n.strstart=f,n.lookahead=z-1,Yt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=z-1,n.match_available=0,t.next_in=h,t.input=o,t.avail_in=i,n.wrap=r,U};var mi=wi,Ei=Zn,vi=Nn,qi=On,bi=gi,_i=pi,yi=xi,Ai=Mi,ki="pako deflate (from Nodeca project)",se={deflateInit:mi,deflateInit2:Ei,deflateReset:vi,deflateResetKeep:qi,deflateSetHeader:bi,deflate:_i,deflateEnd:yi,deflateSetDictionary:Ai,deflateInfo:ki};const Bi=(t,a)=>Object.prototype.hasOwnProperty.call(t,a);var Si=function(t){const a=Array.prototype.slice.call(arguments,1);for(;a.length;){const e=a.shift();if(e){if(typeof e!="object")throw new TypeError(e+"must be non-object");for(const n in e)Bi(e,n)&&(t[n]=e[n])}}return t},Ti=t=>{let a=0;for(let n=0,r=t.length;n<r;n++)a+=t[n].length;const e=new Uint8Array(a);for(let n=0,r=0,i=t.length;n<i;n++){let h=t[n];e.set(h,r),r+=h.length}return e},Ie={assign:Si,flattenChunks:Ti};let Ln=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Ln=!1}const fe=new Uint8Array(256);for(let t=0;t<256;t++)fe[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;fe[254]=fe[254]=1;var Ci=t=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(t);let a,e,n,r,i,h=t.length,o=0;for(r=0;r<h;r++)e=t.charCodeAt(r),(e&64512)===55296&&r+1<h&&(n=t.charCodeAt(r+1),(n&64512)===56320&&(e=65536+(e-55296<<10)+(n-56320),r++)),o+=e<128?1:e<2048?2:e<65536?3:4;for(a=new Uint8Array(o),i=0,r=0;i<o;r++)e=t.charCodeAt(r),(e&64512)===55296&&r+1<h&&(n=t.charCodeAt(r+1),(n&64512)===56320&&(e=65536+(e-55296<<10)+(n-56320),r++)),e<128?a[i++]=e:e<2048?(a[i++]=192|e>>>6,a[i++]=128|e&63):e<65536?(a[i++]=224|e>>>12,a[i++]=128|e>>>6&63,a[i++]=128|e&63):(a[i++]=240|e>>>18,a[i++]=128|e>>>12&63,a[i++]=128|e>>>6&63,a[i++]=128|e&63);return a};const Ii=(t,a)=>{if(a<65534&&t.subarray&&Ln)return String.fromCharCode.apply(null,t.length===a?t:t.subarray(0,a));let e="";for(let n=0;n<a;n++)e+=String.fromCharCode(t[n]);return e};var zi=(t,a)=>{const e=a||t.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(t.subarray(0,a));let n,r;const i=new Array(e*2);for(r=0,n=0;n<e;){let h=t[n++];if(h<128){i[r++]=h;continue}let o=fe[h];if(o>4){i[r++]=65533,n+=o-1;continue}for(h&=o===2?31:o===3?15:7;o>1&&n<e;)h=h<<6|t[n++]&63,o--;if(o>1){i[r++]=65533;continue}h<65536?i[r++]=h:(h-=65536,i[r++]=55296|h>>10&1023,i[r++]=56320|h&1023)}return Ii(i,r)},Ri=(t,a)=>{a=a||t.length,a>t.length&&(a=t.length);let e=a-1;for(;e>=0&&(t[e]&192)===128;)e--;return e<0||e===0?a:e+fe[t[e]]>a?e:a},de={string2buf:Ci,buf2string:zi,utf8border:Ri};function Fi(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var Pn=Fi;const Gn=Object.prototype.toString,{Z_NO_FLUSH:Hi,Z_SYNC_FLUSH:Di,Z_FULL_FLUSH:Oi,Z_FINISH:Ni,Z_OK:Be,Z_STREAM_END:Zi,Z_DEFAULT_COMPRESSION:Li,Z_DEFAULT_STRATEGY:Pi,Z_DEFLATED:Gi}=Ft;function pe(t){this.options=Ie.assign({level:Li,method:Gi,chunkSize:16384,windowBits:15,memLevel:8,strategy:Pi},t||{});let a=this.options;a.raw&&a.windowBits>0?a.windowBits=-a.windowBits:a.gzip&&a.windowBits>0&&a.windowBits<16&&(a.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Pn,this.strm.avail_out=0;let e=se.deflateInit2(this.strm,a.level,a.method,a.windowBits,a.memLevel,a.strategy);if(e!==Be)throw new Error(It[e]);if(a.header&&se.deflateSetHeader(this.strm,a.header),a.dictionary){let n;if(typeof a.dictionary=="string"?n=de.string2buf(a.dictionary):Gn.call(a.dictionary)==="[object ArrayBuffer]"?n=new Uint8Array(a.dictionary):n=a.dictionary,e=se.deflateSetDictionary(this.strm,n),e!==Be)throw new Error(It[e]);this._dict_set=!0}}pe.prototype.push=function(t,a){const e=this.strm,n=this.options.chunkSize;let r,i;if(this.ended)return!1;for(a===~~a?i=a:i=a===!0?Ni:Hi,typeof t=="string"?e.input=de.string2buf(t):Gn.call(t)==="[object ArrayBuffer]"?e.input=new Uint8Array(t):e.input=t,e.next_in=0,e.avail_in=e.input.length;;){if(e.avail_out===0&&(e.output=new Uint8Array(n),e.next_out=0,e.avail_out=n),(i===Di||i===Oi)&&e.avail_out<=6){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(r=se.deflate(e,i),r===Zi)return e.next_out>0&&this.onData(e.output.subarray(0,e.next_out)),r=se.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===Be;if(e.avail_out===0){this.onData(e.output);continue}if(i>0&&e.next_out>0){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(e.avail_in===0)break}return!0};pe.prototype.onData=function(t){this.chunks.push(t)};pe.prototype.onEnd=function(t){t===Be&&(this.result=Ie.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function Ma(t,a){const e=new pe(a);if(e.push(t,!0),e.err)throw e.msg||It[e.err];return e.result}function Ui(t,a){return a=a||{},a.raw=!0,Ma(t,a)}function Yi(t,a){return a=a||{},a.gzip=!0,Ma(t,a)}var Vi=pe,Ji=Ma,ji=Ui,Wi=Yi,Xi=Ft,Ki={Deflate:Vi,deflate:Ji,deflateRaw:ji,gzip:Wi,constants:Xi};const Ee=16209,Qi=16191;var $i=function(a,e){let n,r,i,h,o,f,l,c,E,u,d,p,k,M,y,g,m,x,A,T,v,I,B,S;const b=a.state;n=a.next_in,B=a.input,r=n+(a.avail_in-5),i=a.next_out,S=a.output,h=i-(e-a.avail_out),o=i+(a.avail_out-257),f=b.dmax,l=b.wsize,c=b.whave,E=b.wnext,u=b.window,d=b.hold,p=b.bits,k=b.lencode,M=b.distcode,y=(1<<b.lenbits)-1,g=(1<<b.distbits)-1;t:do{p<15&&(d+=B[n++]<<p,p+=8,d+=B[n++]<<p,p+=8),m=k[d&y];e:for(;;){if(x=m>>>24,d>>>=x,p-=x,x=m>>>16&255,x===0)S[i++]=m&65535;else if(x&16){A=m&65535,x&=15,x&&(p<x&&(d+=B[n++]<<p,p+=8),A+=d&(1<<x)-1,d>>>=x,p-=x),p<15&&(d+=B[n++]<<p,p+=8,d+=B[n++]<<p,p+=8),m=M[d&g];a:for(;;){if(x=m>>>24,d>>>=x,p-=x,x=m>>>16&255,x&16){if(T=m&65535,x&=15,p<x&&(d+=B[n++]<<p,p+=8,p<x&&(d+=B[n++]<<p,p+=8)),T+=d&(1<<x)-1,T>f){a.msg="invalid distance too far back",b.mode=Ee;break t}if(d>>>=x,p-=x,x=i-h,T>x){if(x=T-x,x>c&&b.sane){a.msg="invalid distance too far back",b.mode=Ee;break t}if(v=0,I=u,E===0){if(v+=l-x,x<A){A-=x;do S[i++]=u[v++];while(--x);v=i-T,I=S}}else if(E<x){if(v+=l+E-x,x-=E,x<A){A-=x;do S[i++]=u[v++];while(--x);if(v=0,E<A){x=E,A-=x;do S[i++]=u[v++];while(--x);v=i-T,I=S}}}else if(v+=E-x,x<A){A-=x;do S[i++]=u[v++];while(--x);v=i-T,I=S}for(;A>2;)S[i++]=I[v++],S[i++]=I[v++],S[i++]=I[v++],A-=3;A&&(S[i++]=I[v++],A>1&&(S[i++]=I[v++]))}else{v=i-T;do S[i++]=S[v++],S[i++]=S[v++],S[i++]=S[v++],A-=3;while(A>2);A&&(S[i++]=S[v++],A>1&&(S[i++]=S[v++]))}}else if(x&64){a.msg="invalid distance code",b.mode=Ee;break t}else{m=M[(m&65535)+(d&(1<<x)-1)];continue a}break}}else if(x&64)if(x&32){b.mode=Qi;break t}else{a.msg="invalid literal/length code",b.mode=Ee;break t}else{m=k[(m&65535)+(d&(1<<x)-1)];continue e}break}}while(n<r&&i<o);A=p>>3,n-=A,p-=A<<3,d&=(1<<p)-1,a.next_in=n,a.next_out=i,a.avail_in=n<r?5+(r-n):5-(n-r),a.avail_out=i<o?257+(o-i):257-(i-o),b.hold=d,b.bits=p};const Nt=15,Da=852,Oa=592,Na=0,Ye=1,Za=2,to=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eo=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ao=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),no=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),so=(t,a,e,n,r,i,h,o)=>{const f=o.bits;let l=0,c=0,E=0,u=0,d=0,p=0,k=0,M=0,y=0,g=0,m,x,A,T,v,I=null,B;const S=new Uint16Array(Nt+1),b=new Uint16Array(Nt+1);let P=null,mt,V,O;for(l=0;l<=Nt;l++)S[l]=0;for(c=0;c<n;c++)S[a[e+c]]++;for(d=f,u=Nt;u>=1&&S[u]===0;u--);if(d>u&&(d=u),u===0)return r[i++]=1<<24|64<<16|0,r[i++]=1<<24|64<<16|0,o.bits=1,0;for(E=1;E<u&&S[E]===0;E++);for(d<E&&(d=E),M=1,l=1;l<=Nt;l++)if(M<<=1,M-=S[l],M<0)return-1;if(M>0&&(t===Na||u!==1))return-1;for(b[1]=0,l=1;l<Nt;l++)b[l+1]=b[l]+S[l];for(c=0;c<n;c++)a[e+c]!==0&&(h[b[a[e+c]]++]=c);if(t===Na?(I=P=h,B=20):t===Ye?(I=to,P=eo,B=257):(I=ao,P=no,B=0),g=0,c=0,l=E,v=i,p=d,k=0,A=-1,y=1<<d,T=y-1,t===Ye&&y>Da||t===Za&&y>Oa)return 1;for(;;){mt=l-k,h[c]+1<B?(V=0,O=h[c]):h[c]>=B?(V=P[h[c]-B],O=I[h[c]-B]):(V=96,O=0),m=1<<l-k,x=1<<p,E=x;do x-=m,r[v+(g>>k)+x]=mt<<24|V<<16|O|0;while(x!==0);for(m=1<<l-1;g&m;)m>>=1;if(m!==0?(g&=m-1,g+=m):g=0,c++,--S[l]===0){if(l===u)break;l=a[e+h[c]]}if(l>d&&(g&T)!==A){for(k===0&&(k=d),v+=E,p=l-k,M=1<<p;p+k<u&&(M-=S[p+k],!(M<=0));)p++,M<<=1;if(y+=1<<p,t===Ye&&y>Da||t===Za&&y>Oa)return 1;A=g&T,r[A]=d<<24|p<<16|v-i|0}}return g!==0&&(r[v+g]=l-k<<24|64<<16|0),o.bits=d,0};var re=so;const ro=0,Un=1,Yn=2,{Z_FINISH:La,Z_BLOCK:io,Z_TREES:ve,Z_OK:Rt,Z_STREAM_END:oo,Z_NEED_DICT:lo,Z_STREAM_ERROR:rt,Z_DATA_ERROR:Vn,Z_MEM_ERROR:Jn,Z_BUF_ERROR:ho,Z_DEFLATED:Pa}=Ft,ze=16180,Ga=16181,Ua=16182,Ya=16183,Va=16184,Ja=16185,ja=16186,Wa=16187,Xa=16188,Ka=16189,Se=16190,pt=16191,Ve=16192,Qa=16193,Je=16194,$a=16195,tn=16196,en=16197,an=16198,qe=16199,be=16200,nn=16201,sn=16202,rn=16203,on=16204,ln=16205,je=16206,hn=16207,cn=16208,N=16209,jn=16210,Wn=16211,co=852,fo=592,uo=15,go=uo,fn=t=>(t>>>24&255)+(t>>>8&65280)+((t&65280)<<8)+((t&255)<<24);function wo(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Ht=t=>{if(!t)return 1;const a=t.state;return!a||a.strm!==t||a.mode<ze||a.mode>Wn?1:0},Xn=t=>{if(Ht(t))return rt;const a=t.state;return t.total_in=t.total_out=a.total=0,t.msg="",a.wrap&&(t.adler=a.wrap&1),a.mode=ze,a.last=0,a.havedict=0,a.flags=-1,a.dmax=32768,a.head=null,a.hold=0,a.bits=0,a.lencode=a.lendyn=new Int32Array(co),a.distcode=a.distdyn=new Int32Array(fo),a.sane=1,a.back=-1,Rt},Kn=t=>{if(Ht(t))return rt;const a=t.state;return a.wsize=0,a.whave=0,a.wnext=0,Xn(t)},Qn=(t,a)=>{let e;if(Ht(t))return rt;const n=t.state;return a<0?(e=0,a=-a):(e=(a>>4)+5,a<48&&(a&=15)),a&&(a<8||a>15)?rt:(n.window!==null&&n.wbits!==a&&(n.window=null),n.wrap=e,n.wbits=a,Kn(t))},$n=(t,a)=>{if(!t)return rt;const e=new wo;t.state=e,e.strm=t,e.window=null,e.mode=ze;const n=Qn(t,a);return n!==Rt&&(t.state=null),n},po=t=>$n(t,go);let dn=!0,We,Xe;const xo=t=>{if(dn){We=new Int32Array(512),Xe=new Int32Array(32);let a=0;for(;a<144;)t.lens[a++]=8;for(;a<256;)t.lens[a++]=9;for(;a<280;)t.lens[a++]=7;for(;a<288;)t.lens[a++]=8;for(re(Un,t.lens,0,288,We,0,t.work,{bits:9}),a=0;a<32;)t.lens[a++]=5;re(Yn,t.lens,0,32,Xe,0,t.work,{bits:5}),dn=!1}t.lencode=We,t.lenbits=9,t.distcode=Xe,t.distbits=5},ts=(t,a,e,n)=>{let r;const i=t.state;return i.window===null&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new Uint8Array(i.wsize)),n>=i.wsize?(i.window.set(a.subarray(e-i.wsize,e),0),i.wnext=0,i.whave=i.wsize):(r=i.wsize-i.wnext,r>n&&(r=n),i.window.set(a.subarray(e-n,e-n+r),i.wnext),n-=r,n?(i.window.set(a.subarray(e-n,e),0),i.wnext=n,i.whave=i.wsize):(i.wnext+=r,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=r))),0},Mo=(t,a)=>{let e,n,r,i,h,o,f,l,c,E,u,d,p,k,M=0,y,g,m,x,A,T,v,I;const B=new Uint8Array(4);let S,b;const P=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Ht(t)||!t.output||!t.input&&t.avail_in!==0)return rt;e=t.state,e.mode===pt&&(e.mode=Ve),h=t.next_out,r=t.output,f=t.avail_out,i=t.next_in,n=t.input,o=t.avail_in,l=e.hold,c=e.bits,E=o,u=f,I=Rt;t:for(;;)switch(e.mode){case ze:if(e.wrap===0){e.mode=Ve;break}for(;c<16;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(e.wrap&2&&l===35615){e.wbits===0&&(e.wbits=15),e.check=0,B[0]=l&255,B[1]=l>>>8&255,e.check=G(e.check,B,2,0),l=0,c=0,e.mode=Ga;break}if(e.head&&(e.head.done=!1),!(e.wrap&1)||(((l&255)<<8)+(l>>8))%31){t.msg="incorrect header check",e.mode=N;break}if((l&15)!==Pa){t.msg="unknown compression method",e.mode=N;break}if(l>>>=4,c-=4,v=(l&15)+8,e.wbits===0&&(e.wbits=v),v>15||v>e.wbits){t.msg="invalid self size",e.mode=N;break}e.dmax=1<<e.wbits,e.flags=0,t.adler=e.check=1,e.mode=l&512?Ka:pt,l=0,c=0;break;case Ga:for(;c<16;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(e.flags=l,(e.flags&255)!==Pa){t.msg="unknown compression method",e.mode=N;break}if(e.flags&57344){t.msg="unknown header flags set",e.mode=N;break}e.head&&(e.head.text=l>>8&1),e.flags&512&&e.wrap&4&&(B[0]=l&255,B[1]=l>>>8&255,e.check=G(e.check,B,2,0)),l=0,c=0,e.mode=Ua;case Ua:for(;c<32;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.head&&(e.head.time=l),e.flags&512&&e.wrap&4&&(B[0]=l&255,B[1]=l>>>8&255,B[2]=l>>>16&255,B[3]=l>>>24&255,e.check=G(e.check,B,4,0)),l=0,c=0,e.mode=Ya;case Ya:for(;c<16;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.head&&(e.head.xflags=l&255,e.head.os=l>>8),e.flags&512&&e.wrap&4&&(B[0]=l&255,B[1]=l>>>8&255,e.check=G(e.check,B,2,0)),l=0,c=0,e.mode=Va;case Va:if(e.flags&1024){for(;c<16;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.length=l,e.head&&(e.head.extra_len=l),e.flags&512&&e.wrap&4&&(B[0]=l&255,B[1]=l>>>8&255,e.check=G(e.check,B,2,0)),l=0,c=0}else e.head&&(e.head.extra=null);e.mode=Ja;case Ja:if(e.flags&1024&&(d=e.length,d>o&&(d=o),d&&(e.head&&(v=e.head.extra_len-e.length,e.head.extra||(e.head.extra=new Uint8Array(e.head.extra_len)),e.head.extra.set(n.subarray(i,i+d),v)),e.flags&512&&e.wrap&4&&(e.check=G(e.check,n,d,i)),o-=d,i+=d,e.length-=d),e.length))break t;e.length=0,e.mode=ja;case ja:if(e.flags&2048){if(o===0)break t;d=0;do v=n[i+d++],e.head&&v&&e.length<65536&&(e.head.name+=String.fromCharCode(v));while(v&&d<o);if(e.flags&512&&e.wrap&4&&(e.check=G(e.check,n,d,i)),o-=d,i+=d,v)break t}else e.head&&(e.head.name=null);e.length=0,e.mode=Wa;case Wa:if(e.flags&4096){if(o===0)break t;d=0;do v=n[i+d++],e.head&&v&&e.length<65536&&(e.head.comment+=String.fromCharCode(v));while(v&&d<o);if(e.flags&512&&e.wrap&4&&(e.check=G(e.check,n,d,i)),o-=d,i+=d,v)break t}else e.head&&(e.head.comment=null);e.mode=Xa;case Xa:if(e.flags&512){for(;c<16;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(e.wrap&4&&l!==(e.check&65535)){t.msg="header crc mismatch",e.mode=N;break}l=0,c=0}e.head&&(e.head.hcrc=e.flags>>9&1,e.head.done=!0),t.adler=e.check=0,e.mode=pt;break;case Ka:for(;c<32;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}t.adler=e.check=fn(l),l=0,c=0,e.mode=Se;case Se:if(e.havedict===0)return t.next_out=h,t.avail_out=f,t.next_in=i,t.avail_in=o,e.hold=l,e.bits=c,lo;t.adler=e.check=1,e.mode=pt;case pt:if(a===io||a===ve)break t;case Ve:if(e.last){l>>>=c&7,c-=c&7,e.mode=je;break}for(;c<3;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}switch(e.last=l&1,l>>>=1,c-=1,l&3){case 0:e.mode=Qa;break;case 1:if(xo(e),e.mode=qe,a===ve){l>>>=2,c-=2;break t}break;case 2:e.mode=tn;break;case 3:t.msg="invalid block type",e.mode=N}l>>>=2,c-=2;break;case Qa:for(l>>>=c&7,c-=c&7;c<32;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if((l&65535)!==(l>>>16^65535)){t.msg="invalid stored block lengths",e.mode=N;break}if(e.length=l&65535,l=0,c=0,e.mode=Je,a===ve)break t;case Je:e.mode=$a;case $a:if(d=e.length,d){if(d>o&&(d=o),d>f&&(d=f),d===0)break t;r.set(n.subarray(i,i+d),h),o-=d,i+=d,f-=d,h+=d,e.length-=d;break}e.mode=pt;break;case tn:for(;c<14;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(e.nlen=(l&31)+257,l>>>=5,c-=5,e.ndist=(l&31)+1,l>>>=5,c-=5,e.ncode=(l&15)+4,l>>>=4,c-=4,e.nlen>286||e.ndist>30){t.msg="too many length or distance symbols",e.mode=N;break}e.have=0,e.mode=en;case en:for(;e.have<e.ncode;){for(;c<3;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.lens[P[e.have++]]=l&7,l>>>=3,c-=3}for(;e.have<19;)e.lens[P[e.have++]]=0;if(e.lencode=e.lendyn,e.lenbits=7,S={bits:e.lenbits},I=re(ro,e.lens,0,19,e.lencode,0,e.work,S),e.lenbits=S.bits,I){t.msg="invalid code lengths set",e.mode=N;break}e.have=0,e.mode=an;case an:for(;e.have<e.nlen+e.ndist;){for(;M=e.lencode[l&(1<<e.lenbits)-1],y=M>>>24,g=M>>>16&255,m=M&65535,!(y<=c);){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(m<16)l>>>=y,c-=y,e.lens[e.have++]=m;else{if(m===16){for(b=y+2;c<b;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(l>>>=y,c-=y,e.have===0){t.msg="invalid bit length repeat",e.mode=N;break}v=e.lens[e.have-1],d=3+(l&3),l>>>=2,c-=2}else if(m===17){for(b=y+3;c<b;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}l>>>=y,c-=y,v=0,d=3+(l&7),l>>>=3,c-=3}else{for(b=y+7;c<b;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}l>>>=y,c-=y,v=0,d=11+(l&127),l>>>=7,c-=7}if(e.have+d>e.nlen+e.ndist){t.msg="invalid bit length repeat",e.mode=N;break}for(;d--;)e.lens[e.have++]=v}}if(e.mode===N)break;if(e.lens[256]===0){t.msg="invalid code -- missing end-of-block",e.mode=N;break}if(e.lenbits=9,S={bits:e.lenbits},I=re(Un,e.lens,0,e.nlen,e.lencode,0,e.work,S),e.lenbits=S.bits,I){t.msg="invalid literal/lengths set",e.mode=N;break}if(e.distbits=6,e.distcode=e.distdyn,S={bits:e.distbits},I=re(Yn,e.lens,e.nlen,e.ndist,e.distcode,0,e.work,S),e.distbits=S.bits,I){t.msg="invalid distances set",e.mode=N;break}if(e.mode=qe,a===ve)break t;case qe:e.mode=be;case be:if(o>=6&&f>=258){t.next_out=h,t.avail_out=f,t.next_in=i,t.avail_in=o,e.hold=l,e.bits=c,$i(t,u),h=t.next_out,r=t.output,f=t.avail_out,i=t.next_in,n=t.input,o=t.avail_in,l=e.hold,c=e.bits,e.mode===pt&&(e.back=-1);break}for(e.back=0;M=e.lencode[l&(1<<e.lenbits)-1],y=M>>>24,g=M>>>16&255,m=M&65535,!(y<=c);){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(g&&!(g&240)){for(x=y,A=g,T=m;M=e.lencode[T+((l&(1<<x+A)-1)>>x)],y=M>>>24,g=M>>>16&255,m=M&65535,!(x+y<=c);){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}l>>>=x,c-=x,e.back+=x}if(l>>>=y,c-=y,e.back+=y,e.length=m,g===0){e.mode=ln;break}if(g&32){e.back=-1,e.mode=pt;break}if(g&64){t.msg="invalid literal/length code",e.mode=N;break}e.extra=g&15,e.mode=nn;case nn:if(e.extra){for(b=e.extra;c<b;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.length+=l&(1<<e.extra)-1,l>>>=e.extra,c-=e.extra,e.back+=e.extra}e.was=e.length,e.mode=sn;case sn:for(;M=e.distcode[l&(1<<e.distbits)-1],y=M>>>24,g=M>>>16&255,m=M&65535,!(y<=c);){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(!(g&240)){for(x=y,A=g,T=m;M=e.distcode[T+((l&(1<<x+A)-1)>>x)],y=M>>>24,g=M>>>16&255,m=M&65535,!(x+y<=c);){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}l>>>=x,c-=x,e.back+=x}if(l>>>=y,c-=y,e.back+=y,g&64){t.msg="invalid distance code",e.mode=N;break}e.offset=m,e.extra=g&15,e.mode=rn;case rn:if(e.extra){for(b=e.extra;c<b;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}e.offset+=l&(1<<e.extra)-1,l>>>=e.extra,c-=e.extra,e.back+=e.extra}if(e.offset>e.dmax){t.msg="invalid distance too far back",e.mode=N;break}e.mode=on;case on:if(f===0)break t;if(d=u-f,e.offset>d){if(d=e.offset-d,d>e.whave&&e.sane){t.msg="invalid distance too far back",e.mode=N;break}d>e.wnext?(d-=e.wnext,p=e.wsize-d):p=e.wnext-d,d>e.length&&(d=e.length),k=e.window}else k=r,p=h-e.offset,d=e.length;d>f&&(d=f),f-=d,e.length-=d;do r[h++]=k[p++];while(--d);e.length===0&&(e.mode=be);break;case ln:if(f===0)break t;r[h++]=e.length,f--,e.mode=be;break;case je:if(e.wrap){for(;c<32;){if(o===0)break t;o--,l|=n[i++]<<c,c+=8}if(u-=f,t.total_out+=u,e.total+=u,e.wrap&4&&u&&(t.adler=e.check=e.flags?G(e.check,r,u,h-u):ce(e.check,r,u,h-u)),u=f,e.wrap&4&&(e.flags?l:fn(l))!==e.check){t.msg="incorrect data check",e.mode=N;break}l=0,c=0}e.mode=hn;case hn:if(e.wrap&&e.flags){for(;c<32;){if(o===0)break t;o--,l+=n[i++]<<c,c+=8}if(e.wrap&4&&l!==(e.total&4294967295)){t.msg="incorrect length check",e.mode=N;break}l=0,c=0}e.mode=cn;case cn:I=oo;break t;case N:I=Vn;break t;case jn:return Jn;case Wn:default:return rt}return t.next_out=h,t.avail_out=f,t.next_in=i,t.avail_in=o,e.hold=l,e.bits=c,(e.wsize||u!==t.avail_out&&e.mode<N&&(e.mode<je||a!==La))&&ts(t,t.output,t.next_out,u-t.avail_out),E-=t.avail_in,u-=t.avail_out,t.total_in+=E,t.total_out+=u,e.total+=u,e.wrap&4&&u&&(t.adler=e.check=e.flags?G(e.check,r,u,t.next_out-u):ce(e.check,r,u,t.next_out-u)),t.data_type=e.bits+(e.last?64:0)+(e.mode===pt?128:0)+(e.mode===qe||e.mode===Je?256:0),(E===0&&u===0||a===La)&&I===Rt&&(I=ho),I},mo=t=>{if(Ht(t))return rt;let a=t.state;return a.window&&(a.window=null),t.state=null,Rt},Eo=(t,a)=>{if(Ht(t))return rt;const e=t.state;return e.wrap&2?(e.head=a,a.done=!1,Rt):rt},vo=(t,a)=>{const e=a.length;let n,r,i;return Ht(t)||(n=t.state,n.wrap!==0&&n.mode!==Se)?rt:n.mode===Se&&(r=1,r=ce(r,a,e,0),r!==n.check)?Vn:(i=ts(t,a,e,e),i?(n.mode=jn,Jn):(n.havedict=1,Rt))};var qo=Kn,bo=Qn,_o=Xn,yo=po,Ao=$n,ko=Mo,Bo=mo,So=Eo,To=vo,Co="pako inflate (from Nodeca project)",Mt={inflateReset:qo,inflateReset2:bo,inflateResetKeep:_o,inflateInit:yo,inflateInit2:Ao,inflate:ko,inflateEnd:Bo,inflateGetHeader:So,inflateSetDictionary:To,inflateInfo:Co};function Io(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var zo=Io;const es=Object.prototype.toString,{Z_NO_FLUSH:Ro,Z_FINISH:Fo,Z_OK:ue,Z_STREAM_END:Ke,Z_NEED_DICT:Qe,Z_STREAM_ERROR:Ho,Z_DATA_ERROR:un,Z_MEM_ERROR:Do}=Ft;function xe(t){this.options=Ie.assign({chunkSize:1024*64,windowBits:15,to:""},t||{});const a=this.options;a.raw&&a.windowBits>=0&&a.windowBits<16&&(a.windowBits=-a.windowBits,a.windowBits===0&&(a.windowBits=-15)),a.windowBits>=0&&a.windowBits<16&&!(t&&t.windowBits)&&(a.windowBits+=32),a.windowBits>15&&a.windowBits<48&&(a.windowBits&15||(a.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Pn,this.strm.avail_out=0;let e=Mt.inflateInit2(this.strm,a.windowBits);if(e!==ue)throw new Error(It[e]);if(this.header=new zo,Mt.inflateGetHeader(this.strm,this.header),a.dictionary&&(typeof a.dictionary=="string"?a.dictionary=de.string2buf(a.dictionary):es.call(a.dictionary)==="[object ArrayBuffer]"&&(a.dictionary=new Uint8Array(a.dictionary)),a.raw&&(e=Mt.inflateSetDictionary(this.strm,a.dictionary),e!==ue)))throw new Error(It[e])}xe.prototype.push=function(t,a){const e=this.strm,n=this.options.chunkSize,r=this.options.dictionary;let i,h,o;if(this.ended)return!1;for(a===~~a?h=a:h=a===!0?Fo:Ro,es.call(t)==="[object ArrayBuffer]"?e.input=new Uint8Array(t):e.input=t,e.next_in=0,e.avail_in=e.input.length;;){for(e.avail_out===0&&(e.output=new Uint8Array(n),e.next_out=0,e.avail_out=n),i=Mt.inflate(e,h),i===Qe&&r&&(i=Mt.inflateSetDictionary(e,r),i===ue?i=Mt.inflate(e,h):i===un&&(i=Qe));e.avail_in>0&&i===Ke&&e.state.wrap>0&&t[e.next_in]!==0;)Mt.inflateReset(e),i=Mt.inflate(e,h);switch(i){case Ho:case un:case Qe:case Do:return this.onEnd(i),this.ended=!0,!1}if(o=e.avail_out,e.next_out&&(e.avail_out===0||i===Ke))if(this.options.to==="string"){let f=de.utf8border(e.output,e.next_out),l=e.next_out-f,c=de.buf2string(e.output,f);e.next_out=l,e.avail_out=n-l,l&&e.output.set(e.output.subarray(f,f+l),0),this.onData(c)}else this.onData(e.output.length===e.next_out?e.output:e.output.subarray(0,e.next_out));if(!(i===ue&&o===0)){if(i===Ke)return i=Mt.inflateEnd(this.strm),this.onEnd(i),this.ended=!0,!0;if(e.avail_in===0)break}}return!0};xe.prototype.onData=function(t){this.chunks.push(t)};xe.prototype.onEnd=function(t){t===ue&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=Ie.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function ma(t,a){const e=new xe(a);if(e.push(t),e.err)throw e.msg||It[e.err];return e.result}function Oo(t,a){return a=a||{},a.raw=!0,ma(t,a)}var No=xe,Zo=ma,Lo=Oo,Po=ma,Go=Ft,Uo={Inflate:No,inflate:Zo,inflateRaw:Lo,ungzip:Po,constants:Go};const{Deflate:Yo,deflate:Vo,deflateRaw:Jo,gzip:jo}=Ki,{Inflate:Wo,inflate:Xo,inflateRaw:Ko,ungzip:Qo}=Uo;var $o=Yo,tl=Vo,el=Jo,al=jo,nl=Wo,sl=Xo,rl=Ko,il=Qo,ol=Ft,Re={Deflate:$o,deflate:tl,deflateRaw:el,gzip:al,Inflate:nl,inflate:sl,inflateRaw:rl,ungzip:il,constants:ol};const ll=t=>new TextDecoder().decode(t.subarray(0,t.length)),oh=t=>{const a=new Uint8Array(t.split("").map(n=>n.charCodeAt(0))),e=Re.deflate(a);return btoa(String.fromCharCode.apply(null,[...e]))},hl=t=>{try{const a=new Uint8Array(atob(t).split("").map(n=>n.charCodeAt(0))),e=Re.inflate(a);return ll(e)}catch(a){return console.log(`${a}`),null}},lh=t=>{const a=Re.deflate(t);let e="";for(let n=0;n<a.length;n++)e+=String.fromCharCode(a[n]);return btoa(e)},hh=t=>{try{const a=new Uint8Array(atob(t).split("").map(e=>e.charCodeAt(0)));return Re.inflate(a)}catch(a){return console.log(`${a}`),null}},ye=JSON.parse(hl("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"));class Zt{constructor(a,e,n=null){C(this,"vertices");C(this,"sectors",[]);C(this,"faces",[]);this.index=a,this.isExit=e,this.exitVertex=n,this.vertices=n?[n]:[]}}class nt{constructor(a,e,n,r,i){this.index=a,this.isExit=e,this.vertices=n,this.edges=r,this.sectors=i}}class $e{constructor(a,e,n){C(this,"face");this.index=a,this.vertex=e,this.edges=n}}class gn{constructor(a,e){C(this,"exitEdge",null);C(this,"edges",[]);C(this,"sectors",[]);C(this,"faces",[]);this.index=a,this.isExit=e}}const cl=(t,a)=>{if(t.numNonExitVertices!==a.numNonExitVertices||t.numExitVertices!==a.numExitVertices||t.type!==a.type)return!1;if(t.type==="faces"&&a.type==="faces"){if(t.vertexLists.length!==a.vertexLists.length)return!1;for(let e=0;e<t.vertexLists.length;e++){if(t.vertexLists[e].length!==a.vertexLists[e].length)return!1;for(let n=0;n<t.vertexLists[e].length;n++)if(t.vertexLists[e][n]!==a.vertexLists[e][n])return!1}}if(t.type==="non-exit-vertex"&&a.type==="non-exit-vertex"&&t.edgeCount!==a.edgeCount)return!1;if(t.type==="exit-vertex"&&a.type==="exit-vertex"){if(t.edgeCount!==a.edgeCount||t.spans.length!==a.spans.length)return!1;for(let e=0;e<t.spans.length;e++)if(t.spans[e]!==a.spans[e])return!1}return!0},as=t=>{const a=[];a.push(t.numNonExitVertices),a.push(t.numExitVertices),a.push(t.type),t.type==="faces"?a.push(t.vertexLists):(t.type==="non-exit-vertex"||t.type==="exit-vertex")&&(a.push(t.edgeCount),t.type==="exit-vertex"&&a.push(t.spans));const e=JSON.stringify(a);return q()&&w(cl(Ea(e),t)),e},Ea=t=>{const a=JSON.parse(t),e=a.shift(),n=a.shift(),r=a.shift();return r==="faces"?{numNonExitVertices:e,numExitVertices:n,type:r,vertexLists:a.shift()}:r==="non-exit-vertex"?{numNonExitVertices:e,numExitVertices:n,type:r,edgeCount:a.shift()}:r==="exit-vertex"?{numNonExitVertices:e,numExitVertices:n,type:r,edgeCount:a.shift(),spans:a.shift()}:{numNonExitVertices:e,numExitVertices:n,type:r}};class va{constructor(a,e){C(this,"name");C(this,"vertices");C(this,"edges");C(this,"sectors");C(this,"faces");this.descriptor=a;const n=[...F.range(0,a.numNonExitVertices).map(o=>new gn(o,!1)),...F.range(0,a.numExitVertices).map(o=>new gn(o+a.numNonExitVertices,!0))];let r=[],i=[],h=[];if(a.type==="faces"){for(const o of a.vertexLists){const f=o.map(u=>n[u]),l=f.map((u,d)=>{const p=f[(d+1)%f.length],k=u.edges.find(M=>M.vertices.includes(p));if(k)return k;{const M=new Zt(r.length,!1),y=u.index<p.index?u:p,g=u.index<p.index?p:u;return M.vertices.push(y),M.vertices.push(g),r.push(M),u.edges.push(M),p.edges.push(M),M}}),c=l.map((u,d)=>{const p=l[(d+1)%l.length],k=u.vertices.find(y=>p.vertices.includes(y));q()&&w(k);const M=new $e(i.length,k,[u,p]);return i.push(M),u.sectors.push(M),p.sectors.push(M),k.sectors.push(M),M}),E=new nt(h.length,!1,f,l,c);h.push(E),f.forEach(u=>{u.faces.push(E)}),c.forEach(u=>{u.face=E}),l.forEach(u=>{u.faces.push(E)})}r.forEach(o=>{if(o.faces.length<2){q()&&w(o.faces.length===1);const f=new nt(h.length,!0,o.vertices,[o],[]);h.push(f),o.faces.push(f),o.vertices.forEach(l=>{l.faces.push(f)})}}),n.forEach(o=>{if(o.isExit){const f=new Zt(r.length,!0,o);r.push(f),o.edges.push(f),o.exitEdge=f}})}else if(a.type==="edge"){q()&&w(n.length===0);const o=new Zt(0,!1,null);r.push(o);const f=new nt(0,!0,[],[o],[]);h.push(f);const l=new nt(1,!0,[],[o],[]);h.push(l),o.faces.push(f),o.faces.push(l)}else if(a.type==="non-exit-vertex"){q()&&w(n.length===1&&!n[0].isExit);const o=n[0];r.push(...F.range(0,a.edgeCount).map(f=>{const l=new Zt(f,!1);return o.edges.push(l),l.vertices.push(o),l})),i.push(...F.range(0,a.edgeCount).map(f=>{const l=new $e(f,o,[r[f],r[(f+1)%a.edgeCount]]);return l.edges.forEach(c=>{c.sectors.push(l)}),o.sectors.push(l),l})),h.push(...F.range(0,a.edgeCount).map(f=>{const l=i[f],c=new nt(f,!0,[o],[r[f],r[(f+1)%a.edgeCount]],[l]);return o.faces.push(c),c.edges.forEach(E=>{E.faces.push(c)}),l.face=c,c}))}else if(a.type==="exit-vertex"){q()&&w(n.length===1&&n[0].isExit);const o=n[0];r.push(...F.range(0,a.edgeCount).map(l=>{const c=new Zt(l,!1);return o.edges.push(c),c.vertices.push(o),c}));const f=new Zt(r.length,!0,o);if(r.push(f),o.edges.push(f),o.exitEdge=f,a.spans.length){const l=[];let c=0;a.spans.forEach((E,u)=>{const d=c,p=d+E;c=p+1,l.push(F.range(d,p+1).map(k=>r[k]))}),q()&&w(c===a.edgeCount),l.forEach(E=>{for(let u=0;u<E.length-1;u++){const d=E[u],p=E[u+1],k=new $e(i.length,o,[d,p]);i.push(k),d.sectors.push(k),p.sectors.push(k),o.sectors.push(k);const M=new nt(h.length,!0,[o],[d,p],[k]);h.push(M),o.faces.push(M),d.faces.push(M),p.faces.push(M),k.face=M}}),l.forEach(E=>{const u=E[0],d=E[E.length-1],p=new nt(h.length,!0,[o],[u],[]);h.push(p),u.faces.push(p),o.faces.push(p);const k=new nt(h.length,!0,[o],[d],[]);h.push(k),d.faces.push(k),o.faces.push(k)})}else{q()&&w(a.edgeCount===2);const l=r[0],c=r[1],E=new nt(h.length,!0,[o],[l],[]);h.push(E),l.faces.push(E),o.faces.push(E);const u=new nt(h.length,!0,[o],[l],[]);h.push(u),l.faces.push(u),o.faces.push(u);const d=new nt(h.length,!0,[o],[c],[]);h.push(d),c.faces.push(d),o.faces.push(d);const p=new nt(h.length,!0,[o],[c],[]);h.push(p),c.faces.push(p),o.faces.push(p)}}else throw new Error(`Invalid descriptor: ${a}`);this.vertices=n,this.edges=r,this.sectors=i,this.faces=h,e&&(this.name=e)}serialize(){return as(this.descriptor)}static deserialize(a){return new va(Ea(a))}}const fl=(t,a)=>t.vertices.length!==a.vertices.length||t.edges.length!==a.edges.length||t.faces.length!==a.faces.length||t.sectors.length!==a.sectors.length||t.vertices.filter(e=>e.isExit).length!==a.vertices.filter(e=>e.isExit).length||t.edges.filter(e=>e.isExit).length!==a.edges.filter(e=>e.isExit).length||t.faces.filter(e=>e.isExit).length!==a.faces.filter(e=>e.isExit).length?!1:ya(t,a).length>0&&ya(a,t).length>0,dl=t=>{if(q()){const f=l=>{w(l.every(c=>c.index<l.length))};f([...t.vertexMap.keys()]),f([...t.edgeMap.keys()]),f([...t.sectorMap.keys()]),f([...t.faceMap.keys()])}const a=F.sortBy([...t.vertexMap.keys()],f=>f.index),e=F.sortBy([...t.edgeMap.keys()],f=>f.index),n=F.sortBy([...t.sectorMap.keys()],f=>f.index),r=F.sortBy([...t.faceMap.keys()],f=>f.index),i=f=>[f.x,f.y],h=f=>{for(let l=0;l<a.length;l++)if(t.vertexMap.get(a[l]).equals(f))return l;return i(f)},o=JSON.stringify([a.map(f=>i(t.vertexMap.get(f))),e.map(f=>t.edgeMap.get(f).map(h)),n.map(f=>t.sectorMap.get(f).map(i)),r.map(f=>t.faceMap.get(f).map(i))]);if(q()){const f=ns(o,{vertices:a,edges:e,sectors:n,faces:r,descriptor:{}}),l=(c,E)=>{if(c.length!==E.length)return!1;for(let u=0;u<c.length;u++)if(!c[u].equals(E[u]))return!1;return!0};a.forEach(c=>w(t.vertexMap.get(c).equals(f.vertexMap.get(c)))),e.forEach(c=>w(l(t.edgeMap.get(c),f.edgeMap.get(c)))),n.forEach(c=>w(l(t.sectorMap.get(c),f.sectorMap.get(c)))),r.forEach(c=>w(l(t.faceMap.get(c),f.faceMap.get(c))))}return o},ns=(t,a)=>{const e=JSON.parse(t),n=e[0],r=e[1],i=e[2],h=e[3],o=new Map,f=new Map,l=new Map,c=new Map;n.forEach((u,d)=>{o.set(a.vertices[d],new s(u[0],u[1]))});const E=u=>typeof u=="number"?o.get(a.vertices[u]):new s(u[0],u[1]);return r.forEach((u,d)=>{f.set(a.edges[d],[E(u[0]),E(u[1])])}),i.forEach((u,d)=>{l.set(a.sectors[d],[E(u[0]),E(u[1]),E(u[2])])}),h.forEach((u,d)=>{c.set(a.faces[d],u.map(p=>new s(p[0],p[1])))}),{vertexMap:o,edgeMap:f,sectorMap:l,faceMap:c}},ss=new WeakMap,Vt=[],ul=t=>Vt.find(a=>F.isEqual(a.descriptor,t))??null,gl=t=>{const a=ul(t.descriptor);return a||(Vt.find(e=>fl(t,e))??null)},rs=t=>Vt.find(a=>a.name===t)??null,wl=(t,a)=>{const e=gl(t);return e||(Vt.push(t),ss.set(t,a),t)},ch=()=>({standardPatternBoards:F.fromPairs(Vt.map(t=>[t.name,as(t.descriptor)])),planarPatternMaps:F.fromPairs(Vt.map(t=>[t.name,dl(ss.get(t))])),standardSquareBoardGenerations:Fl.map(t=>t.map(a=>a.name)),standardHexagonalBoardGenerations:Hl.map(t=>t.map(a=>a.name)),standardTriangularBoardGenerations:Dl.map(t=>t.map(a=>a.name)),standardCairoBoardGenerations:Ol.map(t=>t.map(a=>a.name)),standardRhombilleBoardGenerations:Nl.map(t=>t.map(a=>a.name)),standardSnubSquareBoardGenerations:Zl.map(t=>t.map(a=>a.name)),standardTrihexagonalBoardGenerations:Ll.map(t=>t.map(a=>a.name)),standardFloretPentagonalBoardGenerations:Pl.map(t=>t.map(a=>a.name)),standardDeltoidalTrihexagonalBoardGenerations:Gl.map(t=>t.map(a=>a.name)),standardPortugalBoardGenerations:Ul.map(t=>t.map(a=>a.name)),standardRhombitrihexagonalBoardGenerations:Yl.map(t=>t.map(a=>a.name)),standardPrismaticPentagonalBoardGenerations:Vl.map(t=>t.map(a=>a.name)),standardElongatedTriangularBoardGenerations:Jl.map(t=>t.map(a=>a.name))});{const t=Object.keys(ye.standardPatternBoards);for(const a of t){let e=new va(Ea(ye.standardPatternBoards[a]),a);const n=ns(ye.planarPatternMaps[a],e);wl(e,n)}}const Y=(t,a)=>{{const e=rs(t);return q()&&w(e),e}},pl=Y("single-edge"),xl=Y("vertex-2-exit-none"),Ml=Y("vertex-2-exit-one"),ml=Y("vertex-3-exit-two-adjacent"),El=Y("vertex-4-exit-two-opposite"),vl=Y("vertex-4-exit-three-adjacent"),ql=Y("vertex-5-exit-two-one"),bl=Y("vertex-5-exit-four"),_l=Y("vertex-6-exit-triple"),yl=Y("vertex-6-exit-two-two"),Al=Y("vertex-6-exit-three-one"),kl=Y("vertex-6-exit-five"),Bl=Y("vertex-2"),Sl=Y("vertex-3"),Tl=Y("vertex-4"),Cl=Y("vertex-5"),Il=Y("vertex-6"),zl=[xl,Ml,ml,El,vl,ql,bl,_l,yl,Al,kl],Rl=[Bl,Sl,Tl,Cl,Il],fh=[pl,...zl,...Rl],lt=t=>da.get(t,{width:20,height:20}),dh=lt(ot(Ls)),uh=new hr(20,20),gh=lt(ot(js)),wh=new lr(10,1,!0),ph=lt(ot(Vs)),xh=lt(ot(Us)),Mh=lt(ot(Ps)),mh=lt(ot(Xs)),Eh=lt(ot(Js)),vh=lt(ot(Ks)),qh=lt(ot(Gs)),bh=lt(ot(Ws)),_h=lt(ot(Ys)),tt=(t,a,e)=>ye[a].map(n=>n.map(r=>{const i=rs(r);return q()&&w(i),i})),Fl=tt("square","standardSquareBoardGenerations"),Hl=tt("hexagonal","standardHexagonalBoardGenerations"),Dl=tt("triangular","standardTriangularBoardGenerations"),Ol=tt("cairo","standardCairoBoardGenerations"),Nl=tt("rhombille","standardRhombilleBoardGenerations"),Zl=tt("snub-square","standardSnubSquareBoardGenerations"),Ll=tt("trihexagonal","standardTrihexagonalBoardGenerations"),Pl=tt("floret-pentagonal","standardFloretPentagonalBoardGenerations"),Gl=tt("deltoidal-trihexagonal","standardDeltoidalTrihexagonalBoardGenerations"),Ul=tt("portugal","standardPortugalBoardGenerations"),Yl=tt("rhombitrihexagonal","standardRhombitrihexagonalBoardGenerations"),Vl=tt("prismatic-pentagonal","standardPrismaticPentagonalBoardGenerations"),Jl=tt("elongated-triangular","standardElongatedTriangularBoardGenerations");export{th as $,vh as A,tr as B,qh as C,bh as D,_h as E,Aa as F,ot as G,lr as H,Vs as I,js as J,Us as K,Ls as L,Ps as M,eh as N,Xs as O,da as P,Js as Q,nh as R,hr as S,sh as T,ah as U,Ks as V,Ql as W,rh as X,$l as Y,Gs as Z,F as _,Qs as a,Ws as a0,Ys as a1,Xl as a2,Kl as a3,ws as a4,oh as a5,va as a6,fl as a7,as as a8,fh as a9,Es as aA,ae as aB,pl as aC,xl as aD,Ml as aE,ml as aF,El as aG,vl as aH,Bl as aI,Sl as aJ,rs as aK,ul as aL,Pl as aM,Gl as aN,Ul as aO,Yl as aP,Vl as aQ,Jl as aR,ya as aa,Lt as ab,Dl as ac,pn as ad,Hl as ae,Nl as af,Ol as ag,Zl as ah,Ll as ai,dl as aj,Ea as ak,ns as al,xs as am,qs as an,bs as ao,xn as ap,ch as aq,lh as ar,hh as as,cs as at,fs as au,us as av,gs as aw,ps as ax,ms as ay,Ms as az,$s as b,er as c,q as d,w as e,ih as f,Mn as g,Ae as h,ca as i,En as j,ds as k,fa as l,hl as m,_s as n,uh as o,ss as p,wh as q,gh as r,Fl as s,dh as t,ph as u,Tl as v,xh as w,Mh as x,mh as y,Eh as z};
