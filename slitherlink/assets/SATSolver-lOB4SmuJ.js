import{P,m as k}from"./UnivariatePolynomial-1rLpyqfN.js";import{E as p,s as B}from"./BasicPuzzle-DGsxIJRd.js";import{L as c}from"./logic-solver-DfsVuGQ5.js";import{e as E,f as v}from"./getCoordinateClusteredMap-Bd_wM-c0.js";import"./PhetioControlledVisibilityProperty-CzTgKbkx.js";import"./TextPushButton-Coq2A-51.js";import{O as N}from"./autoSolver-D0maTTyV.js";const _=QueryStringMachine.getAll({p:{type:"string",defaultValue:""},debugScan:{type:"flag"},debugSleep:{type:"flag"},debugColors:{type:"flag"},showPointerAreas:{type:"flag"}});class q extends Error{constructor(o){super("Multiple solutions found"),this.solutionEdges=o}}class R extends Error{constructor(){super("Too many iterations!")}}const I=(n,o,r)=>{const g=o.clone();for(const a of r)g.setEdgeState(a,p.BLACK);return N(n,g),{board:n,cleanState:o,solvedState:g,blackEdges:new Set(r)}},ee=(n,o)=>{try{if(B(o))return{board:n,stateProperty:new P(o),solution:I(n,o,[])};const r=j(n,o,{maxIterations:1e4,failOnMultipleSolutions:!0});if(r.length!==1)return null;const g=r[0],a=o.clone();for(const L of g)a.setEdgeState(L,p.BLACK);return N(n,a),E()&&v(B(a)),{board:n,stateProperty:new P(o),solution:I(n,o,g)}}catch(r){if(r instanceof q)return null;throw r}},j=(n,o,r)=>{const g=n.edges.filter(e=>o.getEdgeState(e)===p.BLACK),a=n.edges.filter(e=>o.getEdgeState(e)===p.WHITE);E()&&v(a.length,"Need to have at least some undefined edges to use solver");const L=new Set(a),z=new Map(a.map((e,t)=>[e,`edge${t+1}`])),O=new Map(a.map((e,t)=>[`edge${t+1}`,e])),h=new c.Solver,S=e=>{const t=z.get(e);return E()&&v(t!==void 0,"Edge not found!"),t},V=e=>`-${S(e)}`,C=e=>{for(const t of e)h.require(c.not(S(t)))},x=e=>{h.require(c.or(...e.map(S)))},K=e=>{h.require(c.or(...e.map(V)))},W=(e,t)=>{t>0&&(x(e),k.forEachCombination(e,s=>{s.length===e.length-t+1&&h.require(c.not(c.and(...s.map(V))))}))},M=(e,t)=>{k.forEachCombination(e,s=>{s.length===t+1&&h.require(c.or(...s.map(V)))})},F=e=>{h.require(c.not(c.exactlyOne(...e.map(S))))},H=e=>{M(e,2),F(e)},T=(e,t)=>{t===0?C(e):(W(e,t),M(e,t))};x(a);for(const e of n.vertices){let t=0,s=0,l=[];for(const f of e.edges){const i=o.getEdgeState(f);i===p.BLACK?t++:i===p.WHITE&&(s++,l.push(f))}s!==0&&(t===0?H(l):t===1?T(l,1):C(l))}let b=!1;for(const e of n.faces){const t=o.getFaceValue(e);if(t===null)continue;b=!0;let s=0,l=0,f=[];for(const d of e.edges){const u=o.getEdgeState(d);u===p.BLACK?s++:u===p.WHITE&&(l++,f.push(d))}if(l===0)continue;const i=Math.max(t-s,0);T(f,i)}E()&&v(b,"No faces with values!");const $=()=>{let e=null;return c.disablingAssertions(()=>{e=h.solve()}),e?e.getTrueVars().map(s=>O.get(s)):null};let A=0;const Q=()=>{const e=$();if(e===null)return{touchingValueLoops:[],nonTouchingValueLoops:[]};const t=new Set([...e,...g]),s=[],l=[];for(;t.size;){const f=t.values().next().value,i=[];let d=f.end,u=f,y=!1;for(;u;)t.delete(u),i.push(u),y=y||u.faces.some(m=>o.getFaceValue(m)!==null),u=d.edges.find(m=>t.has(m))??null,u&&(d=u.getOtherVertex(d));E()&&v(i[0].vertices.some(m=>i[i.length-1].vertices.includes(m)),"Loop is not a loop!"),(y?s:l).push(i)}return{touchingValueLoops:s,nonTouchingValueLoops:l}},w=[];for(;;){const e=Q();if(!e.touchingValueLoops.length)break;if(e.touchingValueLoops.length===1&&(w.push(e.touchingValueLoops[0]),w.length>1&&r.failOnMultipleSolutions))throw new q(w);const t=[...e.touchingValueLoops,...e.nonTouchingValueLoops];for(const s of t)K(s.filter(l=>L.has(l)));if(A++,A>r.maxIterations)throw new R}return w};export{q as M,_ as S,ee as a,R as b,I as g,j as s};
