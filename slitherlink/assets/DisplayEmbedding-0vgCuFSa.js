var uo=Object.defineProperty;var po=(i,e,t)=>e in i?uo(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var g=(i,e,t)=>po(i,typeof e!="symbol"?e+"":e,t);import{u as go,c as de,R as ht,S as fo,T as So,U as wo,V as Co,f as yo,g as Eo,h as Ct,J as mo,s as yt,i as Po,j as vo,v as Et,k as Fo,m as mt,w as Vo,n as he,o as Do,q as To,x as Oo,y as Ao,I as ue,G as bo,E as Io,A as No,C as ko,W as Lo,r as xo}from"./Theme-CG_JTTcq.js";import{E as we,a as Ce,d as Ro,V as J,k as je,o as Ue,b as pe,T as h,P as Re,l as Mo,c as Ht,C as Bo,B as ot}from"./Vector2Property-CFyCN_2h.js";import{a as z,N as k,S as B,F as ke,t as Pt,P as X,M as Se,u as vt,T as zt,G as Wo,C as Gt,h as U,B as be,g as Uo,j as Ft,v as Ho,R as zo,H as Yt,L as Go}from"./PhetioControlledVisibilityProperty-thEXBwUY.js";import{a as ut,b as Yo,L as ge,f as jo,c as Xo,P as jt}from"./localStorage-BTLIWA27.js";import{d as O,e as A,_ as Xe,a4 as Xt,P as Ko,S as _o,H as qo,a5 as Jo,h as Vt,k as Zo,n as $o,l as Qo,i as er}from"./patternBoards-DzVBPT7g.js";import{E as v,g as T,h as N,V as pt,i as Kt,j as it,k as nt,l as lt,m as ct,n as Ke,o as _e,p as tr,q as or,F as qe,b as gt,U as rt,a as Dt,C as rr,r as Tt,S as sr,s as ar,t as Ot,u as ir,B as At,d as nr}from"./BasicPuzzle-Bt7fJ87M.js";import{I as ee,E as Je,F as Fe,S as _t,G as qt,H as Jt,P as Zt,Q as $t,J as Qt,R as lr,T as eo,U as to,V as cr,W as oo,X as dr,Y as hr,Z as et,_ as ur,$ as pr,a0 as ro,a1 as gr,a2 as fr,a3 as Sr,a4 as wr,a5 as Cr,B as yr,C as Er,D as oe,A as mr,a6 as bt,L as Pr,a7 as vr}from"./SATSolver-BXmuhJOp.js";import{A as Fr}from"./SpinningIndicatorNode-CK4xca7k.js";import{a as Vr,B as Dr,R as Tr,b as Or,c as Ar,d as br,S as Ir,e as Nr}from"./PatternRule-B98-ERhf.js";const Pe=class Pe extends we{};g(Pe,"PAN_ONLY",new Pe),g(Pe,"DRAG_ONLY",new Pe),g(Pe,"enumeration",new Ce(Pe));let Me=Pe;const so=new ut("panDragModeProperty",Me.PAN_ONLY),ao=new z([so],i=>i===Me.DRAG_ONLY);class ft extends k{constructor(t,o,r,s){super();g(this,"triggerDrag");const a=new Set;if(s!=null&&s.delayInteractionEmitter){const f=s==null?void 0:s.delayInteractionEmitter,p=S=>{a.add(S),setTimeout(()=>{a.delete(S)},700)};f.addListener(p),this.disposeEmitter.addListener(()=>f.removeListener(p))}const c=new B,n=t.map(f=>{const p=o(f);return p.makeImmutable(),c.subpaths.push(...p.subpaths),p});this.mouseArea=this.touchArea=c.makeImmutable();const l=f=>{const p=f.trail.globalToLocalPoint(f.pointer.point);for(let S=0;S<n.length;S++){const y=n[S];if(y.bounds.containsPoint(p)&&y.containsPoint(p)){const E=t[S];if(!a.has(E))return E}}return!1},d=(f,p)=>{const S=l(f);S!==!1&&r(S,p)};this.cursor="pointer";const u=new ke({mouseButton:0,fire:f=>{var p;return d(f,(p=f.domEvent)!=null&&p.shiftKey?2:0)}}),w=new ke({mouseButton:2,fire:f=>{var p;return d(f,(p=f.domEvent)!=null&&p.shiftKey?0:2)}}),C=new ke({mouseButton:1,fire:f=>d(f,1)});if(this.disposeEmitter.addListener(()=>{u.dispose(),w.dispose(),C.dispose()}),s!=null&&s.isDragModeProperty){const f=s.isDragModeProperty,p=(F,V)=>{var I,x;const D=l(F);D!==!1?(I=s.onDragStart)==null||I.call(s,D,V):s.noItemItem!==void 0&&((x=s.onDragStart)==null||x.call(s,s.noItemItem,V))},S=F=>{var I,x;const V=F.trail.globalToLocalPoint(F.pointer.point),D=l(F);D!==!1?(I=s.onDrag)==null||I.call(s,D,V):s.noItemItem!==void 0&&((x=s.onDrag)==null||x.call(s,s.noItemItem,V))},y=()=>{var F;(F=s.onDragEnd)==null||F.call(s)},E=F=>F?l(F)!==!1||s.noItemItem!==void 0:!1,m=new Pt({mouseButton:0,start:F=>{var V;return p(F,(V=F.domEvent)!=null&&V.shiftKey?2:0)},drag:S,end:y,canStartPress:E}),P=new Pt({mouseButton:2,start:F=>{var V;return p(F,(V=F.domEvent)!=null&&V.shiftKey?0:2)},drag:S,end:y,canStartPress:E});this.triggerDrag=F=>{F.domEvent.button===2?P.press(F,this):m.press(F,this)},this.disposeEmitter.addListener(()=>{m.dispose(),P.dispose()});const R=F=>{this.inputListeners=F?[m,P]:[u,w,C]};f.link(R),this.disposeEmitter.addListener(()=>f.unlink(R))}else this.addInputListener(u),this.addInputListener(w),this.addInputListener(C)}}class kr extends ft{constructor(e,t,o){super(e.edges,r=>{const s=r.start.viewCoordinates,a=r.end.viewCoordinates,c=new B;let n;if(r.faces.length===2)n=[s,r.faces[0].viewCoordinates,a,r.faces[1].viewCoordinates];else{O()&&A(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const l=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;O()&&A(l.previous.face===null),O()&&A(l.next.face===null);const d=l.start.viewCoordinates,u=l.end.viewCoordinates,w=l.previous.start.viewCoordinates,C=l.next.end.viewCoordinates,f=(y,E,m)=>{const P=E.minus(y).normalized(),R=m.minus(E).normalized();let F=P.minus(R);return F.getMagnitude()<1e-6?F=P.getPerpendicular():F=F.normalized(),Ro.triangleAreaSigned(y,E,E.plus(F))<0&&(F=F.negated()),F},p=f(w,d,u),S=f(d,u,C);n=[d,r.faces[0].viewCoordinates,u,u.plus(S.times(o.backgroundOffsetDistance)),d.plus(p.times(o.backgroundOffsetDistance))]}return c.polygon(n),c.makeImmutable(),c},o.edgePressListener,{delayInteractionEmitter:t,isDragModeProperty:ao,onDragStart:o.onEdgeDragStart,onDrag:o.onEdgeDrag,onDragEnd:o.onEdgeDragEnd})}}class Lr extends k{constructor(e,t,o,r){const s=new X(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),a=new X(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),c=new X(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,a,c],pickable:!1});const n=e.edges.map(p=>v.BLACK);let l=!1,d=!1,u=!1,w=!1,C=null;const f=Se.multilink([t,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(p,S,y,E,m,P,R)=>{if(this.visible=!S,s.visible=y,a.visible=E,c.visible=P,this.visible){let F=!1;for(let V=0;V<e.edges.length;V++){const D=p.getEdgeState(e.edges[V]);D!==n[V]&&(F=!0,n[V]=D)}if(l!==m&&(F=!0,l=m),d!==y&&(F=!0,d=y),u!==E&&(F=!0,u=E),w!==P&&(F=!0,w=P),C!==R&&(F=!0,C=R),F){const V=new B,D=new B,I=new B;for(let x=0;x<e.edges.length;x++){const q=n[x];if(y&&q===v.WHITE){const M=e.edges[x];V.moveTo(M.start.viewCoordinates.x,M.start.viewCoordinates.y),V.lineTo(M.end.viewCoordinates.x,M.end.viewCoordinates.y)}if(q===v.RED){if(E){const M=e.edges[x],W=.07;let b=M.start.viewCoordinates.blend(M.end.viewCoordinates,.5);if(m){const G=M.end.viewCoordinates.minus(M.start.viewCoordinates).getAngle(),K=new J(-W,-W).rotate(G).add(b),te=new J(W,W).rotate(G).add(b),ie=new J(-W,W).rotate(G).add(b),Ve=new J(W,-W).rotate(G).add(b);D.moveTo(K.x,K.y),D.lineTo(te.x,te.y),D.moveTo(ie.x,ie.y),D.lineTo(Ve.x,Ve.y)}else D.moveTo(b.x-W,b.y-W),D.lineTo(b.x+W,b.y+W),D.moveTo(b.x-W,b.y+W),D.lineTo(b.x+W,b.y-W)}if(P){const M=e.edges[x],W=.4,b=.017,G=M.start.viewCoordinates.blend(M.end.viewCoordinates,.5),K=G.blend(M.start.viewCoordinates,W),te=G.blend(M.end.viewCoordinates,W);for(let ie=0;ie<5;ie++){const Ve=K.blend(te,ie/4);I.moveTo(Ve.x+b,Ve.y),I.arc(Ve.x,Ve.y,b,0,2*Math.PI,!1)}}}}V.makeImmutable(),D.makeImmutable(),I.makeImmutable(),s.shape=V,a.shape=D,c.shape=I}}});this.disposeEmitter.addListener(()=>f.dispose())}}class xr extends k{constructor(t,o,r){const s=new k;super({pickable:!1,children:[s]});g(this,"faceColorNodeMap",new Map);g(this,"faceColorIdMap",new Map);g(this,"adjacentFacesMap",new Map);g(this,"faceColorNodeContainer");g(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,t.faces.forEach(l=>{this.adjacentFacesMap.set(l,l.edges.map(d=>d.getOtherFace(l)).filter(d=>d!==null))});{const l=o.value.getFaceColors();for(const d of l)this.addFaceColor(d,o.value.getFacesWithColor(d));this.addDualColorViews(o.value,l)}this.updateHues();let a=o.value.clone();const c=l=>{const d=a;a=l.clone();const u=d.getFaceColors(),w=l.getFaceColors(),C=[],f=[],p=[];Xt(u,w,C,f,p);const S=new Set(C),y=this.removeInvalidDualColorViews(l),E=[...y];for(const m of f)if(y.add(m),this.faceColorIdMap.has(m.id)){const P=this.faceColorIdMap.get(m.id);this.replaceFaceColor(P,m,l.getFacesWithColor(m)),S.delete(P)}else this.addFaceColor(m,l.getFacesWithColor(m));for(const m of p)this.updateFaceColor(m,l.getFacesWithColor(m));for(const m of S)y.delete(m),this.removeFaceColor(m);this.addDualColorViews(l,[...y]),(f.length||C.length||E.length)&&this.updateHues()};o.lazyLink(c),this.disposeEmitter.addListener(()=>o.unlink(c)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const n=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(n),r.theme.faceColorLightHueLUTProperty.lazyLink(n),r.theme.faceColorDarkHueLUTProperty.lazyLink(n),r.theme.faceColorInsideColorProperty.lazyLink(n),r.theme.faceColorOutsideColorProperty.lazyLink(n),r.theme.faceColorDefaultColorProperty.lazyLink(n),r.faceColorThresholdProperty.lazyLink(n),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(n),r.theme.faceColorLightHueLUTProperty.unlink(n),r.theme.faceColorDarkHueLUTProperty.unlink(n),r.theme.faceColorInsideColorProperty.unlink(n),r.theme.faceColorOutsideColorProperty.unlink(n),r.theme.faceColorDefaultColorProperty.unlink(n),r.faceColorThresholdProperty.unlink(n)})}addFaceColor(t,o){const r=new xe(t,o,this.style);this.faceColorNodeMap.set(t,r),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(t,o,r){O()&&A(t.id===o.id);const s=this.faceColorNodeMap.get(t);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const r=this.faceColorNodeMap.get(t);let s=r.faces.length!==o.length;if(!s)for(let a=0;a<o.length;a++){const c=r.faces[a],n=o[a];if(c!==n){s=!0;break}}s&&r.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const a=this.faceColorNodeMap.get(s);O()&&A(a);const c=t.getOppositeFaceColor(s);if(c){O()&&A(r.has(c)),r.delete(c);const n=this.faceColorNodeMap.get(c);O()&&A(n),this.dualColorViews.add(new It([a,n],this.style))}else this.dualColorViews.add(new It([a],this.style))}}removeInvalidDualColorViews(t){const o=new Set,r=new Set(t.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const a of s.colorNodes)o.add(a.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==T.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new J(0,0),r=()=>{for(const d of t)d.hueVector.getMagnitude()>1e-6?d.hueVector.normalize():d.hueVector.setXY(je.nextDouble()-.5,je.nextDouble()-.5).normalize()},s=new Map,a=[];this.board.faces.forEach(d=>{s.set(d,[])});for(const d of t){const u=new Set;for(const C of d.faces)u.add(C);const w=new Set;for(const C of u){w.add(C);for(const f of this.adjacentFacesMap.get(C))w.add(f)}for(const C of w){const f=s.get(C);if(f){if(f.length)for(const p of f){let S=!1;for(const y of a)if(y.a===p&&y.b===d){y.weight++,S=!0;break}S||a.push({a:p,b:d,weight:1})}f.push(d)}}}const c=new Map;for(const d of t)c.set(d,J.ZERO.copy());const n=(d,u,w)=>{const C=c.get(d),f=c.get(u),p=d.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(d.hueVector);S.magnitudeSquared>1e-11&&S.normalize();const y=.2,E=Math.abs(p),m=w*((Math.max(y,E)-y)/(1-y))**3;S.multiplyScalar(m),C.subtract(S),f.add(S)};let l=1;for(let d=0;d<100;d++){l*=.99;for(const u of t)c.get(u).setXY(0,0);for(const u of a){const w=u.a,C=u.b,f=u.weight;n(w,C,f)}if(t.length<8)for(let u=0;u<t.length;u++){const w=t[u];for(let C=u+1;C<t.length;C++)n(w,t[C],.2)}for(const u of t){const w=c.get(u);w.multiplyScalar(l/u.faceCount),u.hueVector.add(w),c.get(u).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const le=class le extends we{};g(le,"BASIC",new le),g(le,"PRIMARY",new le),g(le,"SECONDARY",new le),g(le,"enumeration",new Ce(le));let se=le;class It{constructor(e,t){g(this,"hueVector");g(this,"faceCount");if(this.colorNodes=e,this.style=t,O()&&A(e.length===1||e.length===2),this.faceCount=Xe.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=se.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],r=o===e[0]?e[1]:e[0];let s;o.type===se.PRIMARY?s=o:r.type===se.PRIMARY||o.type===se.SECONDARY?s=r:(r.type,se.SECONDARY,s=o);const a=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=se.PRIMARY,a.type=se.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class xe extends X{constructor(t,o,r){const s=J.createPolar(1,je.nextDoubleBetween(0,2*Math.PI));super(xe.toShape(o));g(this,"hueVector");g(this,"faceCount");g(this,"dualColorView",null);g(this,"type",se.BASIC);this.faceColor=t,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==T.UNDECIDED?this.fill=xe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const r=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=xe.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(t,o,r,s){const a=r===se.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===se.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,c=(Math.round(t.getAngle()*180/Math.PI)+360)%360;O()&&A(c>=0&&c<a.length);const n=a[c];if(o===T.UNDECIDED)return n;{const d=(o===T.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,u=d.alpha,w=new vt(n);return new vt((1-u)*w.red+u*d.red,(1-u)*w.green+u*d.green,(1-u)*w.blue+u*d.blue).toCSS()}}static toShape(t){const o=new B;for(const r of t)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class Rr extends zt{constructor(e,t){const o=Ue()({font:go,fill:de.uiForegroundColorProperty},t);super(e,o)}}class Mr extends k{constructor(e,t,o){super({translation:e.viewCoordinates}),this.face=e;const s=t.value.getFaceState(e),a=s.possibilityCount===0||s.possibilityCount>9;let c;const n=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(a)c=new Rr(s.possibilityCount,{font:ht,maxWidth:.4,maxHeight:.4});else{const l=new Set(e.vertices);c=new Wo({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(d=>{const u=new k,w=new Set(d.map(p=>p.start)),C=new Set(d.map(p=>p.end)),f=p=>p.minus(e.viewCoordinates);if(u.addChild(new X(B.polygon(e.vertices.map(p=>f(p.viewCoordinates))),{stroke:n,lineWidth:.03,opacity:.2})),w.size){const p=new B;if(d.length===e.edges.length)p.polygon(e.vertices.map(S=>f(S.viewCoordinates)));else{const S=new Set(d);for(;S.size;){const y=[...l].find(P=>[...S].filter(R=>R.start===P||R.end===P).length===1);O()&&A(y);let E=y,m=[...S].find(P=>P.start===E||P.end===E)??null;for(p.moveToPoint(f(E.viewCoordinates));m;)S.delete(m),E=m.getOtherVertex(E),p.lineToPoint(f(E.viewCoordinates)),m=[...S].find(P=>P.start===E||P.end===E)??null}}u.addChild(new X(p,{stroke:n,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const p of e.vertices)!w.has(p)&&!C.has(p)&&u.addChild(new Gt(.1,{fill:n,translation:f(p.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}c.center=J.ZERO,this.addChild(c)}}class Br extends k{constructor(e,t,o,r){super({pickable:!1});const s=Se.multilink([t,r.faceStateVisibleProperty],(c,n)=>{this.children.forEach(l=>l.dispose()),this.children=[],n&&e.faces.forEach(l=>{this.addChild(new Mr(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const a=c=>{this.visible=!c};o.link(a),this.disposeEmitter.addListener(()=>{o.unlink(a),this.children.forEach(c=>c.dispose())})}}class Wr extends ft{constructor(e,t){super(e.faces,o=>o?B.polygon(o.vertices.map(r=>r.viewCoordinates)):new B,t.facePressListener,{isDragModeProperty:ao,onDragStart:t.onFaceDragStart,onDrag:t.onFaceDrag,onDragEnd:t.onFaceDragEnd,noItemItem:null})}}const Ne=class Ne{constructor(e,t){this.incorrectEdges=e,this.incorrectFaces=t}isCorrect(){return this.incorrectEdges.size===0&&this.incorrectFaces.size===0}with(e){return this.isCorrect()?e:e.isCorrect()?this:new Ne(new Set([...this.incorrectEdges,...e.incorrectEdges]),new Set([...this.incorrectFaces,...e.incorrectFaces]))}static with(e){return e.reduce((t,o)=>t.with(o),Ne.CORRECT)}};g(Ne,"CORRECT",new Ne(new Set,new Set));let Le=Ne;class Nt{constructor(e,t,o){g(this,"edgeStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(O()&&A(this.board.edges.includes(e)),t!==v.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new ee(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.edges){const a=t.getEdgeState(s);a!==v.WHITE&&a!==o.getEdgeState(s)&&r.add(s)}return new Le(r,new Set)}}class kt{constructor(e,t,o){g(this,"faceColorsChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){if(s)throw new ee("invalid face color?");const a=new Set([...o.values(),...r.keys(),...o.values()]),c=new Map(this.currentState.getFaceColorMap());for(const d of o.keys())c.set(d,o.get(d));const n=d=>r.has(d)?r.get(d):[...e].includes(d)?this.currentState.getOppositeFaceColor(d):null,l=new Map;for(const d of c.keys()){const u=c.get(d);l.has(u)||l.set(u,new Set([d])),l.get(u).add(d)}for(const d of a){const u=l.get(d);if(!u)continue;const w=[...u];O()&&A(w.length>0);const C=this.solvedState.getFaceColor(w[0]);for(const p of w)if(this.solvedState.getFaceColor(p)!==C)throw new ee("invalid face color");const f=n(d);if(f){let p;if(f.colorState===T.INSIDE?p=this.solvedState.getInsideColor():f.colorState===T.OUTSIDE?p=this.solvedState.getOutsideColor():p=this.solvedState.getFaceColor([...l.get(f)][0]),C===p)throw new ee("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set,s=new Set,a=t.getOutsideColor(),c=t.getInsideColor(),n=o.getOutsideColor(),l=o.getInsideColor();for(const d of t.getFaceColors()){if(s.has(d))continue;const u=t.getOppositeFaceColor(d);s.add(d),u&&s.add(u);const w=t.getFacesWithColor(d),C=u?t.getFacesWithColor(u):[],f=(p,S)=>{o.getFaceColor(p)!==S&&r.add(p)};if(d===a)w.forEach(p=>f(p,n)),C.forEach(p=>f(p,l));else if(d===c)w.forEach(p=>f(p,l)),C.forEach(p=>f(p,n));else if(w.length){let p=w.filter(y=>o.getFaceColor(y)===n).length+C.filter(y=>o.getFaceColor(y)===l).length,S=w.length+C.length;if(p>0&&p<S){const y=p>S/2,E=y?n:l,m=y?l:n;w.forEach(P=>f(P,E)),C.forEach(P=>f(P,m))}}}return new Le(new Set,r)}}class Ur{constructor(e,t,o){g(this,"faceStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){O()&&A(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make face ${t} when it should be ${o}`);const r=this.currentState.getFaceState(e);if(!t.isSubsetOf(r))throw new ee("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Hr{constructor(e,t,o){g(this,"faceValueChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new ee("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Lt{constructor(e,t,o){g(this,"sectorStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){O()&&A(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.halfEdges){const a=s.edge,c=s.next.edge,n=t.getSectorState(s),l=(o.getEdgeState(a)===v.BLACK?1:0)+(o.getEdgeState(c)===v.BLACK?1:0);n.allows(l)||(r.add(a),r.add(c))}return new Le(r,new Set)}}class zr{constructor(e,t,o){g(this,"simpleRegionsChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,r){if([...o].length)throw new ee("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Gr{constructor(e,t,o){g(this,"vertexStateChangedEmitter",new pe);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){O()&&A(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new ee(`Attempt to make vertex ${t} when it should be ${o}`);const r=this.currentState.getVertexState(e);if(!t.isSubsetOf(r))throw new ee("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Yr{constructor(e,t,o){g(this,"anyStateChangedEmitter",new pe);g(this,"edgeStateValidator");g(this,"faceValueValidator");g(this,"simpleRegionDataValidator");g(this,"faceColorValidator");g(this,"sectorStateValidator");g(this,"vertexStateValidator");g(this,"faceStateValidator");O()&&A(e),O()&&A(o),this.edgeStateValidator=new Nt(e,t,o),this.faceValueValidator=new Hr(e,t,o),this.simpleRegionDataValidator=new zr(e,t,o),this.faceColorValidator=new kt(e,t,o),this.sectorStateValidator=new Lt(e,t,o),this.vertexStateValidator=new Gr(e,t,o),this.faceStateValidator=new Ur(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,r){this.simpleRegionDataValidator.modifyRegions(e,t,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){this.faceColorValidator.modifyFaceColors(e,t,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){return Le.with([Nt.getCorrectnessState(e,t,o),kt.getCorrectnessState(e,t,o),Lt.getCorrectnessState(e,t,o)])}}const jr=i=>[i.forwardHalf,i.reversedHalf,i.forwardHalf.previous,i.reversedHalf.previous];class Be{constructor(e){this.edge=e,O()&&A(e)}apply(e){e.getEdgeState(this.edge)!==v.WHITE&&e.setEdgeState(this.edge,v.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=e.getOutsideColor(),a=e.getInsideColor(),c=o?e.getFaceColor(o):s,n=r?e.getFaceColor(r):s,l=e.getOppositeFaceColor(c);if(c===n||l===n){const d=[...e.getFacesWithColor(c),...c===s?[null]:[]],u=l?[...e.getFacesWithColor(l),...l===s?[null]:[]]:[],w=[...d,...u],C=p=>{const S=new Set,y=new Set([p]);for(;y.size>0;){const E=y.values().next().value;if(y.delete(E),S.add(E),E){for(const m of E.edges)if(e.getEdgeState(m)!==v.WHITE){const P=m.getOtherFace(E),R=P?e.getFaceColor(P):s;(R===c||R===l)&&!S.has(P)&&y.add(P)}}else for(const m of w)if(m&&!S.has(m))for(const P of m.edges)P.getOtherFace(m)===null&&e.getEdgeState(P)!==v.WHITE&&y.add(m)}return S},f=C(o);if(!f.has(r)){const p=C(r);O()&&A(f.size>0&&p.size>0),O()&&A([...f].every(I=>!p.has(I)));const S=w.filter(I=>!f.has(I)&&!p.has(I)),y=[],E=[],m=new Map,P=new Map,R=(I,x,q)=>{const M=I.filter(b=>(b?e.getFaceColor(b):s)===c),W=I.filter(b=>(b?e.getFaceColor(b):s)===l);if(x!==null)x!==s&&x!==a&&(M.length||E.push(x),q&&!W.length&&E.push(q));else if(O()&&A(I.every(b=>b)),x=new lt(ct(),T.UNDECIDED),y.push(x),M.length&&W.length){q=new lt(ct(),T.UNDECIDED),y.push(q),P.set(x,q),P.set(q,x);for(const b of M)O()&&A(b),m.set(b,x);for(const b of W)O()&&A(b),m.set(b,q)}else{const b=M.length?M:W;O()&&A(b.length);for(const G of b)O()&&A(G),m.set(G,x)}},F=[...f],V=[...p],D=Xe.sortBy([...S.length?[S]:[],F,V],I=>-I.length+(I.some(x=>!x)?-1e7:0));for(let I=0;I<D.length;I++)R(D[I],I===0?c:null,I===0?l:null);e.modifyFaceColors(y,E,m,P,!1)}}for(const d of jr(this.edge))e.setSectorState(d,N.ANY);for(const d of this.edge.vertices)e.setVertexState(d,pt.any(d));for(const d of this.edge.faces)e.setFaceState(d,Kt.any(d,e.getFaceValue(d)))}getUndo(e){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:it(this.edge)}}static deserializeAction(e,t){const o=nt(e,t.edge);return new Be(o)}}class We{constructor(e){this.face=e,O()&&A(e)}apply(e){this.face.edges.forEach(t=>{new Be(t).apply(e)})}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:Ke(this.face)}}static deserializeAction(e,t){const o=_e(e,t.face);return new We(o)}}class St{constructor(e){this.sector=e,O()&&A(e)}apply(e){e.setSectorState(this.sector,N.ANY);const t=this.sector.end;e.setVertexState(t,pt.any(t));const o=this.sector.face;o&&e.setFaceState(o,Kt.any(o,e.getFaceValue(o)))}getUndo(e){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:tr(this.sector)}}static deserializeAction(e,t){const o=or(e,t.sector);return new St(o)}}class st extends Error{constructor(e){super(e)}}const xt=(i,e,t)=>{Je(t,i,e,!0)},Xr=(i,e,t)=>new Fe([new _t(i,e),new qt(i,e),new Jt(i,e),new Zt(i,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $t(i,e,{solveToRed:!0,solveToBlack:!0}),new Qt(i,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new lr(i,e),new eo(i,e),new to(i,e),new cr(i,e),new oo(i,e),new dr(i,e,{solveToRed:!0,solveToBlack:!0}),new hr(i,e),new et(i,e,{solveToRed:!0,solveToBlack:!0}),new ur(i,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new pr(i,e),new ro(i,e),new gr(i,e,{solveToRed:!0,solveToBlack:!0}),new fr(i,e),new Sr(i,e),new wr(i,e)]),io=(i,e,t,o)=>(r,s,a)=>{const c=[new _t(r,s),new qt(r,s)];return(i||e||t||o)&&(c.push(new Jt(r,s)),(e||t||o)&&(c.push(new eo(r,s)),(t||o)&&(c.push(new oo(r,s)),o&&c.push(new ro(r,s))))),new Fe(c)},Kr={allowEdgeEditProperty:fo,allowAbsoluteFaceColorEditProperty:So,allowFaceColorEditProperty:wo,allowSectorEditProperty:Co,edgesVisibleProperty:yo,edgesHaveColorsProperty:Eo,faceColorsVisibleProperty:Ct,faceColorThresholdProperty:mo,sectorsVisibleProperty:yt,sectorsNextToEdgesVisibleProperty:Po,sectorsTrivialVisibleProperty:vo,vertexStateVisibleProperty:Et,allVertexStateVisibleProperty:Fo,faceStateVisibleProperty:mt,whiteLineVisibleProperty:Vo,redLineVisibleProperty:he,verticesVisibleProperty:Do,smallVertexProperty:To,redXsVisibleProperty:Oo,redXsAlignedProperty:Ao,faceValueStyleProperty:ue,redLineStyleProperty:bo,vertexStyleProperty:Io,joinedLinesJoinProperty:No,joinedLinesCapProperty:ko,safeSolverFactoryProperty:new z([Ct,yt,Et,mt],(i,e,t,o)=>io(i,e,t,o)),autoSolverFactoryProperty:Cr,theme:de},ye=(i,e,t,o,r)=>{const s=io(i,e,t,o);return{faceColorsVisibleProperty:new be(i),sectorsVisibleProperty:new be(e),vertexStateVisibleProperty:new be(t),faceStateVisibleProperty:new be(o),safeSolverFactoryProperty:new Re(s),autoSolverFactoryProperty:r?new z([r],a=>(c,n,l)=>new Fe([s(c,n,l),a(c,n,l)])):new Re(s)}},De=new z([yr,Er],(i,e)=>(t,o,r)=>new Fe([new Zt(t,o,{solveJointToRed:!0,solveForcedLineToBlack:i,solveAlmostEmptyToRed:!0},r?void 0:[]),new $t(t,o,{solveToRed:!0,solveToBlack:i},r?void 0:[]),...e?[new Qt(t,o,{solveToRed:!0,solveToBlack:i,resolveAllRegions:!1},r?void 0:[])]:[]])),_r=new z([De],i=>(e,t,o)=>new Fe([i(e,t,o),new et(e,t,{solveToRed:!0,solveToBlack:!0})])),no=new z([De],i=>(e,t,o)=>new Fe([i(e,t,o),new to(e,t,o?void 0:[])])),qr=new z([no],i=>(e,t,o)=>new Fe([i(e,t,o),new et(e,t,{solveToRed:!0,solveToBlack:!0})])),Jr=i=>({...ye(!0,!1,!1,!1,De),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Zr=i=>({...ye(!0,!1,!1,!1,_r),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),$r=i=>({...ye(!0,!1,!1,!1,new Re((e,t,o)=>new Fe([new et(e,t,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:i,allowEdgeEditProperty:new h(!1),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!1),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),Qr=i=>({...ye(!1,!1,!1,!1,De),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),Zs=i=>({...ye(!1,!0,!1,!1,De),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!1),redLineVisibleProperty:he,verticesVisibleProperty:new h(!0),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!0),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("square"),joinedLinesJoinProperty:new h("miter"),joinedLinesCapProperty:new h("square")}),es=i=>({...ye(!0,!0,!1,!1,no),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!0),allowFaceColorEditProperty:new h(!1),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!0),faceColorThresholdProperty:new h(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),ts=i=>({...ye(!0,!0,!1,!1,qr),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!0),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),os=i=>({...ye(!0,!1,!0,!1,De),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),rs=i=>({...ye(!0,!1,!1,!0,De),theme:i,allowEdgeEditProperty:new h(!0),allowAbsoluteFaceColorEditProperty:new h(!1),allowFaceColorEditProperty:new h(!0),allowSectorEditProperty:new h(!1),edgesVisibleProperty:new h(!0),edgesHaveColorsProperty:new h(!1),faceColorThresholdProperty:new h(2),sectorsNextToEdgesVisibleProperty:new h(!1),sectorsTrivialVisibleProperty:new h(!1),allVertexStateVisibleProperty:new h(!1),whiteLineVisibleProperty:new h(!0),redLineVisibleProperty:he,verticesVisibleProperty:new h(!1),smallVertexProperty:new h(!1),redXsVisibleProperty:new h(!1),redXsAlignedProperty:new h(!1),faceValueStyleProperty:ue,redLineStyleProperty:new h("middle"),vertexStyleProperty:new h("round"),joinedLinesJoinProperty:new h("round"),joinedLinesCapProperty:new h("round")}),ss=Jr(de),as=Zr(de),is=$r(de),lo=Qr(de),ns=es(de),ls=ts(de),cs=os(de),ds=rs(de),at={basicLines:ss,basicFaceColoring:as,pureFaceColor:is,classic:lo,basicSectors:ns,sectorsWithColors:ls,vertexState:cs,faceState:ds,custom:Kr},Rt=lo,hs=i=>({allowEdgeEditProperty:new U(i,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new U(i,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new U(i,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new U(i,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new U(i,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new U(i,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new U(i,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new U(i,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new U(i,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new U(i,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new U(i,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new U(i,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new U(i,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new U(i,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new U(i,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new U(i,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new U(i,{derive:"verticesVisibleProperty"}),smallVertexProperty:new U(i,{derive:"smallVertexProperty"}),redXsVisibleProperty:new U(i,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new U(i,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new U(i,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new U(i,{derive:"redLineStyleProperty"}),vertexStyleProperty:new U(i,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new U(i,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new U(i,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new U(i,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new U(i,{derive:"autoSolverFactoryProperty"}),theme:Lo(new z([i],e=>e.theme))}),us=new Yo("puzzleStyle",{serialize:i=>Object.keys(at).find(e=>at[e]===i),deserialize:i=>i?at[i]??Rt:Rt}),_=hs(us),$s=new ge("showPuzzleStyleProperty",!0),Qs=new ge("showPuzzleTimerProperty",!1),ea=new ge("showSectorViewModesProperty",!1),H=class H extends we{constructor(e){super(),this.isEnabledProperty=e}};g(H,"EDGE_STATE",new H(_.allowEdgeEditProperty)),g(H,"EDGE_STATE_REVERSED",new H(_.allowEdgeEditProperty)),g(H,"FACE_COLOR_INSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),g(H,"FACE_COLOR_OUTSIDE",new H(_.allowAbsoluteFaceColorEditProperty)),g(H,"FACE_COLOR_MATCH",new H(_.allowFaceColorEditProperty)),g(H,"FACE_COLOR_OPPOSITE",new H(_.allowFaceColorEditProperty)),g(H,"SECTOR_STATE",new H(_.allowSectorEditProperty)),g(H,"VERTEX_STATE",new H(_.vertexStateVisibleProperty)),g(H,"FACE_STATE",new H(_.faceStateVisibleProperty)),g(H,"FACE_VALUE",new H(new be(!1))),g(H,"DELETE_FACE",new H(new be(!1))),g(H,"enumeration",new Ce(H));let L=H;const Y=new ut("editModeProperty",L.EDGE_STATE);L.enumeration.values.forEach(i=>{i.isEnabledProperty.lazyLink(e=>{if(!Y.value.isEnabledProperty.value){const t=L.enumeration.values.find(o=>o.isEnabledProperty.value)??null;t&&(Y.value=t)}})});const He=new ge("eraserEnabledProperty",!1),ta=i=>{i.isEnabledProperty.value&&(Y.value=i)},ps=new z([Y],i=>i===L.EDGE_STATE||i===L.EDGE_STATE_REVERSED),wt=new z([Y],i=>i===L.FACE_COLOR_MATCH||i===L.FACE_COLOR_OPPOSITE),oa=wt,gs=new z([Y],i=>i===L.FACE_COLOR_OUTSIDE||i===L.FACE_COLOR_INSIDE),fs=new z([Y],i=>i===L.SECTOR_STATE),Ss=new z([Y],i=>i===L.VERTEX_STATE),ws=new z([Y,wt,gs],(i,e,t)=>e||t||i===L.FACE_STATE||i===L.FACE_VALUE||i===L.DELETE_FACE),re=class re extends we{};g(re,"NONE",new re),g(re,"ABSOLUTE_PAINT",new re),g(re,"MAKE_SAME",new re),g(re,"MAKE_OPPOSITE",new re),g(re,"enumeration",new Ce(re));let Z=re;class Cs{constructor(e){g(this,"paintFaceSet",new Set);g(this,"paintFaceOppositeSet",new Set);g(this,"absolutePaintState",T.INSIDE);g(this,"lastFace",null);g(this,"faceDragStateProperty",new h(Z.NONE));g(this,"dragIndex",0);this.board=e}isNoOpSingleFace(){return(this.faceDragStateProperty.value===Z.MAKE_SAME||this.faceDragStateProperty.value===Z.MAKE_OPPOSITE)&&this.paintFaceSet.size===1&&this.paintFaceOppositeSet.size===0}onAbsolutePaintStart(e,t){this.faceDragStateProperty.value=Z.ABSOLUTE_PAINT,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeSameStart(e){this.faceDragStateProperty.value=Z.MAKE_SAME,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=T.UNDECIDED,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeOppositeStart(e){this.faceDragStateProperty.value=Z.MAKE_OPPOSITE,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=T.UNDECIDED,this.lastFace=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(e){const r=e.viewCoordinates.distance(t),s=e.vertices.map(a=>a.viewCoordinates.distance(t)).reduce((a,c)=>Math.min(a,c),Number.POSITIVE_INFINITY);if(r>.3&&s/r<.7)return!1}const o=this.lastFace;return this.lastFace=e,!this.paintFaceSet.has(e)&&!this.paintFaceOppositeSet.has(e)?(this.faceDragStateProperty.value===Z.MAKE_OPPOSITE&&this.paintFaceSet.has(o)?(O()&&A(!this.paintFaceSet.has(e)),this.paintFaceOppositeSet.add(e)):(O()&&A(!this.paintFaceOppositeSet.has(e)),this.paintFaceSet.add(e)),!0):!1}onDragEnd(){this.faceDragStateProperty.value=Z.NONE}}const $=class $ extends we{};g($,"DEFAULT",new $),g($,"LOADING",new $),g($,"SEARCHING",new $),g($,"FOUND",new $),g($,"NOT_FOUND",new $),g($,"enumeration",new Ce($));let ne=$;const ce=class ce extends we{};g(ce,"NONE",new ce),g(ce,"LINE_DRAG",new ce),g(ce,"EDGE_PAINT",new ce),g(ce,"enumeration",new Ce(ce));let ae=ce;class ys{constructor(e){g(this,"firstEdge");g(this,"edgeStack",[]);g(this,"vertexStack",[]);g(this,"paintEdgeSet",new Set);g(this,"paintEdgeState",v.WHITE);g(this,"lineDragStateProperty",new h(ae.NONE));g(this,"dragIndex",0);this.board=e}onLineDragStart(e){this.firstEdge=e,this.lineDragStateProperty.value=ae.LINE_DRAG,this.edgeStack.length=0,this.edgeStack.push(e),this.vertexStack.length=0,this.dragIndex=Math.ceil(Math.random()*1e10)}onPaintDragStart(e,t){this.firstEdge=e,this.lineDragStateProperty.value=ae.EDGE_PAINT,this.paintEdgeSet.clear(),this.paintEdgeSet.add(e),this.paintEdgeState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(this.lineDragStateProperty.value===ae.LINE_DRAG){const o=this.edgeStack[this.edgeStack.length-1],r=this.edgeStack.length>1?this.edgeStack[this.edgeStack.length-2]:null;if(e===o)return!1;if(e===r)return this.edgeStack.pop(),this.vertexStack.pop(),!0;if(this.edgeStack.includes(e))return!1;if(this.vertexStack.length===0){const s=o.vertices.find(a=>e.vertices.includes(a))??null;return s?(this.edgeStack.push(e),this.vertexStack.push(s),!0):!1}else{const s=this.vertexStack[this.vertexStack.length-1];if(e.vertices.includes(s))return this.edgeStack.pop(),this.edgeStack.push(e),!0;{const a=o.getOtherVertex(s);return e.vertices.includes(a)?(this.edgeStack.push(e),this.vertexStack.push(a),!0):!1}}}else if(this.lineDragStateProperty.value===ae.EDGE_PAINT){const o=e.start.viewCoordinates.distance(e.end.viewCoordinates),r=Math.min(...e.vertices.map(a=>a.viewCoordinates.distance(t))),s=Math.min(...e.faces.map(a=>a.viewCoordinates.distance(t)));if(Math.min(r,s)/o<.3)return!1;if(!this.paintEdgeSet.has(e))return this.paintEdgeSet.add(e),!0}return!1}onDragEnd(){this.lineDragStateProperty.value=ae.NONE}}const j=class j extends we{constructor(e,t,o){super(),this.fromWhite=e,this.fromBlack=t,this.fromRed=o}apply(e){return e===v.WHITE?this.fromWhite:e===v.BLACK?this.fromBlack:this.fromRed}};g(j,"CYCLE",new j(v.BLACK,v.RED,v.WHITE)),g(j,"REVERSE_CYCLE",new j(v.RED,v.WHITE,v.BLACK)),g(j,"BLACK_TOGGLE",new j(v.BLACK,v.WHITE,v.BLACK)),g(j,"RED_TOGGLE",new j(v.RED,v.RED,v.WHITE)),g(j,"WHITE_SET",new j(v.WHITE,v.WHITE,v.WHITE)),g(j,"BLACK_SET",new j(v.BLACK,v.BLACK,v.BLACK)),g(j,"RED_SET",new j(v.RED,v.RED,v.RED)),g(j,"enumeration",new Ce(j));let Ee=j;const Q=class Q extends we{constructor(e,t,o){super(),this.fromUndecided=e,this.fromInside=t,this.fromOutside=o}apply(e){return e===T.UNDECIDED?this.fromUndecided:e===T.OUTSIDE?this.fromOutside:this.fromInside}};g(Q,"CYCLE",new Q(T.INSIDE,T.OUTSIDE,T.UNDECIDED)),g(Q,"REVERSE_CYCLE",new Q(T.OUTSIDE,T.UNDECIDED,T.INSIDE)),g(Q,"INSIDE_TOGGLE",new Q(T.INSIDE,T.UNDECIDED,T.INSIDE)),g(Q,"OUTSIDE_TOGGLE",new Q(T.OUTSIDE,T.OUTSIDE,T.UNDECIDED)),g(Q,"UNDECIDED_SET",new Q(T.UNDECIDED,T.UNDECIDED,T.UNDECIDED)),g(Q,"enumeration",new Ce(Q));let me=Q;const ve=class ve extends we{constructor(e,t){super(),this.edgePressStyles=e,this.faceColorPressStyles=t}};g(ve,"CYCLIC",new ve([Ee.CYCLE,Ee.WHITE_SET,Ee.REVERSE_CYCLE],[me.CYCLE,me.UNDECIDED_SET,me.REVERSE_CYCLE])),g(ve,"TOGGLE",new ve([Ee.BLACK_TOGGLE,Ee.WHITE_SET,Ee.RED_TOGGLE],[me.INSIDE_TOGGLE,me.UNDECIDED_SET,me.OUTSIDE_TOGGLE])),g(ve,"enumeration",new Ce(ve));let dt=ve;const ze=new ut("stateTransitionModeProperty",dt.CYCLIC);class Ze{constructor(e,t,o,r){this.firstEdge=e,this.edges=t,this.state=o,this.dragIndex=r}apply(e){for(const t of this.edges)e.setEdgeState(t,this.state)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.edges.length===0}serializeAction(){return{type:"UserEdgeDragAction",firstEdge:it(this.firstEdge),edges:this.edges.map(e=>it(e)),state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new Ze(nt(e,t.firstEdge),t.edges.map(o=>nt(e,o)),v.enumeration.getValue(t.state),t.dragIndex)}}class $e{constructor(e){this.face=e,O()&&A(e)}apply(e){const t=e.getFaceColor(this.face),o=e.getOppositeFaceColor(t),r=e.getFacesWithColor(t);for(const s of this.face.edges)e.getEdgeState(s)!==v.WHITE&&e.setEdgeState(s,v.WHITE);if(t.colorState!==T.UNDECIDED||o||r.length>1)if(t.colorState===T.UNDECIDED&&r.length===1)O()&&A(o),e.modifyFaceColors([],[],new Map,new Map([[t,null],[o,null]]),!1);else{const s=new lt(ct(),T.UNDECIDED);e.modifyFaceColors([s],[],new Map([[this.face,s]]),new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceOnlyCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceOnlyCompleteAction",face:Ke(this.face)}}static deserializeAction(e,t){const o=_e(e,t.face);return new $e(o)}}class Qe{constructor(e,t,o,r,s){this.primaryFaces=e,this.secondaryFaces=t,this.isAbsolute=o,this.state=r,this.dragIndex=s}apply(e){console.log(this.state,this.primaryFaces,this.secondaryFaces);const t=(r,s,a)=>r&&(e.getOppositeFaceColor(s)===a||e.getOppositeFaceColor(a)===s)?(new $e(r).apply(e),!0):!1,o=(r,s,a)=>r&&s===a?(new $e(r).apply(e),!0):!1;if(this.state!==T.UNDECIDED){const r=this.state===T.OUTSIDE;console.log("absolute",r?"outside":"inside");const s=r?e.getOutsideColor():e.getInsideColor();for(const a of this.primaryFaces){let c=a?e.getFaceColor(a):e.getOutsideColor();s!==c&&(t(a,c,s),c=a?e.getFaceColor(a):e.getOutsideColor(),new qe(oe(e,c),{type:"absolute",isOutside:r}).apply(e))}}else if(this.isAbsolute){console.log("absolute erase");for(const r of this.primaryFaces)r&&new We(r).apply(e)}else{if(console.log("normal"),this.primaryFaces.length&&this.secondaryFaces.length){const s=this.primaryFaces[0],a=this.secondaryFaces[0];let c=s?e.getFaceColor(s):e.getOutsideColor(),n=a?e.getFaceColor(a):e.getOutsideColor();o(a,c,n),c=s?e.getFaceColor(s):e.getOutsideColor(),n=a?e.getFaceColor(a):e.getOutsideColor(),new gt(oe(e,c),oe(e,n)).apply(e)}const r=s=>{for(let a=1;a<s.length;a++){const c=s[a-1],n=s[a];let l=c?e.getFaceColor(c):e.getOutsideColor(),d=n?e.getFaceColor(n):e.getOutsideColor();l!==d&&(t(n,l,d)&&(l=c?e.getFaceColor(c):e.getOutsideColor(),d=n?e.getFaceColor(n):e.getOutsideColor()),new qe(oe(e,l),oe(e,d)).apply(e))}};r(this.primaryFaces),r(this.secondaryFaces)}}getUndo(e){throw new Error("unimplemented")}isEmpty(){return(this.primaryFaces.length===0||this.state===T.UNDECIDED&&this.primaryFaces.length===1)&&this.secondaryFaces.length===0}serializeAction(){return{type:"UserFaceDragAction",primaryFaces:this.primaryFaces.map(e=>e?Ke(e):null),secondaryFaces:this.secondaryFaces.map(e=>e?Ke(e):null),isAbsolute:this.isAbsolute,state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new Qe(t.primaryFaces.map(o=>o?_e(e,o):null),t.secondaryFaces.map(o=>o?_e(e,o):null),t.isAbsolute,T.enumeration.getValue(t.state),t.dragIndex)}}class Es{constructor(e){this.hintAction=e}get annotation(){return this.hintAction.annotation}apply(e){this.hintAction.apply(e)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}const ms=i=>i instanceof Ko?{type:"PolygonGeneratorBoard",generator:i.generator.name,parameters:i.parameters}:i instanceof _o?{type:"SquareBoard",width:i.width,height:i.height}:i instanceof qo?{type:"HexagonalBoard",radius:i.radius,scale:i.scale,isPointyTop:i.isPointyTop,holeRadius:i.holeRadius}:{type:"BaseBoard",vertices:i.vertices.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vx:e.viewCoordinates.x,vy:e.viewCoordinates.y})),faces:i.faces.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vertices:e.vertices.map(t=>i.vertices.indexOf(t))}))},co=i=>({version:1,board:ms(i.board),state:i.stateProperty.value.serializeState(i.board)}),Ps=i=>{const e=co(i);return Jo(JSON.stringify(e))},vs=i=>{const e=co(i),t=i.solution.cleanState.serializeState(i.board),o=i.solution.solvedState.serializeState(i.board),r=[...i.solution.blackEdges].map(s=>i.board.edges.indexOf(s));return{puzzle:e,cleanState:t,solvedState:o,blackEdges:r}};function Fs(i){return new Worker(""+new URL("hintWorker-A_1u8by3.js",import.meta.url).href,{name:i==null?void 0:i.name})}let Te=null;const Ye=new h(!1),ho=()=>(Te||(Te=new Fs,Te==null||Te.addEventListener("message",i=>{i.data.type==="hint-worker-loaded"&&(Ye.value=!0)})),Te);ho();const Vs=new ge("uiHintUsesBuiltInSolve",!1),ra=new ge("showUndoRedoAllProperty",!1),Mt=new ge("dimCompletedNumbersProperty",!0),Bt=new ge("highlightIncorrectNumbersProperty",!0),sa=new ge("highlightIncorrectMovesProperty",!0),Ds=new ge("highlightIntersectionsProperty",!0),aa=new jo("highlightIncorrectMovesDelayProperty",.7);class ia extends Mo{constructor(t,o){const r=Ue()({style:_,initialTimeElapsed:0},o),s=r.style;super();g(this,"timeElapsedProperty",new h(0));g(this,"hintStateProperty",new h(ne.DEFAULT));g(this,"edgeAutoSolvedEmitter",new pe);g(this,"stack");g(this,"stackLengthProperty",new h(0));g(this,"stackPositionProperty",new h(0));g(this,"undoPossibleProperty");g(this,"redoPossibleProperty");g(this,"currentSnapshotProperty");g(this,"hasErrorProperty");g(this,"correctnessStateProperty");g(this,"isSolvedProperty");g(this,"hintWorkerMessageID",0);g(this,"addedHintListener",!1);g(this,"pendingHintActionProperty",new h(null));g(this,"displayedAnnotationProperty");g(this,"pendingActionFaceColorProperty",new h(null));g(this,"pendingActionSectorProperty",new h(null));g(this,"selectedFaceColorHighlightProperty");g(this,"selectedSectorEditProperty");g(this,"autoSolverFactoryProperty");g(this,"style");g(this,"lineDrag");g(this,"faceDrag");this.puzzle=t,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.lineDrag=new ys(t.board),this.faceDrag=new Cs(t.board),this.autoSolverFactoryProperty=new z([mr,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(n,l,d)=>n?d:l),this.displayedAnnotationProperty=new z([this.pendingHintActionProperty],n=>n?n.annotation:null);const a=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(a),Y.lazyLink(a),this.disposeEmitter.addListener(()=>Y.unlink(a)),this.selectedFaceColorHighlightProperty=new z([t.stateProperty,Y,this.pendingActionFaceColorProperty],(n,l,d)=>{if((l===L.FACE_COLOR_MATCH||l===L.FACE_COLOR_OPPOSITE)&&d){const u=n.getFacesWithColor(d.color);return{faceColor:d.color,face:d.face,faces:u}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new z([t.stateProperty,Y,this.pendingActionSectorProperty],(n,l,d)=>l===L.SECTOR_STATE&&d?{sector:d,currentState:n.getSectorState(d)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const n=t.stateProperty.value.clone();xt(t.board,n,this.style.safeSolverFactoryProperty.value),t.stateProperty.value=n}this.stack=[this.getSnapshot(null,t.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new z([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new z([this.currentSnapshotProperty],n=>!n.correctnessState.isCorrect()),this.correctnessStateProperty=new z([this.currentSnapshotProperty],n=>n.correctnessState),this.isSolvedProperty=new z([this.currentSnapshotProperty],n=>{if(n.state.getWeirdEdges().length||n.state.hasInvalidFaceColors())return!1;const l=n.state.getSimpleRegions();return l.length===1&&l[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new z([this.stackPositionProperty],n=>n>0),this.redoPossibleProperty=new z([this.stackPositionProperty,this.stackLengthProperty],(n,l)=>n<l-1);const c=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(c),this.style.safeSolverFactoryProperty.lazyLink(c),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(c),this.style.safeSolverFactoryProperty.unlink(c)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(t){this.isSolvedProperty.value||(this.timeElapsedProperty.value+=Math.min(t,5),localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value)))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",Ps(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(t){this.wipeStackTop(),this.stack.push(t),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(t,o){const r=(o==null?void 0:o.forceDirty)||t instanceof rt;let a=this.stack[this.stackPositionProperty.value].state;o!=null&&o.erase&&(a=a.clone(),o.erase(a));let c=new Set;const n=u=>{c.add(u)};let l=a.createDelta();try{if(l.edgeStateChangedEmitter.addListener(n),bt(this.autoSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(n),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(l)))throw new st("Auto-solver did not respect user action")}catch(u){if(c=new Set,u instanceof ee||u instanceof st)u instanceof ee?console.log("error"):u instanceof st&&console.log("skipping autosolve due to undo"),l=a.createDelta(),l.edgeStateChangedEmitter.addListener(n),bt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(n);else throw u}const d=a.clone();l.apply(d),this.pushTransitionAtCurrentPosition(this.getSnapshot(t,d));for(const u of c)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(u))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(u))}computeCorrectnessState(t=this.puzzle.stateProperty.value){return Yr.getCorrectnessState(this.puzzle.board,t,this.puzzle.solution.solvedState)}getSnapshot(t,o){return new Ts(this.puzzle.board,t,o,this.computeCorrectnessState(o))}addAutoSolveDelta(){const t=this.puzzle.stateProperty.value.createDelta();try{if(Je(this.autoSolverFactoryProperty.value,this.puzzle.board,t,!0),!t.isEmpty()){const o=this.puzzle.stateProperty.value.clone();t.apply(o),this.pushTransitionAtCurrentPosition(this.getSnapshot(new rt,o))}}catch(o){if(!(o instanceof ee))throw o}}onAutoSolveChange(){const t=this.stack[this.stackPositionProperty.value];t.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(t.action||new rt,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(t,o,r){r&&(o=2-o);const s=ze.value.edgePressStyles[o];return console.log(ze.value,s,o,t),s.apply(t)}getNewFaceColorState(t,o,r){r&&(o=2-o);const s=ze.value.faceColorPressStyles[o];return console.log(ze.value,s,o,t),s.apply(t)}getNextEdgeState(t,o){const r=He.value,s=this.puzzle.stateProperty.value.getEdgeState(t);return r?v.WHITE:this.getNewEdgeState(s,o,Y.value===L.EDGE_STATE_REVERSED)}getNextFaceColorState(t,o){const r=this.puzzle.stateProperty.value.getOutsideColor(),s=this.puzzle.stateProperty.value.getInsideColor(),a=this.puzzle.stateProperty.value.getFaceColor(t),c=a===r?T.OUTSIDE:a===s?T.INSIDE:T.UNDECIDED;return this.getNewFaceColorState(c,o,Y.value===L.FACE_COLOR_OUTSIDE)}onUserEdgePress(t,o){const r=this.puzzle.stateProperty.value.getEdgeState(t),s=this.getNextEdgeState(t,o);if(r!==s){const a=this.stack[this.stackPositionProperty.value];a.action&&a.action instanceof Dt&&a.action.edge===t&&this.stackPositionProperty.value--;let c;r!==v.WHITE&&(c=l=>{new Be(t).apply(l)});const n=new Dt(t,s);this.applyUserActionToStack(n,{erase:c,checkAutoSolve:l=>l.getEdgeState(t)===s,excludedEdges:new Set([t])}),this.updateState()}}onUserEdgeDragStart(t,o){if(this.lineDrag.lineDragStateProperty.value!==ae.NONE)return;const r=this.getNextEdgeState(t,o);r===v.BLACK?this.lineDrag.onLineDragStart(t):this.lineDrag.onPaintDragStart(t,r),this.updateEdgeDrag()}onUserEdgeDrag(t,o){this.lineDrag.onDrag(t,o)&&this.updateEdgeDrag()}onUserEdgeDragEnd(){this.lineDrag.onDragEnd()}updateEdgeDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof Ze&&(t.action.dragIndex===this.lineDrag.dragIndex||t.action.firstEdge===this.lineDrag.firstEdge)&&this.stackPositionProperty.value--,O()&&A(this.lineDrag.lineDragStateProperty.value!==ae.NONE,"line drag state should not be NONE");const o=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?this.lineDrag.edgeStack.slice():Array.from(this.lineDrag.paintEdgeSet),r=this.lineDrag.lineDragStateProperty.value===ae.LINE_DRAG?v.BLACK:this.lineDrag.paintEdgeState,s=o.filter(n=>this.puzzle.stateProperty.value.getEdgeState(n)!==v.WHITE),a=new rr(s.map(n=>new Be(n))),c=new Ze(this.lineDrag.firstEdge,o,r,this.lineDrag.dragIndex);this.applyUserActionToStack(c,{erase:n=>a.apply(n),checkAutoSolve:n=>o.every(l=>n.getEdgeState(l)===r),excludedEdges:new Set(this.puzzle.board.edges)}),this.updateState()}onUserFacePress(t,o){const r=He.value,s=Y.value;if(r){if(t){const a=new We(t);this.applyUserActionToStack(a,{erase:c=>a.apply(c)}),this.updateState()}}else if(s===L.FACE_COLOR_MATCH||s===L.FACE_COLOR_OPPOSITE){let a=Y.value===L.FACE_COLOR_MATCH;o===2&&(a=!a);const c=t?this.puzzle.stateProperty.value.getFaceColor(t):this.puzzle.stateProperty.value.getOutsideColor(),n=this.pendingActionFaceColorProperty.value;if(n){if(t!==n.face){const l=n.color;l!==c&&(a?this.applyUserActionToStack(new qe(oe(this.puzzle.stateProperty.value,c),oe(this.puzzle.stateProperty.value,l))):this.applyUserActionToStack(new gt(oe(this.puzzle.stateProperty.value,c),oe(this.puzzle.stateProperty.value,l))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:t,color:c}}else if((s===L.FACE_COLOR_OUTSIDE||s===L.FACE_COLOR_INSIDE)&&t){const a=this.puzzle.stateProperty.value.getOutsideColor(),c=this.puzzle.stateProperty.value.getInsideColor(),n=this.puzzle.stateProperty.value.getFaceColor(t),l=n===a?T.OUTSIDE:n===c?T.INSIDE:T.UNDECIDED,d=this.getNewFaceColorState(l,o,s===L.FACE_COLOR_OUTSIDE);if(l!==d){const u=this.stack[this.stackPositionProperty.value];u.action&&u.action instanceof Tt&&u.action.face===t&&this.stackPositionProperty.value--;let w;const C=new We(t);l!==T.UNDECIDED&&(w=f=>{C.apply(f)}),d===T.UNDECIDED?this.applyUserActionToStack(C,{erase:w}):this.applyUserActionToStack(new Tt(t,d===T.INSIDE),{erase:w}),this.updateState()}}}onUserFaceDragStart(t,o){if(this.faceDrag.faceDragStateProperty.value!==Z.NONE)return;const r=Y.value;if(He.value)this.faceDrag.onAbsolutePaintStart(t,T.UNDECIDED);else if(r===L.FACE_COLOR_MATCH||r===L.FACE_COLOR_OPPOSITE)r===L.FACE_COLOR_MATCH==(o===0)?this.faceDrag.onMakeSameStart(t):this.faceDrag.onMakeOppositeStart(t);else if(r===L.FACE_COLOR_INSIDE||r===L.FACE_COLOR_OUTSIDE){const s=t?this.getNextFaceColorState(t,o):L.FACE_COLOR_OUTSIDE;this.faceDrag.onAbsolutePaintStart(t,s)}this.updateFaceDrag()}onUserFaceDrag(t,o){this.faceDrag.onDrag(t,o)&&this.updateFaceDrag()}onUserFaceDragEnd(){if(this.faceDrag.isNoOpSingleFace()){const t=Y.value===L.FACE_COLOR_MATCH==(this.faceDrag.faceDragStateProperty.value===Z.MAKE_SAME);this.onUserFacePress([...this.faceDrag.paintFaceSet][0],t?0:2)}this.faceDrag.onDragEnd()}updateFaceDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof Qe&&t.action.dragIndex===this.faceDrag.dragIndex&&this.stackPositionProperty.value--;const o=this.faceDrag.faceDragStateProperty.value;if(O()&&A(o!==Z.NONE,"line drag state should not be NONE"),this.faceDrag.isNoOpSingleFace())return;const r=[...this.faceDrag.paintFaceSet],s=o===Z.MAKE_OPPOSITE?[...this.faceDrag.paintFaceOppositeSet]:[],a=this.faceDrag.absolutePaintState,c=o===Z.ABSOLUTE_PAINT,n=new Qe(r,s,c,a,this.faceDrag.dragIndex);this.applyUserActionToStack(n,{checkAutoSolve:l=>{if(r.length){const d=r[0]?l.getFaceColor(r[0]):l.getOutsideColor();if(r.some(u=>(u?l.getFaceColor(u):l.getOutsideColor())!==d))return!1;if(s.length){const u=s[0]?l.getFaceColor(s[0]):l.getOutsideColor();if(s.some(w=>(w?l.getFaceColor(w):l.getOutsideColor())!==u)||l.getOppositeFaceColor(d)!==u)return!1}}return!0}}),this.updateState()}onUserSectorPress(t,o){if(He.value){const s=new St(t);this.applyUserActionToStack(s,{erase:a=>s.apply(a)}),this.updateState()}else this.pendingActionSectorProperty.value=t}onUserSectorSet(t,o){this.applyUserActionToStack(new sr(t,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const t=this.puzzle.stateProperty.value;if(!ar(t))if(Vs.value){const o=t.clone();Je(Xr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Ot,o)),this.updateState()}else{const o=Pr(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,v.BLACK)}),xt(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Ot,r)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=ne.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(t){this.hintStateProperty.value=t?ne.FOUND:ne.NOT_FOUND,t&&(this.pendingHintActionProperty.value=t)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const t=_.allowEdgeEditProperty.value,o=_.allowFaceColorEditProperty.value,r=_.allowSectorEditProperty.value,s=_.vertexStateVisibleProperty.value,a=_.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const c=ho();if(!this.addedHintListener){this.addedHintListener=!0;const n=l=>{if(l.data.type==="hint-response"&&l.data.id===this.hintWorkerMessageID){const d=l.data.action?ir(this.puzzle.board,l.data.action):null;this.onHintReceived(d)}};c.addEventListener("message",n),this.disposeEmitter.addListener(()=>self.removeEventListener("message",n))}if(c.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:t,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:a,serializedSolvablePuzzle:vs(this.puzzle)}),Ye.value)this.hintStateProperty.value=ne.SEARCHING;else{this.hintStateProperty.value=ne.LOADING;const n=l=>{l&&(this.hintStateProperty.value===ne.LOADING&&(this.hintStateProperty.value=ne.SEARCHING),Ye.unlink(n))};Ye.link(n)}}onUserApplyHint(){const t=this.pendingHintActionProperty.value;t&&(this.clearPendingHint(),this.applyUserActionToStack(new Es(t)),this.updateState())}}class Ts{constructor(e,t,o,r){this.board=e,this.action=t,this.state=o,this.correctnessState=r}}class Os extends k{constructor(e,t,o,r){super({pickable:!1}),this.board=e;const s=e.faces.map(l=>null),a=()=>{const l=[],d=o.faceValueStyleProperty.value,u=o.theme.faceValueColorProperty.value,w=o.theme.faceValueCompletedColorProperty.value,C=o.theme.faceValueErrorColorProperty.value,f=o.theme.faceValueRatioColorProperty.value,p=o.faceStateVisibleProperty.value,S=Mt.value,y=Bt.value;this.visible=!p;for(let E=0;E<e.faces.length;E++){const m=s[E];if(m!==null){const P=e.faces[E],R=new Uo("",Ht({subScale:.7},r==null?void 0:r.textOptions)),F=Se.multilink([t],V=>{let D,I,x=!1,q=!1;if(m===null)D="",I=null;else{let M=0,W=0;for(const b of P.edges){const G=V.getEdgeState(b);G===v.BLACK?M++:G===v.WHITE&&W++}if(d==="static"||m===0)D=`${m}`;else if(d==="remaining")D=`${m-M}`,x=M>0;else if(d==="ratio")m-M===0?D="0":(D=`${m-M}<sub style="color: ${f.toCSS()};">/<sub>${W}</sub></sub>`,q=!0),x=M>0;else throw new Error(`unhandled faceValueStyle: ${d}`);M>m&&y?I=C:M===m&&S?I=w:I=u}R.string=D,R.fill=I,R.maxWidth=q?.8:.9,R.maxHeight=q?.8:.9,R.center=P.viewCoordinates});R.disposeEmitter.addListener(()=>F.dispose()),l.push(R)}}this.children.forEach(E=>E.dispose()),this.children=l},c=Se.multilink([t],l=>{let d=!1;for(let u=0;u<e.faces.length;u++){const w=l.getFaceValue(e.faces[u]);w!==s[u]&&(d=!0,s[u]=w)}d&&a()}),n=Se.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,Mt,Bt],a);this.disposeEmitter.addListener(()=>{c.dispose(),n.dispose(),this.children.forEach(l=>l.dispose())})}}const As=(i,e,t)=>{const o=new ke({mouseButton:0,fire:a=>{var c;return e&&e((c=a.domEvent)!=null&&c.shiftKey?2:0)}}),r=new ke({mouseButton:2,fire:a=>{var c;return e&&e((c=a.domEvent)!=null&&c.shiftKey?0:2)}}),s=new ke({mouseButton:1,fire:a=>e&&e(1)});i.addInputListener({down:a=>{so.value===Me.DRAG_ONLY&&t&&t(a)}}),i.addInputListener(o),i.addInputListener(r),i.addInputListener(s),i.cursor="pointer",i.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class tt extends k{constructor(e,t,o,r){const s=Ue()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceBackgroundDragStartListener:()=>{},noninteractive:!1},r);super({pickableProperty:wt}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!s.noninteractive&&As(this,f=>s.facePressListener(null,f),s.faceBackgroundDragStartListener);const a=e.map(f=>f.start.viewCoordinates),c=s.useBackgroundOffsetStroke,n=s.backgroundOffsetDistance,d=Vt(a)>0?-n:n,u=f=>{const p=new Ho;p.addShape(0,f),p.computeSimplifiedFaces(),p.computeFaceInclusion(E=>E[0]>0);const S=p.createFilledSubGraph(),y=S.facesToShape();return p.dispose(),S.dispose(),y},w=tt.getOffsetBackgroundShape(e,c,n),C=t.map(f=>{const p=f.map(y=>y.start.viewCoordinates),S=B.polygon(p);if(c)return u(S.getOffsetShape(d));{const E=S.getStrokedShape(new Ft({lineWidth:2*n})).subpaths.map(m=>new B([m]));return u(Xe.minBy(E,m=>m.getArea()))}});this.children=[new X(w,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...C.map(f=>new X(f,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const r=e.map(n=>n.start.viewCoordinates),s=B.polygon(r),c=Vt(r)>0?-o:o;if(t)return s.getOffsetShape(c).getSimplifiedAreaShape();{const n=s.getStrokedShape(new Ft({lineWidth:2*o})),l=n.subpaths.map(d=>new B([d]));try{return n.bounds.width===9.718028227819117?B.bounds(n.bounds):Xe.maxBy(l,d=>d.getArea()).getSimplifiedAreaShape()}catch{return B.bounds(n.bounds)}}}}class fe extends k{static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,a=o.minus(r),c=s.minus(r),n=a.normalized(),d=c.normalized().minus(n).angle+Math.PI/2,u=e.face?e.face.viewCoordinates:J.createPolar(t,d).plus(r),w=o.average(r),C=s.average(r);return B.polygon([w,r,C,u]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,a=o.minus(r),c=s.minus(r),n=a.normalized(),l=a.angle;let d=c.angle;return d<l&&(d+=2*Math.PI),new B().moveToPoint(r).lineToPoint(n.timesScalar(t).plus(r)).arcPoint(r,t,l,d,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===N.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===N.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===N.NOT_ONE?t.theme.sectorNotOneColorProperty:e===N.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}}g(fe,"nameMap",new Map([[N.NONE,"Invalid"],[N.ONLY_ZERO,"No Lines"],[N.ONLY_ONE,"Only One Line"],[N.ONLY_TWO,"Both Lines"],[N.NOT_ZERO,"At Least One Line"],[N.NOT_ONE,"Zero or Two Lines"],[N.NOT_TWO,"Less Than Two Lines"],[N.ANY,"Any Lines"]]));class bs extends ft{constructor(e,t){super(e.halfEdges,o=>fe.getSectorBaseShape(o,t.backgroundOffsetDistance),t.sectorPressListener)}}const Wt=[.02,.02],Oe=.2,Ge=.02;class Is extends k{constructor(e,t,o){const r=new X(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ZERO,o)}),s=new X(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_ONE,o)}),a=new X(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.NOT_TWO,o)}),c=new X(null,{lineWidth:.025,lineCap:"butt",stroke:fe.getStrokeFromStyle(N.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,a,c]}),this.board=e;const n=e.halfEdges.map(u=>N.NONE),l=e.edges.map(u=>v.BLACK),d=Se.multilink([t,o.sectorsVisibleProperty],(u,w)=>{if(w){let C=!1;for(let f=0;f<e.halfEdges.length;f++){const p=u.getSectorState(e.halfEdges[f]);p!==n[f]&&(C=!0,n[f]=p)}for(let f=0;f<e.edges.length;f++){const p=u.getEdgeState(e.edges[f]);p!==l[f]&&(C=!0,l[f]=p)}if(C){const f=new B,p=new B,S=new B,y=new B;for(let E=0;E<e.halfEdges.length;E++){const m=n[E];if(m!==N.NOT_ZERO&&m!==N.NOT_ONE&&m!==N.NOT_TWO&&m!==N.ONLY_ONE)continue;const P=e.halfEdges[E],R=u.getEdgeState(P.edge),F=u.getEdgeState(P.next.edge);if(R!==v.WHITE||F!==v.WHITE)continue;if(m===N.NOT_ONE){const K=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.BLACK),te=P.end.edges.filter(ie=>u.getEdgeState(ie)===v.WHITE);if(K.length===0&&te.length===2)continue}const V=P.start.viewCoordinates,D=P.end.viewCoordinates,I=P.next.end.viewCoordinates,x=V.minus(D),q=I.minus(D),M=x.normalized(),W=x.angle;let b=q.angle;b<W&&(b+=2*Math.PI);const G=(K,te)=>(K.moveToPoint(M.timesScalar(te).add(D)),K.arcPoint(D,te,W,b,!0),K);if(m===N.ONLY_ONE)G(y,Oe);else if(m===N.NOT_ONE)G(p,Oe-Ge),G(p,Oe+Ge);else if(m===N.NOT_ZERO){const K=new B;G(K,Oe-Ge),G(K,Oe+Ge);const te=K.getDashedShape(Wt,0);f.subpaths.push(...te.subpaths)}else if(m===N.NOT_TWO){const K=new B;G(K,Oe);const te=K.getDashedShape(Wt,0);S.subpaths.push(...te.subpaths)}}r.shape=f.makeImmutable(),s.shape=p.makeImmutable(),a.shape=S.makeImmutable(),c.shape=y.makeImmutable()}}});this.disposeEmitter.addListener(()=>d.dispose())}}class Ns extends k{constructor(e,t,o,r){let s=[];try{let a=new B;for(const n of e.faces)a.polygon(n.vertices.map(l=>l.viewCoordinates));if(e.faceColor.colorState===T.OUTSIDE)try{const n=B.polygon(t.outerBoundary.map(u=>u.start.viewCoordinates)),d=tt.getOffsetBackgroundShape(t.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(n);a=a.bounds.isValid()?a.shapeUnion(d):d}catch(n){console.error(n)}const c=new X(a.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(c)}catch(a){console.error(a)}super({children:s}),this.selectedFaceColorHighlight=e}}class ks extends k{constructor(e,t,o,r){const s=[],a=[],c=e.sector,n=e.currentState,l=fe.getSectorArcShape(c,.5),d=new X(l.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(d);const u=[];if(n===N.ANY&&(u.push(N.NOT_ZERO),u.push(N.NOT_ONE),u.push(N.NOT_TWO)),n.one&&n!==N.ONLY_ONE&&u.push(N.ONLY_ONE),u.length){const w=u.map(p=>{const S=fe.getStrokeFromStyle(p,o);return new Xo({accessibleName:fe.nameMap.get(p),content:new zo(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(c,p)},buttonAppearanceStrategy:xo,baseColor:S,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});a.push(...w);const C=new jt(new Yt({children:w,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});a.push(C);const f=.1;s.push(C),C.centerBottom=d.centerTop.plusXY(0,-.15),C.top<t.top+f&&(C.centerTop=d.centerBottom.plusXY(0,.15)),C.left<t.left+f&&(C.left=t.left+f),C.right>t.right-f&&(C.right=t.right-f)}super({children:s}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{a.forEach(w=>w.dispose())})}}class Ls extends k{constructor(t,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});g(this,"simpleRegionNodeMap",new Map);g(this,"regionIdMap",new Map);g(this,"weirdEdgeNodeMap",new Map);g(this,"regionContainer",new k);g(this,"weirdEdgeContainer",new k);g(this,"adjacentFacesMap",new Map);g(this,"weirdEdgeColorProperty");this.board=t,this.style=r,this.weirdEdgeColorProperty=new z([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,Ds],(c,n,l)=>l?c:n),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),t.faces.forEach(c=>{this.adjacentFacesMap.set(c,c.edges.map(n=>n.getOtherFace(c)).filter(n=>n!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(c=>this.addRegion(c)),o.value.getWeirdEdges().forEach(c=>this.addWeirdEdge(c)),this.updateHues();const s=(c,n)=>{const l=n.getSimpleRegions(),d=c.getSimpleRegions(),u=n.getWeirdEdges(),w=c.getWeirdEdges(),C=[],f=[];Xt(l,d,C,f,[]);const S=new Set(C);for(const y of f)if(this.regionIdMap.has(y.id)){const E=this.regionIdMap.get(y.id);this.replaceRegion(E,y),S.delete(E)}else this.addRegion(y);for(const y of S)this.removeRegion(y);for(const y of u)w.includes(y)||this.removeWeirdEdge(y);for(const y of w)u.includes(y)||this.addWeirdEdge(y);(f.length||C.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const a=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(a),r.edgesHaveColorsProperty.lazyLink(a),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(a),r.edgesHaveColorsProperty.unlink(a)})}addRegion(t){const o=new Ie(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){O()&&A(t.id===o.id);const r=this.simpleRegionNodeMap.get(t);r.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=new Go(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const a=c=>{s.lineCap=c};this.style.joinedLinesCapProperty.link(a),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(a))}this.weirdEdgeNodeMap.set(t,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(t){this.weirdEdgeNodeMap.get(t).dispose(),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new J(0,0),r=()=>{for(const d of t)d.hueVector.getMagnitude()>1e-6?d.hueVector.normalize():d.hueVector.setXY(1,0)},s=new Map,a=[];this.board.faces.forEach(d=>{s.set(d,[])});for(const d of t){const u=new Set;for(const C of d.simpleRegion.edges)for(const f of C.faces)u.add(f);const w=new Set;for(const C of u){w.add(C);for(const f of this.adjacentFacesMap.get(C))w.add(f)}for(const C of w){const f=s.get(C);if(f.length)for(const p of f){let S=!1;for(const y of a)if(y.a===p&&y.b===d){y.weight++,S=!0;break}S||a.push({a:p,b:d,weight:1})}f.push(d)}}const c=new Map;for(const d of t)c.set(d,J.ZERO.copy());const n=(d,u,w)=>{const C=c.get(d),f=c.get(u),p=d.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(d.hueVector);if(S.magnitude>1e-9){S.normalize();const y=.3,E=w*((Math.max(y,p)-y)/(1-y))**3;S.multiplyScalar(E),C.subtract(S),f.add(S)}};let l=1;for(let d=0;d<100;d++){l*=.99;for(const u of t)c.get(u).setXY(0,0);for(const u of a){const w=u.a,C=u.b,f=u.weight;n(w,C,f)}if(t.length<8)for(let u=0;u<t.length;u++){const w=t[u];for(let C=u+1;C<t.length;C++)n(w,t[C],.2)}for(const u of t){const w=c.get(u);w.multiplyScalar(l/u.edgeCount),u.hueVector.add(w),c.get(u).setXY(0,0)}r()}for(const d of t)d.updateHue()}}class Ie extends X{constructor(t,o){const r=J.createPolar(1,je.nextDoubleBetween(0,2*Math.PI));super(Ie.toShape(t),{stroke:Ie.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});g(this,"hueVector");g(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=r,this.edgeCount=t.edges.length;const s=c=>{this.lineJoin=c};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const a=c=>{this.lineCap=c};o.joinedLinesCapProperty.link(a),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(a))}updateHue(){this.stroke=Ie.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:J.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=Ie.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return O()&&A(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(t){const o=new B;let r=!0;for(const s of t.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class xs extends k{constructor(e,t,o){super({pickable:!1}),this.vertex=e;const r=.12,a=e.edges.map(C=>C.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(C=>C.times(r)),n=B.polygon(Bo.grahamScan([J.ZERO,...a],!1)).getOffsetShape(-.05),l=new X(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),d=new X(n,{translation:e.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[l,...a.map(C=>new Gt({radius:.02,translation:C,fill:o.theme.vertexStatePointProperty}))]});let u=null;const w=Se.multilink([t,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(C,f,p)=>{const S=()=>{this.children=[]};if(!f){S();return}const y=C.getVertexState(e);if(!p){let E=!1,m=!1;const P=new Set;for(const F of e.edges){const V=C.getEdgeState(F);E=E||V===v.BLACK,m=m||V===v.WHITE,V===v.WHITE&&P.add(F)}if(E||!m){S();return}if(pt.fromLookup(e,(F,V)=>P.has(F)&&P.has(V),!0).equals(y)){S();return}}if(!u||!u.equals(y)){u=y;const E=new B;for(const m of y.getAllowedPairs()){const P=R=>R.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(r);E.moveToPoint(P(m[0])),E.lineToPoint(P(m[1]))}y.allowsEmpty()&&(E.moveTo(.03,0),E.circle(J.ZERO,.03),E.close()),E.makeImmutable(),l.shape=E}this.children=[d]});this.disposeEmitter.addListener(()=>w.dispose())}}class Rs extends k{constructor(e,t,o,r){super({pickable:!1});const s=Se.multilink([t,r.vertexStateVisibleProperty],(c,n)=>{this.children.forEach(l=>l.dispose()),this.children=[],n&&e.vertices.forEach(l=>{this.addChild(new xs(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const a=c=>{this.visible=!c};o.link(a),this.disposeEmitter.addListener(()=>{o.unlink(a),this.children.forEach(c=>c.dispose())})}}const Ms=.03,Bs=.05;class Ws extends X{constructor(e,t,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=e.edges.map(l=>v.BLACK);let a=r.vertexStyleProperty.value,c=r.smallVertexProperty.value;const n=Se.multilink([t,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(l,d,u,w,C)=>{if(this.visible=!d&&u,this.visible){let f=!1;for(let p=0;p<e.edges.length;p++){const S=l.getEdgeState(e.edges[p]);S!==s[p]&&(f=!0,s[p]=S)}if(a!==w&&(a=w,f=!0),c!==C&&(c=C,f=!0),f){const p=new B;for(let S=0;S<e.vertices.length;S++){const y=e.vertices[S];if(y.edges.every(E=>l.getEdgeState(E)!==v.BLACK)){const E=y.viewCoordinates,m=C?Ms:Bs;w==="round"?(p.moveTo(E.x+m,E.y),p.arc(E.x,E.y,m,0,2*Math.PI,!1)):w==="square"?p.rect(E.x-m,E.y-m,2*m,2*m):O()&&A(!1,`unhandled vertex style: ${w}`)}}this.shape=p}}});this.disposeEmitter.addListener(()=>n.dispose())}}class Ut extends k{constructor(t,o){const r=Ue()({textOptions:{font:ht,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},onEdgeDragStart:()=>{},onEdgeDrag:()=>{},onEdgeDragEnd:()=>{},facePressListener:()=>{},faceBackgroundDragStartListener:V=>this.onFaceBackgroundDragStart(V),onFaceDragStart:()=>{},onFaceDrag:()=>{},onFaceDragEnd:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Re(null),selectedSectorEditProperty:new Re(null),style:_,noninteractive:!1,delayEdgeInteractionEmitter:new pe},o),s=r.style,a=new k({visibleProperty:s.faceColorsVisibleProperty}),c=new k({pickableProperty:ws}),n=new k({pickableProperty:fs}),l=new k({pickableProperty:ps}),d=new k({pickableProperty:Ss}),u=new k,w=new k({pickable:!1}),C=new k({pickable:!1}),f=new k({renderer:Zo.chromium?"canvas":null,pickable:null}),p=new k({pickable:!1}),S=new k,y=new z([t.stateProperty],V=>{if(V.getWeirdEdges().length||V.hasInvalidFaceColors())return!1;const D=V.getSimpleRegions();return D.length===1&&D[0].isSolved}),E=V=>{V?a.addChild(new xr(t.board,t.stateProperty,s)):a.children.forEach(D=>D.dispose())};s.faceColorsVisibleProperty.link(E),c.addChild(new Os(t.board,t.stateProperty,s,r));let m=null;r.noninteractive||(m=new Wr(t.board,r),c.addChild(m)),C.addChild(new Br(t.board,t.stateProperty,y,s));const P=new tt(t.board.outerBoundary,t.board.innerBoundaries,s,r);d.addChild(new Ws(t.board,t.stateProperty,y,s)),w.addChild(new Rs(t.board,t.stateProperty,y,s)),l.addChild(new Lr(t.board,t.stateProperty,y,s)),r.noninteractive||l.addChild(new kr(t.board,r.delayEdgeInteractionEmitter,r)),n.addChild(new Is(t.board,t.stateProperty,s)),r.noninteractive||n.addChild(new bs(t.board,r)),u.addChild(new Ls(t.board,t.stateProperty,s));super(Ht({children:[P,a,c,n,l,d,u,w,C,p,S,f]},r));g(this,"annotationContainer");g(this,"backgroundNode");g(this,"onFaceBackgroundDragStart");this.puzzle=t,m?this.onFaceBackgroundDragStart=V=>{var D;return(D=m.triggerDrag)==null?void 0:D.call(m,V)}:this.onFaceBackgroundDragStart=()=>{},this.annotationContainer=f;const R=V=>{p.children.forEach(D=>D.dispose()),V&&p.addChild(new Ns(V,t.board,s,r))};r.selectedFaceColorHighlightProperty.link(R),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(R));const F=V=>{S.children.forEach(D=>D.dispose()),V&&S.addChild(new ks(V,P,s,r))};r.selectedSectorEditProperty.link(F),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(F)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(E),[a,c,l,d,u,w,C,n].forEach(D=>{D.children.forEach(I=>I.dispose()),D.dispose()}),y.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class na extends k{constructor(e,t,o){const r=Ue()({style:_},o),s=t.getEmbeddedCompleteData(e.inputFeatureSet),a=t.getEmbeddedCompleteData(e.outputFeatureSet),c=new Ut(new At(t.smallBoard,s),{noninteractive:!0,style:r.style}),n=new Ut(new At(t.smallBoard,a),{noninteractive:!0,style:r.style}),l=e.highlander?new k({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(y=>new zt("?",{font:ht,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:y.viewCoordinates}))}):new k,u=t.tightBounds.dilated(.5),w=.5,C=B.roundRectangle(u.x,u.y,u.width,u.height,w,w),f=new k({children:[c,l],clipArea:C,localBounds:u}),p=new k({children:[n,l],clipArea:C,localBounds:u}),S=new jt(new Yt({spacing:.2,children:[f,new Fr(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),p]}),{cornerRadius:w*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[S],super(r),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{c.dispose(),n.dispose()})}}const Us=(i,e)=>{Je(vr,i,e,!0)};class Ae{constructor(e,t,o,r,s,a,c,n,l,d){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=a,this.toSmallEdgeMap=c,this.toSmallSectorMap=n,this.tightBounds=l,this.expandedBounds=d}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const r=this.toSmallFaceMap.get(o);return O()&&A(r),r}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return O()&&A(s),s})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),r=this.toSmallSectorMap.get(o);return O()&&A(r),r}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&t.add(r)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=nr.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof Vr)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof Dr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,v.BLACK));else if(o instanceof Tr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,v.RED));else if(o instanceof Or)t.setSectorState(this.mapSector(o.sector),N.NOT_ZERO);else if(o instanceof Ar)t.setSectorState(this.mapSector(o.sector),N.NOT_ONE);else if(o instanceof br)t.setSectorState(this.mapSector(o.sector),N.NOT_TWO);else if(o instanceof Ir)t.setSectorState(this.mapSector(o.sector),N.ONLY_ONE);else if(o instanceof Nr){const r=(a,c)=>{const n=this.mapFace(a),l=this.mapFace(c),d=n?t.getFaceColor(n):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new qe(oe(t,d),oe(t,u)).apply(t)},s=(a,c)=>{const n=this.mapFace(a),l=this.mapFace(c),d=n?t.getFaceColor(n):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new gt(oe(t,d),oe(t,u)).apply(t)};for(let a=1;a<o.primaryFaces.length;a++)r(o.primaryFaces[a-1],o.primaryFaces[a]);for(let a=1;a<o.secondaryFaces.length;a++)r(o.secondaryFaces[a-1],o.secondaryFaces[a]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return Us(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o,r){const s=ot.NOTHING.copy(),a=n=>{s.addPoint(t.getVertex(o.mapVertex(n)).viewCoordinates)};e.vertices.forEach(a);const c=n=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(n))return;const l=t.getFace(o.mapFace(n));l&&l.vertices.forEach(d=>s.addPoint(d.viewCoordinates))};return e.faces.forEach(c),e.edges.forEach(n=>{let l;if(n.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(n))return;l=o.mapExitEdges(n).map(d=>t.getEdge(d))}else l=[t.getEdge(o.mapNonExitEdge(n))];l.forEach(d=>{s.addPoint(d.start.viewCoordinates),s.addPoint(d.end.viewCoordinates)})}),s}static findBestEmbedding(e,t,o){const r=$o(e,t);if(r.length===0)return null;const s=ot.NOTHING.copy();o.vertices.forEach(l=>s.addPoint(l.viewCoordinates));const a=s.center;let c=null,n=Number.POSITIVE_INFINITY;for(let l=0;l<r.length;l++){const d=r[l],w=Ae.getEmbeddingBounds(e,t,d).center,C=a.distance(w);C<n&&(n=C,c=d)}return c}static getDisplayEmbedding(e,t,o,r,s){const a=Ae.getEmbeddingBounds(e,t,r,s),c=a.dilated(.5),n=o.faces.filter(S=>{const y=ot.NOTHING.copy();return S.vertices.forEach(E=>y.addPoint(E.viewCoordinates)),c.intersectsBounds(y)}),l=o.vertices.filter(S=>S.faces.some(y=>n.includes(y))),d=Qo({vertices:l.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates})),faces:n.map(S=>({logicalCoordinates:S.logicalCoordinates,vertices:S.vertices.map(y=>({logicalCoordinates:y.logicalCoordinates,viewCoordinates:y.viewCoordinates}))}))}),u=new er(d),w=1e-6,C=new Map(n.map((S,y)=>{const E=u.faces.find(m=>m.viewCoordinates.equalsEpsilon(S.viewCoordinates,w));return O()&&A(E),[S,E]})),f=new Map(o.edges.map(S=>{const y=u.edges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w)||E.start.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w))??null;return y?[S,y]:null}).filter(S=>S!==null)),p=new Map(o.halfEdges.map(S=>{const y=u.halfEdges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,w)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,w))??null;return y?[S,y]:null}).filter(S=>S!==null));return O()&&A(r),new Ae(e,t,o,r,u,C,f,p,a,c)}static getOptionsForRule(e){const t=e.outputFeatureSet.getAffectedFaces(),o=e.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>t.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(e,t,o){return Ae.getDisplayEmbedding(e.patternBoard,t,t.board,o,Ae.getOptionsForRule(e))}}export{Vs as A,Xr as B,Us as C,Y as D,na as E,Mr as F,L as G,He as H,so as I,Me as J,Ps as K,ne as L,aa as M,oa as N,As as O,Ut as P,_ as Q,ta as R,dt as S,hs as T,Rr as U,xs as V,Ae as W,Yr as X,Zs as a,Jr as b,Zr as c,$r as d,ts as e,ia as f,Qr as g,lo as h,ss as i,as as j,is as k,ns as l,ls as m,ds as n,Kr as o,us as p,Mt as q,Bt as r,ea as s,sa as t,Ds as u,cs as v,ze as w,$s as x,Qs as y,ra as z};
