var De=Object.defineProperty;var Ie=(m,e,t)=>e in m?De(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t;var F=(m,e,t)=>(Ie(m,typeof e!="symbol"?e+"":e,t),t);import{E as h,A as b,d as D,j as I,F as U,f as _,i as W,S as ee,k as He,l as We,e as re,m as Me,n as Ne,o as Oe,p as Ke,q as je,V as ne,r as $,t as qe,s as ie,u as $e,v as Ue,w as Ge}from"./BasicPuzzle-B1djSMlq.js";import{k as Ze,P as Ae,m as Ve}from"./UnivariatePolynomial-CzQEP6td.js";import{L as K}from"./PatternBoardSolver-D5oFTW2t.js";import{e as O,f as P,_ as Z}from"./patternBoards-7WmHeiIn.js";import{d as Je}from"./PhetioControlledVisibilityProperty-C87s29LU.js";import{L as R}from"./TextPushButton-B0wSyc3V.js";class Y{constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const t=e.nextAction();if(t)return t}return null}clone(e){return new Y(this.solvers.map(t=>t.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class k extends Error{constructor(e){super(e)}}class ae{constructor(e,t,s,o){F(this,"dirtyEdges",new Set);F(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyEdges=new Set(o):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,l,n,c)=>{for(const i of c)for(const a of i.edges)this.dirtyEdges.add(a);for(const i of n){const a=this.state.getFacesWithColor(i);for(const f of a)for(const d of f.edges)this.dirtyEdges.add(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new k("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===h.WHITE){const s=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),o=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=s===o,l=this.state.getOppositeFaceColor(s)===o;if(this.options.solveToBlack&&l)return new b(new D(e,h.BLACK),{type:"FaceColorToBlack",edge:e},this.board);if(this.options.solveToRed&&r)return new b(new D(e,h.RED),{type:"FaceColorToRed",edge:e},this.board)}this.dirtyEdges.delete(e)}return null}clone(e){return new ae(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class ce{constructor(e,t,s,o){F(this,"dirtyVertices",[]);F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,l)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=e.edges;let s=0,o=0;if(t.forEach(r=>{const l=this.state.getEdgeState(r);return l===h.BLACK?s++:l===h.WHITE&&o++,l}),s>2)throw new k("Too many black edges on vertex");if(s===1&&o===0)throw new k("Nowhere for the single edge to go");if(o>0){if(this.options.solveJointToRed&&s===2){const r=t.filter(n=>this.state.getEdgeState(n)===h.WHITE),l=t.filter(n=>this.state.getEdgeState(n)===h.BLACK);return O()&&P(l.length===2),new b(new I(r.map(n=>new D(n,h.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:l},this.board)}else if(this.options.solveForcedLineToBlack&&s===1&&o===1){const r=t.find(n=>this.state.getEdgeState(n)===h.WHITE),l=t.find(n=>this.state.getEdgeState(n)===h.BLACK);return O()&&P(r),O()&&P(l),new b(new D(r,h.BLACK),{type:"ForcedLine",vertex:e,blackEdge:l,whiteEdge:r,redEdges:t.filter(n=>this.state.getEdgeState(n)===h.RED)},this.board)}else if(this.options.solveAlmostEmptyToRed&&s===0&&o===1){const r=t.find(l=>this.state.getEdgeState(l)===h.WHITE);return O()&&P(r),new b(new D(r,h.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:t.filter(l=>this.state.getEdgeState(l)===h.RED)},this.board)}}}return null}clone(e){return new ce(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class le{constructor(e,t,s,o){F(this,"dirtyFaces",[]);F(this,"faceListener");F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceListener=(r,l)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,l)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceValue(e);if(t!==null){const s=e.edges;let o=0,r=0,l=0;if(s.forEach(n=>{const c=this.state.getEdgeState(n);return c===h.BLACK?o++:c===h.RED?r++:l++,c}),o>t)throw new k("Too many black edges on face");if(r>e.edges.length-t)throw new k("Too many red edges on face");if(l>0){if(this.options.solveToRed&&o===t){const n=s.filter(i=>this.state.getEdgeState(i)===h.WHITE),c=s.filter(i=>this.state.getEdgeState(i)===h.BLACK);return new b(new I(n.map(i=>new D(i,h.RED))),{type:"FaceSatisfied",face:e,whiteEdges:n,blackEdges:c},this.board)}else if(this.options.solveToBlack&&r===e.edges.length-t){const n=s.filter(i=>this.state.getEdgeState(i)===h.WHITE),c=s.filter(i=>this.state.getEdgeState(i)===h.RED);return new b(new I(n.map(i=>new D(i,h.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:n,redEdges:c},this.board)}}}}return null}clone(e){return new le(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class de{constructor(e,t,s,o){F(this,"dirtySimpleRegions");F(this,"hasDirtyWeirdEdges",!1);F(this,"simpleRegionListener");F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtySimpleRegions=new Set(o):this.dirtySimpleRegions=new Set(t.getSimpleRegions()),this.simpleRegionListener=(r,l,n,c)=>{for(const i of l)this.dirtySimpleRegions.delete(i);for(const i of r)this.dirtySimpleRegions.add(i);this.hasDirtyWeirdEdges=t.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,l,n)=>{if(l===h.RED){const c=this.state.getSimpleRegions(),i=a=>{let f=a,d=null,u=0;do{if(u++>1e4)throw new Error("infinite loop detected");const y=f.edges.filter(A=>this.state.getEdgeState(A)===h.BLACK);if(y.length===1){for(const A of c)(A.a===f||A.b===f)&&this.dirtySimpleRegions.add(A);break}if(y.length!==0)break;const E=f.edges.filter(A=>this.state.getEdgeState(A)===h.WHITE);if(E.length!==2)break;const v=E[0].getOtherVertex(f)===d?E[1]:E[0];d=f,f=v.getOtherVertex(f)}while(f!==a)};i(r.start),i(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new k("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const t=e.values().next().value;if(!t.isSolved){const s=t.a,o=t.b,r=t.halfEdges[0].edge;for(const l of s.edges){if(l===r||this.state.getEdgeState(l)===h.RED)continue;const n=[l];let c=l,i=l.getOtherVertex(s);for(;i!==o;){let a=!1;const f=i.edges.filter(d=>{if(d===c)return!1;const u=this.state.getEdgeState(d);return u===h.BLACK&&(a=!0),u===h.WHITE});if(f.length!==1||a)break;c=f[0],n.push(c),i=c.getOtherVertex(i)}if(i===o){if(this.isSolvedWithAddedEdges(t,n)){if(this.options.solveToBlack)return new b(new I(n.map(a=>new D(a,h.BLACK))),{type:"ForcedSolveLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n},this.board)}else if(this.options.solveToRed)return new b(new I(n.map(a=>new D(a,h.RED))),{type:"PrematureForcedLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n},this.board)}}}e.delete(t)}return null}isSolvedWithAddedEdges(e,t){const s=new Set(e.edges);for(const o of t)s.add(o);for(const o of this.board.faces){const r=this.state.getFaceValue(o);if(r!==null&&o.edges.filter(n=>s.has(n)).length!==r)return!1}return!0}clone(e){return new de(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const H=(m,e)=>{if(e.colorState===U.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===U.INSIDE)return{type:"absolute",isOutside:!1};{const t=[...m.getFacesWithColor(e)][0];return O()&&P(t),{type:"face",face:t}}};class he{constructor(e,t,s,o){F(this,"dirtyFaces",new Set);F(this,"edgeListener");F(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,l,n,c)=>{const i=a=>{this.dirtyFaces.add(a);for(const f of a.edges){const d=f.getOtherFace(a);d&&this.dirtyFaces.add(d)}};for(const a of c)i(a);for(const a of[...r,...n]){const f=this.state.getFacesWithColor(a);for(const d of f)i(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,l)=>{for(const n of r.faces)this.dirtyFaces.add(n)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new k("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,t=o=>{const r=o.getOtherFace(e),l=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new Ye(l,o)},s=e.edges.filter(o=>this.state.getEdgeState(o)===h.WHITE).map(t);if(s.length){const o=this.state.getFaceValue(e);if(o===null){const r=s[0].color;if(e.edges.map(t).every(c=>c.color===r)&&this.options.solveToRed){const c=e.edges.map(a=>a.getOtherFace(e)).filter(a=>a!==null);if(this.board.faces.some(a=>a!==e&&this.state.getFaceValue(a)!==null&&!c.includes(a)))return new b(new I(s.map(a=>new D(a.edge,h.RED))),{type:"FaceColorNoTrivialLoop",face:e},this.board)}}else{const r=e.edges.filter(c=>this.state.getEdgeState(c)===h.BLACK).length,l=(c,i,a)=>{let f=[];for(const p of i){const V=p.color;let g=!1;for(const C of f)if(C.mainColor===V){C.mainColorSides.add(p),g=!0;break}else if(C.oppositeColor===V){C.oppositeColorSides.add(p),g=!0;break}if(!g){const C=this.state.getOppositeFaceColor(V),x=new Xe(V,C,0,0);f.push(x),x.mainColorSides.add(p)}}f=Z.sortBy(f,p=>-p.size);const u=Z.sortBy(f.flatMap(p=>{const V=[new be(p.mainColor,p.mainCount,p.mainColorSides)];return p.oppositeColor&&p.oppositeColorSides.size&&V.push(new be(p.oppositeColor,p.oppositeCount,p.oppositeColorSides)),V}),p=>-p.size)[0],y=u.size,E=c,v=i.length-E,A=Math.max(E,v),z=y>E,S=y>v,L=y===A;if(z&&S)throw new k("Too many adjacent faces with the same color");const w=()=>{const p=V=>[V[0].map(g=>g.edge),V[1].map(g=>g.edge)];return{face:e,remainingValue:c,availableSideCount:i.length,balancedPairs:a.map(p)}};if(z&&this.options.solveToRed)return new b(new I([...u.sides].map(p=>new D(p.edge,h.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...u.sides].map(p=>p.edge),...w()},this.board);if(S&&this.options.solveToBlack)return new b(new I([...u.sides].map(p=>new D(p.edge,h.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...u.sides].map(p=>p.edge),...w()},this.board);if(L&&this.options.solveColors){const p=u.color,V=i.filter(C=>C.color!==p),g=Z.uniq(V.map(C=>C.color)).filter(C=>C!==this.state.getOppositeFaceColor(p));if(g.length)return O()&&P(g.every(C=>this.state.getFaceColors().includes(C))),new b(new I(g.map(C=>new _(H(this.state,p),H(this.state,C)))),{type:"FaceColorBalance",matchingEdges:[...u.sides].map(C=>C.edge),oppositeEdges:[...V].map(C=>C.edge),...w()},this.board)}if(this.options.allowPartialReduction)for(const p of f){if(p.size<1)continue;const V=[...p.mainColorSides].slice(0,p.size),g=[...p.oppositeColorSides].slice(0,p.size),C=i.filter(x=>!V.includes(x)&&!g.includes(x));if(C.length){const x=l(E-p.size,C,a.concat([[V,g]]));if(x)return x}}return null},n=l(o-r,s,[]);if(n)return n}}this.dirtyFaces.delete(e)}return null}clone(e){return new he(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Ye{constructor(e,t){this.color=e,this.edge=t}}class Xe{constructor(e,t,s,o){F(this,"mainColorSides",new Set);F(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=t,this.mainCount=s,this.oppositeCount=o}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class be{constructor(e,t,s){this.color=e,this.count=t,this.sides=s}get size(){return this.sides.size}}const Qe=(m,e)=>{let t=0;for(;m.dirty;){if(t++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const s=m.nextAction();s&&s.apply(e)}},_e=(m,e)=>{try{Qe(m,e)}finally{m.dispose()}},et=(m,e,t,s,o)=>{const r=m(e,t,o);s(),_e(r,t)},tt=(m,e,t,s)=>{et(m,e,t,()=>{},s)},X=m=>{const e=[];for(const t of m.edges){const s=t.getOtherFace(m);s&&e.push(s)}return e},Te=(m,e)=>m.start===e||m.end===e;class fe{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const l of X(o))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;if(t===s-1)for(const o of e.edges){const r=o.getOtherFace(e);if(r){const l=this.state.getFaceValue(r),n=r.edges.length;if(l===n-1){const c=new Set([...X(e),...X(r)]);if(this.board.faces.some(i=>(this.state.getFaceValue(i)??0)>0&&!c.has(i))){const i=v=>!Te(v,o.start)&&!Te(v,o.end),a=e.edges.filter(i),f=r.edges.filter(i),d=v=>!v.faces.some(A=>A===e||A===r),u=[...o.start.edges.filter(d),...o.end.edges.filter(d)],y=[o,...a,...f].filter(v=>this.state.getEdgeState(v)!==h.BLACK),E=u.filter(v=>this.state.getEdgeState(v)!==h.RED);if(y.length||E.length)return new b(new I([...y.map(v=>new D(v,h.BLACK)),...E.map(v=>new D(v,h.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:y,toRedEdges:E},this.board)}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new fe(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ge{constructor(e,t,s){F(this,"dirtySectors");F(this,"edgeListener");F(this,"sectorListener");this.board=e,this.state=t,s?this.dirtySectors=new Set(s):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(o,r,l)=>{this.dirtySectors.add(o.forwardHalf),this.dirtySectors.add(o.forwardHalf.previous),this.dirtySectors.add(o.reversedHalf),this.dirtySectors.add(o.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(o,r,l)=>{this.dirtySectors.add(o)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getSectorState(e);if(o===W.NONE)throw new k(`invalid sector state: ${o}`);const r=this.state.getEdgeState(t),l=this.state.getEdgeState(s),n=(r===h.WHITE?1:0)+(l===h.WHITE?1:0),c=(r===h.BLACK?1:0)+(l===h.BLACK?1:0),i=(a,f)=>new b(new I([...a.map(d=>new D(d,h.BLACK)),...f.map(d=>new D(d,h.RED))]),{type:"ForcedSector",sector:e,sectorState:o,toRedEdges:f,toBlackEdges:a},this.board);if(n===0){if(!o.allows(c))throw new k(`invalid state: ${o} with ${c} black edges with no white`)}else if(n===1){const a=o.allows(c),f=o.allows(c+1);if(!a&&!f)throw new k(`invalid state: ${o} with ${c} black edges and 1 white`);if(a&&!f)return i([],[r===h.WHITE?t:s]);if(f&&!a)return i([r===h.WHITE?t:s],[])}else if(n===2){if(o===W.ONLY_ZERO)return i([],[t,s]);if(o===W.ONLY_TWO)return i([t,s],[])}else throw new k(`invalid white count: ${n}`)}return null}clone(e){return new ge(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class ue{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const l of X(o))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;let o=null;if(t===0?o=W.ONLY_ZERO:t===1?o=W.NOT_TWO:t===s-1?o=W.NOT_ZERO:t===s&&(o=W.ONLY_TWO),o){const r=e.halfEdges,l=[],n=[];for(const c of r){const i=this.state.getSectorState(c),a=i.and(o);if(a===W.NONE)throw new k(`invalid sector state: ${i}`);i!==a&&(l.push(new ee(c,a)),n.push(c))}if(l.length)return new b(new I(l),{type:"StaticFaceSectors",face:e,sectors:n},this.board)}this.dirtyFaces.delete(e)}return null}clone(e){return new ue(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class pe{constructor(e,t,s,o){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new k("Vertex has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===h.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const c=[...n][0];c===h.RED&&this.options.solveToRed&&s.push(r),c===h.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new b(new I([...s.map(r=>new D(r,h.RED)),...o.map(r=>new D(r,h.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:s,toBlackEdges:o},this.board)}return null}clone(e){return new pe(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Se{constructor(e,t,s){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new k("Vertex has no possibilities");const s=He(e),o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>W.NONE);for(const i of t.getAllowedPairs())for(let a=0;a<s.length;a++){const f=s[a],d=f.edge,u=f.next.edge,y=i[0],E=i[1],v=(d===y||d===E?1:0)+(u===y||u===E?1:0);r[a]=r[a].with(v)}if(t.allowsEmpty())for(let i=0;i<s.length;i++)r[i]=r[i].withZero(!0);for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===W.NONE)throw new k("Sector has no possibilities");const l=[],n=[],c=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(l.push(s[i]),n.push(o[i]),c.push(r[i]));if(l.length)return new b(new I(l.map((i,a)=>new ee(i,c[a]))),{type:"VertexStateToSector",vertex:e,sectors:l,beforeStates:n,afterStates:c},this.board)}return null}clone(e){return new Se(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class we{constructor(e,t,s){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new k("Vertex has no possibilities");const o=We(e).map(n=>n.face?this.state.getFaceColor(n.face):this.state.getOutsideColor()),r=new Set(o);if(r.size!==1){const n=new Map([...r].map(i=>[i,new Map([...r].map(a=>[a,!1]))])),c=new Map([...r].map(i=>[i,new Map([...r].map(a=>[a,!1]))]));for(const i of t.getAllowedPairs()){const a=e.edges.indexOf(i[0]),f=e.edges.indexOf(i[1]),d=Math.min(a,f),u=Math.max(a,f),y=o.slice(d,u),E=[...o.slice(u),...o.slice(0,d)],v=A=>{for(let z=0;z<A.length;z++)for(let S=z+1;S<A.length;S++)n.get(A[z]).set(A[S],!0),n.get(A[S]).set(A[z],!0)};v(y),v(E);for(const A of y)for(const z of E)A!==z&&(c.get(A).set(z,!0),c.get(z).set(A,!0))}for(const i of r)for(const a of r){if(i===a)continue;const f=t.allowsEmpty()||n.get(i).get(a),d=c.get(i).get(a);if(f&&!d)return new b(new re(H(this.state,i),H(this.state,a)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(u=>this.state.getFaceColor(u)===i),facesB:e.faces.filter(u=>this.state.getFaceColor(u)===a)},this.board);if(d&&!f&&this.state.getOppositeFaceColor(i)!==a)return new b(new _(H(this.state,i),H(this.state,a)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(u=>this.state.getFaceColor(u)===i),facesB:e.faces.filter(u=>this.state.getFaceColor(u)===a)},this.board)}}const l=this.dirtyVertices.pop();O()&&P(l===e)}return null}clone(e){return new we(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Q{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const t=e.getFaceState(this.face);return new Q(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:Me(this.face),state:this.state.serialize()}}static deserializeAction(e,t){const s=Ne(e,t.face);return new Q(s,Oe.deserialize(s,t.state))}}class te{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceValueListener");F(this,"vertexStateListener");F(this,"faceColorListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces.filter(o=>t.getFaceValue(o)!==null)),this.faceValueListener=(o,r)=>{this.dirtyFaces.add(o)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=o=>{for(const r of o.faces)this.dirtyFaces.add(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(o,r,l,n)=>{const c=i=>{this.dirtyFaces.add(i);for(const a of i.edges){const f=a.getOtherFace(i);f&&this.dirtyFaces.add(f)}};for(const i of n)c(i);for(const i of[...o,...l]){const a=this.state.getFacesWithColor(i);for(const f of a)c(f)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const t=this.state.getFaceState(e),s=Oe.fromVertexAndColorData(e,this.board,this.state).and(t);if(!t.equals(s))return new b(new Q(e,s),{type:"FaceState",face:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new te(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class ye{constructor(e,t,s,o){F(this,"dirtyFaces",[]);F(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new k("Face has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===h.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const c=[...n][0];c===h.RED&&this.options.solveToRed&&s.push(r),c===h.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new b(new I([...s.map(r=>new D(r,h.RED)),...o.map(r=>new D(r,h.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:s,toBlackEdges:o},this.board)}return null}clone(e){return new ye(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class Ee{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new k("Face has no possibilities");const s=e.halfEdges,o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>W.NONE);for(const i of t.getAllowedCombinations())for(let a=0;a<s.length;a++){const f=s[a],d=f.edge,u=f.next.edge,y=(i.includes(d)?1:0)+(i.includes(u)?1:0);r[a]=r[a].with(y)}for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===W.NONE)throw new k("Sector has no possibilities");const l=[],n=[],c=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(l.push(s[i]),n.push(o[i]),c.push(r[i]));if(l.length)return new b(new I(l.map((i,a)=>new ee(i,c[a]))),{type:"FaceStateToSector",face:e,sectors:l,beforeStates:n,afterStates:c},this.board)}return null}clone(e){return new Ee(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class Ce{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new k("Face has no possibilities");const s=new Map(e.edges.map(c=>{const i=c.getOtherFace(e);return[c,i?this.state.getFaceColor(i):this.state.getOutsideColor()]})),o=[e,...e.edges.map(c=>c.getOtherFace(e)).filter(Z.identity)],r=this.state.getFaceColor(e),l=new Set([...s.values(),r]);if(l.size!==1){const c=new Map([...l].map(a=>[a,new Map([...l].map(f=>[f,!1]))])),i=new Map([...l].map(a=>[a,new Map([...l].map(f=>[f,!1]))]));for(const a of t.getAllowedCombinations()){const f=new Set([r]),d=new Set;for(const y of e.edges)a.includes(y)?d.add(s.get(y)):f.add(s.get(y));const u=y=>{for(let E=0;E<y.length;E++)for(let v=E+1;v<y.length;v++)c.get(y[E]).set(y[v],!0),c.get(y[v]).set(y[E],!0)};u([...f]),u([...d]);for(const y of f)for(const E of d)y!==E&&(i.get(y).set(E,!0),i.get(E).set(y,!0))}for(const a of l)for(const f of l){if(a===f)continue;const d=c.get(a).get(f),u=i.get(a).get(f);if(d&&!u)return new b(new re(H(this.state,a),H(this.state,f)),{type:"FaceStateToSameFaceColor",face:e,facesA:o.filter(y=>this.state.getFaceColor(y)===a),facesB:o.filter(y=>this.state.getFaceColor(y)===f)},this.board);if(u&&!d&&this.state.getOppositeFaceColor(a)!==f)return new b(new _(H(this.state,a),H(this.state,f)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:o.filter(y=>this.state.getFaceColor(y)===a),facesB:o.filter(y=>this.state.getFaceColor(y)===f)},this.board)}}const n=this.dirtyFaces.pop();O()&&P(n===e)}return null}clone(e){return new Ce(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class J{constructor(e,t){this.vertex=e,this.state=t}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const t=e.getVertexState(this.vertex);return new J(this.vertex,t)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:Ke(this.vertex),state:this.state.serialize()}}static deserializeAction(e,t){const s=je(e,t.vertex);return new J(s,ne.deserialize(s,t.state))}}class me{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new k("Face has no possibilities");const s=e.vertices.map(n=>this.state.getVertexState(n)),o=s.map(n=>{const c=n.vertex.edges.filter(i=>i.faces.includes(e));return O()&&P(c.length===2),{vertex:n.vertex,vertexState:n,edgeA:c[0],edgeB:c[1],...n.getBinaryCombinationsAllowed(c[0],c[1])}}),r=o.map(n=>({vertex:n.vertex,vertexState:n.vertexState,edgeA:n.edgeA,edgeB:n.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const n of t.getAllowedCombinations())for(const c of r){const i=n.includes(c.edgeA),a=n.includes(c.edgeB);i&&a&&(c.allowsBoth=!0),i&&!a&&(c.allowsAOnly=!0),!i&&a&&(c.allowsBOnly=!0),!i&&!a&&(c.allowsNone=!0)}const l=[];for(let n=0;n<r.length;n++){const c=o[n],i=r[n];if(i.allowsBoth&&(i.allowsBoth=c.allowsBoth),i.allowsAOnly&&(i.allowsAOnly=c.allowsAOnly),i.allowsBOnly&&(i.allowsBOnly=c.allowsBOnly),i.allowsNone&&(i.allowsNone=c.allowsNone),i.allowsBoth!==c.allowsBoth||i.allowsAOnly!==c.allowsAOnly||i.allowsBOnly!==c.allowsBOnly||i.allowsNone!==c.allowsNone){const a=c.vertexState,f=ne.fromLookup(c.vertex,(d,u)=>{if(!a.allowsPair(d,u))return!1;const E=d===i.edgeA||u===i.edgeA,v=d===i.edgeB||u===i.edgeB;if(E&&v)return i.allowsBoth;if(E&&!v)return i.allowsAOnly;if(!E&&v)return i.allowsBOnly;if(!E&&!v)return i.allowsNone;throw new Error("Unreachable")},a.allowsEmpty()&&i.allowsNone);O()&&P(f.isSubsetOf(a)),a.equals(f)||l.push(f)}}if(l.length)return new b(new I(l.map(n=>new J(n.vertex,n))),{type:"FaceStateToVertexState",face:e,vertices:l.map(n=>n.vertex),beforeStates:l.map(n=>s.find(c=>c.vertex===n.vertex)),afterStates:l},this.board)}return null}clone(e){return new me(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}const Re=()=>Ze.nextInt(Number.MAX_SAFE_INTEGER);class j{constructor(e,t){F(this,"dirtyEdges",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>{this.dirtyEdges.add(s)}),this.edgeListener=(s,o)=>{this.dirtyEdges.add(s)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),t=this.state.getWeirdEdges(),s=new Set,o=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===h.BLACK?s.add(d):o.add(d);const r=new Set,l=new Set,n=new Set(e),c=new Set,i=new Set,a=new Set(t);for(const d of o)a.has(d)&&(a.delete(d),i.add(d));for(const d of s)a.has(d)&&s.delete(d),[...n].some(u=>u.halfEdges.some(y=>y.edge===d))&&s.delete(d);for(const d of e)if(d.halfEdges.some(u=>o.has(u.edge))){const u=[];let y=[];for(const E of d.halfEdges)o.has(E.edge)?y.length>0&&(u.push(y),y=[]):y.push(E);if(y.length>0&&u.push(y),l.add(d),n.delete(d),u.length){if(d.isSolved&&u.length>1){const v=u[0][0],A=u[u.length-1][u[u.length-1].length-1];v.start===A.end&&u[0].unshift(...u.pop())}const E=Z.maxBy(u,v=>v.length);for(const v of u){const A=new $(v===E?d.id:Re(),v);r.add(A),n.add(A)}}}const f=d=>{const u=d.start,y=d.end,E=[...n].find(w=>w.a===u||w.b===u)||null,v=[...n].find(w=>w.a===y||w.b===y)||null,A=u.edges.filter(w=>this.state.getEdgeState(w)===h.BLACK).length,z=y.edges.filter(w=>this.state.getEdgeState(w)===h.BLACK).length;if(A>2||z>2)return!1;const S=w=>{n.add(w),r.add(w)},L=w=>{n.delete(w),r.has(w)?r.delete(w):l.add(w)};if(E&&v)if(E===v)if(j.isSolvedWithAddedEdge(this.board,this.state,E,d))L(E),S(new $(E.id,j.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]),!0));else return!1;else{const w=E.halfEdges.length>=v.halfEdges.length?E:v,p=w===E?v:E,V=new $(w.id,j.combineHalfEdgeArrays(w.halfEdges,[d.forwardHalf],p.halfEdges));L(w),L(p),S(V)}else if(E){const w=new $(E.id,j.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]));L(E),S(w)}else if(v){const w=new $(v.id,j.combineHalfEdgeArrays(v.halfEdges,[d.forwardHalf]));L(v),S(w)}else{const w=new $(Re(),[d.forwardHalf]);S(w)}return!0};for(const d of a)f(d)&&(i.add(d),a.delete(d));for(const d of s)f(d)||(c.add(d),a.add(d));return this.dirtyEdges.clear(),r.size||l.size||c.size||i.size?new b(new qe(this.board,r,l,c,i),{type:"SimpleRegions"},this.board):null}clone(e){return new j(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,t,s,o){if(o.start!==s.a&&o.start!==s.b||o.end!==s.a&&o.end!==s.b)return!1;const r=new Set(s.edges);r.add(o);for(const l of e.faces){const n=t.getFaceValue(l);if(n!==null&&l.edges.filter(i=>r.has(i)).length!==n)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let t=[...e[0]];for(let s=1;s<e.length;s++){const o=e[s];if(o.length!==0)if(t[0].start===o[0].start)t=[...o.map(r=>r.reversed).reverse(),...t];else if(t[0].start===o[o.length-1].end)t=[...o,...t];else if(t[t.length-1].end===o[0].start)t=[...t,...o];else if(t[t.length-1].end===o[o.length-1].end)t=[...t,...o.map(r=>r.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return t}}class ve{constructor(e,t){F(this,"hasDirtySimpleRegions",!0);F(this,"simpleRegionListener");this.board=e,this.state=t,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(ie(this.state)){const e=this.board.edges.filter(t=>this.state.getEdgeState(t)===h.WHITE);if(e.length)return new b(new I(e.map(t=>new D(t,h.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e},this.board)}return this.hasDirtySimpleRegions=!1,null}clone(e){return new ve(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}class st{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Fe{constructor(e,t){F(this,"hadEdgeAdjusted",!1);F(this,"dirtyEdges",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>this.dirtyEdges.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyEdges.add(s),this.hadEdgeAdjusted=this.hadEdgeAdjusted||r!==h.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var t;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const s=new Map,o=new oe(U.OUTSIDE,new Set),r=new oe(U.INSIDE,new Set);o.opposite=r,r.opposite=o;const l=new Set([o,r,...this.board.faces.map(S=>{const L=new oe(U.UNDECIDED,new Set([S]));return s.set(S,L),L})]);let n=!1;const c=S=>{if(S===null)return o;const L=s.get(S);return O()&&P(L),L},i=(S,L)=>{if(L===o||L===r)return i(L,S);O()&&P(S!==L);for(const w of L.faces)S.faces.add(w),s.set(w,S);return L.faces.clear(),l.delete(L),S},a=(S,L)=>{if(O()&&P(l.has(S)&&l.has(L)),S===L)return;const w=S.opposite,p=L.opposite;if(w&&w===L){n=!0;return}if(p&&p===S){n=!0;return}const V=i(S,L),g=w&&p?i(w,p):w||p;V.opposite=g,g&&(g.opposite=V)},f=(S,L)=>{if(O()&&P(l.has(S)&&l.has(L)),S===L){n=!0;return}if(S.opposite&&S.opposite===L)return;const w=S.opposite,p=L.opposite;if(w&&w===p){n=!0;return}const V=p?i(S,p):S,g=w?i(L,w):L;V.opposite=g,g.opposite=V};for(const S of this.board.edges){if(n)break;const L=this.state.getEdgeState(S);if(L!==h.WHITE){const w=c(S.forwardFace),p=c(S.reversedFace);L===h.BLACK?f(w,p):L===h.RED&&a(w,p)}}if(O()){const S=new Set(this.board.faces);for(const L of l)for(const w of L.faces)S.delete(w);P(S.size===0)}if(n)return new b(new st,{type:"InvalidFaceColoring"},this.board);const d=new Set(this.state.getFaceColors()),u=new Set,y=new Map,E=(S,L)=>{O()&&P(d.has(S)),O()&&P(L.faceColor===null),d.delete(S),L.faceColor=S};E(this.state.getOutsideColor(),o),E(this.state.getInsideColor(),r);for(const S of l){if(!S.faceColor){const w=new Set([...S.faces].map(g=>this.state.getFaceColor(g)));let p=null,V=0;for(const g of w){if(!d.has(g))continue;const C=this.state.getFacesWithColor(g);C.some(x=>!S.faces.has(x))||C.length>V&&(p=g,V=C.length)}if(p)E(p,S);else{const g=new $e(Ue(),U.UNDECIDED);u.add(g),S.faceColor=g}}const L=S.faceColor;O()&&P(L),S.faces.forEach(w=>{this.state.getFaceColor(w)!==L&&y.set(w,L)})}const v=new Set(d),A=new Map;for(const S of l){const L=S.faceColor,w=((t=S.opposite)==null?void 0:t.faceColor)??null;let p=u.has(L);p||(p=this.state.getOppositeFaceColor(L)!==w),p&&A.set(L,w)}return u.size>0||v.size>0||y.size>0||A.size>0||this.state.hasInvalidFaceColors()?new b(new Ge(this.board,u,v,y,A,!1),{type:"GeneralFaceColoring"},this.board):null}else for(;this.dirtyEdges.size;){const s=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(s);const o=this.state.getEdgeState(s);if(o!==h.WHITE){const r=s.forwardFace?this.state.getFaceColor(s.forwardFace):this.state.getOutsideColor(),l=s.reversedFace?this.state.getFaceColor(s.reversedFace):this.state.getOutsideColor();if(o===h.BLACK){if(this.state.getOppositeFaceColor(r)!==l)return new b(new _(H(this.state,r),H(this.state,l)),{type:"FaceColoringBlackEdge",edge:s},this.board)}else if(o===h.RED&&r!==l)return new b(new re(H(this.state,r),H(this.state,l)),{type:"FaceColoringRedEdge",edge:s},this.board)}}return null}clone(e){return new Fe(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class oe{constructor(e,t){F(this,"opposite",null);F(this,"faceColor",null);this.colorState=e,this.faces=t}}class Le{constructor(e,t){F(this,"dirtySectors",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.halfEdges.forEach(s=>this.dirtySectors.add(s)),this.edgeListener=(s,o,r)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getEdgeState(t),r=this.state.getEdgeState(s),l=this.state.getSectorState(e);let n=l;const c=(o===h.WHITE?1:0)+(r===h.WHITE?1:0),i=(o===h.BLACK?1:0)+(r===h.BLACK?1:0),a=(o===h.RED?1:0)+(r===h.RED?1:0);if(c===0?n=W.getOnly(i):c===1&&(i&&n.zero&&(n=n.withDisallowZero()),a&&n.two&&(n=n.withDisallowTwo())),n!==l)return new b(new ee(e,n),{type:c===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:l,afterState:n},this.board)}return null}clone(e){return new Le(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class xe{constructor(e,t){F(this,"dirtyVertices",new Set);F(this,"edgeListener");F(this,"sectorListener");F(this,"faceColorListener");this.board=e,this.state=t,e.vertices.forEach(s=>this.dirtyVertices.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyVertices.add(s.start),this.dirtyVertices.add(s.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,o,r)=>{this.dirtyVertices.add(s.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(s,o,r,l)=>{for(const n of l)for(const c of n.vertices)this.dirtyVertices.add(c);for(const n of r){const c=this.state.getFacesWithColor(n);for(const i of c)for(const a of i.vertices)this.dirtyVertices.add(a)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const t=this.state.getVertexState(e),s=ne.fromEdgeColorSectorData(e,this.state).and(t);if(!t.equals(s))return new b(new J(e,s),{type:"VertexState",vertex:e,beforeState:t,afterState:s},this.board)}return null}clone(e){return new xe(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}const Pe=(m,e,t)=>new Y([new j(m,e),new ve(m,e),new Fe(m,e),new Le(m,e),new xe(m,e)]),Wt=new R("autoSolveEnabledProperty",!0),Mt=new R("autoSolveToBlackProperty",!1),Nt=new R("autoSolveSimpleLoopsProperty",!1),ot=new R("autoSolveSimpleVertexJointToRedProperty",!0),it=new R("autoSolveSimpleVertexForcedLineToBlackProperty",!0),rt=new R("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),nt=new R("autoSolveSimpleFaceToRedProperty",!0),at=new R("autoSolveSimpleFaceToBlackProperty",!0),ct=new R("autoSolveSimpleLoopToRedProperty",!0),lt=new R("autoSolveSimpleLoopToBlackProperty",!1),dt=new R("autoSolveDoubleMinusOneFacesProperty",!1),ht=new R("autoSolveStaticFaceSectorProperty",!0),ft=new R("autoSolveSimpleSectorProperty",!1),gt=new R("autoSolveVertexToRedEdgeProperty",!1),ut=new R("autoSolveVertexToBlackEdgeProperty",!1),pt=new R("autoSolveVertexToSectorsProperty",!1),St=new R("autoSolveVertexToFaceColorProperty",!1),wt=new R("autoSolveFaceColorToRedProperty",!1),yt=new R("autoSolveFaceColorToBlackProperty",!1),Et=new R("autoSolveFaceColorParityToRedProperty",!1),Ct=new R("autoSolveFaceColorParityToBlackProperty",!1),mt=new R("autoSolveFaceColorParityColorsProperty",!1),vt=new R("autoSolveFaceColorParityPartialReductionProperty",!1),Ft=new R("autoSolveVertexColorToFaceProperty",!1),Lt=new R("autoSolveFaceToRedProperty",!1),xt=new R("autoSolveFaceToBlackProperty",!1),At=new R("autoSolveFaceToSectorsProperty",!1),Vt=new R("autoSolveFaceToFaceColorsProperty",!1),bt=new R("autoSolveFaceToVertexProperty",!1),Tt=(m,e,t)=>new Y([Pe(m,e),new te(m,e)]),ke=(m,e)=>{tt(Tt,m,e,!0)},Kt=new Je([ot,it,rt,nt,at,ct,lt,dt,ht,ft,gt,ut,pt,St,wt,yt,Et,Ct,mt,vt,Ft,Lt,xt,At,Vt,bt],(m,e,t,s,o,r,l,n,c,i,a,f,d,u,y,E,v,A,z,S,L,w,p,V,g,C)=>(x,T,B)=>new Y([...m||e||t?[new ce(x,T,{solveJointToRed:m,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},B?void 0:[])]:[],...s||o?[new le(x,T,{solveToRed:s,solveToBlack:o},B?void 0:[])]:[],...n?[new fe(x,T,B?void 0:[])]:[],Pe(x,T),...c?[new ue(x,T,B?void 0:[])]:[],...i?[new ge(x,T,B?void 0:[])]:[],...r||l?[new de(x,T,{solveToRed:r,solveToBlack:l,resolveAllRegions:!1},B?void 0:[])]:[],...a||f?[new pe(x,T,{solveToRed:a,solveToBlack:f},B?void 0:[])]:[],...d?[new Se(x,T,B?void 0:[])]:[],...y||E?[new ae(x,T,{solveToRed:y,solveToBlack:E},B?void 0:[])]:[],...v||A||z?[new he(x,T,{solveToRed:v,solveToBlack:A,solveColors:z,allowPartialReduction:S},B?void 0:[])]:[],...u?[new we(x,T,B?void 0:[])]:[],...L?[new te(x,T,B?void 0:[])]:[],...w||p?[new ye(x,T,{solveToRed:w,solveToBlack:p},B?void 0:[])]:[],...V?[new Ee(x,T,B?void 0:[])]:[],...g?[new Ce(x,T,B?void 0:[])]:[],...C?[new me(x,T,B?void 0:[])]:[]]));class ze extends Error{constructor(e){super("Multiple solutions found"),this.solutionEdges=e}}class Rt extends Error{constructor(){super("Too many iterations!")}}const Be=(m,e,t)=>{const s=e.clone();for(const o of t)s.setEdgeState(o,h.BLACK);return ke(m,s),{board:m,cleanState:e,solvedState:s,blackEdges:new Set(t)}},jt=(m,e)=>{try{if(ie(e))return{board:m,stateProperty:new Ae(e),solution:Be(m,e,[])};const t=Bt(m,e,{maxIterations:1e4,failOnMultipleSolutions:!0});if(t.length!==1)return null;const s=t[0],o=e.clone();for(const r of s)o.setEdgeState(r,h.BLACK);return ke(m,o),O()&&P(ie(o)),{board:m,stateProperty:new Ae(e),solution:Be(m,e,s)}}catch(t){if(t instanceof ze)return null;throw t}},Bt=(m,e,t)=>{const s=m.edges.filter(g=>e.getEdgeState(g)===h.BLACK),o=m.edges.filter(g=>e.getEdgeState(g)===h.WHITE);O()&&P(o.length,"Need to have at least some undefined edges to use solver");const r=new Set(o),l=new Map(o.map((g,C)=>[g,`edge${C+1}`])),n=new Map(o.map((g,C)=>[`edge${C+1}`,g])),c=new K.Solver,i=g=>{const C=l.get(g);return O()&&P(C!==void 0,"Edge not found!"),C},a=g=>`-${i(g)}`,f=g=>{for(const C of g)c.require(K.not(i(C)))},d=g=>{c.require(K.or(...g.map(i)))},u=g=>{c.require(K.or(...g.map(a)))},y=(g,C)=>{C>0&&(d(g),Ve.forEachCombination(g,x=>{x.length===g.length-C+1&&c.require(K.not(K.and(...x.map(a))))}))},E=(g,C)=>{Ve.forEachCombination(g,x=>{x.length===C+1&&c.require(K.or(...x.map(a)))})},v=g=>{c.require(K.not(K.exactlyOne(...g.map(i))))},A=g=>{E(g,2),v(g)},z=(g,C)=>{C===0?f(g):(y(g,C),E(g,C))};d(o);for(const g of m.vertices){let C=0,x=0,T=[];for(const B of g.edges){const M=e.getEdgeState(B);M===h.BLACK?C++:M===h.WHITE&&(x++,T.push(B))}x!==0&&(C===0?A(T):C===1?z(T,1):f(T))}let S=!1;for(const g of m.faces){const C=e.getFaceValue(g);if(C===null)continue;S=!0;let x=0,T=0,B=[];for(const q of g.edges){const N=e.getEdgeState(q);N===h.BLACK?x++:N===h.WHITE&&(T++,B.push(q))}if(T===0)continue;const M=Math.max(C-x,0);z(B,M)}O()&&P(S,"No faces with values!");const L=()=>{let g=null;return K.disablingAssertions(()=>{g=c.solve()}),g?g.getTrueVars().map(x=>n.get(x)):null};let w=0;const p=()=>{const g=L();if(g===null)return{touchingValueLoops:[],nonTouchingValueLoops:[]};const C=new Set([...g,...s]),x=[],T=[];for(;C.size;){const B=C.values().next().value,M=[];let q=B.end,N=B,se=!1;for(;N;)C.delete(N),M.push(N),se=se||N.faces.some(G=>e.getFaceValue(G)!==null),N=q.edges.find(G=>C.has(G))??null,N&&(q=N.getOtherVertex(q));O()&&P(M[0].vertices.some(G=>M[M.length-1].vertices.includes(G)),"Loop is not a loop!"),(se?x:T).push(M)}return{touchingValueLoops:x,nonTouchingValueLoops:T}},V=[];for(;;){const g=p();if(!g.touchingValueLoops.length)break;if(g.touchingValueLoops.length===1&&(V.push(g.touchingValueLoops[0]),V.length>1&&t.failOnMultipleSolutions))throw new ze(V);const C=[...g.touchingValueLoops,...g.nonTouchingValueLoops];for(const x of C)u(x.filter(T=>r.has(T)));if(w++,w>t.maxIterations)throw new Rt}return V};export{he as $,Mt as A,Nt as B,tt as C,Be as D,jt as E,Bt as F,ke as G,Rt as H,k as I,ve as J,Fe as K,Le as L,ze as M,xe as N,Y as O,Kt as P,ce as Q,le as R,j as S,de as T,ae as U,te as V,ue as W,fe as X,ge as Y,pe as Z,Se as _,ot as a,we as a0,ye as a1,Ee as a2,Ce as a3,me as a4,et as a5,H as a6,Pe as a7,it as b,rt as c,nt as d,at as e,ct as f,lt as g,dt as h,ht as i,ft as j,gt as k,ut as l,pt as m,St as n,wt as o,yt as p,Et as q,Ct as r,mt as s,vt as t,Ft as u,Lt as v,xt as w,At as x,Vt as y,Wt as z};
