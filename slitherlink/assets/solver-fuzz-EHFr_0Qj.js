import"./Vector2Property-CFyCN_2h.js";import{N as E,D as x,B as H}from"./PhetioControlledVisibilityProperty-thEXBwUY.js";import"./localStorage-BTLIWA27.js";import{S as D,H as F,_ as h,d as W,e as k,P as G}from"./patternBoards-DzVBPT7g.js";import{p as L}from"./polygonGenerators-B6WeaZhu.js";import{P as M,B as y,X as V,Q as z}from"./DisplayEmbedding-0vgCuFSa.js";import{E as v,B as I,s as f}from"./BasicPuzzle-Bt7fJ87M.js";import{g as q,a as K,s as i,A as S}from"./AnnotationNode-7eyds_Jc.js";import{N as O}from"./SATSolver-BXmuhJOp.js";import"./Theme-CG_JTTcq.js";import"./SpinningIndicatorNode-CK4xca7k.js";import"./PatternRule-B98-ERhf.js";import"./PatternBoardSolver-DIArGw3P.js";import"./SlitherQueryParameters-CLuuf2TR.js";self.assertions.enableAssert();const A=new E,Q=new E({renderer:"svg",children:[A]}),d=new x(Q,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(d.domElement);d.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");const R=o=>G.get(o,o.defaultParameterValues),P=[new D(10,10),new F(4,1,!0),...L.map(R)];(async()=>{let o=null;const w=new H(!1);for(;;){console.log("board loaded");const t=P[Math.floor(Math.random()*P.length)],b=await q(t,w),c=await K(b,()=>!0,w),r=c.cleanState.clone();c.blackEdges.forEach(u=>r.setEdgeState(u,v.BLACK)),O(t,r);const p=I.fromSolvedPuzzle(c);o&&o.dispose(),o=new M(p,{scale:30,left:20,top:20}),A.addChild(o),d.updateDisplay(),await i(50);const e=p.stateProperty.value.clone(),m=y(t,e),g=()=>{p.stateProperty.value=e.clone(),d.updateDisplay()};let B=0;for(;!f(e);){if(o.clearAnnotationNodes(),B++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const u=e.clone(),N=m.clone(u),n=m.nextAction();if(n){console.log(n);const s=new V(t,e,r);o.addAnnotationNode(new S(t,n.annotation,z)),g(),await i(0);try{n.apply(s)}catch(l){console.error(l);debugger;const a=N.nextAction();a&&a.apply(s)}n.apply(e)}else if(!f(e)){const s=y(t,e),l=s.nextAction();if(l)throw o.addAnnotationNode(new S(t,l.annotation,z)),g(),await i(0),new Error("Fresh solver should not have any actions");s.dispose();const a=h.find(h.shuffle(t.edges),C=>e.getEdgeState(C)===v.WHITE);if(W()&&k(a),e.setEdgeState(a,r.getEdgeState(a)),console.log("setting white edge to red/black",a),!m.dirty)throw new Error("Solver should be dirty after setting edge state")}g(),await i(0)}if(!f(e))throw new Error("Solver did not solve the puzzle")}})();
