var q=Object.defineProperty;var U=(O,e,s)=>e in O?q(O,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):O[e]=s;var E=(O,e,s)=>(U(O,typeof e!="symbol"?e+"":e,s),s);import{e as l,f as h,_ as L}from"./getCoordinateClusteredMap-Bd_wM-c0.js";import{F as z,I as f,d as B,B as p,R as g,b as y,c as A,S as C,a as M}from"./SectorOnlyOneFeature-B1Nn5A2g.js";import{P as Z}from"./PatternBoardSolver-vRQRWARQ.js";import{a as R,E as $,d as H}from"./UnivariatePolynomial-1rLpyqfN.js";import{r as K}from"./patternBoards-CVo-HFgJ.js";const G=(O,e)=>{const s=new Map,t=r=>{const n=r.slice(),a=[];for(;n.length;){const c=n.find(k=>k.isExit);l()&&h(c);const T=k=>{const v=k.vertices.flatMap(V=>V.edges).filter(V=>n.includes(V));return l()&&h(v.length===1),v[0]};R(n,c);let N=c;for(;N===c||!N.isExit;){const k=T(N);R(n,k),N=k}const D=N,W=Math.min(c.exitVertex.index,D.exitVertex.index),j=Math.max(c.exitVertex.index,D.exitVertex.index);a.push({minVertexIndex:W,maxVertexIndex:j})}const d=L.sortBy(a,c=>c.minVertexIndex);return`${e.map(c=>r.includes(c)?"1":"0")}${d.map(c=>`,c${c.minVertexIndex}-${c.maxVertexIndex}`)}`};for(const r of O){const n=t(r);s.has(n)?s.get(n).push(r):s.set(n,[r])}const i=[],o=[];for(const r of s.values())r.length>1?o.push(r):i.push(r[0]);return{highlanderSolutions:i,excludedSolutionGroups:o}},Q=(O,e)=>{const s=e.filter(i=>i instanceof z),t=new Set(s.map(i=>i.face));return O.edges.filter(i=>i.isExit||i.faces.some(o=>!t.has(o)))},m=class m extends ${};E(m,"INCOMPATIBLE",new m),E(m,"NO_MATCH_NEEDS_FACE_VALUES",new m),E(m,"NO_MATCH_NEEDS_STATE",new m),E(m,"MATCH",new m),E(m,"enumeration",new H(m));let S=m;const I=new WeakMap;class b{constructor(e){E(this,"connectedFacePairs",[]);E(this,"connectedExitFacePairs",[]);E(this,"connectedComponents",[]);this.patternBoard=e;for(const s of e.faces){const t=new Set([s]),i=[new P(s,[])];let o=!0;for(;i.length;){const r=i.shift(),{face:n,edges:a}=r;for(const d of n.edges)if(d.faces.length===2){const c=d.faces[0]===n?d.faces[1]:d.faces[0];if(!t.has(c)){const T=[...a,d];if(t.add(c),i.push(new P(c,T)),s.index<c.index){const N=new J(s,c,T);this.connectedFacePairs.push(N),n.isExit&&c.isExit&&this.connectedExitFacePairs.push(N)}else o=!1}}}o&&this.connectedComponents.push([...t])}}static get(e){let s=I.get(e);return s||(s=new b(e),I.set(e,s)),s}}class J{constructor(e,s,t){this.a=e,this.b=s,this.shortestPath=t,l()&&h(e.index<s.index)}containsFace(e){return this.a===e||this.b===e}containsFacePair(e,s){return this.a===e&&this.b===s||this.a===s&&this.b===e}}class P{constructor(e,s){this.face=e,this.edges=s}}const F=class F extends ${};E(F,"INCOMPATIBLE",new F),E(F,"DORMANT",new F),E(F,"MATCH",new F),E(F,"enumeration",new H(F));let u=F;const w=[];class x{constructor(e,s=new Map,t=new Set,i=new Set,o=new Set,r=new Set,n=new Set,a=new Set,d=new Set,c=new Map,T=new Set,N=new Map){E(this,"size");this.patternBoard=e,this.faceValueMap=s,this.blackEdges=t,this.redEdges=i,this.sectorsNotZero=o,this.sectorsNotOne=r,this.sectorsNotTwo=n,this.sectorsOnlyOne=a,this.faceColorDualFeatures=d,this.faceToColorDualMap=c,this.sectors=T,this.edgeToSectorsMap=N,this.size=this.computeSize()}addFaceValue(e,s){const t=this.faceValueMap.get(e);if(t!==void 0){if(t!==s)throw new f(new z(e,s),[new z(e,t)])}else this.faceValueMap.set(e,s),this.size++;l()&&this.verifySize()}addSameColorFaces(e,s){this.addFaceColorDual(B.fromPrimarySecondaryFaces([e,s],[]))}addOppositeColorFaces(e,s){this.addFaceColorDual(B.fromPrimarySecondaryFaces([e],[s]))}addFaceColorDual(e){l()&&h(e);const s=e;for(const t of[...this.faceColorDualFeatures])if(e.overlapsWith(t)){const i=e.union(t);if(i)e=i,this.faceColorDualFeatures.delete(t),this.size-=t.allFaces.size-1;else throw new f(s,[t])}this.faceColorDualFeatures.add(e),this.size+=e.allFaces.size-1;for(const t of e.allFaces)this.faceToColorDualMap.set(t,e);l()&&this.verifySize()}addBlackEdge(e){if(l()&&h(e),this.blackEdges.has(e))return;if(this.redEdges.has(e)){debugger;throw new f(new p(e),[new g(e)])}this.size++,this.blackEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(i);let o=0;if(this.sectorsNotZero.has(t)&&(this.sectorsNotZero.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.blackEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new f(new p(e),[new g(i),new y(t)]);o++}if(this.sectorsNotTwo.has(t))if(this.redEdges.has(i))this.sectorsNotTwo.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new f(new p(e),[new p(i),new A(t)]);o++}if(this.sectorsOnlyOne.has(t))if(this.redEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new f(new p(e),[new p(i),new C(t)]);o++}o===0&&this.removeSector(t)}l()&&this.verifySize()}addRedEdge(e){if(l()&&h(e),this.redEdges.has(e))return;if(this.blackEdges.has(e))throw new f(new g(e),[new p(e)]);this.size++,this.redEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(i);let o=0;if(this.sectorsNotTwo.has(t)&&(this.sectorsNotTwo.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.redEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new f(new g(e),[new p(i),new y(t)]);o++}if(this.sectorsNotZero.has(t))if(this.blackEdges.has(i))this.sectorsNotZero.delete(t),this.size--;else{if(this.redEdges.has(i))throw new f(new g(e),[new g(i),new M(t)]);o++}if(this.sectorsOnlyOne.has(t))if(this.blackEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new f(new g(e),[new g(i),new C(t)]);o++}o===0&&this.removeSector(t)}l()&&this.verifySize()}addSectorNotZero(e){if(l()&&h(e),this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.redEdges.has(s),o=this.redEdges.has(t);if(i&&o)throw new f(new M(e),[new g(s),new g(t)]);this.blackEdges.has(s)||this.blackEdges.has(t)||(i?this.addBlackEdge(t):o?this.addBlackEdge(s):this.sectorsNotOne.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.size--,this.sectorsNotTwo.delete(e),this.addSectorOnlyOne(e)):(this.size++,this.sectorsNotZero.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotOne(e){if(l()&&h(e),this.sectorsNotOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t),r=this.redEdges.has(s),n=this.redEdges.has(t);if(i&&n)throw new f(new y(e),[new p(s),new g(t)]);if(o&&r)throw new f(new y(e),[new p(t),new g(s)]);if(this.sectorsOnlyOne.has(e))throw new f(new y(e),[new C(e)]);i&&o||r&&n||(i?this.addBlackEdge(t):o?this.addBlackEdge(s):r?this.addRedEdge(t):n?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotOne.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotTwo(e){if(l()&&h(e),this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t);if(i&&o)throw new f(new A(e),[new p(s),new p(t)]);this.redEdges.has(s)||this.redEdges.has(t)||(i?this.addRedEdge(t):o?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.size--,this.sectorsNotZero.delete(e),this.addSectorOnlyOne(e)):this.sectorsNotOne.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotTwo.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorOnlyOne(e){if(l()&&h(e),this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t),r=this.redEdges.has(s),n=this.redEdges.has(t);if(i&&o)throw new f(new C(e),[new p(s),new p(t)]);if(r&&n)throw new f(new C(e),[new g(s),new g(t)]);if(this.sectorsNotOne.has(e))throw new f(new C(e),[new y(e)]);i&&n||o&&r||(i?this.addRedEdge(t):o?this.addRedEdge(s):r?this.addBlackEdge(t):n?this.addBlackEdge(s):this.sectorsNotZero.has(e)&&(this.size--,this.sectorsNotZero.delete(e)),this.sectorsNotTwo.has(e)&&(this.size--,this.sectorsNotTwo.delete(e)),this.size++,this.sectorsOnlyOne.add(e),this.ensureSector(e),l()&&this.verifySize())}addFeature(e){if(e instanceof z)this.addFaceValue(e.face,e.value);else if(e instanceof B)this.addFaceColorDual(e);else if(e instanceof p)this.addBlackEdge(e.edge);else if(e instanceof g)this.addRedEdge(e.edge);else if(e instanceof M)this.addSectorNotZero(e.sector);else if(e instanceof y)this.addSectorNotOne(e.sector);else if(e instanceof A)this.addSectorNotTwo(e.sector);else if(e instanceof C)this.addSectorOnlyOne(e.sector);else throw new Error(`unimplemented type of feature for FeatureSet: ${e}`);l()&&this.verifySize()}ensureSector(e){if(!this.sectors.has(e)){this.sectors.add(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);let i=this.edgeToSectorsMap.get(s);i?i.add(e):(i=new Set([e]),this.edgeToSectorsMap.set(s,i));let o=this.edgeToSectorsMap.get(t);o?o.add(e):(o=new Set([e]),this.edgeToSectorsMap.set(t,o))}}removeSector(e){if(this.sectors.has(e)){this.sectors.delete(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.edgeToSectorsMap.get(s);i&&(i.delete(e),i.size===0&&this.edgeToSectorsMap.delete(s));const o=this.edgeToSectorsMap.get(t);o&&(o.delete(e),o.size===0&&this.edgeToSectorsMap.delete(t))}}computeSize(){let e=this.faceValueMap.size+this.blackEdges.size+this.redEdges.size+this.sectorsNotZero.size+this.sectorsNotOne.size+this.sectorsNotTwo.size+this.sectorsOnlyOne.size;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}verifySize(){l()&&h(this.size===this.computeSize(),"size mismatch")}getInputDifficultyScoreA(){let e=0;e+=this.faceValueMap.size*.5,e+=this.blackEdges.size*1;for(const s of this.redEdges)e+=s.isExit?2.5:1.2;e+=this.sectorsOnlyOne.size*3,e+=this.sectorsNotOne.size*4,e+=this.sectorsNotTwo.size*4.1,e+=this.sectorsNotZero.size*4.2;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}getInputDifficultyScoreB(){let e=0;const s=1,t=.8;e+=1.3*this.patternBoard.faces.filter(i=>!i.isExit).length,this.patternBoard.vertices.length===0?e-=10:this.patternBoard.vertices.length===1&&(e-=4);for(const i of this.faceValueMap.values())i===null?e+=.01:i===0?e+=.4:e+=.5;e+=this.blackEdges.size*s;for(const i of this.redEdges)i.isExit?i.exitVertex.edges.length>=4?e+=t:e+=2*t:e+=t;e+=this.sectorsOnlyOne.size*1.5,e+=this.sectorsNotOne.size*1.6,e+=this.sectorsNotTwo.size*1.7,e+=this.sectorsNotZero.size*1.8;for(const i of this.faceColorDualFeatures)e+=i.allFaces.size-1;return e}static empty(e){return new x(e)}static emptyWithVertexOrderLimit(e,s){const t=x.empty(e);for(const i of e.vertices)i.isExit&&i.edges.length>s&&t.addRedEdge(i.exitEdge);return t}static fromFeatures(e,s){const t=new x(e);for(const i of s)t.addFeature(i);return t}static fromSolution(e,s){return x.fromFeatures(e,[...e.edges.filter(t=>!s.includes(t)||!t.isExit).map(t=>s.includes(t)?new p(t):new g(t))])}clone(){return new x(this.patternBoard,new Map(this.faceValueMap),new Set(this.blackEdges),new Set(this.redEdges),new Set(this.sectorsNotZero),new Set(this.sectorsNotOne),new Set(this.sectorsNotTwo),new Set(this.sectorsOnlyOne),new Set(this.faceColorDualFeatures),new Map(this.faceToColorDualMap),new Set(this.sectors),new Map(this.edgeToSectorsMap))}getFeaturesArray(){return[...[...this.faceValueMap.entries()].map(([e,s])=>new z(e,s)),...this.faceColorDualFeatures,...[...this.blackEdges].map(e=>new p(e)),...[...this.redEdges].map(e=>new g(e)),...[...this.sectorsNotZero].map(e=>new M(e)),...[...this.sectorsNotOne].map(e=>new y(e)),...[...this.sectorsNotTwo].map(e=>new A(e)),...[...this.sectorsOnlyOne].map(e=>new C(e))]}getHighlanderFeaturesArray(){return this.getFeaturesArray().filter(e=>e instanceof z||e instanceof g&&e.edge.isExit)}getFaceValue(e){return this.faceValueMap.get(e)}getFaceColorDualFromFace(e){return this.faceToColorDualMap.get(e)??null}impliesFaceValue(e,s){const t=this.faceValueMap.get(e);return t!==void 0&&t===s}impliesBlackEdge(e){return this.blackEdges.has(e)}impliesRedEdge(e){return this.redEdges.has(e)}impliesSectorNotZero(e){return this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])||this.blackEdges.has(e.edges[1])}impliesSectorNotOne(e){return this.sectorsNotOne.has(e)||this.blackEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])}impliesSectorNotTwo(e){return this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e)||this.redEdges.has(e.edges[0])||this.redEdges.has(e.edges[1])}impliesSectorOnlyOne(e){return this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])}impliesFaceColorDualFeature(e){for(const s of this.faceColorDualFeatures)if(e.isSubsetOf(s))return!0;return!1}impliesFeature(e){if(e instanceof B)return this.impliesFaceColorDualFeature(e);if(e instanceof p)return this.impliesBlackEdge(e.edge);if(e instanceof g)return this.impliesRedEdge(e.edge);if(e instanceof M)return this.impliesSectorNotZero(e.sector);if(e instanceof y)return this.impliesSectorNotOne(e.sector);if(e instanceof A)return this.impliesSectorNotTwo(e.sector);if(e instanceof C)return this.impliesSectorOnlyOne(e.sector);if(e instanceof z)return this.impliesFaceValue(e.face,e.value);throw new Error(`unimplemented type of feature for FeatureSet: ${e}`)}getAffectedEdges(){return new Set([...this.blackEdges,...this.redEdges,...this.edgeToSectorsMap.keys()])}getAffectedSectors(){return new Set([...this.sectorsNotZero.values(),...this.sectorsNotOne.values(),...this.sectorsNotTwo.values(),...this.sectorsOnlyOne.values()])}getAffectedFaces(){return new Set([...this.faceValueMap.keys()])}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.hasSameShapeAs(e))return!1;const s=K(this.patternBoard,this.patternBoard);for(const t of s)try{const i=this.embedded(this.patternBoard,t);if(i&&i.equals(e))return!0}catch(i){if(!(i instanceof f))throw i}return!1}isCanonicalWith(e){w.length=0;for(const s of e)l()&&h(s.isAutomorphism),s.isIdentityAutomorphism||w.push(s);if(w.length===0)return!0;if(this.faceValueMap.size)for(let s=0;s<this.patternBoard.faces.length&&w.length;s++){const t=this.patternBoard.faces[s],i=this.faceValueMap.get(t),o=i===void 0?-2:i===null?-1:i;for(let r=0;r<w.length;r++){const a=w[r].inverseMapFace(t);l()&&h(a);const d=this.faceValueMap.get(a),c=d===void 0?-2:d===null?-1:d;if(c<o)return!1;c>o&&(w.splice(r,1),r--)}}if(this.blackEdges.size||this.redEdges.size)for(let s=0;s<this.patternBoard.edges.length&&w.length;s++){const t=this.patternBoard.edges[s],i=this.blackEdges.has(t)?1:this.redEdges.has(t)?2:0;for(let o=0;o<w.length;o++){const n=w[o].inverseMapEdge(t);l()&&h(n);const a=this.blackEdges.has(n)?1:this.redEdges.has(n)?2:0;if(a<i)return!1;a>i&&(w.splice(o,1),o--)}}if(this.sectorsNotZero.size||this.sectorsNotOne.size||this.sectorsNotTwo.size||this.sectorsOnlyOne.size)for(let s=0;s<this.patternBoard.sectors.length&&w.length;s++){const t=this.patternBoard.sectors[s],i=(this.sectorsOnlyOne.has(t)?1:0)+(this.sectorsNotOne.has(t)?2:0)+(this.sectorsNotTwo.has(t)?4:0)+(this.sectorsNotZero.has(t)?8:0);for(let o=0;o<w.length;o++){const n=w[o].inverseMapSector(t);l()&&h(n);const a=(this.sectorsOnlyOne.has(n)?1:0)+(this.sectorsNotOne.has(n)?2:0)+(this.sectorsNotTwo.has(n)?4:0)+(this.sectorsNotZero.has(n)?8:0);if(a<i)return!1;a>i&&(w.splice(o,1),o--)}}return!(this.faceColorDualFeatures.size&&!B.areCanonicalWith([...this.faceColorDualFeatures],w))}embedded(e,s){try{return x.fromFeatures(e,this.getFeaturesArray().flatMap(t=>t.embedded(s)))}catch(t){if(t instanceof f)return null;throw t}}hasSameShapeAs(e){return this.faceValueMap.size===e.faceValueMap.size&&this.blackEdges.size===e.blackEdges.size&&this.redEdges.size===e.redEdges.size&&this.sectorsNotZero.size===e.sectorsNotZero.size&&this.sectorsNotOne.size===e.sectorsNotOne.size&&this.sectorsNotTwo.size===e.sectorsNotTwo.size&&this.sectorsOnlyOne.size===e.sectorsOnlyOne.size&&this.faceColorDualFeatures.size===e.faceColorDualFeatures.size}getBoardMatchState(e,s,t=!1){let i=!0;for(const[o,r]of this.faceValueMap)if(e.faceValues[s.mapFace(o).index]!==r)return u.INCOMPATIBLE;for(const o of this.blackEdges){l()&&h(!o.isExit);const r=s.mapNonExitEdge(o).index;if(!e.blackEdgeValues[r]){if(i=!1,e.redEdgeValues[r])return u.INCOMPATIBLE;if(t)return u.DORMANT}}for(const o of this.redEdges)if(o.isExit){const r=s.mapExitEdges(o);for(const n of r){const a=n.index;if(!e.redEdgeValues[a]){if(i=!1,e.blackEdgeValues[a])return u.INCOMPATIBLE;if(t)return u.DORMANT}}}else{const r=s.mapNonExitEdge(o).index;if(!e.redEdgeValues[r]){if(i=!1,e.blackEdgeValues[r])return u.INCOMPATIBLE;if(t)return u.DORMANT}}for(const o of this.sectorsNotZero){const r=s.mapSector(o).index;if(!e.sectorNotZeroValues[r]&&(i=!1,t))return u.DORMANT}for(const o of this.sectorsNotOne){const r=s.mapSector(o).index;if(!e.sectorNotOneValues[r]&&(i=!1,t))return u.DORMANT}for(const o of this.sectorsNotTwo){const r=s.mapSector(o).index;if(!e.sectorNotTwoValues[r]&&(i=!1,t))return u.DORMANT}for(const o of this.sectorsOnlyOne){const r=s.mapSector(o).index;if(!e.sectorOnlyOneValues[r]&&(i=!1,t))return u.DORMANT}for(const o of this.faceColorDualFeatures){const r=o.primaryFaces.map(d=>e.faceColors[s.mapFace(d).index]),n=r[0];l()&&h(n);for(const d of r)if(d!==n&&(i=!1,t))return u.DORMANT;const a=o.secondaryFaces.map(d=>e.faceColors[s.mapFace(d).index]);if(a.length>1){const d=a[0];for(const c of a)if(c!==d&&(i=!1,t))return u.DORMANT}if(a.length){const d=o.secondaryFaces.map(c=>e.oppositeFaceColors[s.mapFace(c).index]);for(const c of d)if(c!==n&&(i=!1,t))return u.DORMANT;if(!i&&!t){for(const c of d)if(a.includes(c))return u.INCOMPATIBLE}}if(!i&&!t){const d=o.primaryFaces.map(c=>e.oppositeFaceColors[s.mapFace(c).index]);for(const c of r)if(a.includes(c))return u.INCOMPATIBLE;for(const c of d)if(r.includes(c))return u.INCOMPATIBLE}}return i?u.MATCH:u.DORMANT}getShapeString(){return`${this.faceValueMap.size} ${this.blackEdges.size} ${this.redEdges.size} ${this.sectorsNotZero.size} ${this.sectorsNotOne.size} ${this.sectorsNotTwo.size} ${this.sectorsOnlyOne.size} ${this.faceColorDualFeatures.size}`}isSubsetOf(e){for(const s of this.blackEdges)if(!e.impliesBlackEdge(s))return!1;for(const s of this.redEdges)if(!e.impliesRedEdge(s))return!1;for(const[s,t]of this.faceValueMap)if(!e.impliesFaceValue(s,t))return!1;for(const s of this.sectorsNotZero)if(!e.impliesSectorNotZero(s))return!1;for(const s of this.sectorsNotOne)if(!e.impliesSectorNotOne(s))return!1;for(const s of this.sectorsNotTwo)if(!e.impliesSectorNotTwo(s))return!1;for(const s of this.sectorsOnlyOne)if(!e.impliesSectorOnlyOne(s))return!1;for(const s of this.faceColorDualFeatures)if(!e.impliesFaceColorDualFeature(s))return!1;return!0}equals(e){if(!this.hasSameShapeAs(e))return!1;for(const[t,i]of this.faceValueMap)if(e.faceValueMap.get(t)!==i)return!1;for(const t of this.blackEdges)if(!e.blackEdges.has(t))return!1;for(const t of this.redEdges)if(!e.redEdges.has(t))return!1;for(const t of this.sectorsNotZero)if(!e.sectorsNotZero.has(t))return!1;for(const t of this.sectorsNotOne)if(!e.sectorsNotOne.has(t))return!1;for(const t of this.sectorsNotTwo)if(!e.sectorsNotTwo.has(t))return!1;for(const t of this.sectorsOnlyOne)if(!e.sectorsOnlyOne.has(t))return!1;const s=new Set;e.faceColorDualFeatures.forEach(t=>s.add(t.toCanonicalString()));for(const t of this.faceColorDualFeatures)if(!s.has(t.toCanonicalString()))return!1;return!0}applyFeaturesFrom(e){e.getFeaturesArray().forEach(s=>this.addFeature(s))}union(e){if(this.size<e.size)return e.union(this);const s=this.clone();try{return s.applyFeaturesFrom(e),s}catch(t){if(t instanceof f)return null;throw t}}isCompatibleWith(e){return this.union(e)!==null}getQuickCompatibilityWith(e){let s=!0;for(const i of this.blackEdges){if(e.impliesRedEdge(i))return S.INCOMPATIBLE;s&&!e.impliesBlackEdge(i)&&(s=!1)}for(const i of this.redEdges){if(e.impliesBlackEdge(i))return S.INCOMPATIBLE;s&&!e.impliesRedEdge(i)&&(s=!1)}for(const i of this.sectorsNotZero)s&&!e.impliesSectorNotZero(i)&&(s=!1);for(const i of this.sectorsNotOne){if(e.impliesSectorOnlyOne(i))return S.INCOMPATIBLE;s&&!e.impliesSectorNotOne(i)&&(s=!1)}for(const i of this.sectorsNotTwo)s&&!e.impliesSectorNotTwo(i)&&(s=!1);for(const i of this.sectorsOnlyOne){if(e.impliesSectorNotOne(i))return S.INCOMPATIBLE;s&&!e.impliesSectorOnlyOne(i)&&(s=!1)}for(const i of this.faceColorDualFeatures)s&&!e.impliesFaceColorDualFeature(i)&&(s=!1);let t=!0;for(const[i,o]of this.faceValueMap){const r=e.getFaceValue(i);if(r===void 0)t=!1;else if(r!==o)return S.INCOMPATIBLE}return t?s?S.MATCH:S.NO_MATCH_NEEDS_STATE:S.NO_MATCH_NEEDS_FACE_VALUES}toCanonicalString(){return`feat:${L.sortBy(this.getFeaturesArray().map(e=>e.toCanonicalString())).join("/")}`}getSolutions(e=!1){const s=this.getFeaturesArray();let t=Z.getSolutions(this.patternBoard,s);return t.length&&e&&(t=G(t,Q(this.patternBoard,s)).highlanderSolutions),t}hasSolution(e=!1){return e?this.getSolutions(e).length>0:Z.hasSolution(this.patternBoard,this.getFeaturesArray())}addSolvedEdgeFeatures(e){const s=new Array(this.patternBoard.edges.length).fill(!1),t=new Array(this.patternBoard.edges.length).fill(!1),i=new Set(this.patternBoard.edges),o=new Set(this.patternBoard.vertices.filter(r=>r.isExit));for(const r of e){const n=new Set(i);for(const a of r)s[a.index]=!0,n.delete(a);for(const a of n)t[a.index]=!0;for(const a of[...o])r.has(a.exitEdge)&&o.delete(a),a.edges.filter(d=>r.has(d)).length<2&&o.delete(a)}for(const r of this.patternBoard.edges)if(!r.isExit){const n=s[r.index],a=t[r.index];n&&!a&&this.addBlackEdge(r),!n&&a&&this.addRedEdge(r)}for(const r of o)this.addRedEdge(r.exitEdge)}addSolvedSectorFeatures(e){const s=new Array(this.patternBoard.sectors.length).fill(!1),t=new Array(this.patternBoard.sectors.length).fill(!1),i=new Array(this.patternBoard.sectors.length).fill(!1);for(const o of e)for(const r of this.patternBoard.sectors){const n=(o.has(r.edges[0])?1:0)+(o.has(r.edges[1])?1:0);n===0?s[r.index]=!0:n===1?t[r.index]=!0:n===2&&(i[r.index]=!0)}for(const o of this.patternBoard.sectors){const r=s[o.index],n=t[o.index],a=i[o.index];n&&!r&&!a?this.addSectorOnlyOne(o):r&&n&&!a?this.addSectorNotTwo(o):r&&a&&!n?this.addSectorNotOne(o):!r&&n&&a&&this.addSectorNotZero(o)}}addSolvedFaceColorDualFeatures(e){l()&&h(e.length>0);const s=b.get(this.patternBoard),t=new Set(s.connectedFacePairs.map(i=>new X(i)));for(const i of e)for(const o of[...t]){let r=!0;for(const n of o.pair.shortestPath)i.has(n)&&(r=!r);r?o.isOnlyOpposite=!1:o.isOnlySame=!1,!o.isOnlySame&&!o.isOnlyOpposite&&t.delete(o)}for(const i of t)i.isOnlySame?this.addSameColorFaces(i.pair.a,i.pair.b):i.isOnlyOpposite&&this.addOppositeColorFaces(i.pair.a,i.pair.b)}serialize(){const e={};return this.faceValueMap.size>0&&(e.faceValues=[...this.faceValueMap.entries()].map(([s,t])=>({face:s.index,value:t}))),this.blackEdges.size>0&&(e.blackEdges=[...this.blackEdges].map(s=>s.index)),this.redEdges.size>0&&(e.redEdges=[...this.redEdges].map(s=>s.index)),this.sectorsNotZero.size>0&&(e.sectorsNotZero=[...this.sectorsNotZero].map(s=>s.index)),this.sectorsNotOne.size>0&&(e.sectorsNotOne=[...this.sectorsNotOne].map(s=>s.index)),this.sectorsNotTwo.size>0&&(e.sectorsNotTwo=[...this.sectorsNotTwo].map(s=>s.index)),this.sectorsOnlyOne.size>0&&(e.sectorsOnlyOne=[...this.sectorsOnlyOne].map(s=>s.index)),this.faceColorDualFeatures.size>0&&(e.faceColorDualFeatures=[...this.faceColorDualFeatures].map(s=>s.serialize())),e}static deserialize(e,s){const t=new x(s);for(const i of e.faceValues||[])t.addFaceValue(s.faces[i.face],i.value);for(const i of e.blackEdges||[])t.addBlackEdge(s.edges[i]);for(const i of e.redEdges||[])t.addRedEdge(s.edges[i]);for(const i of e.sectorsNotZero||[])t.addSectorNotZero(s.sectors[i]);for(const i of e.sectorsNotOne||[])t.addSectorNotOne(s.sectors[i]);for(const i of e.sectorsNotTwo||[])t.addSectorNotTwo(s.sectors[i]);for(const i of e.sectorsOnlyOne||[])t.addSectorOnlyOne(s.sectors[i]);for(const i of e.faceColorDualFeatures||[])t.addFaceColorDual(B.deserialize(i,s));return t}}const oe={solveEdges:!0,solveSectors:!1,solveFaceColors:!1,highlander:!1};class X{constructor(e){E(this,"isOnlySame",!0);E(this,"isOnlyOpposite",!0);this.pair=e}}export{oe as B,x as F,b as a,u as b,S as c,G as f,Q as g};
