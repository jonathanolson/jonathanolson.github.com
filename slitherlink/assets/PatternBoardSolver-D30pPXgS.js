var x=Object.defineProperty;var M=(r,e,t)=>e in r?x(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var l=(r,e,t)=>(M(r,typeof e!="symbol"?e+"":e,t),t);import{L as f}from"./logic-solver-DfLyjx-d.js";import{T as v,i as T,f as L,j as N,a as k,l as V,c as A}from"./operations-CXBIDRbn.js";import{e as m,f as c}from"./getCoordinateClusteredMap-DnTHDDo2.js";class E{constructor(e){l(this,"nameMap",new Map);l(this,"termMap",new Map);l(this,"solver",new f.Solver);e&&this.addFormulas(e)}addFormula(e){this.solver.require(e instanceof v?e.name:e.logic),this.addTermsFrom(e)}addFormulas(e){for(const t of e)this.addFormula(t)}addTermsFrom(e){if(e instanceof v)this.nameMap.has(e.name)?m()&&(c(this.nameMap.get(e.name)===e.value),c(this.termMap.get(e.value)===e.name)):(this.nameMap.set(e.name,e.value),m()&&c(!this.termMap.has(e.value)),this.termMap.set(e.value,e.name));else for(const t of e.parameters)this.addTermsFrom(t)}getNextSolution(){let e=null;if(f.disablingAssertions(()=>{e=this.solver.solve()}),e){const t=e.getTrueVars(),s=new Set(t),i=new Set([...this.nameMap.keys()].filter(o=>!s.has(o)));return this.solver.require(f.or(...[...s].map(o=>`-${o}`),...[...i].map(o=>o))),t.map(o=>{const n=this.nameMap.get(o);return m()&&c(n!==void 0),n})}else return null}}class P{constructor(e){this.vertex=e}isPossibleWith(e){const t=this.vertex.edges.filter(s=>e(s)).length;return t===0||t===2}getPossibleFormula(e){return T(this.vertex.edges.map(t=>e(t)))}}class p{constructor(e){this.possibleLoops=e}isPossibleWith(e){return this.possibleLoops.every(t=>t.some(s=>!e(s)))}getPossibleFormula(e){return this.possibleLoops.length?L(this.possibleLoops.map(t=>N(t.map(s=>e(s))))):k}static fromBoard(e){return new p(p.findLoops(e.edges,e.vertices).map(t=>[...t]))}static findLoops(e,t){const s=[],i=new Set,o=new Set,n=[],F=(u,S)=>{for(const d of u.edges){if(d.vertices.length<2)continue;const a=d.vertices.find(g=>g!==u);if(m()&&c(a),!o.has(a))if(a===S&&n.length>=2){const g=[...n,d],w=g.map(b=>b.index).sort().join(",");i.has(w)||(i.add(w),s.push(new Set(g)))}else o.add(a),n.push(d),F(a,S),n.pop(),o.delete(a)}};for(const u of t)F(u,u);return s}}const j=r=>[...r.vertices.map(e=>new P(e)),p.fromBoard(r)];class h{constructor(e){l(this,"solver",new E);l(this,"getFormula");this.getFormula=t=>new v(t,`e${t.index}`);for(const t of j(e))this.addFeature(t);e.vertices.length===0&&this.solver.addFormula(V([this.getFormula(e.edges[0]),A(this.getFormula(e.edges[0]))]))}addFeature(e){this.solver.addFormula(e.getPossibleFormula(this.getFormula))}getNextSolution(){return this.solver.getNextSolution()}getRemainingSolutions(){const e=[];for(;;){const t=this.getNextSolution();if(t)e.push(t);else break}return e}static forEachSolution(e,t,s){const i=new h(e);for(const o of t)i.addFeature(o);for(;;){const o=i.getNextSolution();if(o)s(o);else break}}static countSolutions(e,t){let s=0;return h.forEachSolution(e,t,()=>{s++}),s}static getSolutions(e,t){const s=new h(e);for(const i of t)s.addFeature(i);return s.getRemainingSolutions()}static hasSolution(e,t){const s=new h(e);for(const i of t)s.addFeature(i);return s.getNextSolution()!==null}}export{E as F,h as P,j as g};
