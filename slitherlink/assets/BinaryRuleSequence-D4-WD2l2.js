var N=Object.defineProperty;var G=(c,e,t)=>e in c?N(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var v=(c,e,t)=>(G(c,typeof e!="symbol"?e+"":e,t),t);import{H as k,B as C}from"./BinaryRuleCollection-ji_RLyUt.js";import{P as D,d as P,s as L}from"./PatternRule-BA2nP0w7.js";import{g as V}from"./generalPatternBoardGenerations-BAr_gTbc.js";import{q as A,n as I,E as U,G as _,H,I as W,J as Z,K as z,L as J,M as K,N as Y,t as Q,v as X,p as q}from"./patternBoards-DyfRjV5l.js";import{_ as F,e as E,f as x}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{l as $}from"./Vector2Property-95p6aBvi.js";import{B as ee,F as y}from"./FeatureSet-CMNix-co.js";import{B as te,R as se,S as T}from"./RichSolution-Cj_kfC3b.js";import{P as re}from"./PatternBoardSolver-D30pPXgS.js";const oe={...ee,featureLimit:Number.POSITIVE_INFINITY,hitFeatureLimitCallback:null,includeFaceValueZero:!1,prefilterRules:null,logModulo:1e6,vertexOrderLimit:null};class w{constructor(e,t){this.antecedent=e,this.consequent=t}toString(){return`${this.antecedent.toString()} -> ${this.consequent.toString()}`}static implicationSetClosure(e,t){let s=t,o=!0;for(;o;){o=!1;const d=e.length;for(let u=0;u<d;u++){const a=e[u],i=a.antecedent,n=a.consequent,l=s;(i&l)===i&&i!==l&&(n&l)!==n&&(s|=n,o=!0)}}return s}static implicationSetClosureLessThanI(e,t,s){if((t&1n<<BigInt(s))!==0n)return null;let o=t&~((1n<<BigInt(s))-1n)|1n<<BigInt(s),u=~((1n<<BigInt(s+1))-1n)&~o,a=!0;for(;a;){a=!1;const i=e.length;for(let n=0;n<i;n++){const l=e[n],r=l.antecedent,g=l.consequent;if((r&o)===r&&r!==o&&(g&o)!==g){if(g&u)return null;o|=g,a=!0}}}return o}}class ne{static forEachImplication(e,t,s,o){const d=(o==null?void 0:o.logModulo)??1e6,u=o==null?void 0:o.logModuloCallback,a=[];let i=0n;const n=new Array(e).fill(0n);let l=0;const r=Date.now();for(;i!==null;){l++,l%d===0&&u&&u(l,i,a,Math.round((Date.now()-r)/1e3));const g=t(i);if(i!==g){const p=new w(i,g);s(p),a.push(p);let b=i;if(b!==0n&&(b&b-1n)===0n){let B=0;for(;b>1n;)b>>=1n,B++;const f=~((1n<<BigInt(B+1))-1n);n[B]|=f&g}}let h=null;for(let p=0;p<e;p++){if((i&n[p])!==n[p])continue;const b=w.implicationSetClosureLessThanI(a,i,p);if(b!==null){h=b;break}}if(h!==null)i=h;else break}}}const R=(c,e)=>(c.withOptionalData&1n<<BigInt(e))!==0n;class le{constructor(e,t){v(this,"singleAttributeObjectsMap");v(this,"doubleAttributeObjectsMap");this.numAttributes=e,this.solutionAttributeSets=t,t.length>350?(this.singleAttributeObjectsMap=F.range(0,e).map(s=>t.filter(o=>R(o,s))),console.log(`single filter size: ${F.sum(this.singleAttributeObjectsMap.map(s=>s.length))}`),t.length>1500?(this.doubleAttributeObjectsMap=F.range(0,e).map(s=>F.range(s+1,e).map(o=>this.singleAttributeObjectsMap[s].filter(d=>R(d,o)))),console.log(`double filter size: ${F.sum(this.doubleAttributeObjectsMap.map(s=>F.sum(s.map(o=>o.length))))}`)):this.doubleAttributeObjectsMap=null):(this.singleAttributeObjectsMap=null,this.doubleAttributeObjectsMap=null)}getSolutionAttributeSets(e){let t=this.solutionAttributeSets;if(this.singleAttributeObjectsMap){let s=[],o=e,d=0;for(;o>0n;)o&1n&&s.push(d),o>>=1n,d++;if(this.doubleAttributeObjectsMap&&s.length>=2)for(let u=0;u<s.length-1;u++){const a=s[u],i=s[u+1],n=this.doubleAttributeObjectsMap[a][i-(a+1)];n.length<t.length&&(t=n)}else if(s.length>=1)for(let u=0;u<s.length;u++){const a=this.singleAttributeObjectsMap[s[u]];a.length<t.length&&(t=a)}}return t}}const ie={logModulo:1e6},ae=(c,e,t,s,o,d)=>{const u=$()({},ie,d),a={solveEdges:e,solveSectors:t,solveFaceColors:s,highlander:o},i=c.patternBoard,n=c.getFeaturesArray(),l=new te(i,a),r=l.numAttributes,h=re.getSolutions(i,n).map(f=>new se(i,l,f,a.highlander));let p;if(o){const f=new k(c,l,h);p=m=>{const S=f.getSolutionAttributeSets(m);return T.solutionClosure(r,S,m)}}else{const f=new le(r,h.map(m=>l.getSolutionAttributeSet(m.solutionSet)));p=m=>{const S=f.getSolutionAttributeSets(m);return T.solutionClosure(r,S,m)}}const b=(1n<<BigInt(r))-1n,B=[];return ne.forEachImplication(r,p,f=>{if(f.consequent===b)return;const m=c.clone(),S=c.clone(),O=l.getBitsFeatureSet(f.antecedent);m.applyFeaturesFrom(O);const j=l.getBitsFeatureSet(f.consequent);S.applyFeaturesFrom(j),!m.equals(S)&&B.push(new D(i,m,S,o))},{logModulo:u.logModulo,logModuloCallback:(f,m,S,O)=>{console.log(`${f.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")} [${l.getBinaryString(m)}] (${l.getIndicesString(m)}) ${S.length} ${O}s`)}}),B},ce=(c,e)=>{const t=$()({},oe,e);E()&&x(!isFinite(t.featureLimit));const s=A(c,c),o=t.highlander?c.faces.filter(r=>{if(!r.isExit||r.edges.length!==1)return!1;const h=r.edges[0].faces.find(p=>p!==r);return h?!h.isExit:!1}):[],d=[],u=[...c.faces.filter(r=>!r.isExit),...o],a=(r,g)=>{if(g===u.length)r.isCanonicalWith(s)&&d.push(r);else{const h=u[g],p=h.isExit?[]:F.range(t.includeFaceValueZero?0:1,h.edges.length);t.highlander&&p.push(null),a(r,g+1);for(const b of p){const B=r.clone();B.addFaceValue(h,b),a(B,g+1)}}},i=t.vertexOrderLimit===null?y.empty(c):y.emptyWithVertexOrderLimit(c,t.vertexOrderLimit);a(i,0);const n=(t.prefilterRules??[]).flatMap(r=>r.getEmbeddedRules(A(r.patternBoard,c))),l=[];for(const r of d){console.log(r.toCanonicalString());const g=ae(r,t.solveEdges,t.solveSectors,t.solveFaceColors,t.highlander,{logModulo:t.logModulo});for(const h of g)h.isRedundant(n)||(l.push(h),n.push(...h.getEmbeddedRules(s)))}return F.sortBy(l,r=>r.inputFeatureSet.getInputDifficultyScoreA())};class M{constructor(e){v(this,"boardType");v(this,"solveEdges");v(this,"solveSectors");v(this,"solveFaceColors");v(this,"highlander");v(this,"vertexOrderLimit");v(this,"collection");v(this,"processedBoards");v(this,"currentBoards");this.boardType=e.boardType,this.solveEdges=e.solveEdges,this.solveSectors=e.solveSectors,this.solveFaceColors=e.solveFaceColors,this.highlander=e.highlander,this.vertexOrderLimit=e.vertexOrderLimit,this.collection=C.deserialize(e.collection),this.processedBoards=e.processedBoards.map(P),this.currentBoards=e.currentBoards.map(P)}getName(){return M.getName(this)}getGenerations(){const e={general:[...I.map(t=>[t]),...V],square:[[U],[_],[H],[W],[Z],[z],[J],[K],[Y],...Q],hexagonal:[...I.map(t=>[t]),...X]}[this.boardType];return E()&&x(e,`Unknown board type: ${this.boardType}`),e}getCurrentGeneration(){return this.getGenerations().find(t=>t.some(s=>!this.processedBoards.includes(s)))??null}getNextBoard(){const e=this.getCurrentGeneration();if(e){const t=e.filter(s=>!this.processedBoards.includes(s)&&!this.currentBoards.includes(s));return t.length?t[0]:null}else return null}getStatusString(){const e=this.getName(),t=this.getCurrentGeneration();if(t){let s=`${e}
`;const o=t.filter(n=>this.processedBoards.includes(n)),d=t.filter(n=>this.currentBoards.includes(n));E()&&x(d.length===this.currentBoards.length);const u=t.filter(n=>!this.processedBoards.includes(n)&&!this.currentBoards.includes(n)),a=n=>{let l=`${Math.floor(100*n/t.length)}`;l.length===1&&(l=" "+l);let r=`${n}`;for(;r.length<`${t.length}`.length;)r=" "+r;return`${l}% ${r}/${t.length}`},i=(n,l)=>`  ${a(n.length)} ${l} ${n.map(r=>r.name).join(", ")}
`;return s+=i(o,"processed | "),s+=i(d,"current   | "),s+=i(u,"remaining | "),s}else return`${e} (complete)`}getCollectionForBoard(e){const t=q.get(e);E()&&x(t,"planarPatternMap should be defined");const s=this.collection.withPatternBoardFilter(d=>A(d,e).length>0),o=ce(e,{solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,includeFaceValueZero:e.faces.filter(d=>!d.isExit).length===1,prefilterRules:s.getRules()});return C.fromRules(o)}addProcessingBoard(e){this.currentBoards.push(e)}removeProcessingBoard(e){this.currentBoards=this.currentBoards.filter(t=>t!==e)}addProcessedBoardCollection(e,t){this.collection=this.collection.withRules(t.getRules()),this.processedBoards.push(e),this.removeProcessingBoard(e)}serialize(){return{boardType:this.boardType,solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,collection:this.collection.serialize(),processedBoards:this.processedBoards.map(L),currentBoards:this.currentBoards.map(L)}}static deserialize(e){return new M(e)}static empty(e){return new M({boardType:e.boardType,solveEdges:e.solveEdges,solveSectors:e.solveSectors,solveFaceColors:e.solveFaceColors,highlander:e.highlander,vertexOrderLimit:e.vertexOrderLimit,collection:C.empty().serialize(),processedBoards:[],currentBoards:[]})}static getName(e){let t=`${e.boardType}-`;if(e.vertexOrderLimit!==null)if(e.boardType==="square"&&e.vertexOrderLimit===4||e.boardType==="hexagonal"&&e.vertexOrderLimit===3)t+="only-";else throw new Error("Specify naming convention for vertexOrderLimit");if(e.solveEdges&&e.solveSectors&&e.solveFaceColors)t+="all";else{let s=!1;e.solveEdges&&(t+="edge",s=!0),e.solveSectors&&(s&&(t+="-"),t+="sector",s=!0),e.solveFaceColors&&(s&&(t+="-"),t+="color",s=!0)}return e.highlander||(t+="-unrestricted"),t}}export{M as B};
