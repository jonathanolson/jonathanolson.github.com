import{d as q}from"./BasicPuzzle-Bt7fJ87M.js";import{K as V,L as A,M as D,O as z}from"./SATSolver-BXmuhJOp.js";import{k as F,O as P}from"./Vector2Property-CFyCN_2h.js";import{S as h}from"./SlitherQueryParameters-CLuuf2TR.js";import{_ as b,d as v,e as O}from"./patternBoards-DzVBPT7g.js";import{c as B}from"./Theme-CG_JTTcq.js";import{W as j,E as _}from"./DisplayEmbedding-0vgCuFSa.js";import{N as $,F as J,P as w,S as C,j as I}from"./PhetioControlledVisibilityProperty-thEXBwUY.js";let S=null,k=0;const ee=()=>{if(S&&(k++,k>5)){const t=S;S=null,t(null)}},K=async function(t){return new Promise((i,s)=>{S=i,k=0,h.debugSleep&&console.log("sleep start"),setTimeout(()=>{h.debugSleep&&console.log("sleep end"),S===i&&(S=null,i(null)),h.debugSleep&&console.log("resolved")},t)})};class Q extends Error{constructor(){super("Interrupted")}}const N=async function(t,i){if(await K(t),h.debugSleep&&console.log("after sleep before interrupt check"),i.value)throw new Q},se=async(t,i,s)=>{let m=0;for(;m++<100;){const c=q.fromFaces(t,()=>null),p=F.shuffle(t.faces);let o=-1,r=[];const u=e=>{try{return r=A(t,e,{maxIterations:1e4,failOnMultipleSolutions:!0}),r.length}catch(d){if(d instanceof D)return 2;if(d instanceof z)return 0;throw d}};for(const e of p){h.debugSleep&&console.log("going to sleep"),i&&await N(0,i),h.debugSleep&&console.log("finished sleep, generating next!");let d=F.shuffle(b.range(0,e.edges.length));d[0]===0&&(d=F.shuffle(d));for(const g of d){const a=c.createDelta();if(a.setFaceValue(e,g),o=u(a),o>=1){a.apply(c),s&&s.emit(t.faces.indexOf(e),g);break}}if(o===1)break}if(o===1)return V(t,c,r[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},le=async(t,i=()=>!0,s,m)=>{const c=t.board,p=t.cleanState.clone(),o=F.shuffle(c.faces),r=u=>{try{return A(c,u,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(e){if(e instanceof D)return!0;throw e}};v()&&O(!r(p),"Initial state has multiple solutions"),v()&&O(i(c,p.clone()),"Initial state is not easy enough");for(const u of o){s&&await N(0,s);const e=p.getFaceValue(u);if(e===null){m&&m.emit(c.faces.indexOf(u),null);continue}const d=p.createDelta();d.setFaceValue(u,null),!r(d)&&i(c,d.clone())?(d.apply(p),m&&m.emit(c.faces.indexOf(u),null)):m&&m.emit(c.faces.indexOf(u),e)}return V(t.board,p,t.blackEdges)};class re extends ${constructor(i,s,m,c=null){let p;const o=e=>new C().moveToPoint(e.start.viewCoordinates).lineToPoint(e.end.viewCoordinates).getStrokedShape(new I({lineWidth:.2,lineCap:"round"})).getStrokedShape(new I({lineWidth:.02})),r=(e,d)=>new w(o(e),{fill:d}),u=[];if(s.type==="ForcedLine")p=[r(s.whiteEdge,"red"),r(s.blackEdge,"blue")];else if(s.type==="AlmostEmptyToRed")p=[r(s.whiteEdge,"red"),...s.redEdges.map(e=>r(e,"blue"))];else if(s.type==="JointToRed")p=[...s.whiteEdges.map(e=>r(e,"red")),...s.blackEdges.map(e=>r(e,"blue"))];else if(s.type==="FaceSatisfied")p=[...s.whiteEdges.map(e=>r(e,"red")),...s.blackEdges.map(e=>r(e,"blue"))];else if(s.type==="FaceAntiSatisfied")p=[...s.whiteEdges.map(e=>r(e,"red")),...s.redEdges.map(e=>r(e,"blue"))];else if(s.type==="ForcedSolveLoop")p=[...s.regionEdges.map(e=>r(e,"blue")),...s.pathEdges.map(e=>r(e,"red"))];else if(s.type==="PrematureForcedLoop")p=[...s.regionEdges.map(e=>r(e,"blue")),...s.pathEdges.map(e=>r(e,"red"))];else if(s.type==="CompletingEdgesAfterSolve")p=[...s.whiteEdges.map(e=>r(e,"red"))];else if(s.type==="FaceColoringBlackEdge")p=[r(s.edge,"red")];else if(s.type==="FaceColoringRedEdge")p=[r(s.edge,"red")];else if(s.type==="FaceColorToBlack")p=[r(s.edge,"red")];else if(s.type==="FaceColorToRed")p=[r(s.edge,"red")];else if(s.type==="FaceColorNoTrivialLoop")p=[...s.face.edges.map(e=>r(e,"red"))];else if(s.type==="FaceColorMatchToRed"||s.type==="FaceColorMatchToBlack"||s.type==="FaceColorBalance")p=[...s.balancedPairs.flatMap((e,d)=>{const g=["green","blue","black"][d%3],a=["magenta","orange","yellow"][d%3];return[...e[0].map(f=>r(f,g)),...e[1].map(f=>r(f,a))]})],s.type==="FaceColorMatchToRed"?p.push(...s.matchingEdges.map(e=>r(e,"red"))):s.type==="FaceColorMatchToBlack"?p.push(...s.matchingEdges.map(e=>r(e,"red"))):s.type==="FaceColorBalance"&&(p.push(...s.matchingEdges.map(e=>r(e,"orange"))),p.push(...s.oppositeEdges.map(e=>r(e,"red"))));else if(s.type==="DoubleMinusOneFaces")p=[...s.toBlackEdges.map(e=>r(e,"red")),...s.toRedEdges.map(e=>r(e,"red"))];else if(s.type==="SingleEdgeToSector"||s.type==="DoubleEdgeToSector")p=[s.sector.edge,s.sector.next.edge].map(e=>r(e,"red"));else if(s.type==="ForcedSector"){const e=[...s.toRedEdges,...s.toBlackEdges];p=[s.sector.edge,s.sector.next.edge].map(d=>r(d,e.includes(d)?"red":"blue"))}else if(s.type==="StaticFaceSectors")p=b.uniq(s.sectors.flatMap(e=>[e.edge,e.next.edge])).map(e=>r(e,"red"));else if(s.type==="VertexState")p=s.vertex.edges.map(e=>r(e,"blue"));else if(s.type==="VertexStateToEdge")p=[...s.toBlackEdges.map(e=>r(e,"red")),...s.toRedEdges.map(e=>r(e,"red"))];else if(s.type==="VertexStateToSector")p=b.uniq(s.sectors.flatMap(e=>[e.edge,e.next.edge])).map(e=>r(e,"red"));else if(s.type==="VertexStateToSameFaceColor"||s.type==="VertexStateToOppositeFaceColor")p=b.uniq([...s.facesA,...s.facesB].flatMap(e=>e.edges)).map(e=>r(e,"red"));else if(s.type==="FaceState")p=s.face.edges.map(e=>r(e,"red"));else if(s.type==="FaceStateToEdge")p=[...s.toBlackEdges.map(e=>r(e,"red")),...s.toRedEdges.map(e=>r(e,"red"))];else if(s.type==="FaceStateToSector")p=b.uniq(s.sectors.flatMap(e=>[e.edge,e.next.edge])).map(e=>r(e,"red"));else if(s.type==="FaceStateToSameFaceColor"||s.type==="FaceStateToOppositeFaceColor"){const e=new Set([...s.facesA,...s.facesB].flatMap(g=>g.edges)),d=s.face.edges.filter(g=>!e.has(g));p=[...[...e].map(g=>r(g,"red")),...d.map(g=>r(g,"blue"))]}else if(s.type==="FaceStateToVertexState")p=s.face.edges.filter(d=>s.vertices.includes(d.start)||s.vertices.includes(d.end)).map(d=>r(d,"red"));else if(s.type==="Pattern"){if(p=[],c){const e=j.getDisplayEmbeddingFromRule(s.rule,s.boardPatternBoard,s.embedding),d=new _(s.rule,e,{inputListeners:[new J({fire:()=>{console.log(s.rule.getBinaryIdentifier());const l=self.open(`./rule?r=${encodeURIComponent(s.rule.getBinaryIdentifier())}`,"_blank");l&&l.focus()}})],cursor:"pointer"}),g=.5+.05,a=.15,f=.1,M=l=>e.expandedBounds[l.minCoordinate]+a-(c[l.minCoordinate]+g),T=l=>c[l.maxCoordinate]-g-(e.expandedBounds[l.maxCoordinate]-a),R=l=>Math.min((c[l.opposite.size]-2*g)/d[l.opposite.size],Math.max(M(l),T(l))/d[l.size],1),W=l=>{d[l.opposite.centerCoordinate]=e.expandedBounds[l.opposite.centerCoordinate],M(l)>T(l)?(d[l.maxSide]=e.expandedBounds[l.minCoordinate]-a,d[l.minSide]<c[l.minCoordinate]+f&&(d[l.minSide]=c[l.minCoordinate]+f)):(d[l.minSide]=e.expandedBounds[l.maxCoordinate]+a,d[l.maxSide]>c[l.maxCoordinate]-f&&(d[l.maxSide]=c[l.maxCoordinate]-f)),d[l.opposite.minSide]<c[l.opposite.minCoordinate]+f&&(d[l.opposite.minSide]=c[l.opposite.minCoordinate]+f),d[l.opposite.maxSide]>c[l.opposite.maxCoordinate]-f&&(d[l.opposite.maxSide]=c[l.opposite.maxCoordinate]-f)};let y=P.VERTICAL,x=R(y);if(x<1){const l=R(y.opposite);l>x&&(y=y.opposite,x=l)}d.scale(Math.max(x,.3)),W(y);{const l=e.tightBounds.dilated(.21),E=.3;p.push(new w(C.roundRectangle(l.x,l.y,l.width,l.height,E,E),{stroke:B.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const l=e.tightBounds.dilated(.21),E=.3;p.push(new w(C.roundRectangle(l.x,l.y,l.width,l.height,E,E),{stroke:B.blackLineColorProperty,lineWidth:.13,pickable:!1}))}p.push(d)}}else p=[],console.log(`unknown type: ${s.type}`);super({children:p,pickable:s.type==="Pattern"?null:!1}),this.board=i,this.annotation=s,this.style=m,this.disposeEmitter.addListener(()=>u.forEach(e=>e()))}}export{re as A,le as a,se as g,N as i,K as s,ee as w};
