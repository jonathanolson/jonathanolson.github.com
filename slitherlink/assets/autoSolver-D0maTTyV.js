var xe=Object.defineProperty;var Ae=(F,e,t)=>e in F?xe(F,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):F[e]=t;var C=(F,e,t)=>(Ae(F,typeof e!="symbol"?e+"":e,t),t);import{h as Ve}from"./UnivariatePolynomial-1rLpyqfN.js";import{c as Re}from"./PhetioControlledVisibilityProperty-CzTgKbkx.js";import{L as O}from"./TextPushButton-Coq2A-51.js";import{E as f,a as z,b as k,F as N,S as I,f as Oe,g as Te,h as be,i as Be,j as ze,k as Pe,l as ve,m as ke,n as De,V as ee,o as U,p as Me,s as Ie,q as He,r as We,t as Ne}from"./BasicPuzzle-DGsxIJRd.js";import{e as b,f as V,_ as q}from"./getCoordinateClusteredMap-Bd_wM-c0.js";class ${constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const t=e.nextAction();if(t)return t}return null}clone(e){return new $(this.solvers.map(t=>t.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class B extends Error{constructor(e){super(e)}}class L{constructor(e,t){this.action=e,this.annotation=t}apply(e){this.action.apply(e)}getUndo(e){return new L(this.action.getUndo(e),this.annotation)}isEmpty(){return this.action.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}class te{constructor(e,t,s,o){C(this,"dirtyEdges",new Set);C(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyEdges=new Set(o):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,a,n,l)=>{for(const i of l)for(const c of i.edges)this.dirtyEdges.add(c);for(const i of n){const c=this.state.getFacesWithColor(i);for(const h of c)for(const d of h.edges)this.dirtyEdges.add(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new B("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===f.WHITE){const s=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),o=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=s===o,a=this.state.getOppositeFaceColor(s)===o;if(this.options.solveToBlack&&a)return new L(new z(e,f.BLACK),{type:"FaceColorToBlack",edge:e});if(this.options.solveToRed&&r)return new L(new z(e,f.RED),{type:"FaceColorToRed",edge:e})}this.dirtyEdges.delete(e)}return null}clone(e){return new te(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class se{constructor(e,t,s,o){C(this,"dirtyVertices",[]);C(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,a)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=e.edges;let s=0,o=0;if(t.forEach(r=>{const a=this.state.getEdgeState(r);return a===f.BLACK?s++:a===f.WHITE&&o++,a}),s>2)throw new B("Too many black edges on vertex");if(s===1&&o===0)throw new B("Nowhere for the single edge to go");if(o>0){if(this.options.solveJointToRed&&s===2){const r=t.filter(n=>this.state.getEdgeState(n)===f.WHITE),a=t.filter(n=>this.state.getEdgeState(n)===f.BLACK);return b()&&V(a.length===2),new L(new k(r.map(n=>new z(n,f.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:a})}else if(this.options.solveForcedLineToBlack&&s===1&&o===1){const r=t.find(n=>this.state.getEdgeState(n)===f.WHITE),a=t.find(n=>this.state.getEdgeState(n)===f.BLACK);return b()&&V(r),b()&&V(a),new L(new z(r,f.BLACK),{type:"ForcedLine",vertex:e,blackEdge:a,whiteEdge:r,redEdges:t.filter(n=>this.state.getEdgeState(n)===f.RED)})}else if(this.options.solveAlmostEmptyToRed&&s===0&&o===1){const r=t.find(a=>this.state.getEdgeState(a)===f.WHITE);return b()&&V(r),new L(new z(r,f.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:t.filter(a=>this.state.getEdgeState(a)===f.RED)})}}}return null}clone(e){return new se(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class oe{constructor(e,t,s,o){C(this,"dirtyFaces",[]);C(this,"faceListener");C(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceListener=(r,a)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,a)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceValue(e);if(t!==null){const s=e.edges;let o=0,r=0,a=0;if(s.forEach(n=>{const l=this.state.getEdgeState(n);return l===f.BLACK?o++:l===f.RED?r++:a++,l}),o>t)throw new B("Too many black edges on face");if(r>e.edges.length-t)throw new B("Too many red edges on face");if(a>0){if(this.options.solveToRed&&o===t){const n=s.filter(i=>this.state.getEdgeState(i)===f.WHITE),l=s.filter(i=>this.state.getEdgeState(i)===f.BLACK);return new L(new k(n.map(i=>new z(i,f.RED))),{type:"FaceSatisfied",face:e,whiteEdges:n,blackEdges:l})}else if(this.options.solveToBlack&&r===e.edges.length-t){const n=s.filter(i=>this.state.getEdgeState(i)===f.WHITE),l=s.filter(i=>this.state.getEdgeState(i)===f.RED);return new L(new k(n.map(i=>new z(i,f.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:n,redEdges:l})}}}}return null}clone(e){return new oe(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class ie{constructor(e,t,s,o){C(this,"dirtySimpleRegions");C(this,"hasDirtyWeirdEdges",!1);C(this,"simpleRegionListener");C(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtySimpleRegions=new Set(o):this.dirtySimpleRegions=new Set(t.getSimpleRegions()),this.simpleRegionListener=(r,a,n,l)=>{for(const i of a)this.dirtySimpleRegions.delete(i);for(const i of r)this.dirtySimpleRegions.add(i);this.hasDirtyWeirdEdges=t.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,a,n)=>{if(a===f.RED){const l=this.state.getSimpleRegions(),i=c=>{let h=c,d=null,g=0;do{if(g++>1e4)throw new Error("infinite loop detected");const w=h.edges.filter(v=>this.state.getEdgeState(v)===f.BLACK);if(w.length===1){for(const v of l)(v.a===h||v.b===h)&&this.dirtySimpleRegions.add(v);break}if(w.length!==0)break;const y=h.edges.filter(v=>this.state.getEdgeState(v)===f.WHITE);if(y.length!==2)break;const E=y[0].getOtherVertex(h)===d?y[1]:y[0];d=h,h=E.getOtherVertex(h)}while(h!==c)};i(r.start),i(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new B("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const t=e.values().next().value;if(!t.isSolved){const s=t.a,o=t.b,r=t.halfEdges[0].edge;for(const a of s.edges){if(a===r||this.state.getEdgeState(a)===f.RED)continue;const n=[a];let l=a,i=a.getOtherVertex(s);for(;i!==o;){let c=!1;const h=i.edges.filter(d=>{if(d===l)return!1;const g=this.state.getEdgeState(d);return g===f.BLACK&&(c=!0),g===f.WHITE});if(h.length!==1||c)break;l=h[0],n.push(l),i=l.getOtherVertex(i)}if(i===o){if(this.isSolvedWithAddedEdges(t,n)){if(this.options.solveToBlack)return new L(new k(n.map(c=>new z(c,f.BLACK))),{type:"ForcedSolveLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n})}else if(this.options.solveToRed)return new L(new k(n.map(c=>new z(c,f.RED))),{type:"PrematureForcedLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n})}}}e.delete(t)}return null}isSolvedWithAddedEdges(e,t){const s=new Set(e.edges);for(const o of t)s.add(o);for(const o of this.board.faces){const r=this.state.getFaceValue(o);if(r!==null&&o.edges.filter(n=>s.has(n)).length!==r)return!1}return!0}clone(e){return new ie(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const H=(F,e)=>{if(e.colorState===N.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===N.INSIDE)return{type:"absolute",isOutside:!1};{const t=[...F.getFacesWithColor(e)][0];return b()&&V(t),{type:"face",face:t}}},J=(F,e)=>e.type==="face"?F.getFaceColor(e.face):e.isOutside?F.getOutsideColor():F.getInsideColor();class K{constructor(e,t){this.a=e,this.b=t,b()&&V(e),b()&&V(t)}apply(e){const t=J(e,this.a),s=J(e,this.b);if(t===s)return;const o=e.getOppositeFaceColor(t),r=e.getOppositeFaceColor(s);if(b()){const d=new Set(e.getFaceColors());V(d.has(t)),V(d.has(s)),o&&V(d.has(o)),r&&V(d.has(r))}if(o&&o===s||r&&r===t){e.modifyFaceColors([],[],new Map,new Map,!0);return}const a=[],n=new Map,l=new Map,i=K.combineFaces(t,s,e,a,n),c=o&&r?K.combineFaces(o,r,e,a,n):o||r;i===t&&c===o||i===s&&c===r||(l.set(i,c),c&&l.set(c,i)),e.modifyFaceColors([],a,n,l,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeSameAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorMakeSameAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorMakeSameAction")}static combineFaces(e,t,s,o,r){let a=null;if(e.colorState!==N.UNDECIDED)a=t;else if(t.colorState!==N.UNDECIDED)a=e;else{const l=s.getFacesWithColor(e),i=s.getFacesWithColor(t);a=l.length>i.length?t:e}const n=a===e?t:e;o.push(a);for(const l of s.getFacesWithColor(a))r.set(l,n);return n}}class X{constructor(e,t){this.a=e,this.b=t,b()&&V(e),b()&&V(t)}apply(e){const t=J(e,this.a),s=J(e,this.b);if(t===s){e.modifyFaceColors([],[],new Map,new Map,!0);return}const o=e.getOppositeFaceColor(t),r=e.getOppositeFaceColor(s);if(b()){const h=new Set(e.getFaceColors());V(h.has(t)),V(h.has(s)),o&&V(h.has(o)),r&&V(h.has(r))}if(o&&o===s||r&&r===t)return;if(o&&o===r){e.modifyFaceColors([],[],new Map,new Map,!0);return}const a=[],n=new Map,l=new Map,i=r?K.combineFaces(t,r,e,a,n):t,c=o?K.combineFaces(s,o,e,a,n):s;l.set(i,c),l.set(c,i),e.modifyFaceColors([],a,n,l,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeOppositeAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorMakeOppositeAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorMakeOppositeAction")}}class re{constructor(e,t,s,o){C(this,"dirtyFaces",new Set);C(this,"edgeListener");C(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,a,n,l)=>{const i=c=>{this.dirtyFaces.add(c);for(const h of c.edges){const d=h.getOtherFace(c);d&&this.dirtyFaces.add(d)}};for(const c of l)i(c);for(const c of[...r,...n]){const h=this.state.getFacesWithColor(c);for(const d of h)i(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,a)=>{for(const n of r.faces)this.dirtyFaces.add(n)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new B("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,t=o=>{const r=o.getOtherFace(e),a=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new Ke(a,o)},s=e.edges.filter(o=>this.state.getEdgeState(o)===f.WHITE).map(t);if(s.length){const o=this.state.getFaceValue(e);if(o===null){const r=s[0].color;if(e.edges.map(t).every(l=>l.color===r)&&this.options.solveToRed){const l=e.edges.map(c=>c.getOtherFace(e)).filter(c=>c!==null);if(this.board.faces.some(c=>c!==e&&this.state.getFaceValue(c)!==null&&!l.includes(c)))return new L(new k(s.map(c=>new z(c.edge,f.RED))),{type:"FaceColorNoTrivialLoop",face:e})}}else{const r=e.edges.filter(l=>this.state.getEdgeState(l)===f.BLACK).length,a=(l,i,c)=>{let h=[];for(const u of i){const A=u.color;let x=!1;for(const R of h)if(R.mainColor===A){R.mainColorSides.add(u),x=!0;break}else if(R.oppositeColor===A){R.oppositeColorSides.add(u),x=!0;break}if(!x){const R=this.state.getOppositeFaceColor(A),T=new je(A,R,0,0);h.push(T),T.mainColorSides.add(u)}}h=q.sortBy(h,u=>-u.size);const g=q.sortBy(h.flatMap(u=>{const A=[new Ee(u.mainColor,u.mainCount,u.mainColorSides)];return u.oppositeColor&&u.oppositeColorSides.size&&A.push(new Ee(u.oppositeColor,u.oppositeCount,u.oppositeColorSides)),A}),u=>-u.size)[0],w=g.size,y=l,E=i.length-y,v=Math.max(y,E),P=w>y,p=w>E,m=w===v;if(P&&p)throw new B("Too many adjacent faces with the same color");const S=()=>{const u=A=>[A[0].map(x=>x.edge),A[1].map(x=>x.edge)];return{face:e,remainingValue:l,availableSideCount:i.length,balancedPairs:c.map(u)}};if(P&&this.options.solveToRed)return new L(new k([...g.sides].map(u=>new z(u.edge,f.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...g.sides].map(u=>u.edge),...S()});if(p&&this.options.solveToBlack)return new L(new k([...g.sides].map(u=>new z(u.edge,f.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...g.sides].map(u=>u.edge),...S()});if(m&&this.options.solveColors){const u=g.color,A=i.filter(R=>R.color!==u),x=q.uniq(A.map(R=>R.color)).filter(R=>R!==this.state.getOppositeFaceColor(u));if(x.length)return b()&&V(x.every(R=>this.state.getFaceColors().includes(R))),new L(new k(x.map(R=>new X(H(this.state,u),H(this.state,R)))),{type:"FaceColorBalance",matchingEdges:[...g.sides].map(R=>R.edge),oppositeEdges:[...A].map(R=>R.edge),...S()})}if(this.options.allowPartialReduction)for(const u of h){if(u.size<1)continue;const A=[...u.mainColorSides].slice(0,u.size),x=[...u.oppositeColorSides].slice(0,u.size),R=i.filter(T=>!A.includes(T)&&!x.includes(T));if(R.length){const T=a(y-u.size,R,c.concat([[A,x]]));if(T)return T}}return null},n=a(o-r,s,[]);if(n)return n}}this.dirtyFaces.delete(e)}return null}clone(e){return new re(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Ke{constructor(e,t){this.color=e,this.edge=t}}class je{constructor(e,t,s,o){C(this,"mainColorSides",new Set);C(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=t,this.mainCount=s,this.oppositeCount=o}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class Ee{constructor(e,t,s){this.color=e,this.count=t,this.sides=s}get size(){return this.sides.size}}const Ue=(F,e)=>{let t=0;for(;F.dirty;){if(t++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const s=F.nextAction();s&&s.apply(e)}},qe=(F,e)=>{try{Ue(F,e)}finally{F.dispose()}},Ge=(F,e,t,s,o)=>{const r=F(e,t,o);s(),qe(r,t)},$e=(F,e,t,s)=>{Ge(F,e,t,()=>{},s)},Z=F=>{const e=[];for(const t of F.edges){const s=t.getOtherFace(F);s&&e.push(s)}return e},me=(F,e)=>F.start===e||F.end===e;class ne{constructor(e,t,s){C(this,"dirtyFaces");C(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const a of Z(o))this.dirtyFaces.add(a)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;if(t===s-1)for(const o of e.edges){const r=o.getOtherFace(e);if(r){const a=this.state.getFaceValue(r),n=r.edges.length;if(a===n-1){const l=new Set([...Z(e),...Z(r)]);if(this.board.faces.some(i=>(this.state.getFaceValue(i)??0)>0&&!l.has(i))){const i=E=>!me(E,o.start)&&!me(E,o.end),c=e.edges.filter(i),h=r.edges.filter(i),d=E=>!E.faces.some(v=>v===e||v===r),g=[...o.start.edges.filter(d),...o.end.edges.filter(d)],w=[o,...c,...h].filter(E=>this.state.getEdgeState(E)!==f.BLACK),y=g.filter(E=>this.state.getEdgeState(E)!==f.RED);if(w.length||y.length)return new L(new k([...w.map(E=>new z(E,f.BLACK)),...y.map(E=>new z(E,f.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:w,toRedEdges:y})}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new ne(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ae{constructor(e,t,s){C(this,"dirtySectors");C(this,"edgeListener");C(this,"sectorListener");this.board=e,this.state=t,s?this.dirtySectors=new Set(s):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(o,r,a)=>{this.dirtySectors.add(o.forwardHalf),this.dirtySectors.add(o.forwardHalf.previous),this.dirtySectors.add(o.reversedHalf),this.dirtySectors.add(o.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(o,r,a)=>{this.dirtySectors.add(o)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getSectorState(e);if(o===I.NONE)throw new B(`invalid sector state: ${o}`);const r=this.state.getEdgeState(t),a=this.state.getEdgeState(s),n=(r===f.WHITE?1:0)+(a===f.WHITE?1:0),l=(r===f.BLACK?1:0)+(a===f.BLACK?1:0),i=(c,h)=>new L(new k([...c.map(d=>new z(d,f.BLACK)),...h.map(d=>new z(d,f.RED))]),{type:"ForcedSector",sector:e,sectorState:o,toRedEdges:h,toBlackEdges:c});if(n===0){if(!o.allows(l))throw new B(`invalid state: ${o} with ${l} black edges with no white`)}else if(n===1){const c=o.allows(l),h=o.allows(l+1);if(!c&&!h)throw new B(`invalid state: ${o} with ${l} black edges and 1 white`);if(c&&!h)return i([],[r===f.WHITE?t:s]);if(h&&!c)return i([r===f.WHITE?t:s],[])}else if(n===2){if(o===I.ONLY_ZERO)return i([],[t,s]);if(o===I.ONLY_TWO)return i([t,s],[])}else throw new B(`invalid white count: ${n}`)}return null}clone(e){return new ae(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class j{constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new j(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:Oe(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new j(Te(e,t.sector),I.deserialize(t.state))}}class ce{constructor(e,t,s){C(this,"dirtyFaces");C(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const a of Z(o))this.dirtyFaces.add(a)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;let o=null;if(t===0?o=I.ONLY_ZERO:t===1?o=I.NOT_TWO:t===s-1?o=I.NOT_ZERO:t===s&&(o=I.ONLY_TWO),o){const r=e.halfEdges,a=[],n=[];for(const l of r){const i=this.state.getSectorState(l),c=i.and(o);if(c===I.NONE)throw new B(`invalid sector state: ${i}`);i!==c&&(a.push(new j(l,c)),n.push(l))}if(a.length)return new L(new k(a),{type:"StaticFaceSectors",face:e,sectors:n})}this.dirtyFaces.delete(e)}return null}clone(e){return new ce(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class le{constructor(e,t,s,o){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new B("Vertex has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const l=[...n][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new L(new k([...s.map(r=>new z(r,f.RED)),...o.map(r=>new z(r,f.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:s,toBlackEdges:o})}return null}clone(e){return new le(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class de{constructor(e,t,s){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new B("Vertex has no possibilities");const s=be(e),o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>I.NONE);for(const i of t.getAllowedPairs())for(let c=0;c<s.length;c++){const h=s[c],d=h.edge,g=h.next.edge,w=i[0],y=i[1],E=(d===w||d===y?1:0)+(g===w||g===y?1:0);r[c]=r[c].with(E)}if(t.allowsEmpty())for(let i=0;i<s.length;i++)r[i]=r[i].withZero(!0);for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===I.NONE)throw new B("Sector has no possibilities");const a=[],n=[],l=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(a.push(s[i]),n.push(o[i]),l.push(r[i]));if(a.length)return new L(new k(a.map((i,c)=>new j(i,l[c]))),{type:"VertexStateToSector",vertex:e,sectors:a,beforeStates:n,afterStates:l})}return null}clone(e){return new de(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class he{constructor(e,t,s){C(this,"dirtyVertices",[]);C(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new B("Vertex has no possibilities");const o=Be(e).map(n=>n.face?this.state.getFaceColor(n.face):this.state.getOutsideColor()),r=new Set(o);if(r.size!==1){const n=new Map([...r].map(i=>[i,new Map([...r].map(c=>[c,!1]))])),l=new Map([...r].map(i=>[i,new Map([...r].map(c=>[c,!1]))]));for(const i of t.getAllowedPairs()){const c=e.edges.indexOf(i[0]),h=e.edges.indexOf(i[1]),d=Math.min(c,h),g=Math.max(c,h),w=o.slice(d,g),y=[...o.slice(g),...o.slice(0,d)],E=v=>{for(let P=0;P<v.length;P++)for(let p=P+1;p<v.length;p++)n.get(v[P]).set(v[p],!0),n.get(v[p]).set(v[P],!0)};E(w),E(y);for(const v of w)for(const P of y)v!==P&&(l.get(v).set(P,!0),l.get(P).set(v,!0))}for(const i of r)for(const c of r){if(i===c)continue;const h=t.allowsEmpty()||n.get(i).get(c),d=l.get(i).get(c);if(h&&!d)return new L(new K(H(this.state,i),H(this.state,c)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===i),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===c)});if(d&&!h&&this.state.getOppositeFaceColor(i)!==c)return new L(new X(H(this.state,i),H(this.state,c)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(g=>this.state.getFaceColor(g)===i),facesB:e.faces.filter(g=>this.state.getFaceColor(g)===c)})}}const a=this.dirtyVertices.pop();b()&&V(a===e)}return null}clone(e){return new he(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Y{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const t=e.getFaceState(this.face);return new Y(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:ze(this.face),state:this.state.serialize()}}static deserializeAction(e,t){const s=Pe(e,t.face);return new Y(s,ve.deserialize(s,t.state))}}class Q{constructor(e,t,s){C(this,"dirtyFaces");C(this,"faceValueListener");C(this,"vertexStateListener");C(this,"faceColorListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces.filter(o=>t.getFaceValue(o)!==null)),this.faceValueListener=(o,r)=>{this.dirtyFaces.add(o)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=o=>{for(const r of o.faces)this.dirtyFaces.add(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(o,r,a,n)=>{const l=i=>{this.dirtyFaces.add(i);for(const c of i.edges){const h=c.getOtherFace(i);h&&this.dirtyFaces.add(h)}};for(const i of n)l(i);for(const i of[...o,...a]){const c=this.state.getFacesWithColor(i);for(const h of c)l(h)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const t=this.state.getFaceState(e),s=ve.fromVertexAndColorData(e,this.board,this.state).and(t);if(!t.equals(s))return new L(new Y(e,s),{type:"FaceState",face:e,beforeState:t,afterState:s})}return null}clone(e){return new Q(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class fe{constructor(e,t,s,o){C(this,"dirtyFaces",[]);C(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new B("Face has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const l=[...n][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new L(new k([...s.map(r=>new z(r,f.RED)),...o.map(r=>new z(r,f.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:s,toBlackEdges:o})}return null}clone(e){return new fe(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class ge{constructor(e,t,s){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new B("Face has no possibilities");const s=e.halfEdges,o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>I.NONE);for(const i of t.getAllowedCombinations())for(let c=0;c<s.length;c++){const h=s[c],d=h.edge,g=h.next.edge,w=(i.includes(d)?1:0)+(i.includes(g)?1:0);r[c]=r[c].with(w)}for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===I.NONE)throw new B("Sector has no possibilities");const a=[],n=[],l=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(a.push(s[i]),n.push(o[i]),l.push(r[i]));if(a.length)return new L(new k(a.map((i,c)=>new j(i,l[c]))),{type:"FaceStateToSector",face:e,sectors:a,beforeStates:n,afterStates:l})}return null}clone(e){return new ge(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class ue{constructor(e,t,s){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new B("Face has no possibilities");const s=new Map(e.edges.map(l=>{const i=l.getOtherFace(e);return[l,i?this.state.getFaceColor(i):this.state.getOutsideColor()]})),o=[e,...e.edges.map(l=>l.getOtherFace(e)).filter(q.identity)],r=this.state.getFaceColor(e),a=new Set([...s.values(),r]);if(a.size!==1){const l=new Map([...a].map(c=>[c,new Map([...a].map(h=>[h,!1]))])),i=new Map([...a].map(c=>[c,new Map([...a].map(h=>[h,!1]))]));for(const c of t.getAllowedCombinations()){const h=new Set([r]),d=new Set;for(const w of e.edges)c.includes(w)?d.add(s.get(w)):h.add(s.get(w));const g=w=>{for(let y=0;y<w.length;y++)for(let E=y+1;E<w.length;E++)l.get(w[y]).set(w[E],!0),l.get(w[E]).set(w[y],!0)};g([...h]),g([...d]);for(const w of h)for(const y of d)w!==y&&(i.get(w).set(y,!0),i.get(y).set(w,!0))}for(const c of a)for(const h of a){if(c===h)continue;const d=l.get(c).get(h),g=i.get(c).get(h);if(d&&!g)return new L(new K(H(this.state,c),H(this.state,h)),{type:"FaceStateToSameFaceColor",face:e,facesA:o.filter(w=>this.state.getFaceColor(w)===c),facesB:o.filter(w=>this.state.getFaceColor(w)===h)});if(g&&!d&&this.state.getOppositeFaceColor(c)!==h)return new L(new X(H(this.state,c),H(this.state,h)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:o.filter(w=>this.state.getFaceColor(w)===c),facesB:o.filter(w=>this.state.getFaceColor(w)===h)})}}const n=this.dirtyFaces.pop();b()&&V(n===e)}return null}clone(e){return new ue(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class G{constructor(e,t){this.vertex=e,this.state=t}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const t=e.getVertexState(this.vertex);return new G(this.vertex,t)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:ke(this.vertex),state:this.state.serialize()}}static deserializeAction(e,t){const s=De(e,t.vertex);return new G(s,ee.deserialize(s,t.state))}}class pe{constructor(e,t,s){C(this,"dirtyFaces",[]);C(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new B("Face has no possibilities");const s=e.vertices.map(n=>this.state.getVertexState(n)),o=s.map(n=>{const l=n.vertex.edges.filter(i=>i.faces.includes(e));return b()&&V(l.length===2),{vertex:n.vertex,vertexState:n,edgeA:l[0],edgeB:l[1],...n.getBinaryCombinationsAllowed(l[0],l[1])}}),r=o.map(n=>({vertex:n.vertex,vertexState:n.vertexState,edgeA:n.edgeA,edgeB:n.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const n of t.getAllowedCombinations())for(const l of r){const i=n.includes(l.edgeA),c=n.includes(l.edgeB);i&&c&&(l.allowsBoth=!0),i&&!c&&(l.allowsAOnly=!0),!i&&c&&(l.allowsBOnly=!0),!i&&!c&&(l.allowsNone=!0)}const a=[];for(let n=0;n<r.length;n++){const l=o[n],i=r[n];if(i.allowsBoth&&(i.allowsBoth=l.allowsBoth),i.allowsAOnly&&(i.allowsAOnly=l.allowsAOnly),i.allowsBOnly&&(i.allowsBOnly=l.allowsBOnly),i.allowsNone&&(i.allowsNone=l.allowsNone),i.allowsBoth!==l.allowsBoth||i.allowsAOnly!==l.allowsAOnly||i.allowsBOnly!==l.allowsBOnly||i.allowsNone!==l.allowsNone){const c=l.vertexState,h=ee.fromLookup(l.vertex,(d,g)=>{if(!c.allowsPair(d,g))return!1;const y=d===i.edgeA||g===i.edgeA,E=d===i.edgeB||g===i.edgeB;if(y&&E)return i.allowsBoth;if(y&&!E)return i.allowsAOnly;if(!y&&E)return i.allowsBOnly;if(!y&&!E)return i.allowsNone;throw new Error("Unreachable")},c.allowsEmpty()&&i.allowsNone);b()&&V(h.isSubsetOf(c)),c.equals(h)||a.push(h)}}if(a.length)return new L(new k(a.map(n=>new G(n.vertex,n))),{type:"FaceStateToVertexState",face:e,vertices:a.map(n=>n.vertex),beforeStates:a.map(n=>s.find(l=>l.vertex===n.vertex)),afterStates:a})}return null}clone(e){return new pe(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}const Fe=()=>Ve.nextInt(Number.MAX_SAFE_INTEGER);class W{constructor(e,t){C(this,"dirtyEdges",new Set);C(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>{this.dirtyEdges.add(s)}),this.edgeListener=(s,o)=>{this.dirtyEdges.add(s)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),t=this.state.getWeirdEdges(),s=new Set,o=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===f.BLACK?s.add(d):o.add(d);const r=new Set,a=new Set,n=new Set(e),l=new Set,i=new Set,c=new Set(t);for(const d of o)c.has(d)&&(c.delete(d),i.add(d));for(const d of s)c.has(d)&&s.delete(d),[...n].some(g=>g.halfEdges.some(w=>w.edge===d))&&s.delete(d);for(const d of e)if(d.halfEdges.some(g=>o.has(g.edge))){const g=[];let w=[];for(const y of d.halfEdges)o.has(y.edge)?w.length>0&&(g.push(w),w=[]):w.push(y);if(w.length>0&&g.push(w),a.add(d),n.delete(d),g.length){if(d.isSolved&&g.length>1){const E=g[0][0],v=g[g.length-1][g[g.length-1].length-1];E.start===v.end&&g[0].unshift(...g.pop())}const y=q.maxBy(g,E=>E.length);for(const E of g){const v=new U(E===y?d.id:Fe(),E);r.add(v),n.add(v)}}}const h=d=>{const g=d.start,w=d.end,y=[...n].find(S=>S.a===g||S.b===g)||null,E=[...n].find(S=>S.a===w||S.b===w)||null,v=g.edges.filter(S=>this.state.getEdgeState(S)===f.BLACK).length,P=w.edges.filter(S=>this.state.getEdgeState(S)===f.BLACK).length;if(v>2||P>2)return!1;const p=S=>{n.add(S),r.add(S)},m=S=>{n.delete(S),r.has(S)?r.delete(S):a.add(S)};if(y&&E)if(y===E)if(W.isSolvedWithAddedEdge(this.board,this.state,y,d))m(y),p(new U(y.id,W.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]),!0));else return!1;else{const S=y.halfEdges.length>=E.halfEdges.length?y:E,u=S===y?E:y,A=new U(S.id,W.combineHalfEdgeArrays(S.halfEdges,[d.forwardHalf],u.halfEdges));m(S),m(u),p(A)}else if(y){const S=new U(y.id,W.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf]));m(y),p(S)}else if(E){const S=new U(E.id,W.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]));m(E),p(S)}else{const S=new U(Fe(),[d.forwardHalf]);p(S)}return!0};for(const d of c)h(d)&&(i.add(d),c.delete(d));for(const d of s)h(d)||(l.add(d),c.add(d));return this.dirtyEdges.clear(),r.size||a.size||l.size||i.size?new L(new Me(this.board,r,a,l,i),{type:"SimpleRegions"}):null}clone(e){return new W(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,t,s,o){if(o.start!==s.a&&o.start!==s.b||o.end!==s.a&&o.end!==s.b)return!1;const r=new Set(s.edges);r.add(o);for(const a of e.faces){const n=t.getFaceValue(a);if(n!==null&&a.edges.filter(i=>r.has(i)).length!==n)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let t=[...e[0]];for(let s=1;s<e.length;s++){const o=e[s];if(o.length!==0)if(t[0].start===o[0].start)t=[...o.map(r=>r.reversed).reverse(),...t];else if(t[0].start===o[o.length-1].end)t=[...o,...t];else if(t[t.length-1].end===o[0].start)t=[...t,...o];else if(t[t.length-1].end===o[o.length-1].end)t=[...t,...o.map(r=>r.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return t}}class we{constructor(e,t){C(this,"hasDirtySimpleRegions",!0);C(this,"simpleRegionListener");this.board=e,this.state=t,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(Ie(this.state)){const e=this.board.edges.filter(t=>this.state.getEdgeState(t)===f.WHITE);if(e.length)return new L(new k(e.map(t=>new z(t,f.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e})}return this.hasDirtySimpleRegions=!1,null}clone(e){return new we(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}class Ze{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Se{constructor(e,t){C(this,"hadEdgeAdjusted",!1);C(this,"dirtyEdges",new Set);C(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>this.dirtyEdges.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyEdges.add(s),this.hadEdgeAdjusted=this.hadEdgeAdjusted||r!==f.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var t;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const s=new Map,o=new _(N.OUTSIDE,new Set),r=new _(N.INSIDE,new Set);o.opposite=r,r.opposite=o;const a=new Set([o,r,...this.board.faces.map(p=>{const m=new _(N.UNDECIDED,new Set([p]));return s.set(p,m),m})]);let n=!1;const l=p=>{if(p===null)return o;const m=s.get(p);return b()&&V(m),m},i=(p,m)=>{if(m===o||m===r)return i(m,p);b()&&V(p!==m);for(const S of m.faces)p.faces.add(S),s.set(S,p);return m.faces.clear(),a.delete(m),p},c=(p,m)=>{if(b()&&V(a.has(p)&&a.has(m)),p===m)return;const S=p.opposite,u=m.opposite;if(S&&S===m){n=!0;return}if(u&&u===p){n=!0;return}const A=i(p,m),x=S&&u?i(S,u):S||u;A.opposite=x,x&&(x.opposite=A)},h=(p,m)=>{if(b()&&V(a.has(p)&&a.has(m)),p===m){n=!0;return}if(p.opposite&&p.opposite===m)return;const S=p.opposite,u=m.opposite;if(S&&S===u){n=!0;return}const A=u?i(p,u):p,x=S?i(m,S):m;A.opposite=x,x.opposite=A};for(const p of this.board.edges){if(n)break;const m=this.state.getEdgeState(p);if(m!==f.WHITE){const S=l(p.forwardFace),u=l(p.reversedFace);m===f.BLACK?h(S,u):m===f.RED&&c(S,u)}}if(b()){const p=new Set(this.board.faces);for(const m of a)for(const S of m.faces)p.delete(S);V(p.size===0)}if(n)return new L(new Ze,{type:"InvalidFaceColoring"});const d=new Set(this.state.getFaceColors()),g=new Set,w=new Map,y=(p,m)=>{b()&&V(d.has(p)),b()&&V(m.faceColor===null),d.delete(p),m.faceColor=p};y(this.state.getOutsideColor(),o),y(this.state.getInsideColor(),r);for(const p of a){if(!p.faceColor){const S=new Set([...p.faces].map(x=>this.state.getFaceColor(x)));let u=null,A=0;for(const x of S){if(!d.has(x))continue;const R=this.state.getFacesWithColor(x);R.some(T=>!p.faces.has(T))||R.length>A&&(u=x,A=R.length)}if(u)y(u,p);else{const x=new He(We(),N.UNDECIDED);g.add(x),p.faceColor=x}}const m=p.faceColor;b()&&V(m),p.faces.forEach(S=>{this.state.getFaceColor(S)!==m&&w.set(S,m)})}const E=new Set(d),v=new Map;for(const p of a){const m=p.faceColor,S=((t=p.opposite)==null?void 0:t.faceColor)??null;let u=g.has(m);u||(u=this.state.getOppositeFaceColor(m)!==S),u&&v.set(m,S)}return g.size>0||E.size>0||w.size>0||v.size>0||this.state.hasInvalidFaceColors()?new L(new Ne(this.board,g,E,w,v,!1),{type:"GeneralFaceColoring"}):null}else for(;this.dirtyEdges.size;){const s=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(s);const o=this.state.getEdgeState(s);if(o!==f.WHITE){const r=s.forwardFace?this.state.getFaceColor(s.forwardFace):this.state.getOutsideColor(),a=s.reversedFace?this.state.getFaceColor(s.reversedFace):this.state.getOutsideColor();if(o===f.BLACK){if(this.state.getOppositeFaceColor(r)!==a)return new L(new X(H(this.state,r),H(this.state,a)),{type:"FaceColoringBlackEdge",edge:s})}else if(o===f.RED&&r!==a)return new L(new K(H(this.state,r),H(this.state,a)),{type:"FaceColoringRedEdge",edge:s})}}return null}clone(e){return new Se(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class _{constructor(e,t){C(this,"opposite",null);C(this,"faceColor",null);this.colorState=e,this.faces=t}}class ye{constructor(e,t){C(this,"dirtySectors",new Set);C(this,"edgeListener");this.board=e,this.state=t,e.halfEdges.forEach(s=>this.dirtySectors.add(s)),this.edgeListener=(s,o,r)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getEdgeState(t),r=this.state.getEdgeState(s),a=this.state.getSectorState(e);let n=a;const l=(o===f.WHITE?1:0)+(r===f.WHITE?1:0),i=(o===f.BLACK?1:0)+(r===f.BLACK?1:0),c=(o===f.RED?1:0)+(r===f.RED?1:0);if(l===0?n=I.getOnly(i):l===1&&(i&&n.zero&&(n=n.withDisallowZero()),c&&n.two&&(n=n.withDisallowTwo())),n!==a)return new L(new j(e,n),{type:l===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:a,afterState:n})}return null}clone(e){return new ye(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Ce{constructor(e,t){C(this,"dirtyVertices",new Set);C(this,"edgeListener");C(this,"sectorListener");C(this,"faceColorListener");this.board=e,this.state=t,e.vertices.forEach(s=>this.dirtyVertices.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyVertices.add(s.start),this.dirtyVertices.add(s.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,o,r)=>{this.dirtyVertices.add(s.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(s,o,r,a)=>{for(const n of a)for(const l of n.vertices)this.dirtyVertices.add(l);for(const n of r){const l=this.state.getFacesWithColor(n);for(const i of l)for(const c of i.vertices)this.dirtyVertices.add(c)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const t=this.state.getVertexState(e),s=ee.fromEdgeColorSectorData(e,this.state).and(t);if(!t.equals(s))return new L(new G(e,s),{type:"VertexState",vertex:e,beforeState:t,afterState:s})}return null}clone(e){return new Ce(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}const Le=(F,e,t)=>new $([new W(F,e),new we(F,e),new Se(F,e),new ye(F,e),new Ce(F,e)]),Rt=new O("autoSolveEnabledProperty",!0),Ot=new O("autoSolveToBlackProperty",!1),Tt=new O("autoSolveSimpleLoopsProperty",!1),Je=new O("autoSolveSimpleVertexJointToRedProperty",!0),Ye=new O("autoSolveSimpleVertexForcedLineToBlackProperty",!0),Xe=new O("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),Qe=new O("autoSolveSimpleFaceToRedProperty",!0),_e=new O("autoSolveSimpleFaceToBlackProperty",!0),et=new O("autoSolveSimpleLoopToRedProperty",!0),tt=new O("autoSolveSimpleLoopToBlackProperty",!1),st=new O("autoSolveDoubleMinusOneFacesProperty",!1),ot=new O("autoSolveStaticFaceSectorProperty",!0),it=new O("autoSolveSimpleSectorProperty",!1),rt=new O("autoSolveVertexToRedEdgeProperty",!1),nt=new O("autoSolveVertexToBlackEdgeProperty",!1),at=new O("autoSolveVertexToSectorsProperty",!1),ct=new O("autoSolveVertexToFaceColorProperty",!1),lt=new O("autoSolveFaceColorToRedProperty",!1),dt=new O("autoSolveFaceColorToBlackProperty",!1),ht=new O("autoSolveFaceColorParityToRedProperty",!1),ft=new O("autoSolveFaceColorParityToBlackProperty",!1),gt=new O("autoSolveFaceColorParityColorsProperty",!1),ut=new O("autoSolveFaceColorParityPartialReductionProperty",!1),pt=new O("autoSolveVertexColorToFaceProperty",!1),wt=new O("autoSolveFaceToRedProperty",!1),St=new O("autoSolveFaceToBlackProperty",!1),yt=new O("autoSolveFaceToSectorsProperty",!1),Ct=new O("autoSolveFaceToFaceColorsProperty",!1),Et=new O("autoSolveFaceToVertexProperty",!1),mt=(F,e,t)=>new $([Le(F,e),new Q(F,e)]),bt=(F,e)=>{$e(mt,F,e,!0)},Bt=new Re([Je,Ye,Xe,Qe,_e,et,tt,st,ot,it,rt,nt,at,ct,lt,dt,ht,ft,gt,ut,pt,wt,St,yt,Ct,Et],(F,e,t,s,o,r,a,n,l,i,c,h,d,g,w,y,E,v,P,p,m,S,u,A,x,R)=>(T,D,M)=>new $([...F||e||t?[new se(T,D,{solveJointToRed:F,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},M?void 0:[])]:[],...s||o?[new oe(T,D,{solveToRed:s,solveToBlack:o},M?void 0:[])]:[],...n?[new ne(T,D,M?void 0:[])]:[],Le(T,D),...l?[new ce(T,D,M?void 0:[])]:[],...i?[new ae(T,D,M?void 0:[])]:[],...r||a?[new ie(T,D,{solveToRed:r,solveToBlack:a,resolveAllRegions:!1},M?void 0:[])]:[],...c||h?[new le(T,D,{solveToRed:c,solveToBlack:h},M?void 0:[])]:[],...d?[new de(T,D,M?void 0:[])]:[],...w||y?[new te(T,D,{solveToRed:w,solveToBlack:y},M?void 0:[])]:[],...E||v||P?[new re(T,D,{solveToRed:E,solveToBlack:v,solveColors:P,allowPartialReduction:p},M?void 0:[])]:[],...g?[new he(T,D,M?void 0:[])]:[],...m?[new Q(T,D,M?void 0:[])]:[],...S||u?[new fe(T,D,{solveToRed:S,solveToBlack:u},M?void 0:[])]:[],...A?[new ge(T,D,M?void 0:[])]:[],...x?[new ue(T,D,M?void 0:[])]:[],...R?[new pe(T,D,M?void 0:[])]:[]]));export{he as $,L as A,ft as B,$ as C,gt as D,ut as E,K as F,pt as G,wt as H,B as I,St as J,yt as K,Ct as L,Ot as M,Tt as N,bt as O,se as P,oe as Q,ne as R,j as S,ye as T,ce as U,ae as V,Ce as W,le as X,de as Y,te as Z,re as _,X as a,Q as a0,fe as a1,ge as a2,ue as a3,pe as a4,Bt as a5,Le as a6,W as b,we as c,Se as d,ie as e,Rt as f,H as g,Je as h,$e as i,Ye as j,Xe as k,Qe as l,_e as m,et as n,tt as o,st as p,ot as q,it as r,rt as s,nt as t,at as u,ct as v,Ge as w,lt as x,dt as y,ht as z};
