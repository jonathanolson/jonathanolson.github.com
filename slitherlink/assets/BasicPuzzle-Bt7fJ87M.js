var at=Object.defineProperty;var it=(o,e,t)=>e in o?at(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var p=(o,e,t)=>it(o,typeof e!="symbol"?e+"":e,t);import{d,e as l,_ as De,a6 as ot,ab as rt,S as Qe,H as Xe}from"./patternBoards-DzVBPT7g.js";import{E as Te,a as Le,b as A,k as nt,T as ct,O as Ve}from"./Vector2Property-CFyCN_2h.js";import"./PhetioControlledVisibilityProperty-thEXBwUY.js";import"./localStorage-BTLIWA27.js";import{P as lt}from"./PatternRule-B98-ERhf.js";const ht=(o,e)=>{if(o.forwardHalf.next.edge===e)return o.forwardHalf;if(o.reversedHalf.next.edge===e)return o.reversedHalf;if(e.forwardHalf.next.edge===o)return e.forwardHalf;if(e.reversedHalf.next.edge===o)return e.reversedHalf;throw new Error("Edges are not connected")},O=class O extends Te{};p(O,"WHITE",new O),p(O,"BLACK",new O),p(O,"RED",new O),p(O,"enumeration",new Le(O));let y=O;const P=(o,e)=>{const t=o.edges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return d()&&l(t),t},B=o=>({start:{x:o.start.logicalCoordinates.x,y:o.start.logicalCoordinates.y},end:{x:o.end.logicalCoordinates.x,y:o.end.logicalCoordinates.y}});class Q{constructor(e,t=new Map){this.board=e,this.edgeStateMap=t}apply(e){for(const[t,s]of this.edgeStateMap)e.setEdgeState(t,s)}getUndo(e){const t=new Map;for(const s of this.edgeStateMap.keys())t.set(s,e.getEdgeState(s));return new Q(this.board,t)}isEmpty(){return this.edgeStateMap.size===0}serializeAction(){return{type:"GeneralEdgeAction",edges:Array.from(this.edgeStateMap.entries()).map(([e,t])=>({edge:B(e),state:t.name}))}}static deserializeAction(e,t){return new Q(e,new Map(t.edges.map(s=>[P(e,s.edge),y.enumeration.getValue(s.state)])))}}const be=(o,e)=>({type:"EdgeData",edges:o.edges.filter(t=>e.getEdgeState(t)!==y.WHITE).map(t=>({edge:B(t),state:e.getEdgeState(t).name}))});class ne extends Q{constructor(t,s,a=new Map){super(t,a);p(this,"edgeStateChangedEmitter",new A);this.parentState=s}getEdgeState(t){return this.edgeStateMap.has(t)?this.edgeStateMap.get(t):this.parentState.getEdgeState(t)}setEdgeState(t,s){const a=this.getEdgeState(t);a!==s&&(this.edgeStateMap.set(t,s),this.edgeStateChangedEmitter.emit(t,s,a))}clone(){return new ne(this.board,this.parentState,new Map(this.edgeStateMap))}createDelta(){return new ne(this.board,this,new Map)}serializeState(t){return be(t,this)}}class X{constructor(e,t){p(this,"edgeStateChangedEmitter",new A);p(this,"edgeStateMap",new Map);this.board=e,e.edges.forEach(s=>{this.edgeStateMap.set(s,t(s))})}getEdgeState(e){return d()&&l(this.edgeStateMap.has(e)),this.edgeStateMap.get(e)}setEdgeState(e,t){d()&&l(this.edgeStateMap.has(e));const s=this.edgeStateMap.get(e);s!==t&&(this.edgeStateMap.set(e,t),this.edgeStateChangedEmitter.emit(e,t,s))}clone(){return new X(this.board,e=>this.getEdgeState(e))}createDelta(){return new ne(this.board,this)}serializeState(e){return be(e,this)}static deserializeState(e,t){const s=new Map(t.edges.map(a=>[P(e,a.edge),y.enumeration.getValue(a.state)]));return new X(e,a=>s.get(a)??y.WHITE)}}const L=(o,e)=>{const t=o.faces.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return d()&&l(t),t};class ie{constructor(e,t){this.id=e,this.colorState=t}}class dt{constructor(e,t,s,a,i,r){this.board=e,this.addedFaceColors=t,this.removedFaceColors=s,this.faceChangeMap=a,this.oppositeChangeMap=i,this.invalidFaceColor=r,d()&&l(s.size<=a.size)}apply(e){e.modifyFaceColors(this.addedFaceColors,this.removedFaceColors,this.faceChangeMap,this.oppositeChangeMap,this.invalidFaceColor)}getUndo(e){throw new Error("getUndo unimplemented in GeneralFaceColorAction")}isEmpty(){return this.addedFaceColors.size===0&&this.removedFaceColors.size===0&&this.faceChangeMap.size===0&&this.oppositeChangeMap.size===0}serializeAction(){throw new Error("serializeAction unimplemented in GeneralFaceColorAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in GeneralFaceColorAction")}}const b=o=>({x:o.logicalCoordinates.x,y:o.logicalCoordinates.y}),V=class V extends Te{};p(V,"OUTSIDE",new V),p(V,"INSIDE",new V),p(V,"UNDECIDED",new V),p(V,"enumeration",new Le(V));let z=V;const gt=(o,e,t)=>({id:o.id,colorState:o.colorState.toString(),faces:e.map(b),oppositeFaceColorId:t}),ke=o=>({type:"FaceColorData",colors:o.getFaceColors().map(e=>{var t;return gt(e,o.getFacesWithColor(e),((t=o.getOppositeFaceColor(e))==null?void 0:t.id)??null)}),invalidFaceColor:o.hasInvalidFaceColors()});class ce extends dt{constructor(t,s,a=new Set,i=new Set,r=new Map,c=new Map,n=!1){super(t,a,i,r,c,n);p(this,"faceColorsChangedEmitter",new A);this.parentState=s}getFaceColors(){return[...[...this.parentState.getFaceColors()].filter(t=>!this.removedFaceColors.has(t)),...this.addedFaceColors]}getInsideColor(){return this.parentState.getInsideColor()}getOutsideColor(){return this.parentState.getOutsideColor()}getFaceColor(t){return this.faceChangeMap.has(t)?this.faceChangeMap.get(t):this.parentState.getFaceColor(t)}getFacesWithColor(t){let s;this.addedFaceColors.has(t)?s=new Set:s=new Set(this.parentState.getFacesWithColor(t));for(const[a,i]of this.faceChangeMap.entries())i===t?s.add(a):s.has(a)&&s.delete(a);return[...s]}getFaceColorMap(){const t=new Map(this.parentState.getFaceColorMap());for(const[s,a]of this.faceChangeMap.entries())t.set(s,a);return t}getOppositeFaceColor(t){const s=this.oppositeChangeMap.get(t);return s!==void 0?s:this.parentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.invalidFaceColor||this.parentState.hasInvalidFaceColors()}modifyFaceColors(t,s,a,i,r){for(const g of t)this.addedFaceColors.add(g);const c=new Set;for(const g of s)c.add(g),this.addedFaceColors.has(g)?this.addedFaceColors.delete(g):this.removedFaceColors.add(g);for(const[g,m]of a.entries())this.faceChangeMap.set(g,m);for(const[g,m]of i.entries())c.has(g)||this.oppositeChangeMap.set(g,m);const n=new Set(s);for(const g of this.oppositeChangeMap.keys()){const m=this.oppositeChangeMap.get(g);m&&n.has(m)&&this.oppositeChangeMap.set(g,null)}if(d()){const g=[...i.values()].filter(M=>M!==null),m=De.uniq(g);l(g.length===m.length)}const h=new Set(i.keys());this.invalidFaceColor=r,this.faceColorsChangedEmitter.emit(t,s,h,[...a.keys()])}clone(){return new ce(this.board,this.parentState,new Set(this.addedFaceColors),new Set(this.removedFaceColors),new Map(this.faceChangeMap),new Map(this.oppositeChangeMap),this.invalidFaceColor||this.parentState.hasInvalidFaceColors())}createDelta(){return new ce(this.board,this)}serializeState(t){return ke(this)}}const ze=()=>nt.nextInt(Number.MAX_SAFE_INTEGER);class H{constructor(e,t,s,a,i,r,c,n){p(this,"faceColorsChangedEmitter",new A);p(this,"faceColors");p(this,"colorMap");p(this,"colorInverseMap");p(this,"oppositeColorMap");p(this,"outsideColor");p(this,"insideColor");p(this,"invalidFaceColor");this.board=e,d()&&l(!t||c,"Provide all or none of the optional arguments"),this.outsideColor=r||new ie(ze(),z.OUTSIDE),this.insideColor=c||new ie(ze(),z.INSIDE),this.colorMap=new Map(s||[...e.faces].map(h=>[h,new ie(ze(),z.UNDECIDED)])),this.faceColors=new Set(t||[this.outsideColor,this.insideColor,...e.faces.map(h=>this.colorMap.get(h))]),d()&&l(this.board.faces.every(h=>this.colorMap.has(h))),d()&&l(this.board.faces.every(h=>this.faceColors.has(this.colorMap.get(h)))),this.colorInverseMap=new Map(a?[...a.keys()].map(h=>[h,new Set([...a.get(h)])]):[...this.faceColors].map(h=>[h,new Set([...this.colorMap.keys()].filter(g=>this.colorMap.get(g)===h))])),this.oppositeColorMap=new Map(i||[[this.outsideColor,this.insideColor],[this.insideColor,this.outsideColor]]),this.invalidFaceColor=!!n}getFaceColors(){return[...this.faceColors]}getInsideColor(){return this.insideColor}getOutsideColor(){return this.outsideColor}getFaceColor(e){const t=this.colorMap.get(e);return d()&&l(t),t}getFacesWithColor(e){d()&&l(this.faceColors.has(e));const t=this.colorInverseMap.get(e);return d()&&l(t),[...t]}getFaceColorMap(){return new Map(this.colorMap)}getOppositeFaceColor(e){return this.oppositeColorMap.get(e)??null}hasInvalidFaceColors(){return this.invalidFaceColor}modifyFaceColors(e,t,s,a,i){for(const n of e)this.faceColors.add(n),this.colorInverseMap.set(n,new Set);for(const[n,h]of s.entries()){const g=this.colorMap.get(n);d()&&l(g),this.colorMap.set(n,h),this.colorInverseMap.get(g).delete(n),this.colorInverseMap.get(h).add(n)}const r=new Set;for(const n of t)r.add(n),this.faceColors.delete(n),this.colorInverseMap.delete(n),this.oppositeColorMap.delete(n);for(const[n,h]of a.entries())h===null?this.oppositeColorMap.delete(n):r.has(n)||(this.oppositeColorMap.set(n,h),this.oppositeColorMap.set(h,n));for(const n of this.faceColors)this.oppositeColorMap.has(n)&&r.has(this.oppositeColorMap.get(n))&&this.oppositeColorMap.delete(n);const c=new Set(a.keys());if(this.invalidFaceColor=i,d()&&l(this.board.faces.every(n=>this.colorMap.has(n))),d()&&l(this.board.faces.every(n=>this.faceColors.has(this.colorMap.get(n)))),d()){const n=new Set(this.getFaceColors());for(const h of n){const g=this.getOppositeFaceColor(h);g&&!n.has(g)&&l(!1,`opposite color ${g} of color ${h} is not in the set of colors`)}for(const h of this.oppositeColorMap.keys())l(this.oppositeColorMap.has(this.oppositeColorMap.get(h)))}this.faceColorsChangedEmitter.emit(e,t,c,[...s.keys()])}clone(){return new H(this.board,this.faceColors,this.colorMap,this.colorInverseMap,this.oppositeColorMap,this.outsideColor,this.insideColor,this.invalidFaceColor)}createDelta(){return new ce(this.board,this)}serializeState(e){return ke(this)}static deserializeState(e,t){const s=t.colors.map(h=>{const g=h.id,m=z.enumeration.getValue(h.colorState);return d()&&l(m),new ie(g,m)}),a=new Map,i=new Map,r=new Map;s.forEach((h,g)=>{const m=t.colors[g].faces.map(F=>L(e,F));m.forEach(F=>a.set(F,h)),i.set(h,new Set(m));const M=t.colors[g].oppositeFaceColorId;if(M!==null){const F=s.find(f=>f.id===M);d()&&l(F),r.set(h,F)}});const c=s.find(h=>h.colorState===z.OUTSIDE);d()&&l(c);const n=s.find(h=>h.colorState===z.INSIDE);return d()&&l(n),new H(e,new Set(s),a,i,r,c,n,t.invalidFaceColor)}}const k=[],Ge=o=>{for(;k.length<=o;)k.push(k.length===0?1:k[k.length-1]*k.length);return k},_e=(o,e,t)=>t[o]/(t[e]*t[o-e]),oe=(o,e)=>{o=De.sortBy(o);const t=Ge(e);let s=0;const a=o.length;for(let i=0;i<a;i++){const r=o[i-1]+1,c=o[i];for(let n=i==0?0:r;n<c;n++)s+=_e(e-n-1,a-i-1,t)}return s},pt=(o,e)=>_e(o,e,Ge(o)),re=(o,e)=>{let t=0;for(let s=0;s<o.length;s++)t+=1<<e-o[s]-1;return t},ut=o=>1<<o,et=o=>{const e=new Uint8Array(Math.ceil(o.length/8));for(let s=0;s<o.length;s++)o[s]&&(e[Math.floor(s/8)]|=1<<7-s%8);const t=btoa(String.fromCharCode(...e));if(d()){const s=Ne(t,o.length);l(o.length===s.length&&o.every((a,i)=>a===s[i]))}return t},Ne=(o,e)=>{const t=Uint8Array.from(atob(o),a=>a.charCodeAt(0)),s=[];for(let a=0;a<t.length*8;a++)s.push((t[Math.floor(a/8)]&1<<7-a%8)!==0);return s.slice(0,e)};class C{constructor(e,t,s,a){p(this,"order");p(this,"possibilityCount");p(this,"matrix");this.face=e,this.faceValue=t,this.order=e.edges.length,s?this.matrix=s:this.matrix=De.range(0,C.getMatrixSize(this.order,this.faceValue)).map(()=>!0),a!==void 0?this.possibilityCount=a:this.possibilityCount=this.matrix.filter(i=>i).length,d()&&l(this.matrix.length===C.getMatrixSize(this.order,this.faceValue)),d()&&l(this.possibilityCount===this.matrix.filter(i=>i).length)}isAny(){return this.possibilityCount===C.getMatrixSize(this.order,this.faceValue)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.allowsBlackEdges([])}allowsBlackEdges(e){return this.matrix[this.getBlackEdgesIndex(e)]}getAllowedCombinations(){const e=[];return C.forEachEdgeCombination(this.face.edges,this.faceValue,(t,s)=>{this.matrix[this.getIndexFromIndices(t)]&&e.push(s.slice())}),d()&&l(e.length===this.possibilityCount),e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedCombinations())s.includes(e)?t.add(y.BLACK):t.add(y.RED);return this.allowsEmpty()&&t.add(y.RED),t}getBlackEdgesIndex(e){const t=e.map(s=>this.face.edges.indexOf(s));return d()&&l(t.every(s=>s>=0)),this.getIndexFromIndices(t)}getIndexFromIndices(e){return this.faceValue===null?re(e,this.order):oe(e,this.order)}equals(e){return this.face===e.face&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return d()&&l(this.face===e.face),new C(this.face,this.faceValue,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return d()&&l(this.face===e.face),new C(this.face,this.faceValue,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withBlackEdges(e,t){const s=this.getBlackEdgesIndex(e);return new C(this.face,this.faceValue,this.matrix.slice(0,s).concat(t,this.matrix.slice(s+1)))}serialize(){if(this.isAny())return{faceValue:this.faceValue,matrix:"",isAny:!0};const e={faceValue:this.faceValue,matrix:et(this.matrix),isAny:!1};return d()&&l(this.equals(C.deserialize(this.face,e))),e}static getMatrixSize(e,t){return t===null?ut(e):pt(e,t)}static forEachIndexCombination(e,t,s){let a=[];const i=()=>{if(t!==null){if(a.length===t){s(a);return}}else s(a);const r=a.length>0?a[a.length-1]+1:0;for(let c=r;c<e;c++)a.push(c),i(),a.pop()};i()}static forEachEdgeCombination(e,t,s){let a=[],i=[];const r=()=>{if(t!==null){if(a.length===t){s(a,i);return}}else s(a,i);const c=a.length>0?a[a.length-1]+1:0;for(let n=c;n<e.length;n++)a.push(n),i.push(e[n]),r(),a.pop(),i.pop()};r()}static fromLookup(e,t,s){const a=e.edges.length,i=new Array(C.getMatrixSize(a,t)).fill(!1);return C.forEachEdgeCombination(e.edges,t,(r,c)=>{if(s(c)){const h=t===null?re(r,a):oe(r,a);i[h]=!0}}),new C(e,t,i)}static none(e,t){const s=C.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!1);return new C(e,t,a,0)}static any(e,t){const s=C.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!0);return new C(e,t,a,s)}static withOnlyBlackEdges(e,t,s){const a=C.getMatrixSize(e.edges.length,t),i=new Array(a).fill(!1),r=s.map(n=>e.edges.indexOf(n)),c=t===null?re(r,e.edges.length):oe(r,e.edges.length);return i[c]=!0,new C(e,t,i,1)}static withoutBlackEdges(e,t,s){const a=C.getMatrixSize(e.edges.length,t),i=new Array(a).fill(!0),r=s.map(n=>e.edges.indexOf(n)),c=t===null?re(r,e.edges.length):oe(r,e.edges.length);return i[c]=!1,new C(e,t,i,a-1)}static fromVertexAndColorData(e,t,s){const i=e.vertices.map(g=>s.getVertexState(g)).map(g=>{const m=g.vertex.edges.filter(M=>M.faces.includes(e));return d()&&l(m.length===2),{edgeA:m[0],edgeB:m[1],...g.getBinaryCombinationsAllowed(m[0],m[1])}}),r=new Map(e.edges.map(g=>{const m=g.getOtherFace(e);return[g,m?s.getFaceColor(m):s.getOutsideColor()]})),c=s.getFaceColor(e),n=new Set([...r.values(),c]),h=new Map([...n].map(g=>[g,s.getOppositeFaceColor(g)]));return C.fromLookup(e,s.getFaceValue(e),g=>{const m=new Set(g);for(const f of i){const u=m.has(f.edgeA),S=m.has(f.edgeB);if(u&&S&&!f.allowsBoth||u&&!S&&!f.allowsAOnly||!u&&S&&!f.allowsBOnly||!u&&!S&&!f.allowsNone)return!1}const M=new Set([c]),F=new Set;for(const f of e.edges){const u=r.get(f);d()&&l(u),m.has(f)?F.add(u):M.add(u)}for(const f of M){if(F.has(f))return!1;const u=h.get(f);if(u&&M.has(u))return!1}for(const f of F){const u=h.get(f);if(u&&F.has(u))return!1}if(m.size===e.edges.length){for(const f of t.faces)if(s.getFaceValue(f)!==null){for(const u of f.edges)if(!m.has(u))return!1}}return!0})}static deserialize(e,t){return t.isAny?C.any(e,t.faceValue):new C(e,t.faceValue,Ne(t.matrix,C.getMatrixSize(e.edges.length,t.faceValue)))}}class le{constructor(e,t=new Map){this.board=e,this.faceStateMap=t}apply(e){for(const[t,s]of this.faceStateMap)e.setFaceState(t,s)}getUndo(e){const t=new Map;for(const s of this.faceStateMap.keys())t.set(s,e.getFaceState(s));return new le(this.board,t)}isEmpty(){return this.faceStateMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceStateMap.entries()).map(([e,t])=>({face:b(e),state:t.serialize()}))}}static deserializeAction(e,t){return new le(e,new Map(t.faces.map(s=>[L(e,s.face),C.deserialize(L(e,s.face),s.state)])))}}const Ue=(o,e)=>({type:"FaceStateData",faces:o.faces.map(t=>({face:b(t),state:e.getFaceState(t).serialize()}))});class he extends le{constructor(t,s,a=new Map){super(t,a);p(this,"faceStateChangedEmitter",new A);this.parentState=s}getFaceState(t){return this.faceStateMap.has(t)?this.faceStateMap.get(t):this.parentState.getFaceState(t)}setFaceState(t,s){const a=this.getFaceState(t);a.equals(s)||(this.faceStateMap.set(t,s),this.faceStateChangedEmitter.emit(t,s,a))}clone(){return new he(this.board,this.parentState,new Map(this.faceStateMap))}createDelta(){return new he(this.board,this,new Map)}serializeState(t){return Ue(t,this)}}class q{constructor(e,t){p(this,"faceStateChangedEmitter",new A);p(this,"faceStateMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceStateMap.set(s,t(s))})}getFaceState(e){return d()&&l(this.faceStateMap.has(e)),this.faceStateMap.get(e)}setFaceState(e,t){d()&&l(this.faceStateMap.has(e));const s=this.faceStateMap.get(e);s.equals(t)||(this.faceStateMap.set(e,t),this.faceStateChangedEmitter.emit(e,t,s))}clone(){return new q(this.board,e=>this.getFaceState(e))}createDelta(){return new he(this.board,this)}serializeState(e){return Ue(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>{const i=L(e,a.face);return[i,C.deserialize(i,a.state)]}));return new q(e,a=>{const i=s.get(a);return d()&&l(i),i})}}class J{constructor(e,t=new Map){this.board=e,this.faceValueMap=t}apply(e){for(const[t,s]of this.faceValueMap)e.setFaceValue(t,s)}getUndo(e){const t=new Map;for(const s of this.faceValueMap.keys())t.set(s,e.getFaceValue(s));return new J(this.board,t)}isEmpty(){return this.faceValueMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceValueMap.entries()).map(([e,t])=>({face:b(e),state:t}))}}static deserializeAction(e,t){return new J(e,new Map(t.faces.map(s=>[L(e,s.face),s.state])))}}const Pe=(o,e)=>({type:"FaceValueData",faces:o.faces.filter(t=>e.getFaceValue(t)!==null).map(t=>({face:b(t),state:e.getFaceValue(t)}))});class de extends J{constructor(t,s,a=new Map){super(t,a);p(this,"faceValueChangedEmitter",new A);this.parentState=s}getFaceValue(t){return this.faceValueMap.has(t)?this.faceValueMap.get(t):this.parentState.getFaceValue(t)}setFaceValue(t,s){this.getFaceValue(t)!==s&&(this.faceValueMap.set(t,s),this.faceValueChangedEmitter.emit(t,s))}clone(){return new de(this.board,this.parentState,new Map(this.faceValueMap))}createDelta(){return new de(this.board,this,new Map)}serializeState(t){return Pe(t,this)}}class G{constructor(e,t){p(this,"faceValueChangedEmitter",new A);p(this,"faceValueMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceValueMap.set(s,t(s))})}getFaceValue(e){return d()&&l(this.faceValueMap.has(e)),this.faceValueMap.get(e)}setFaceValue(e,t){d()&&l(this.faceValueMap.has(e)),this.faceValueMap.get(e)!==t&&(this.faceValueMap.set(e,t),this.faceValueChangedEmitter.emit(e,t))}clone(){return new G(this.board,e=>this.getFaceValue(e))}createDelta(){return new de(this.board,this)}serializeState(e){return Pe(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>[L(e,a.face),a.state]));return new G(e,a=>s.get(a)??null)}}const Re=(o,e)=>{const t=o.halfEdges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return d()&&l(t),t},Oe=o=>({start:{x:o.start.logicalCoordinates.x,y:o.start.logicalCoordinates.y},end:{x:o.end.logicalCoordinates.x,y:o.end.logicalCoordinates.y}}),w=class w extends Te{constructor(e,t,s,a){super(),this.zero=e,this.one=t,this.two=s,this.serializedValue=a}allows(e){return d()&&l(e===0||e===1||e===2),e===0&&this.zero||e===1&&this.one||e===2&&this.two}isSubsetOf(e){return(!this.zero||e.zero)&&(!this.one||e.one)&&(!this.two||e.two)}and(e){return w.getWithValue(this.zero&&e.zero,this.one&&e.one,this.two&&e.two)}or(e){return w.getWithValue(this.zero||e.zero,this.one||e.one,this.two||e.two)}withZero(e){return w.getWithValue(e,this.one,this.two)}withOne(e){return w.getWithValue(this.zero,e,this.two)}withTwo(e){return w.getWithValue(this.zero,this.one,e)}with(e){return d()&&l(e===0||e===1||e===2),w.getWithValue(e===0?!0:this.zero,e===1?!0:this.one,e===2?!0:this.two)}withAllowZero(){return this.withZero(!0)}withAllowOne(){return this.withOne(!0)}withAllowTwo(){return this.withTwo(!0)}withDisallowZero(){return this.withZero(!1)}withDisallowOne(){return this.withOne(!1)}withDisallowTwo(){return this.withTwo(!1)}serialize(){return this.serializedValue}static getWithValue(e,t,s){return w.enumeration.values.find(a=>a.zero===e&&a.one===t&&a.two===s)}static getOnly(e){return d()&&l(e===0||e===1||e===2),w.getWithValue(e===0,e===1,e===2)}static getNot(e){return d()&&l(e===0||e===1||e===2),w.getWithValue(e!==0,e!==1,e!==2)}static deserialize(e){const t=ft.get(e);return d()&&l(t,`invalid serialized value: ${e}`),t}};p(w,"NONE",new w(!1,!1,!1,0)),p(w,"ONLY_ZERO",new w(!0,!1,!1,1)),p(w,"ONLY_ONE",new w(!1,!0,!1,2)),p(w,"ONLY_TWO",new w(!1,!1,!0,3)),p(w,"NOT_ZERO",new w(!1,!0,!0,4)),p(w,"NOT_ONE",new w(!0,!1,!0,5)),p(w,"NOT_TWO",new w(!0,!0,!1,6)),p(w,"ANY",new w(!0,!0,!0,7)),p(w,"enumeration",new Le(w)),p(w,"trivialStates",[w.NONE,w.ONLY_ZERO,w.ONLY_TWO,w.ANY]);let T=w;const ft=new Map(T.enumeration.values.map(o=>[o.serializedValue,o]));class ge{constructor(e,t=new Map){this.board=e,this.sectorStateMap=t}apply(e){for(const[t,s]of this.sectorStateMap)e.setSectorState(t,s)}getUndo(e){const t=new Map;for(const s of this.sectorStateMap.keys())t.set(s,e.getSectorState(s));return new ge(this.board,t)}isEmpty(){return this.sectorStateMap.size===0}serializeAction(){return{type:"GeneralSectorAction",sectors:Array.from(this.sectorStateMap.entries()).map(([e,t])=>({sector:Oe(e),state:t.serialize()}))}}static deserializeAction(e,t){return new ge(e,new Map(t.sectors.map(s=>[Re(e,s.sector),T.deserialize(s.state)])))}}const Be=(o,e)=>({type:"SectorStateData",sectors:o.halfEdges.filter(t=>e.getSectorState(t)!==T.ANY).map(t=>({sector:Oe(t),state:e.getSectorState(t).serialize()}))});class pe extends ge{constructor(t,s,a=new Map){super(t,a);p(this,"sectorStateChangedEmitter",new A);this.parentState=s}getSectorState(t){return this.sectorStateMap.has(t)?this.sectorStateMap.get(t):this.parentState.getSectorState(t)}setSectorState(t,s){const a=this.getSectorState(t);a!==s&&(this.sectorStateMap.set(t,s),this.sectorStateChangedEmitter.emit(t,s,a))}clone(){return new pe(this.board,this.parentState,new Map(this.sectorStateMap))}createDelta(){return new pe(this.board,this,new Map)}serializeState(t){return Be(t,this)}}class Z{constructor(e,t=()=>T.ANY){p(this,"sectorStateChangedEmitter",new A);p(this,"sectorStateMap",new Map);this.board=e,e.halfEdges.forEach(s=>{this.sectorStateMap.set(s,t(s))})}getSectorState(e){return d()&&l(this.sectorStateMap.has(e)),this.sectorStateMap.get(e)}setSectorState(e,t){d()&&l(this.sectorStateMap.has(e));const s=this.sectorStateMap.get(e);s!==t&&(this.sectorStateMap.set(e,t),this.sectorStateChangedEmitter.emit(e,t,s))}clone(){return new Z(this.board,e=>this.getSectorState(e))}createDelta(){return new pe(this.board,this)}serializeState(e){return Be(e,this)}static deserializeState(e,t){const s=new Map(t.sectors.map(a=>[Re(e,a.sector),T.deserialize(a.state)]));return new Z(e,a=>s.get(a)??T.ANY)}}class _{constructor(e,t,s=!1){p(this,"edges");p(this,"a");p(this,"b");if(this.id=e,this.halfEdges=t,this.isSolved=s,this.a=t[0].start,this.b=t[t.length-1].end,this.edges=t.map(a=>a.edge),d()){l(t.length>0);for(let a=0;a<t.length-1;a++)l(t[a].end===t[a+1].start)}}static deserializeSimpleRegion(e,t){return new _(t.id,t.halfEdges.map(s=>Re(e,s)),t.isSolved)}}const Ie=o=>({id:o.id,halfEdges:o.halfEdges.map(Oe),isSolved:o.isSolved}),Ft=o=>{const e=o.getSimpleRegions();return e.length===1&&e[0].isSolved&&o.getWeirdEdges().length===0},He=o=>({type:"SimpleRegionData",simpleRegions:o.getSimpleRegions().map(Ie),weirdEdges:o.getWeirdEdges().map(B)});class ee{constructor(e,t=new Set,s=new Set,a=new Set,i=new Set){this.board=e,this.addedRegions=t,this.removedRegions=s,this.addedWeirdEdges=a,this.removedWeirdEdges=i}apply(e){e.modifyRegions(this.addedRegions,this.removedRegions,this.addedWeirdEdges,this.removedWeirdEdges)}getUndo(e){return new ee(this.board,this.removedRegions,this.addedRegions,this.removedWeirdEdges,this.addedWeirdEdges)}isEmpty(){return this.addedRegions.size===0&&this.removedRegions.size===0&&this.addedWeirdEdges.size===0&&this.removedWeirdEdges.size===0}serializeAction(){return{type:"GeneralSimpleRegionAction",addedRegions:Array.from(this.addedRegions).map(Ie),removedRegions:Array.from(this.removedRegions).map(Ie),addedWeirdEdges:Array.from(this.addedWeirdEdges).map(B),removedWeirdEdges:Array.from(this.removedWeirdEdges).map(B)}}static deserializeAction(e,t){return new ee(e,new Set(t.addedRegions.map(s=>_.deserializeSimpleRegion(e,s))),new Set(t.removedRegions.map(s=>_.deserializeSimpleRegion(e,s))),new Set(t.addedWeirdEdges.map(s=>P(e,s))),new Set(t.removedWeirdEdges.map(s=>P(e,s))))}}class ue extends ee{constructor(t,s,a=new Set,i=new Set,r=new Set,c=new Set){super(t,a,i,r,c);p(this,"simpleRegionsChangedEmitter",new A);this.parentState=s}getSimpleRegions(){return[...this.parentState.getSimpleRegions().filter(t=>!this.removedRegions.has(t)),...this.addedRegions]}getSimpleRegionWithVertex(t){for(const s of this.getSimpleRegions())if(s.a===t||s.b===t)return s;return null}getSimpleRegionWithEdge(t){for(const s of this.getSimpleRegions())if(s.edges.includes(t))return s;return null}getSimpleRegionWithId(t){for(const s of this.getSimpleRegions())if(s.id===t)return s;return null}getWeirdEdges(){return[...this.parentState.getWeirdEdges().filter(t=>!this.removedWeirdEdges.has(t)),...this.addedWeirdEdges]}modifyRegions(t,s,a,i){for(const r of s)this.addedRegions.has(r)?this.addedRegions.delete(r):this.removedRegions.add(r);for(const r of t)this.addedRegions.add(r);for(const r of i)this.addedWeirdEdges.has(r)?this.addedWeirdEdges.delete(r):this.removedWeirdEdges.add(r);for(const r of a)this.addedWeirdEdges.add(r);this.simpleRegionsChangedEmitter.emit(t,s,a,i)}clone(){return new ue(this.board,this.parentState,new Set(this.addedRegions),new Set(this.removedRegions),new Set(this.addedWeirdEdges),new Set(this.removedWeirdEdges))}createDelta(){return new ue(this.board,this)}serializeState(t){return He(this)}}class Y{constructor(e,t,s){p(this,"simpleRegionsChangedEmitter",new A);p(this,"simpleRegions");p(this,"weirdEdges");this.board=e,this.simpleRegions=new Set(t),this.weirdEdges=new Set(s)}getSimpleRegions(){return[...this.simpleRegions]}getSimpleRegionWithVertex(e){for(const t of this.simpleRegions)if(t.a===e||t.b===e)return t;return null}getSimpleRegionWithEdge(e){for(const t of this.simpleRegions)if(t.edges.includes(e))return t;return null}getSimpleRegionWithId(e){for(const t of this.simpleRegions)if(t.id===e)return t;return null}getWeirdEdges(){return[...this.weirdEdges]}modifyRegions(e,t,s,a){for(const i of t)this.simpleRegions.delete(i);for(const i of e)this.simpleRegions.add(i);for(const i of a)this.weirdEdges.delete(i);for(const i of s)this.weirdEdges.add(i);this.simpleRegionsChangedEmitter.emit(e,t,s,a)}clone(){return new Y(this.board,this.simpleRegions,this.weirdEdges)}createDelta(){return new ue(this.board,this)}serializeState(e){return He(this)}static deserializeState(e,t){return new Y(e,t.simpleRegions.map(s=>_.deserializeSimpleRegion(e,s)),t.weirdEdges.map(s=>P(e,s)))}}const We=(o,e)=>{const t=o.vertices.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return d()&&l(t),t},tt=o=>({x:o.logicalCoordinates.x,y:o.logicalCoordinates.y}),mt=o=>o.incomingHalfEdges,St=o=>{let e=mt(o);return e=[...e.slice(1),e[0]],d()&&l(e[0].edge===o.edges[1]&&e[0].next.edge===o.edges[0]),e};class E{constructor(e,t,s){p(this,"order");p(this,"possibilityCount");p(this,"matrix");this.vertex=e,this.order=e.edges.length,t?this.matrix=t:this.matrix=De.range(0,E.getMatrixSize(this.order)).map(()=>!0),s!==void 0?this.possibilityCount=s:this.possibilityCount=this.matrix.filter(a=>a).length,d()&&l(this.matrix.length===E.getMatrixSize(this.order)),d()&&l(this.possibilityCount===this.matrix.filter(a=>a).length)}isAny(){return this.possibilityCount===E.getMatrixSize(this.order)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.matrix[E.getMatrixSize(this.order)-1]}allowsPair(e,t){return this.matrix[this.getPairIndex(e,t)]}getBinaryCombinationsAllowed(e,t){let s=this.allowsEmpty(),a=!1,i=!1,r=!1;for(const c of this.getAllowedPairs()){const n=c[0]===e||c[1]===e,h=c[0]===t||c[1]===t;n&&h?a=!0:n?i=!0:h?r=!0:s=!0}return{allowsNone:s,allowsBoth:a,allowsAOnly:i,allowsBOnly:r}}getAllowedPairs(){const e=[];let t=0;for(let s=0;s<this.order;s++)for(let a=s+1;a<this.order;a++)this.matrix[t++]&&e.push([this.vertex.edges[s],this.vertex.edges[a]]);return e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedPairs())s[0]===e||s[1]===e?t.add(y.BLACK):t.add(y.RED);return this.allowsEmpty()&&t.add(y.RED),t}getPairIndex(e,t){const s=this.vertex.edges.indexOf(e),a=this.vertex.edges.indexOf(t),i=Math.min(s,a),r=Math.max(s,a);return E.getIndex(i,r,this.order)}equals(e){return this.vertex===e.vertex&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return d()&&l(this.vertex===e.vertex),new E(this.vertex,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return d()&&l(this.vertex===e.vertex),new E(this.vertex,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withEmpty(e){return new E(this.vertex,this.matrix.slice(0,-1).concat(e))}withPair(e,t,s){const a=this.getPairIndex(e,t);return new E(this.vertex,this.matrix.slice(0,a).concat(s,this.matrix.slice(a+1)))}serialize(){const e=et(this.matrix);return d()&&l(this.equals(E.deserialize(this.vertex,e))),e}static getIndex(e,t,s){return e*(2*s-e-1)/2+(t-e-1)}static getMatrixSize(e){return e*(e-1)/2+1}static fromLookup(e,t,s){const a=e.edges.length,i=[];for(let r=0;r<a;r++)for(let c=r+1;c<a;c++)i.push(t(e.edges[r],e.edges[c]));return i.push(s),new E(e,i)}static none(e){return E.fromLookup(e,()=>!1,!1)}static any(e){return E.fromLookup(e,()=>!0,!0)}static withOnlyEmpty(e){return E.fromLookup(e,()=>!1,!0)}static withOnlyPair(e,t,s){return E.fromLookup(e,(a,i)=>a===t&&i===s||a===s&&i===t,!1)}static withoutEmpty(e){return E.fromLookup(e,()=>!0,!1)}static withoutPair(e,t,s){return E.fromLookup(e,(a,i)=>a!==t&&a!==s||i!==t&&i!==s,!0)}static fromEdgeColorSectorData(e,t){const s=e.edges.length,a=[],i=e.edges.filter(u=>t.getEdgeState(u)===y.BLACK);if(i.length>2)return E.none(e);if(i.length===2)return E.withOnlyPair(e,i[0],i[1]);const r=i.length?i[0]:null,c=new Set(e.edges.filter(u=>t.getEdgeState(u)===y.RED));if(c.size===s)return E.withOnlyEmpty(e);const n=St(e),h=n.map(u=>t.getSectorState(u)),g=h.every(u=>u.zero),m=n.map(u=>u.face?t.getFaceColor(u.face):t.getOutsideColor()),M=new Set(m),F=new Map([...M].map(u=>[u,t.getOppositeFaceColor(u)])),f=[...F.values()].every(u=>!u||!M.has(u));for(let u=0;u<s;u++){const S=e.edges[u];if(c.has(S)){for(let x=u+1;x<s;x++)a.push(!1);continue}for(let x=u+1;x<s;x++){let v=!0;const ae=e.edges[x];if(v&&c.has(ae)&&(v=!1),v&&r&&S!==r&&ae!==r&&(v=!1),v&&(v=v&&h.every(($,j)=>{const R=n[j];let I=0;return(S===R.edge||S===R.next.edge)&&I++,(ae===R.edge||ae===R.next.edge)&&I++,$.allows(I)})),v){const $=m.slice(u,x),j=[...m.slice(x),...m.slice(0,u)];$.some(R=>j.includes(R))&&(v=!1),v&&$.some(R=>{const I=F.get(R);return I&&$.includes(I)})&&(v=!1),v&&j.some(R=>{const I=F.get(R);return I&&j.includes(I)})&&(v=!1)}a.push(v)}}return a.push(i.length===0&&g&&f),new E(e,a)}static deserialize(e,t){return new E(e,Ne(t,E.getMatrixSize(e.edges.length)))}}class fe{constructor(e,t=new Map){this.board=e,this.vertexStateMap=t}apply(e){for(const[t,s]of this.vertexStateMap)e.setVertexState(t,s)}getUndo(e){const t=new Map;for(const s of this.vertexStateMap.keys())t.set(s,e.getVertexState(s));return new fe(this.board,t)}isEmpty(){return this.vertexStateMap.size===0}serializeAction(){return{type:"GeneralVertexAction",vertices:Array.from(this.vertexStateMap.entries()).map(([e,t])=>({vertex:tt(e),state:t.serialize()}))}}static deserializeAction(e,t){return new fe(e,new Map(t.vertices.map(s=>[We(e,s.vertex),E.deserialize(We(e,s.vertex),s.state)])))}}const qe=(o,e)=>({type:"VertexStateData",vertices:o.vertices.filter(t=>!e.getVertexState(t).isAny()).map(t=>({vertex:tt(t),state:e.getVertexState(t).serialize()}))});class me extends fe{constructor(t,s,a=new Map){super(t,a);p(this,"vertexStateChangedEmitter",new A);this.parentState=s}getVertexState(t){return this.vertexStateMap.has(t)?this.vertexStateMap.get(t):this.parentState.getVertexState(t)}setVertexState(t,s){const a=this.getVertexState(t);a.equals(s)||(this.vertexStateMap.set(t,s),this.vertexStateChangedEmitter.emit(t,s,a))}clone(){return new me(this.board,this.parentState,new Map(this.vertexStateMap))}createDelta(){return new me(this.board,this,new Map)}serializeState(t){return qe(t,this)}}class K{constructor(e,t=E.any){p(this,"vertexStateChangedEmitter",new A);p(this,"vertexStateMap",new Map);this.board=e,e.vertices.forEach(s=>{this.vertexStateMap.set(s,t(s))})}getVertexState(e){return d()&&l(this.vertexStateMap.has(e)),this.vertexStateMap.get(e)}setVertexState(e,t){d()&&l(this.vertexStateMap.has(e));const s=this.vertexStateMap.get(e);s.equals(t)||(this.vertexStateMap.set(e,t),this.vertexStateChangedEmitter.emit(e,t,s))}clone(){return new K(this.board,e=>this.getVertexState(e))}createDelta(){return new me(this.board,this)}serializeState(e){return qe(e,this)}static deserializeState(e,t){const s=new Map(t.vertices.map(a=>{const i=We(e,a.vertex);return[i,E.deserialize(i,a.state)]}));return new K(e,a=>s.get(a)??E.any(a))}}class se{apply(e){}getUndo(e){return this}isEmpty(){return!0}serializeAction(){return{type:"NoOpAction"}}static deserializeAction(e,t){return new se}}class Ze extends se{constructor(){super(...arguments);p(this,"isUserLoadPuzzleAutoSolveAction",!0)}serializeAction(){return{type:"UserLoadPuzzleAutoSolveAction"}}static deserializeAction(t,s){return new Ze}}class Ye extends se{constructor(){super(...arguments);p(this,"isUserRequestSolveAction",!0)}serializeAction(){return{type:"UserRequestSolveAction"}}static deserializeAction(t,s){return new Ye}}class Se{constructor(e,t=!0){this.edge=e,this.forward=t}apply(e){const t=e.getEdgeState(this.edge);t===y.WHITE?e.setEdgeState(this.edge,this.forward?y.BLACK:y.RED):t===y.BLACK?e.setEdgeState(this.edge,this.forward?y.RED:y.WHITE):e.setEdgeState(this.edge,this.forward?y.WHITE:y.BLACK)}getUndo(e){return new Se(this.edge,!this.forward)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateCycleAction",edge:B(this.edge),forward:this.forward}}static deserializeAction(e,t){return new Se(P(e,t.edge),t.forward)}}class we{constructor(e,t){this.edge=e,this.state=t}apply(e){e.setEdgeState(this.edge,this.state)}getUndo(e){const t=e.getEdgeState(this.edge);return new we(this.edge,t)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateSetAction",edge:B(this.edge),state:this.state.name}}static deserializeAction(e,t){return new we(P(e,t.edge),y.enumeration.getValue(t.state))}}const Ce=(o,e)=>e.type==="face"?o.getFaceColor(e.face):e.isOutside?o.getOutsideColor():o.getInsideColor(),Ee=(o,e)=>e.type==="face"?{type:"face",face:L(o,e.face)}:{type:"absolute",isOutside:e.isOutside},ye=o=>o.type==="face"?{type:"face",face:b(o.face)}:{type:"absolute",isOutside:o.isOutside};class U{constructor(e,t){this.a=e,this.b=t,d()&&l(e),d()&&l(t)}apply(e){const t=Ce(e,this.a),s=Ce(e,this.b);if(t===s)return;const a=e.getOppositeFaceColor(t),i=e.getOppositeFaceColor(s);if(d()){const M=new Set(e.getFaceColors());l(M.has(t)),l(M.has(s)),a&&l(M.has(a)),i&&l(M.has(i))}if(a&&a===s||i&&i===t){e.modifyFaceColors([],[],new Map,new Map,!0);return}const r=[],c=new Map,n=new Map,h=U.combineFaces(t,s,e,r,c),g=a&&i?U.combineFaces(a,i,e,r,c):a||i;h===t&&g===a||h===s&&g===i||(n.set(h,g),g&&n.set(g,h)),e.modifyFaceColors([],r,c,n,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeSameAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeSameAction",a:ye(this.a),b:ye(this.b)}}static deserializeAction(e,t){return new U(Ee(e,t.a),Ee(e,t.b))}static combineFaces(e,t,s,a,i){let r=null;if(e.colorState!==z.UNDECIDED)r=t;else if(t.colorState!==z.UNDECIDED)r=e;else{const n=s.getFacesWithColor(e),h=s.getFacesWithColor(t);r=n.length>h.length?t:e}const c=r===e?t:e;a.push(r);for(const n of s.getFacesWithColor(r))i.set(n,c);return c}}class Ke{constructor(e,t){this.a=e,this.b=t,d()&&l(e),d()&&l(t)}apply(e){const t=Ce(e,this.a),s=Ce(e,this.b);if(t===s){e.modifyFaceColors([],[],new Map,new Map,!0);return}const a=e.getOppositeFaceColor(t),i=e.getOppositeFaceColor(s);if(d()){const m=new Set(e.getFaceColors());l(m.has(t)),l(m.has(s)),a&&l(m.has(a)),i&&l(m.has(i))}if(a&&a===s||i&&i===t)return;if(a&&a===i){e.modifyFaceColors([],[],new Map,new Map,!0);return}const r=[],c=new Map,n=new Map,h=i?U.combineFaces(t,i,e,r,c):t,g=a?U.combineFaces(s,a,e,r,c):s;n.set(h,g),n.set(g,h),e.modifyFaceColors([],r,c,n,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeOppositeAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeOppositeAction",a:ye(this.a),b:ye(this.b)}}static deserializeAction(e,t){return new Ke(Ee(e,t.a),Ee(e,t.b))}}class $e{constructor(e,t){this.face=e,this.isInside=t,d()&&l(e)}apply(e){const t=e.getOutsideColor(),s=e.getInsideColor(),a=this.isInside?s:t,i=this.isInside?t:s,r=e.getFaceColor(this.face),c=e.getOppositeFaceColor(r);if(d()){const n=new Set(e.getFaceColors());l(n.has(r)),c&&l(n.has(c))}if(r!==a)if(r===i)e.modifyFaceColors([],[],new Map([[this.face,a]]),new Map,!1);else{const n=[r,...c?[c]:[]],h=new Map;for(const g of e.getFacesWithColor(r))h.set(g,a);if(c)for(const g of e.getFacesWithColor(c))h.set(g,i);e.modifyFaceColors([],n,h,new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in FaceColorSetAbsoluteAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorSetAbsoluteAction",face:b(this.face),isInside:this.isInside}}static deserializeAction(e,t){const s=L(e,t.face),a=t.isInside;return new $e(s,a)}}class Me{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceValue(this.face,this.state)}getUndo(e){const t=e.getFaceValue(this.face);return new Me(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceValueSetAction",edge:b(this.face),state:this.state}}static deserializeAction(e,t){return new Me(L(e,t.edge),t.state)}}class xe{constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new xe(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:Oe(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new xe(Re(e,t.sector),T.deserialize(t.state))}}const Je=new WeakMap;class je extends ot{constructor(t){const s=new Map(t.vertices.map((i,r)=>[i,r])),a=i=>{const r=s.get(i);return d()&&l(r!==void 0),r};super({numNonExitVertices:t.vertices.length,numExitVertices:0,type:"faces",vertexLists:[...t.faces.map(i=>i.vertices.map(a)),t.outerBoundary.map(i=>a(i.start)),...t.innerBoundaries.map(i=>i.map(r=>a(r.start)))]});p(this,"vertexToIndexMap");p(this,"edgeToPatternEdgeMap",new Map);p(this,"patternEdgeToEdgeMap",new Map);p(this,"sectorToPatternSectorMap",new Map);p(this,"patternSectorToSectorMap",new Map);p(this,"outsidePatternFace",null);p(this,"faceToPatternFaceMap",new Map);p(this,"patternFaceToFaceMap",new Map);this.board=t,d()&&l(this.vertices.length===t.vertices.length),d()&&l(this.edges.length===t.edges.length),d()&&l(this.faces.length===t.faces.length+1+t.innerBoundaries.length),this.vertexToIndexMap=s,this.edges.forEach((i,r)=>{d()&&l(i.vertices.length===2);const c=this.getVertex(i.vertices[0]),n=this.getVertex(i.vertices[1]),h=c.getEdgeTo(n);d()&&l(h),this.edgeToPatternEdgeMap.set(h,i),this.patternEdgeToEdgeMap.set(i,h)}),this.sectors.forEach(i=>{d()&&l(i.edges.length===2);const r=this.getEdge(i.edges[0]),c=this.getEdge(i.edges[1]),n=ht(r,c);this.sectorToPatternSectorMap.set(n,i),this.patternSectorToSectorMap.set(i,n)}),this.faces.forEach(i=>{d()&&l(i.sectors.length>=3);const c=this.getSector(i.sectors[0]).face;c===null?this.outsidePatternFace=i:this.faceToPatternFaceMap.set(c,i),this.patternFaceToFaceMap.set(i,c)})}getVertex(t){const s=t.index;return d()&&l(s>=0&&s<this.vertices.length),this.board.vertices[s]}getPatternVertex(t){const s=this.vertexToIndexMap.get(t);return d()&&l(s!==void 0),this.vertices[s]}getEdge(t){const s=this.patternEdgeToEdgeMap.get(t);return d()&&l(s!==void 0),s}getPatternEdge(t){const s=this.edgeToPatternEdgeMap.get(t);return d()&&l(s!==void 0),s}getSector(t){const s=this.patternSectorToSectorMap.get(t);return d()&&l(s!==void 0),s}getPatternSector(t){const s=this.sectorToPatternSectorMap.get(t);return d()&&l(s!==void 0),s}getFace(t){const s=this.patternFaceToFaceMap.get(t);return d()&&l(s!==void 0),s}getPatternFace(t){const s=this.faceToPatternFaceMap.get(t);return d()&&l(s!==void 0),s}getOutsidePatternFace(){return d()&&l(this.outsidePatternFace!==null),this.outsidePatternFace}static get(t){let s=Je.get(t);return s||(s=new je(t),Je.set(t,s)),s}}class Fe{constructor(e,t,s){this.action=e,this.annotation=t,this.board=s}apply(e){this.action.apply(e)}getUndo(e){return new Fe(this.action.getUndo(e),this.annotation,this.board)}isEmpty(){return this.action.isEmpty()}serializeAction(){let e=null;if(this.annotation.type==="Pattern"){const t=a=>({faceValues:a.faceValues.map(i=>({face:i.face===null?null:s.faces.indexOf(i.face),value:i.value})),blackEdges:a.blackEdges.map(i=>s.edges.indexOf(i)),redEdges:a.redEdges.map(i=>s.edges.indexOf(i)),sectorsNotZero:a.sectorsNotZero.map(i=>s.halfEdges.indexOf(i)),sectorsNotOne:a.sectorsNotOne.map(i=>s.halfEdges.indexOf(i)),sectorsNotTwo:a.sectorsNotTwo.map(i=>s.halfEdges.indexOf(i)),sectorsOnlyOne:a.sectorsOnlyOne.map(i=>s.halfEdges.indexOf(i)),faceColorDuals:a.faceColorDuals.map(i=>({primaryFaces:i.primaryFaces.map(r=>r===null?null:s.faces.indexOf(r)),secondaryFaces:i.secondaryFaces.map(r=>r===null?null:s.faces.indexOf(r))}))}),s=this.annotation.boardPatternBoard.board;e={type:"Pattern",rule:this.annotation.rule.serialize(),embedding:this.annotation.embedding.serialize(),input:t(this.annotation.input),output:t(this.annotation.output),affectedEdges:[...this.annotation.affectedEdges].map(a=>s.edges.indexOf(a)),affectedSectors:[...this.annotation.affectedSectors].map(a=>s.halfEdges.indexOf(a)),affectedFaces:[...this.annotation.affectedFaces].map(a=>s.faces.indexOf(a))}}else this.annotation.type==="ForcedSolveLoop"?e={type:"ForcedSolveLoop",a:this.board.vertices.indexOf(this.annotation.a),b:this.board.vertices.indexOf(this.annotation.b),regionEdges:[...this.annotation.regionEdges].map(t=>this.board.edges.indexOf(t)),pathEdges:[...this.annotation.pathEdges].map(t=>this.board.edges.indexOf(t))}:this.annotation.type;if(e!==null)return{type:"AnnotatedAction",action:this.action.serializeAction(),annotation:e};throw new Error("unimplemented")}static deserializeAction(e,t){d()&&l(t.type==="AnnotatedAction");const s=t.annotation.type,a=W(e,t.action);let i=null;if(s==="Pattern"){const r=u=>({faceValues:u.faceValues.map(S=>({face:S.face===null?null:e.faces[S.face],value:S.value})),blackEdges:u.blackEdges.map(S=>e.edges[S]),redEdges:u.redEdges.map(S=>e.edges[S]),sectorsNotZero:u.sectorsNotZero.map(S=>e.halfEdges[S]),sectorsNotOne:u.sectorsNotOne.map(S=>e.halfEdges[S]),sectorsNotTwo:u.sectorsNotTwo.map(S=>e.halfEdges[S]),sectorsOnlyOne:u.sectorsOnlyOne.map(S=>e.halfEdges[S]),faceColorDuals:u.faceColorDuals.map(S=>({primaryFaces:S.primaryFaces.map(x=>x===null?null:e.faces[x]),secondaryFaces:S.secondaryFaces.map(x=>x===null?null:e.faces[x])}))}),c=lt.deserialize(t.annotation.rule),n=je.get(e),h=rt.deserialize(c.patternBoard,n,t.annotation.embedding),g=r(t.annotation.input),m=r(t.annotation.output),M=new Set(t.annotation.affectedEdges.map(u=>e.edges[u])),F=new Set(t.annotation.affectedSectors.map(u=>e.halfEdges[u])),f=new Set(t.annotation.affectedFaces.map(u=>e.faces[u]));i={type:"Pattern",rule:c,boardPatternBoard:n,embedding:h,input:g,output:m,affectedEdges:M,affectedSectors:F,affectedFaces:f}}else s==="ForcedSolveLoop"?i={type:"ForcedSolveLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(r=>e.edges[r]),pathEdges:t.annotation.pathEdges.map(r=>e.edges[r])}:s==="PrematureForcedLoop"&&(i={type:"PrematureForcedLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(r=>e.edges[r]),pathEdges:t.annotation.pathEdges.map(r=>e.edges[r])});if(i!==null)return new Fe(a,i,e);throw new Error("unimplemented deserializeAction on AnnotatedAction")}}class ve{constructor(e){this.actions=e}apply(e){for(let t=0;t<this.actions.length;t++)this.actions[t].apply(e)}getUndo(e){return new ve(this.actions.map(t=>t.getUndo(e)).reverse())}isEmpty(){return this.actions.some(e=>!e.isEmpty())}serializeAction(){return{type:"CompositeAction",actions:this.actions.map(e=>e.serializeAction())}}static deserializeAction(e,t){return new ve(t.actions.map(s=>W(e,s)))}}const W=(o,e)=>{const t=e.type;if(t==="CompositeAction")return ve.deserializeAction(o,e);if(t==="AnnotatedAction")return Fe.deserializeAction(o,e);if(t==="CompleteAction")return te.deserializeAction(o,e);if(t==="EdgeStateCycleAction")return Se.deserializeAction(o,e);if(t==="EdgeStateSetAction")return we.deserializeAction(o,e);if(t==="GeneralEdgeAction")return Q.deserializeAction(o,e);if(t==="FaceValueSetAction")return Me.deserializeAction(o,e);if(t==="GeneralFaceAction")return J.deserializeAction(o,e);if(t==="GeneralSimpleRegionAction")return ee.deserializeAction(o,e);if(t==="NoOpAction")return se.deserializeAction(o,e);if(t==="UserLoadPuzzleAutoSolveAction")return Ze.deserializeAction(o,e);if(t==="UserRequestSolveAction")return Ye.deserializeAction(o,e);if(t==="FaceColorMakeOppositeAction")return Ke.deserializeAction(o,e);if(t==="FaceColorMakeSameAction")return U.deserializeAction(o,e);if(t==="FaceColorSetAbsoluteAction")return $e.deserializeAction(o,e);if(t==="SectorStateSetAction")return xe.deserializeAction(o,e);throw new Error(`Unknown action type: ${t}, could not deserialize`)};class te{constructor(e,t,s,a,i,r,c){this.faceValueAction=e,this.edgeStateAction=t,this.simpleRegionAction=s,this.faceColorAction=a,this.sectorStateAction=i,this.vertexStateAction=r,this.faceStateAction=c}apply(e){this.faceValueAction.apply(e),this.edgeStateAction.apply(e),this.simpleRegionAction.apply(e),this.faceColorAction.apply(e),this.sectorStateAction.apply(e),this.vertexStateAction.apply(e),this.faceStateAction.apply(e)}getUndo(e){return new te(this.faceValueAction.getUndo(e),this.edgeStateAction.getUndo(e),this.simpleRegionAction.getUndo(e),this.faceColorAction.getUndo(e),this.sectorStateAction.getUndo(e),this.vertexStateAction.getUndo(e),this.faceStateAction.getUndo(e))}isEmpty(){return this.faceValueAction.isEmpty()&&this.edgeStateAction.isEmpty()&&this.simpleRegionAction.isEmpty()&&this.faceColorAction.isEmpty()&&this.sectorStateAction.isEmpty()&&this.vertexStateAction.isEmpty()&&this.faceStateAction.isEmpty()}serializeAction(){return{type:"CompleteAction",faceValueAction:this.faceValueAction.serializeAction(),edgeStateAction:this.edgeStateAction.serializeAction(),simpleRegionAction:this.simpleRegionAction.serializeAction(),faceColorAction:this.faceColorAction.serializeAction(),sectorStateAction:this.sectorStateAction.serializeAction(),vertexStateAction:this.vertexStateAction.serializeAction(),faceStateAction:this.faceStateAction.serializeAction()}}static deserializeAction(e,t){return new te(W(e,t.faceStateAction),W(e,t.edgeStateAction),W(e,t.simpleRegionAction),W(e,t.faceColorAction),W(e,t.sectorStateAction),W(e,t.vertexStateAction),W(e,t.faceStateAction))}}const st=(o,e)=>({type:"CompleteData",faceValueData:Pe(o,e),edgeStateData:be(o,e),simpleRegionData:He(e),faceColorData:ke(e),sectorStateData:Be(o,e),vertexStateData:qe(o,e),faceStateData:Ue(o,e)});class Ae extends te{constructor(t,s,a,i,r,c,n){super(t,s,a,i,r,c,n);p(this,"anyStateChangedEmitter",new A);this.faceValueDelta=t,this.edgeStateDelta=s,this.simpleRegionDelta=a,this.faceColorDelta=i,this.sectorStateDelta=r,this.vertexStateDelta=c,this.faceStateDelta=n;const h=()=>this.anyStateChangedEmitter.emit();t.faceValueChangedEmitter.addListener(h),s.edgeStateChangedEmitter.addListener(h),a.simpleRegionsChangedEmitter.addListener(h),i.faceColorsChangedEmitter.addListener(h),r.sectorStateChangedEmitter.addListener(h),c.vertexStateChangedEmitter.addListener(h),n.faceStateChangedEmitter.addListener(h)}getFaceValue(t){return this.faceValueDelta.getFaceValue(t)}setFaceValue(t,s){this.faceValueDelta.setFaceValue(t,s)}get faceValueChangedEmitter(){return this.faceValueDelta.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateDelta.getEdgeState(t)}setEdgeState(t,s){this.edgeStateDelta.setEdgeState(t,s)}get edgeStateChangedEmitter(){return this.edgeStateDelta.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDelta.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDelta.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDelta.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDelta.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDelta.getWeirdEdges()}modifyRegions(t,s,a,i){this.simpleRegionDelta.modifyRegions(t,s,a,i)}get simpleRegionsChangedEmitter(){return this.simpleRegionDelta.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorDelta.getFaceColors()}getInsideColor(){return this.faceColorDelta.getInsideColor()}getOutsideColor(){return this.faceColorDelta.getOutsideColor()}getFaceColor(t){return this.faceColorDelta.getFaceColor(t)}getFacesWithColor(t){return this.faceColorDelta.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorDelta.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorDelta.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorDelta.hasInvalidFaceColors()}modifyFaceColors(t,s,a,i,r){this.faceColorDelta.modifyFaceColors(t,s,a,i,r)}get faceColorsChangedEmitter(){return this.faceColorDelta.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateDelta.getSectorState(t)}setSectorState(t,s){this.sectorStateDelta.setSectorState(t,s)}get sectorStateChangedEmitter(){return this.sectorStateDelta.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateDelta.getVertexState(t)}setVertexState(t,s){this.vertexStateDelta.setVertexState(t,s)}get vertexStateChangedEmitter(){return this.vertexStateDelta.vertexStateChangedEmitter}getFaceState(t){return this.faceStateDelta.getFaceState(t)}setFaceState(t,s){this.faceStateDelta.setFaceState(t,s)}get faceStateChangedEmitter(){return this.faceStateDelta.faceStateChangedEmitter}clone(){return new Ae(this.faceValueDelta.clone(),this.edgeStateDelta.clone(),this.simpleRegionDelta.clone(),this.faceColorDelta.clone(),this.sectorStateDelta.clone(),this.vertexStateDelta.clone(),this.faceStateDelta.clone())}createDelta(){return new Ae(this.faceValueDelta.createDelta(),this.edgeStateDelta.createDelta(),this.simpleRegionDelta.createDelta(),this.faceColorDelta.createDelta(),this.sectorStateDelta.createDelta(),this.vertexStateDelta.createDelta(),this.faceStateDelta.createDelta())}serializeState(t){return st(t,this)}}class D{constructor(e,t,s,a,i,r,c){p(this,"anyStateChangedEmitter",new A);this.faceValueData=e,this.edgeStateData=t,this.simpleRegionData=s,this.faceColorData=a,this.sectorStateData=i,this.vertexStateData=r,this.faceStateData=c;const n=()=>this.anyStateChangedEmitter.emit();e.faceValueChangedEmitter.addListener(n),t.edgeStateChangedEmitter.addListener(n),s.simpleRegionsChangedEmitter.addListener(n),a.faceColorsChangedEmitter.addListener(n),i.sectorStateChangedEmitter.addListener(n),r.vertexStateChangedEmitter.addListener(n),c.faceStateChangedEmitter.addListener(n)}static fromFacesEdges(e,t,s){const a=new G(e,t);return new D(a,new X(e,s),new Y(e),new H(e),new Z(e),new K(e),new q(e,i=>C.any(i,a.getFaceValue(i))))}static fromFaces(e,t){return D.fromFacesEdges(e,t,()=>y.WHITE)}static fromFaceValueData(e,t){return D.fromFaces(e,s=>t.getFaceValue(s))}static empty(e){return D.fromFaces(e,()=>null)}static faceMapLookup(e){const t=new Map(Array.from(e.entries()).map(([s,a])=>[`${s.x},${s.y}`,a]));return s=>{const a=t.get(`${s.logicalCoordinates.x},${s.logicalCoordinates.y}`);return a!==void 0?a:null}}getFaceValue(e){return this.faceValueData.getFaceValue(e)}setFaceValue(e,t){this.faceValueData.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueData.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateData.getEdgeState(e)}setEdgeState(e,t){this.edgeStateData.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateData.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionData.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionData.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionData.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionData.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionData.getWeirdEdges()}modifyRegions(e,t,s,a){this.simpleRegionData.modifyRegions(e,t,s,a)}get simpleRegionsChangedEmitter(){return this.simpleRegionData.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorData.getFaceColors()}getInsideColor(){return this.faceColorData.getInsideColor()}getOutsideColor(){return this.faceColorData.getOutsideColor()}getFaceColor(e){return this.faceColorData.getFaceColor(e)}getFacesWithColor(e){return this.faceColorData.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorData.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorData.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorData.hasInvalidFaceColors()}modifyFaceColors(e,t,s,a,i){this.faceColorData.modifyFaceColors(e,t,s,a,i)}get faceColorsChangedEmitter(){return this.faceColorData.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateData.getSectorState(e)}setSectorState(e,t){this.sectorStateData.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateData.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateData.getVertexState(e)}setVertexState(e,t){this.vertexStateData.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateData.vertexStateChangedEmitter}getFaceState(e){return this.faceStateData.getFaceState(e)}setFaceState(e,t){this.faceStateData.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateData.faceStateChangedEmitter}clone(){return new D(this.faceValueData.clone(),this.edgeStateData.clone(),this.simpleRegionData.clone(),this.faceColorData.clone(),this.sectorStateData.clone(),this.vertexStateData.clone(),this.faceStateData.clone())}createDelta(){return new Ae(this.faceValueData.createDelta(),this.edgeStateData.createDelta(),this.simpleRegionData.createDelta(),this.faceColorData.createDelta(),this.sectorStateData.createDelta(),this.vertexStateData.createDelta(),this.faceStateData.createDelta())}serializeState(e){return st(e,this)}static deserializeState(e,t){const s=G.deserializeState(e,t.faceValueData);return new D(s,X.deserializeState(e,t.edgeStateData),t.simpleRegionData?Y.deserializeState(e,t.simpleRegionData):new Y(e),t.faceColorData?H.deserializeState(e,t.faceColorData):new H(e),t.sectorStateData?Z.deserializeState(e,t.sectorStateData):new Z(e),t.vertexStateData?K.deserializeState(e,t.vertexStateData):new K(e),t.faceStateData?q.deserializeState(e,t.faceStateData):new q(e,a=>C.any(a,s.getFaceValue(a))))}}class N{constructor(e,t){p(this,"stateProperty");this.board=e,this.stateProperty=new ct(t)}static fromSolvedPuzzle(e){return new N(e.board,e.cleanState)}static loadDefaultPuzzle(){return N.loadFromSimpleString("10x18 .3.1....1..032....0......3.1....02.3...02....3.1...........2011.01..01.......3...2302..........1102...3.......22..03.0322...........3.2....13...2.30....2.2......1....103..2....1.3.")}static loadFromSimpleString(e){const[t,s]=e.split(" "),[a,i]=t.split("x").map(n=>parseInt(n)),r=new Qe(a,i),c=D.fromFaces(r,n=>{const h=n.logicalCoordinates.y*a+n.logicalCoordinates.x,g=s[h];return g==="."?null:parseInt(g)});return new N(r,c)}static loadDeprecatedScalaString(e){if(!e.includes("!"))return N.loadFromSimpleString(e);const t=1,s=2,a=4,i=8,[r,c]=e.split(" "),[n,h]=r.split("x").map(f=>parseInt(f)),g=new Qe(n,h),m=f=>3*(f.logicalCoordinates.y*n+f.logicalCoordinates.x)+1,M=(f,u)=>{const S=m(f),x=parseInt(c[S+1]),v=parseInt(c[S+2]);return x&u?y.BLACK:v&u?y.RED:y.WHITE},F=D.fromFacesEdges(g,f=>{const u=c[m(f)];return u==="."?null:parseInt(u)},f=>{if((f.start.logicalCoordinates.x===f.end.logicalCoordinates.x?Ve.VERTICAL:Ve.HORIZONTAL)===Ve.HORIZONTAL){const S=f.start.logicalCoordinates.x<f.end.logicalCoordinates.x?f.forwardFace:f.reversedFace,x=f.start.logicalCoordinates.x<f.end.logicalCoordinates.x?f.reversedFace:f.forwardFace;return S?M(S,s):M(x,i)}else{const S=f.start.logicalCoordinates.y<f.end.logicalCoordinates.y?f.reversedFace:f.forwardFace,x=f.start.logicalCoordinates.y<f.end.logicalCoordinates.y?f.forwardFace:f.reversedFace;return S?M(S,t):M(x,a)}});return new N(g,F)}static loadPointyTopHexagonalString(e){d()&&l(e.startsWith("h")||e.startsWith("H"));const[t,s]=e.slice(1).split(" "),a=parseInt(t),i=new Xe(a,Math.sqrt(3)/2,e.startsWith("h")),r=Xe.enumeratePointyFaceCoordinates(a),c=new Map;for(let h=0;h<s.length;h++){const g=s[h];if(g===".")continue;const m=r[h];c.set(m,parseInt(g))}const n=D.fromFaces(i,D.faceMapLookup(c));return new N(i,n)}}export{Fe as A,N as B,ve as C,_ as D,y as E,U as F,G,ee as H,ht as I,xe as S,Ze as U,E as V,we as a,Ke as b,je as c,D as d,X as e,Y as f,z as g,T as h,C as i,B as j,P as k,ie as l,ze as m,b as n,L as o,Oe as p,Re as q,$e as r,Ft as s,Ye as t,W as u,tt as v,We as w,St as x,mt as y,dt as z};
