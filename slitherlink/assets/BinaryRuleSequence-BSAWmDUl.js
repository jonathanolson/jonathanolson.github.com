var N=Object.defineProperty;var k=(c,e,t)=>e in c?N(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var v=(c,e,t)=>k(c,typeof e!="symbol"?e+"":e,t);import{_ as F,d as M,e as A,aa as C,a9 as P,aC as D,aD as V,aE as G,aF as U,aG as _,aH as H,aI as W,aJ as Z,v as z,s as J,ae as Y,p as K,n as Q}from"./patternBoards-DzVBPT7g.js";import{j as X,P as q,F as y,i as I,s as L}from"./PatternRule-B98-ERhf.js";import{H as ee,B as O}from"./BinaryRuleCollection-CpgpJAWO.js";import{B as te,R as se,S as T}from"./RichSolution-QrT0LZKn.js";import{P as oe}from"./PatternBoardSolver-DIArGw3P.js";import{j}from"./Vector2Property-CFyCN_2h.js";import{g as re}from"./generalPatternBoardGenerations-Ab_bRwdX.js";const ne={...X,featureLimit:Number.POSITIVE_INFINITY,hitFeatureLimitCallback:null,includeFaceValueZero:!1,prefilterRules:null,logModulo:1e6,vertexOrderLimit:null};class w{constructor(e,t){this.antecedent=e,this.consequent=t}toString(){return`${this.antecedent.toString()} -> ${this.consequent.toString()}`}static implicationSetClosure(e,t){let s=t,o=!0;for(;o;){o=!1;const i=e.length;for(let n=0;n<i;n++){const l=e[n],a=l.antecedent,d=l.consequent,u=s;(a&u)===a&&a!==u&&(d&u)!==d&&(s|=d,o=!0)}}return s}static implicationSetClosureLessThanI(e,t,s){if((t&1n<<BigInt(s))!==0n)return null;let o=t&~((1n<<BigInt(s))-1n)|1n<<BigInt(s),n=~((1n<<BigInt(s+1))-1n)&~o,l=!0;for(;l;){l=!1;const a=e.length;for(let d=0;d<a;d++){const u=e[d],r=u.antecedent,h=u.consequent;if((r&o)===r&&r!==o&&(h&o)!==h){if(h&n)return null;o|=h,l=!0}}}return o}}class le{static forEachImplication(e,t,s,o){const i=(o==null?void 0:o.logModulo)??1e6,n=o==null?void 0:o.logModuloCallback,l=[];let a=0n;const d=new Array(e).fill(0n);let u=0;const r=Date.now();for(;a!==null;){u++,u%i===0&&n&&n(u,a,l,Math.round((Date.now()-r)/1e3));const h=t(a);if(a!==h){const p=new w(a,h);s(p),l.push(p);let f=a;if(f!==0n&&(f&f-1n)===0n){let B=0;for(;f>1n;)f>>=1n,B++;const b=~((1n<<BigInt(B+1))-1n);d[B]|=b&h}}let g=null;for(let p=0;p<e;p++){if((a&d[p])!==d[p])continue;const f=w.implicationSetClosureLessThanI(l,a,p);if(f!==null){g=f;break}}if(g!==null)a=g;else break}}}const R=(c,e)=>(c.withOptionalData&1n<<BigInt(e))!==0n;class ae{constructor(e,t){v(this,"singleAttributeObjectsMap");v(this,"doubleAttributeObjectsMap");this.numAttributes=e,this.solutionAttributeSets=t,t.length>350?(this.singleAttributeObjectsMap=F.range(0,e).map(s=>t.filter(o=>R(o,s))),console.log(`single filter size: ${F.sum(this.singleAttributeObjectsMap.map(s=>s.length))}`),t.length>1500?(this.doubleAttributeObjectsMap=F.range(0,e).map(s=>F.range(s+1,e).map(o=>this.singleAttributeObjectsMap[s].filter(i=>R(i,o)))),console.log(`double filter size: ${F.sum(this.doubleAttributeObjectsMap.map(s=>F.sum(s.map(o=>o.length))))}`)):this.doubleAttributeObjectsMap=null):(this.singleAttributeObjectsMap=null,this.doubleAttributeObjectsMap=null)}getSolutionAttributeSets(e){let t=this.solutionAttributeSets;if(this.singleAttributeObjectsMap){let s=[],o=e,i=0;for(;o>0n;)o&1n&&s.push(i),o>>=1n,i++;if(this.doubleAttributeObjectsMap&&s.length>=2)for(let n=0;n<s.length-1;n++){const l=s[n],a=s[n+1],d=this.doubleAttributeObjectsMap[l][a-(l+1)];d.length<t.length&&(t=d)}else if(s.length>=1)for(let n=0;n<s.length;n++){const l=this.singleAttributeObjectsMap[s[n]];l.length<t.length&&(t=l)}}return t}}const ie={logModulo:1e6},ce=(c,e,t,s,o,i)=>{const n=j()({},ie,i),l={solveEdges:e,solveSectors:t,solveFaceColors:s,highlander:o},a=c.patternBoard,d=c.getFeaturesArray(),u=new te(a,l),r=u.numAttributes,g=oe.getSolutions(a,d).map(b=>new se(a,u,b,l.highlander));let p;if(o){const b=new ee(c,u,g);p=m=>{const S=b.getSolutionAttributeSets(m);return T.solutionClosure(r,S,m)}}else{const b=new ae(r,g.map(m=>u.getSolutionAttributeSet(m.solutionSet)));p=m=>{const S=b.getSolutionAttributeSets(m);return T.solutionClosure(r,S,m)}}const f=(1n<<BigInt(r))-1n,B=[];return le.forEachImplication(r,p,b=>{if(b.consequent===f)return;const m=c.clone(),S=c.clone(),x=u.getBitsFeatureSet(b.antecedent);m.applyFeaturesFrom(x);const $=u.getBitsFeatureSet(b.consequent);S.applyFeaturesFrom($),!m.equals(S)&&B.push(new q(a,m,S,o))},{logModulo:n.logModulo,logModuloCallback:(b,m,S,x)=>{console.log(`${b.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")} [${u.getBinaryString(m)}] (${u.getIndicesString(m)}) ${S.length} ${x}s`)}}),B},ue=(c,e)=>{const t=j()({},ne,e);M()&&A(!isFinite(t.featureLimit));const s=C(c,c),o=t.highlander?c.faces.filter(r=>{if(!r.isExit||r.edges.length!==1)return!1;const g=r.edges[0].faces.find(p=>p!==r);return g?!g.isExit:!1}):[],i=[],n=[...c.faces.filter(r=>!r.isExit),...o],l=(r,h)=>{if(h===n.length)r.isCanonicalWith(s)&&i.push(r);else{const g=n[h],p=g.isExit?[]:F.range(t.includeFaceValueZero?0:1,g.edges.length);t.highlander&&p.push(null),l(r,h+1);for(const f of p){const B=r.clone();B.addFaceValue(g,f),l(B,h+1)}}},a=t.vertexOrderLimit===null?y.empty(c):y.emptyWithVertexOrderLimit(c,t.vertexOrderLimit);l(a,0);const d=(t.prefilterRules??[]).flatMap(r=>r.getEmbeddedRules(C(r.patternBoard,c))),u=[];for(const r of i){console.log(r.toCanonicalString());const h=ce(r,t.solveEdges,t.solveSectors,t.solveFaceColors,t.highlander,{logModulo:t.logModulo});for(const g of h)g.isRedundant(d)||(u.push(g),d.push(...g.getEmbeddedRules(s)))}return F.sortBy(u,r=>r.inputFeatureSet.getInputDifficultyScoreA())};class E{constructor(e){v(this,"boardType");v(this,"solveEdges");v(this,"solveSectors");v(this,"solveFaceColors");v(this,"highlander");v(this,"vertexOrderLimit");v(this,"collection");v(this,"processedBoards");v(this,"currentBoards");this.boardType=e.boardType,this.solveEdges=e.solveEdges,this.solveSectors=e.solveSectors,this.solveFaceColors=e.solveFaceColors,this.highlander=e.highlander,this.vertexOrderLimit=e.vertexOrderLimit,this.collection=O.deserialize(e.collection),this.processedBoards=e.processedBoards.map(I),this.currentBoards=e.currentBoards.map(I)}getName(){return E.getName(this)}getGenerations(){const e={general:[...P.map(t=>[t]),...re],square:[[D],[V],[G],[U],[_],[H],[W],[Z],[z],...J],hexagonal:[...P.map(t=>[t]),...Y]}[this.boardType];return M()&&A(e,`Unknown board type: ${this.boardType}`),e}getAvailableBoards(){const e=[],t=[],s=(o,i)=>Q(o,i,!0).length>0;for(const o of this.getGenerations()){let i=!1;for(const n of o){if(this.processedBoards.includes(n)){i=!0;continue}!t.some(l=>s(l,n))&&!this.currentBoards.includes(n)&&e.push(n),t.push(n)}if(!i)break}return F.sortBy(e,o=>o.edges.length)}getNextBoard(){return this.getAvailableBoards()[0]??null}getStatusString(){const e=this.getName(),t=this.getAvailableBoards();if(t){let s=`${e}
`;const o=this.processedBoards,i=this.currentBoards,n=t.filter(a=>!this.processedBoards.includes(a)&&!this.currentBoards.includes(a)),l=(a,d)=>`  ${d} ${a.map(u=>u.name).join(", ")}
`;return s+=l(o,"processed | "),s+=l(i,"current   | "),s+=l(n,"remaining | "),s}else return`${e} (complete)`}getCollectionForBoard(e){const t=K.get(e);M()&&A(t,"planarPatternMap should be defined");const s=this.collection.withPatternBoardFilter(i=>C(i,e).length>0),o=ue(e,{solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,includeFaceValueZero:e.faces.filter(i=>!i.isExit).length===1,prefilterRules:s.getRules()});return O.fromRules(o)}addProcessingBoard(e){this.currentBoards.push(e)}removeProcessingBoard(e){this.currentBoards=this.currentBoards.filter(t=>t!==e)}addProcessedBoardCollection(e,t){this.collection=this.collection.withRules(t.getRules()),this.processedBoards.push(e),this.removeProcessingBoard(e)}serialize(){return{boardType:this.boardType,solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,collection:this.collection.serialize(),processedBoards:this.processedBoards.map(L),currentBoards:this.currentBoards.map(L)}}static deserialize(e){return new E(e)}static empty(e){return new E({boardType:e.boardType,solveEdges:e.solveEdges,solveSectors:e.solveSectors,solveFaceColors:e.solveFaceColors,highlander:e.highlander,vertexOrderLimit:e.vertexOrderLimit,collection:O.empty().serialize(),processedBoards:[],currentBoards:[]})}static getName(e){let t=`${e.boardType}-`;if(e.vertexOrderLimit!==null)if(e.boardType==="square"&&e.vertexOrderLimit===4||e.boardType==="hexagonal"&&e.vertexOrderLimit===3)t+="only-";else throw new Error("Specify naming convention for vertexOrderLimit");if(e.solveEdges&&e.solveSectors&&e.solveFaceColors)t+="all";else{let s=!1;e.solveEdges&&(t+="edge",s=!0),e.solveSectors&&(s&&(t+="-"),t+="sector",s=!0),e.solveFaceColors&&(s&&(t+="-"),t+="color",s=!0)}return e.highlander||(t+="-unrestricted"),t}}export{E as B};
