var $=Object.defineProperty;var k=(c,e,t)=>e in c?$(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var v=(c,e,t)=>(k(c,typeof e!="symbol"?e+"":e,t),t);import{H as D,B as A}from"./BinaryRuleCollection-3SET39HA.js";import{j as V,P as G,F as P,i as y,s as L}from"./PatternRule-BPSy1pyf.js";import{g as U}from"./generalPatternBoardGenerations-BYWxxbUb.js";import{_ as F,e as E,f as x,aj as C,ai as T,aM as _,aN as H,aO as W,aP as Z,aQ as z,aR as Q,aS as Y,aT as J,v as K,s as X,an as q,p as ee,o as te}from"./patternBoards-DKw4bfen.js";import{j}from"./UnivariatePolynomial-CzQEP6td.js";import{B as se,R as oe,S as I}from"./RichSolution-DRmVpgml.js";import{P as re}from"./PatternBoardSolver-DIAz22yg.js";const ne={...V,featureLimit:Number.POSITIVE_INFINITY,hitFeatureLimitCallback:null,includeFaceValueZero:!1,prefilterRules:null,logModulo:1e6,vertexOrderLimit:null};class w{constructor(e,t){this.antecedent=e,this.consequent=t}toString(){return`${this.antecedent.toString()} -> ${this.consequent.toString()}`}static implicationSetClosure(e,t){let s=t,o=!0;for(;o;){o=!1;const i=e.length;for(let l=0;l<i;l++){const a=e[l],r=a.antecedent,d=a.consequent,u=s;(r&u)===r&&r!==u&&(d&u)!==d&&(s|=d,o=!0)}}return s}static implicationSetClosureLessThanI(e,t,s){if((t&1n<<BigInt(s))!==0n)return null;let o=t&~((1n<<BigInt(s))-1n)|1n<<BigInt(s),l=~((1n<<BigInt(s+1))-1n)&~o,a=!0;for(;a;){a=!1;const r=e.length;for(let d=0;d<r;d++){const u=e[d],n=u.antecedent,h=u.consequent;if((n&o)===n&&n!==o&&(h&o)!==h){if(h&l)return null;o|=h,a=!0}}}return o}}class le{static forEachImplication(e,t,s,o){const i=(o==null?void 0:o.logModulo)??1e6,l=o==null?void 0:o.logModuloCallback,a=[];let r=0n;const d=new Array(e).fill(0n);let u=0;const n=Date.now();for(;r!==null;){u++,u%i===0&&l&&l(u,r,a,Math.round((Date.now()-n)/1e3));const h=t(r);if(r!==h){const p=new w(r,h);s(p),a.push(p);let f=r;if(f!==0n&&(f&f-1n)===0n){let B=0;for(;f>1n;)f>>=1n,B++;const b=~((1n<<BigInt(B+1))-1n);d[B]|=b&h}}let g=null;for(let p=0;p<e;p++){if((r&d[p])!==d[p])continue;const f=w.implicationSetClosureLessThanI(a,r,p);if(f!==null){g=f;break}}if(g!==null)r=g;else break}}}const R=(c,e)=>(c.withOptionalData&1n<<BigInt(e))!==0n;class ae{constructor(e,t){v(this,"singleAttributeObjectsMap");v(this,"doubleAttributeObjectsMap");this.numAttributes=e,this.solutionAttributeSets=t,t.length>350?(this.singleAttributeObjectsMap=F.range(0,e).map(s=>t.filter(o=>R(o,s))),console.log(`single filter size: ${F.sum(this.singleAttributeObjectsMap.map(s=>s.length))}`),t.length>1500?(this.doubleAttributeObjectsMap=F.range(0,e).map(s=>F.range(s+1,e).map(o=>this.singleAttributeObjectsMap[s].filter(i=>R(i,o)))),console.log(`double filter size: ${F.sum(this.doubleAttributeObjectsMap.map(s=>F.sum(s.map(o=>o.length))))}`)):this.doubleAttributeObjectsMap=null):(this.singleAttributeObjectsMap=null,this.doubleAttributeObjectsMap=null)}getSolutionAttributeSets(e){let t=this.solutionAttributeSets;if(this.singleAttributeObjectsMap){let s=[],o=e,i=0;for(;o>0n;)o&1n&&s.push(i),o>>=1n,i++;if(this.doubleAttributeObjectsMap&&s.length>=2)for(let l=0;l<s.length-1;l++){const a=s[l],r=s[l+1],d=this.doubleAttributeObjectsMap[a][r-(a+1)];d.length<t.length&&(t=d)}else if(s.length>=1)for(let l=0;l<s.length;l++){const a=this.singleAttributeObjectsMap[s[l]];a.length<t.length&&(t=a)}}return t}}const ie={logModulo:1e6},ce=(c,e,t,s,o,i)=>{const l=j()({},ie,i),a={solveEdges:e,solveSectors:t,solveFaceColors:s,highlander:o},r=c.patternBoard,d=c.getFeaturesArray(),u=new se(r,a),n=u.numAttributes,g=re.getSolutions(r,d).map(b=>new oe(r,u,b,a.highlander));let p;if(o){const b=new D(c,u,g);p=m=>{const S=b.getSolutionAttributeSets(m);return I.solutionClosure(n,S,m)}}else{const b=new ae(n,g.map(m=>u.getSolutionAttributeSet(m.solutionSet)));p=m=>{const S=b.getSolutionAttributeSets(m);return I.solutionClosure(n,S,m)}}const f=(1n<<BigInt(n))-1n,B=[];return le.forEachImplication(n,p,b=>{if(b.consequent===f)return;const m=c.clone(),S=c.clone(),M=u.getBitsFeatureSet(b.antecedent);m.applyFeaturesFrom(M);const N=u.getBitsFeatureSet(b.consequent);S.applyFeaturesFrom(N),!m.equals(S)&&B.push(new G(r,m,S,o))},{logModulo:l.logModulo,logModuloCallback:(b,m,S,M)=>{console.log(`${b.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")} [${u.getBinaryString(m)}] (${u.getIndicesString(m)}) ${S.length} ${M}s`)}}),B},ue=(c,e)=>{const t=j()({},ne,e);E()&&x(!isFinite(t.featureLimit));const s=C(c,c),o=t.highlander?c.faces.filter(n=>{if(!n.isExit||n.edges.length!==1)return!1;const g=n.edges[0].faces.find(p=>p!==n);return g?!g.isExit:!1}):[],i=[],l=[...c.faces.filter(n=>!n.isExit),...o],a=(n,h)=>{if(h===l.length)n.isCanonicalWith(s)&&i.push(n);else{const g=l[h],p=g.isExit?[]:F.range(t.includeFaceValueZero?0:1,g.edges.length);t.highlander&&p.push(null),a(n,h+1);for(const f of p){const B=n.clone();B.addFaceValue(g,f),a(B,h+1)}}},r=t.vertexOrderLimit===null?P.empty(c):P.emptyWithVertexOrderLimit(c,t.vertexOrderLimit);a(r,0);const d=(t.prefilterRules??[]).flatMap(n=>n.getEmbeddedRules(C(n.patternBoard,c))),u=[];for(const n of i){console.log(n.toCanonicalString());const h=ce(n,t.solveEdges,t.solveSectors,t.solveFaceColors,t.highlander,{logModulo:t.logModulo});for(const g of h)g.isRedundant(d)||(u.push(g),d.push(...g.getEmbeddedRules(s)))}return F.sortBy(u,n=>n.inputFeatureSet.getInputDifficultyScoreA())};class O{constructor(e){v(this,"boardType");v(this,"solveEdges");v(this,"solveSectors");v(this,"solveFaceColors");v(this,"highlander");v(this,"vertexOrderLimit");v(this,"collection");v(this,"processedBoards");v(this,"currentBoards");this.boardType=e.boardType,this.solveEdges=e.solveEdges,this.solveSectors=e.solveSectors,this.solveFaceColors=e.solveFaceColors,this.highlander=e.highlander,this.vertexOrderLimit=e.vertexOrderLimit,this.collection=A.deserialize(e.collection),this.processedBoards=e.processedBoards.map(y),this.currentBoards=e.currentBoards.map(y)}getName(){return O.getName(this)}getGenerations(){const e={general:[...T.map(t=>[t]),...U],square:[[_],[H],[W],[Z],[z],[Q],[Y],[J],[K],...X],hexagonal:[...T.map(t=>[t]),...q]}[this.boardType];return E()&&x(e,`Unknown board type: ${this.boardType}`),e}getAvailableBoards(){const e=[],t=[],s=(o,i)=>te(o,i,!0).length>0;for(const o of this.getGenerations()){let i=!1;for(const l of o){if(this.processedBoards.includes(l)){i=!0;continue}t.some(a=>s(a,l))||e.push(l),t.push(l)}if(!i)break}return F.sortBy(e,o=>o.edges.length)}getNextBoard(){return this.getAvailableBoards()[0]??null}getStatusString(){const e=this.getName(),t=this.getAvailableBoards();if(t){let s=`${e}
`;const o=this.processedBoards,i=t.filter(r=>this.currentBoards.includes(r));E()&&x(i.length===this.currentBoards.length);const l=t.filter(r=>!this.processedBoards.includes(r)&&!this.currentBoards.includes(r)),a=(r,d)=>`  ${d} ${r.map(u=>u.name).join(", ")}
`;return s+=a(o,"processed | "),s+=a(i,"current   | "),s+=a(l,"remaining | "),s}else return`${e} (complete)`}getCollectionForBoard(e){const t=ee.get(e);E()&&x(t,"planarPatternMap should be defined");const s=this.collection.withPatternBoardFilter(i=>C(i,e).length>0),o=ue(e,{solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,includeFaceValueZero:e.faces.filter(i=>!i.isExit).length===1,prefilterRules:s.getRules()});return A.fromRules(o)}addProcessingBoard(e){this.currentBoards.push(e)}removeProcessingBoard(e){this.currentBoards=this.currentBoards.filter(t=>t!==e)}addProcessedBoardCollection(e,t){this.collection=this.collection.withRules(t.getRules()),this.processedBoards.push(e),this.removeProcessingBoard(e)}serialize(){return{boardType:this.boardType,solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,collection:this.collection.serialize(),processedBoards:this.processedBoards.map(L),currentBoards:this.currentBoards.map(L)}}static deserialize(e){return new O(e)}static empty(e){return new O({boardType:e.boardType,solveEdges:e.solveEdges,solveSectors:e.solveSectors,solveFaceColors:e.solveFaceColors,highlander:e.highlander,vertexOrderLimit:e.vertexOrderLimit,collection:A.empty().serialize(),processedBoards:[],currentBoards:[]})}static getName(e){let t=`${e.boardType}-`;if(e.vertexOrderLimit!==null)if(e.boardType==="square"&&e.vertexOrderLimit===4||e.boardType==="hexagonal"&&e.vertexOrderLimit===3)t+="only-";else throw new Error("Specify naming convention for vertexOrderLimit");if(e.solveEdges&&e.solveSectors&&e.solveFaceColors)t+="all";else{let s=!1;e.solveEdges&&(t+="edge",s=!0),e.solveSectors&&(s&&(t+="-"),t+="sector",s=!0),e.solveFaceColors&&(s&&(t+="-"),t+="color",s=!0)}return e.highlander||(t+="-unrestricted"),t}}export{O as B};
