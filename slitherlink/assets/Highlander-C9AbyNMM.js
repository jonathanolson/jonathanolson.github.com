var w=Object.defineProperty;var T=(x,e,i)=>e in x?w(x,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):x[e]=i;var o=(x,e,i)=>(T(x,typeof e!="symbol"?e+"":e,i),i);import{e as m,f as I,_ as y}from"./patternBoards-7WmHeiIn.js";import{g as f}from"./PatternRule-DJzvheEf.js";import{E as _,e as A}from"./UnivariatePolynomial-CzQEP6td.js";class V{constructor(e,i){this.minVertexIndex=e,this.maxVertexIndex=i}}const r=class r extends _{};o(r,"NON_EXIT_RED",new r),o(r,"NON_EXIT_BLACK",new r),o(r,"EXIT_HARD_RED",new r),o(r,"EXIT_BLACK",new r),o(r,"EXIT_SOFT_RED_DOUBLE_BLACK",new r),o(r,"enumeration",new A(r));let a=r;class F{constructor(e,i,c){o(this,"solutionSet");o(this,"isEdgeBlack");o(this,"richEdgeStateMap",new Map);o(this,"vertexConnection",null);o(this,"vertexConnectionKey",null);this.patternBoard=e,this.solution=i,this.solutionSet=new Set(i),this.isEdgeBlack=t=>this.solutionSet.has(t);for(const t of e.edges){let s;t.isExit?this.isEdgeBlack(t)?s=a.EXIT_BLACK:t.exitVertex.edges.every(l=>!this.isEdgeBlack(l))?s=a.EXIT_SOFT_RED_DOUBLE_BLACK:s=a.EXIT_HARD_RED:s=this.isEdgeBlack(t)?a.NON_EXIT_BLACK:a.NON_EXIT_RED,this.richEdgeStateMap.set(t,s)}if(c)if(e.faces.some(t=>!t.isExit)){const t=new Set(this.solutionSet),s=[];for(;t.size;){let n;for(const E of t)if(E.isExit){n=E;break}m()&&I(n);const B=E=>{for(const K of E.vertices)for(const u of K.edges)if(t.has(u))return u;throw new Error("no next edge found")};t.delete(n);let d=n;for(;d===n||!d.isExit;){const E=B(d);t.delete(E),d=E}const g=d,p=Math.min(n.exitVertex.index,g.exitVertex.index),C=Math.max(n.exitVertex.index,g.exitVertex.index);s.push(new V(p,C))}const l=y.sortBy(s,n=>n.minVertexIndex);this.vertexConnection=l,this.vertexConnectionKey=l.map(n=>`c${n.minVertexIndex}-${n.maxVertexIndex}`).join(",")}else this.vertexConnection=[],this.vertexConnectionKey=""}isCompatibleWithFeature(e){return e.isPossibleWith(this.isEdgeBlack)}isCompatibleWithFeatureSet(e){return e.getFeaturesArray().every(i=>this.isCompatibleWithFeature(i))}toDebugString(){return`[${this.patternBoard.edges.map(e=>this.isEdgeBlack(e)?"1":"0")}] ${this.vertexConnectionKey??""}`}}class h{static filterWithFeatureSet(e,i){const c=f(i.patternBoard,i.getFeaturesArray()),t=i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s));return h.filterWithInfo(e,c,t)}static getHighlanderKeyWithFeatureSet(e,i){const c=f(i.patternBoard,i.getFeaturesArray()),t=new Set(i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s)));return h.getHighlanderKeyWithInfo(e,c,t)}static getHighlanderKeyWithInfo(e,i,c){return i.map(t=>{const s=e.richEdgeStateMap.get(t);return m()&&I(s),t.isExit?c.has(t)?s===a.EXIT_BLACK?"1":"0":s===a.EXIT_SOFT_RED_DOUBLE_BLACK?"2":s===a.EXIT_BLACK?"1":"0":s===a.NON_EXIT_BLACK?"1":"0"}).join("")+"/"+e.vertexConnectionKey}static filterWithInfo(e,i,c){const t=new Map,s=new Set(c);for(const l of e){const n=h.getHighlanderKeyWithInfo(l,i,s);t.has(n)?t.set(n,null):t.set(n,l)}return[...t.values()].filter(l=>{if(l===null)return!1;for(const n of c)if(l.solutionSet.has(n))return!1;return!0})}}export{F as G,h as H};
