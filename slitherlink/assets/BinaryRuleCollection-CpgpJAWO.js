var z=Object.defineProperty;var T=(g,t,e)=>t in g?z(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var S=(g,t,e)=>T(g,typeof t!="symbol"?t+"":t,e);import{d as F,e as y,_ as A,aa as M,ar as W,as as $}from"./patternBoards-DzVBPT7g.js";import{g as q,P as v,k as E,l as b,m as P,s as N,i as U}from"./PatternRule-B98-ERhf.js";import{H as L,G}from"./GenericRichSolution-dcEeS49P.js";import{P as O}from"./PatternBoardSolver-DIArGw3P.js";class V{constructor(t,e,s){S(this,"exitEdgeIndices");S(this,"solutionAttributeSetLists");this.initialFeatureSet=t,this.binaryFeatureMap=e,this.richSolutions=s;const n=t.patternBoard,i=n.edges.filter(o=>o.isExit);this.exitEdgeIndices=i.map(o=>e.getExitIndex(o)),this.solutionAttributeSetLists=new Array(1<<i.length).fill([]);const r=q(n,t.getFeaturesArray()),a=(o,l,c)=>{if(o===i.length){const d=L.filterWithInfo(s,r,c).map(h=>h.solutionAttributeSet);this.solutionAttributeSetLists[l]=d}else a(o+1,l,c),a(o+1,l|1<<o,[...c,i[o]])};a(0,0,[])}getSolutionAttributeSets(t){let e=0;for(let s=0;s<this.exitEdgeIndices.length;s++){const n=this.exitEdgeIndices[s];(t&1n<<BigInt(n))!==0n&&(e|=1<<s)}return this.solutionAttributeSetLists[e]}}const k=new WeakMap,j=(g,t=!1)=>{F()&&y(g);let e=k.get(g)??null;return e||(e=O.getSolutions(g,[]),t&&k.set(g,e)),e},H=new WeakMap,J=(g,t=!1)=>{F()&&y(g);let e=H.get(g)??null;return e||(e=j(g).map(s=>new G(g,s,!0),t),t&&H.set(g,e)),e},K=(g,t,e)=>{const s=g.inputFeatureSet.getFeaturesArray(),n=g.outputFeatureSet.getFeaturesArray();let i=e??J(g.patternBoard);t&&(i=V.filterWithFeatureSet(i,g.inputFeatureSet)),i=i.filter(r=>s.every(a=>a.isPossibleWith(r.isEdgeBlack)));for(const r of i)if(!n.every(a=>a.isPossibleWith(r.isEdgeBlack)))return!1;return!0};class R{constructor(t,e,s,n,i){if(this.patternBoards=t,this.data=e,this.ruleIndices=s,this.nextRuleIndex=n,this.highlander=i,F())for(let r=0;r<s.length;r++)y(e[s[r]]<t.length,"pattern board index")}clone(){return new R(this.patternBoards.slice(),new Uint8Array(this.data),this.ruleIndices.slice(),this.nextRuleIndex,this.highlander)}addRule(t){this.patternBoards.includes(t.patternBoard)||this.patternBoards.push(t.patternBoard);const e=t.getBinary(this.patternBoards);this.nextRuleIndex+e.length>this.data.length&&this.allocateMoreSpace(e.length),this.highlander||(this.highlander=t.highlander),this.data.set(e,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=e.length}addRuleSuffixBytes(t,e,s){this.patternBoards.includes(t)||this.patternBoards.push(t);const n=[this.patternBoards.indexOf(t),...e];this.nextRuleIndex+n.length>this.data.length&&this.allocateMoreSpace(n.length),this.highlander||(this.highlander=s),this.data.set(n,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=n.length}getRules(){const t=[];return this.forEachRule(e=>t.push(e)),t}get size(){return this.ruleIndices.length}allocateMoreSpace(t){const e=Math.max(this.data.length*2,this.data.length+t),s=new Uint8Array(e);s.set(this.data,0),this.data=s}getRule(t,e){return v.fromBinary(this.patternBoards,this.data,this.ruleIndices[t],e===void 0?this.highlander:e)}getRuleBytes(t,e){const s=this.ruleIndices[t],n=t+1<this.ruleIndices.length?this.ruleIndices[t+1]:this.nextRuleIndex,i=[];for(let r=e?s:s+1;r<n;r++)i.push(this.data[r]);return i}getRulePatternBoard(t){return this.patternBoards[this.data[this.ruleIndices[t]]]}forEachRule(t){for(let e=0;e<this.ruleIndices.length;e++)t(this.getRule(e))}withPatternBoardFilter(t){const e=this.patternBoards.map(t),s=this.patternBoards.filter((a,o)=>e[o]),n=[],i=[];let r=0;for(let a=0;a<this.ruleIndices.length;a++){const o=this.ruleIndices[a],l=this.data[o];if(F()&&y(l<this.patternBoards.length,"pattern board index"),e[l]){const c=s.indexOf(this.patternBoards[l]);F()&&y(c!==-1,"pattern board index");const d=a+1<this.ruleIndices.length?this.ruleIndices[a+1]:this.data.length;n.push(c,...this.data.slice(o+1,d)),i.push(r),F()&&y(n[r]===c,"pattern board index"),r=n.length}}return new R(s,new Uint8Array(n),i,r,this.highlander)}withRules(t){const e=this.highlander||t.some(a=>a.highlander),s=A.uniq([...this.patternBoards,...t.map(a=>a.patternBoard)]),n=[...this.data],i=[...this.ruleIndices];let r=this.nextRuleIndex;for(const a of t)n.push(...a.getBinary(s)),i.push(r),r=n.length;return new R(s,new Uint8Array(n),i,r,e)}withCollection(t){const e=this.clone();return t.forEachRule(s=>{e.addRule(s)}),e}withCollectionNonequal(t){const e=this.clone();let s=0;const n=this.getRules();return t.forEachRule(i=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,n.every(r=>!i.equals(r))&&e.addRule(i)}),e}withCollectionNonredundant(t){const e=this.clone();let s=0;return t.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,e.isRuleRedundant(n)||e.addRule(n)}),e}withoutCollectionNonequal(t){const e=R.empty();let s=0;const n=t.getRules();return this.forEachRule(i=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,n.every(r=>!i.equals(r))&&e.addRule(i)}),e}withoutCollectionNonredundant(t){const e=R.empty();let s=0;return this.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,t.isRuleRedundant(n)||e.addRule(n)}),e}withRulesApplied(t,e=()=>!1){const s=t.clone();for(;;){const n=s.clone();let i=null,r=[];for(let a=0;a<this.ruleIndices.length;a++){const o=this.ruleIndices[a],l=this.data[o],c=this.patternBoards[l];c!==i&&(i=c,r=M(c,t.patternBoard));const d=r;for(const h of d)if(this.isActionableEmbeddingFromFeatureSet(s,a,h)){const f=this.getRule(a).embedded(s.patternBoard,h);if(F()){self.isPatternRuleValid=K;const p=f.getMatchState(s);if(p===E.INCOMPATIBLE||p===E.DORMANT){debugger;throw new Error("Why would this happen")}}f.apply(s)}}if(e(s)||n.equals(s))break}return s}isRuleRedundant(t){return t.isTrivial()?!0:t.outputFeatureSet.isSubsetOf(this.withRulesApplied(t.inputFeatureSet,e=>t.outputFeatureSet.isSubsetOf(e)))}findNextActionableEmbeddedRuleFromData(t,e,s=0,n,i=this.size){let r=0;for(let a=s;a<i;a++){r%1e3===0&&console.log("search",r),r++;const o=this.ruleIndices[a],l=this.data[o],c=this.patternBoards[l],d=M(c,t);for(const h of d)if(this.isActionableEmbeddingFromData(t,e,a,h)){const u=n?this.getRule(a,n(a)):this.getRule(a),f=u.embedded(t,h);if(F()&&(y(u.inputFeatureSet.getBoardMatchState(e,h,!0)===b.MATCH),y(u.outputFeatureSet.getBoardMatchState(e,h,!0)!==b.MATCH),y(!f||!!u.inputFeatureSet.embedded(c,h))),f)return{rule:u,embeddedRule:f,embedding:h,ruleIndex:a};debugger;throw new Error("Why would this happen")}}return null}isActionableEmbeddingFromData(t,e,s,n){let i=this.ruleIndices[s];const r=this.data[i++],a=this.patternBoards[r];F()&&y(a,"pattern board");const o=P(a);for(;;){const l=this.data[i++];if(l===255)break;if(l===254){const c=this.data[i++];for(F()&&y(c<128);;){const d=this.data[i++];if(d===255||d===254){i--;break}if(d&128){const h=d&127,u=e.oppositeFaceColors[n.mapFace(a.faces[c]).index],f=e.faceColors[n.mapFace(a.faces[h]).index];if(u!==f)return!1}else{const h=d,u=e.faceColors[n.mapFace(a.faces[c]).index],f=e.faceColors[n.mapFace(a.faces[h]).index];if(u!==f)return!1}}}else{const c=o.featureMatchers[l];if(c(e,n)!==b.MATCH)return!1}}for(;;){const l=this.data[i++];if(l===255)break;if(l===254){const c=this.data[i++];for(F()&&y(c<128);;){const d=this.data[i++];if(d===255||d===254){i--;break}if(d&128){const h=d&127,u=e.oppositeFaceColors[n.mapFace(a.faces[c]).index],f=e.faceColors[n.mapFace(a.faces[h]).index];if(u!==f)return!0}else{const h=d,u=e.faceColors[n.mapFace(a.faces[c]).index],f=e.faceColors[n.mapFace(a.faces[h]).index];if(u!==f)return!0}}}else{const c=o.featureMatchers[l];if(c(e,n)!==b.MATCH)return!0}}return!1}isActionableEmbeddingFromFeatureSet(t,e,s){let n=this.ruleIndices[e];const i=this.data[n++],r=this.patternBoards[i];F()&&y(r,"pattern board");const a=P(r);for(;;){const o=this.data[n++];if(o===255)break;if(o===254){const l=this.data[n++];F()&&y(l<128);const c=s.mapFace(r.faces[l]),d=t.getFaceColorDualFromFace(c);if(!d)return!1;const h=d.secondaryFaces.includes(c);F()&&y(h||d.primaryFaces.includes(c));const u=h?d.secondaryFaces:d.primaryFaces,f=h?d.primaryFaces:d.secondaryFaces;for(;;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const m=p&127,x=s.mapFace(r.faces[m]);if(!f.includes(x))return!1}else{const m=p,x=s.mapFace(r.faces[m]);if(!u.includes(x))return!1}}}else{const l=a.featureSetMatchers[o];if(l(t,s)!==b.MATCH)return!1}}for(;;){const o=this.data[n++];if(o===255)break;if(o===254){const l=this.data[n++];F()&&y(l<128);const c=s.mapFace(r.faces[l]),d=t.getFaceColorDualFromFace(c);if(!d)return!0;const h=d.secondaryFaces.includes(c);F()&&y(h||d.primaryFaces.includes(c));const u=h?d.secondaryFaces:d.primaryFaces,f=h?d.primaryFaces:d.secondaryFaces;for(;;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const m=p&127,x=s.mapFace(r.faces[m]);if(!f.includes(x))return!0}else{const m=p,x=s.mapFace(r.faces[m]);if(!u.includes(x))return!0}}}else{const l=a.featureSetMatchers[o];if(l(t,s)!==b.MATCH)return!0}}return!1}getActionableEmbeddingsFromData(t,e,s){let n=this.ruleIndices[s];const i=this.data[n++],r=this.patternBoards[i];F()&&y(r,"pattern board");const a=P(r);let o=M(r,t),l=o.slice();for(;;){const h=this.data[n++];let u=0;if(h===255)break;if(h===254){const f=this.data[n++];for(F()&&y(f<128);;){const p=this.data[n++];if(p===255||p===254){n--;break}if(p&128){const x=p&127;for(let I=0;I<o.length;I++){const B=o[I],w=e.oppositeFaceColors[B.mapFace(r.faces[f]).index],C=e.faceColors[B.mapFace(r.faces[x]).index];w===C&&(l[u++]=B)}}else{const x=p;for(let I=0;I<o.length;I++){const B=o[I],w=e.faceColors[B.mapFace(r.faces[f]).index],C=e.faceColors[B.mapFace(r.faces[x]).index];w===C&&(l[u++]=B)}}if(l.length=u,u===0)return l;const m=o;o=l,l=m,u=0}}else{const f=a.featureMatchers[h];for(let m=0;m<o.length;m++){const x=o[m];f(e,x)===b.MATCH&&(l[u++]=x)}if(l.length=u,u===0)return l;const p=o;o=l,l=p,u=0}}const c=o.map(()=>!1);let d=0;for(;;){const h=this.data[n++];if(h===255)break;if(h===254){const u=this.data[n++];for(F()&&y(u<128);;){const f=this.data[n++];if(f===255||f===254){n--;break}if(f&128){const p=f&127;for(let m=0;m<o.length;m++)if(!c[m]){const x=o[m],I=e.oppositeFaceColors[x.mapFace(r.faces[u]).index],B=e.faceColors[x.mapFace(r.faces[p]).index];I!==B&&(c[m]=!0,d++)}}else{const p=f;for(let m=0;m<o.length;m++)if(!c[m]){const x=o[m],I=e.faceColors[x.mapFace(r.faces[u]).index],B=e.faceColors[x.mapFace(r.faces[p]).index];I!==B&&(c[m]=!0,d++)}}}}else{const u=a.featureMatchers[h];for(let f=0;f<o.length;f++)if(!c[f]){const p=o[f];u(e,p)!==b.MATCH&&(c[f]=!0,d++)}}}return d?o.filter((h,u)=>c[u]):[]}serialize(){return{patternBoards:this.patternBoards.map(N),rules:W(this.data.subarray(0,this.nextRuleIndex)),highlander:this.highlander}}static deserialize(t){const e=$(t.rules);if(!e)throw new Error("Failed to decompress rules!");let s=0;const n=[];for(;s<e.length;){n.push(s),F()&&y(e[s]!==254);let i=0;for(;i<2;)F()&&y(s<e.length,"Unexpected end of data"),e[s++]===255&&i++}return new R(t.patternBoards.map(U),e,n,e.length,t.highlander)}static empty(){return new R([],new Uint8Array(0),[],0,!1)}static fromRules(t){const e=t.some(a=>a.highlander),s=A.uniq(t.map(a=>a.patternBoard)),n=[];let i=0;const r=[];for(const a of t)n.push(...a.getBinary(s)),r.push(i),i=n.length;return new R(s,new Uint8Array(n),r,i,e)}}export{R as B,V as H,J as g,K as i};
