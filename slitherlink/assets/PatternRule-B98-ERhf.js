var ee=Object.defineProperty;var se=(E,e,s)=>e in E?ee(E,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):E[e]=s;var p=(E,e,s)=>se(E,typeof e!="symbol"?e+"":e,s);import{d as l,e as h,_ as I,aa as X,aK as te,ak as ie,aL as re,a6 as ne,a8 as ae}from"./patternBoards-DzVBPT7g.js";import{a as oe,b as ce,c as le,d as de,e as he,f as Y,h as ue,l as _,i as fe,P as q}from"./PatternBoardSolver-DIArGw3P.js";import{f as j,E as L,a as $}from"./Vector2Property-CFyCN_2h.js";class m{constructor(e){this.edge=e}toCanonicalString(){return`black-${this.edge.index}`}isPossibleWith(e){return e(this.edge)}getPossibleFormula(e){return e(this.edge)}embedded(e){return this.edge.isExit?[]:[new m(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof m&&e.edge===this.edge}indexEquals(e){return e instanceof m&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"black-edge",edge:this.edge.index}}static deserialize(e,s){return new m(s.edges[e.edge])}}class A{constructor(e,s){this.face=e,this.value=s}toCanonicalString(){return`face-${this.face.index}-${this.value??"blank"}`}isPossibleWith(e){return this.face.edges.filter(t=>e(t)).length===this.value}getPossibleFormula(e){return this.value===null?oe:ce(this.face.edges.map(s=>e(s)),this.value)}embedded(e){return[new A(e.mapFace(this.face),this.value)]}equals(e){return e instanceof A&&e.face===this.face&&e.value===this.value}indexEquals(e){return e instanceof A&&e.face.index===this.face.index&&e.value===this.value}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face",face:this.face.index,value:this.value}}static deserialize(e,s){return new A(s.faces[e.face],e.value)}}const ge=(E,e)=>{const s=new Map,t=n=>{const a=n.slice(),o=[];for(;a.length;){const d=a.find(P=>P.isExit);l()&&h(d);const S=P=>{const W=P.vertices.flatMap(Z=>Z.edges).filter(Z=>a.includes(Z));return l()&&h(W.length===1),W[0]};j(a,d);let f=d;for(;f===d||!f.isExit;){const P=S(f);j(a,P),f=P}const T=f,R=Math.min(d.exitVertex.index,T.exitVertex.index),V=Math.max(d.exitVertex.index,T.exitVertex.index);o.push({minVertexIndex:R,maxVertexIndex:V})}const u=I.sortBy(o,d=>d.minVertexIndex);return`${e.map(d=>n.includes(d)?"1":"0")}${u.map(d=>`,c${d.minVertexIndex}-${d.maxVertexIndex}`)}`};for(const n of E){const a=t(n);s.has(a)?s.get(a).push(n):s.set(a,[n])}const i=[],r=[];for(const n of s.values())n.length>1?r.push(n):i.push(n[0]);return{highlanderSolutions:i,excludedSolutionGroups:r}},pe=(E,e)=>{const s=e.filter(i=>i instanceof A),t=new Set(s.map(i=>i.face));return E.edges.filter(i=>i.isExit||i.faces.some(r=>!t.has(r)))},U=new WeakMap;class H{constructor(e){p(this,"connectedFacePairs",[]);p(this,"connectedExitFacePairs",[]);p(this,"connectedComponents",[]);this.patternBoard=e;for(const s of e.faces){const t=new Set([s]),i=[new Q(s,[])];let r=!0;for(;i.length;){const n=i.shift(),{face:a,edges:o}=n;for(const u of a.edges)if(u.faces.length===2){const d=u.faces[0]===a?u.faces[1]:u.faces[0];if(!t.has(d)){const S=[...o,u];if(t.add(d),i.push(new Q(d,S)),s.index<d.index){const f=new me(s,d,S);this.connectedFacePairs.push(f),a.isExit&&d.isExit&&this.connectedExitFacePairs.push(f)}else r=!1}}}r&&this.connectedComponents.push([...t])}}static get(e){let s=U.get(e);return s||(s=new H(e),U.set(e,s)),s}}class me{constructor(e,s,t){this.a=e,this.b=s,this.shortestPath=t,l()&&h(e.index<s.index)}containsFace(e){return this.a===e||this.b===e}containsFacePair(e,s){return this.a===e&&this.b===s||this.a===s&&this.b===e}}class Q{constructor(e,s){this.face=e,this.edges=s}}class y extends Error{constructor(e,s){super(`Feature ${e.toCanonicalString()} incompatible with ${s.map(t=>t.toCanonicalString()).join(", ")}`),this.mainFeature=e,this.incompatibleFeatures=s}}class w{constructor(e,s){p(this,"allFaces",new Set);p(this,"canonicalString",null);p(this,"sameColorPaths",null);p(this,"oppositeColorPaths",null);if(this.primaryFaces=e,this.secondaryFaces=s,l()&&h(e.length+s.length>1),l()&&h(e.length),this.allFaces=new Set([...e,...s]),this.allFaces.size!==e.length+s.length)throw new y(this,[])}toCanonicalString(){if(this.canonicalString===null){const e=I.sortBy(this.primaryFaces.map(n=>n.index)),s=I.sortBy(this.secondaryFaces.map(n=>n.index)),t=e.length>s.length||e.length===s.length&&e[0]<s[0],i=t?e:s,r=t?s:e;this.canonicalString=`face-color-dual-${i.join(",")}-${r.join(",")}`}return this.canonicalString}isPossibleWith(e){for(const s of this.getSameColorPaths())if(s.filter(t=>e(t)).length%2!==0)return!1;for(const s of this.getOppositeColorPaths())if(s.filter(t=>e(t)).length%2===0)return!1;return!0}getPossibleFormula(e){return le([...this.getSameColorPaths().map(s=>de(s.map(t=>e(t)))),...this.getOppositeColorPaths().map(s=>he(s.map(t=>e(t))))])}embedded(e){const s=I.uniq(this.primaryFaces.map(i=>e.mapFace(i))),t=I.uniq(this.secondaryFaces.map(i=>e.mapFace(i)));return s.length===1&&t.length===0?[]:[new w(s,t)]}equals(e){if(!(e instanceof w)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(r=>i.includes(r));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}indexEquals(e){if(!(e instanceof w)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(r=>i.some(n=>r.index===n.index));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}isSubsetOf(e){if(!(e instanceof w)||this.allFaces.size>e.allFaces.size)return!1;for(const t of this.allFaces.values())if(!e.allFaces.has(t))return!1;return e.primaryFaces.includes(this.primaryFaces[0])?this.primaryFaces.every(t=>e.primaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.secondaryFaces.includes(t)):this.primaryFaces.every(t=>e.secondaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.primaryFaces.includes(t))}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face-color-dual",primaryFaces:this.primaryFaces.map(e=>e.index),secondaryFaces:this.secondaryFaces.map(e=>e.index)}}overlapsWith(e){for(const s of this.allFaces)if(e.allFaces.has(s))return!0;return!1}union(e){const s=this.primaryFaces.some(i=>e.primaryFaces.includes(i))||this.secondaryFaces.some(i=>e.secondaryFaces.includes(i)),t=this.primaryFaces.some(i=>e.secondaryFaces.includes(i))||this.secondaryFaces.some(i=>e.primaryFaces.includes(i));return l()&&h(s||t),s&&t?null:s?w.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.primaryFaces])],[...new Set([...this.secondaryFaces,...e.secondaryFaces])]):w.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.secondaryFaces])],[...new Set([...this.secondaryFaces,...e.primaryFaces])])}ensurePaths(){if(this.sameColorPaths===null){const e=[],s=[],t=new Set([...this.primaryFaces,...this.secondaryFaces]),i=this.primaryFaces[0],r=new Set([i]);for(let n=1;r.size<t.size;n++){if(n>100)throw new Error("FaceColorDualFeature.fromPrimarySecondaryFaces: could not find all connections");const a=(o,u,d)=>{for(const S of o.edges){if(S.faces.length!==2||u.includes(S))continue;const f=S.faces.find(T=>T!==o);if(l()&&h(f),!r.has(f))if(t.has(f)){const T=[...u,S],R=d,V=f;this.primaryFaces.includes(R)===this.primaryFaces.includes(V)?e.push(T):s.push(T),r.add(f)}else a(f,[...u,S],d)}};[...r].forEach(o=>a(o,[],o))}this.sameColorPaths=e,this.oppositeColorPaths=s}}getSameColorPaths(){return this.ensurePaths(),this.sameColorPaths}getOppositeColorPaths(){return this.ensurePaths(),this.oppositeColorPaths}isCompatibleWith(e){let s=!1,t=!1;const i=new Set([...this.allFaces].filter(r=>e.allFaces.has(r)));for(const r of this.primaryFaces)i.has(r)&&(e.primaryFaces.includes(r)&&(s=!0),e.secondaryFaces.includes(r)&&(t=!0));for(const r of this.secondaryFaces)i.has(r)&&(e.primaryFaces.includes(r)&&(t=!0),e.secondaryFaces.includes(r)&&(s=!0));return!s||!t}static areCanonicalWith(e,s){const t=e.map(i=>i.toCanonicalString()).sort().join("//");for(const i of s)if(e.map(n=>{const a=n.embedded(i);return l()&&h(a.length===1),a[0].toCanonicalString()}).sort().join("//")<t)return!1;return!0}static deserialize(e,s){return new w(e.primaryFaces.map(t=>s.faces[t]),e.secondaryFaces.map(t=>s.faces[t]))}static fromPrimarySecondaryFaces(e,s){return l()&&h(e.length+s.length>1),l()&&h(e.length),new w(e,s)}}const b=class b extends L{};p(b,"INCOMPATIBLE",new b),p(b,"NO_MATCH_NEEDS_FACE_VALUES",new b),p(b,"NO_MATCH_NEEDS_STATE",new b),p(b,"MATCH",new b),p(b,"enumeration",new $(b));let x=b;const k=class k extends L{};p(k,"INCOMPATIBLE",new k),p(k,"DORMANT",new k),p(k,"MATCH",new k),p(k,"enumeration",new $(k));let c=k;class g{constructor(e){this.edge=e}toCanonicalString(){return`red-${this.edge.index}`}isPossibleWith(e){return!e(this.edge)}getPossibleFormula(e){return Y(e(this.edge))}embedded(e){return this.edge.isExit?e.mapExitEdges(this.edge).map(s=>new g(s)):[new g(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof g&&e.edge===this.edge}indexEquals(e){return e instanceof g&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"red-edge",edge:this.edge.index}}static deserialize(e,s){return new g(s.edges[e.edge])}}class F{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==1}getPossibleFormula(e){return ue(this.sector.edges.map(s=>e(s)))}embedded(e){return[new F(e.mapSector(this.sector))]}equals(e){return e instanceof F&&e.sector===this.sector}indexEquals(e){return e instanceof F&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(o=>this.equals(o)))return!0;let s=!1,t=!1,i=!1,r=!1;const n=this.sector.edges[0],a=this.sector.edges[1];for(const o of e)o instanceof m&&(o.edge===n?s=!0:o.edge===a&&(t=!0)),o instanceof g&&(o.edge===n?i=!0:o.edge===a&&(r=!0));return s&&t||i&&r}serialize(){return{type:"sector-not-one",sector:this.sector.index}}static deserialize(e,s){return new F(s.sectors[e.sector])}}class M{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-two-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==2}getPossibleFormula(e){return _(this.sector.edges.map(s=>Y(e(s))))}embedded(e){return[new M(e.mapSector(this.sector))]}equals(e){return e instanceof M&&e.sector===this.sector}indexEquals(e){return e instanceof M&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof g&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-two",sector:this.sector.index}}static deserialize(e,s){return new M(s.sectors[e.sector])}}class z{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-zero-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==0}getPossibleFormula(e){return _(this.sector.edges.map(s=>e(s)))}embedded(e){return[new z(e.mapSector(this.sector))]}equals(e){return e instanceof z&&e.sector===this.sector}indexEquals(e){return e instanceof z&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof m&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-zero",sector:this.sector.index}}static deserialize(e,s){return new z(s.sectors[e.sector])}}class N{constructor(e){this.sector=e}toCanonicalString(){return`sector-only-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length===1}getPossibleFormula(e){return fe(this.sector.edges.map(s=>e(s)))}embedded(e){return[new N(e.mapSector(this.sector))]}equals(e){return e instanceof N&&e.sector===this.sector}indexEquals(e){return e instanceof N&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(i=>this.equals(i)))return!0;let s=!1,t=!1;for(const i of e)i instanceof m&&this.sector.edges.includes(i.edge)?s=!0:i instanceof g&&this.sector.edges.includes(i.edge)&&(t=!0);return s&&t}serialize(){return{type:"sector-only-one",sector:this.sector.index}}static deserialize(e,s){return new N(s.sectors[e.sector])}}const O=[];class C{constructor(e,s=new Map,t=new Set,i=new Set,r=new Set,n=new Set,a=new Set,o=new Set,u=new Set,d=new Map,S=new Set,f=new Map){p(this,"size");this.patternBoard=e,this.faceValueMap=s,this.blackEdges=t,this.redEdges=i,this.sectorsNotZero=r,this.sectorsNotOne=n,this.sectorsNotTwo=a,this.sectorsOnlyOne=o,this.faceColorDualFeatures=u,this.faceToColorDualMap=d,this.sectors=S,this.edgeToSectorsMap=f,this.size=this.computeSize()}addFaceValue(e,s){const t=this.faceValueMap.get(e);if(t!==void 0){if(t!==s)throw new y(new A(e,s),[new A(e,t)])}else this.faceValueMap.set(e,s),this.size++;l()&&this.verifySize()}addSameColorFaces(e,s){this.addFaceColorDual(w.fromPrimarySecondaryFaces([e,s],[]))}addOppositeColorFaces(e,s){this.addFaceColorDual(w.fromPrimarySecondaryFaces([e],[s]))}addFaceColorDual(e){l()&&h(e);const s=e;for(const t of[...this.faceColorDualFeatures])if(e.overlapsWith(t)){const i=e.union(t);if(i)e=i,this.faceColorDualFeatures.delete(t),this.size-=t.allFaces.size-1;else throw new y(s,[t])}this.faceColorDualFeatures.add(e),this.size+=e.allFaces.size-1;for(const t of e.allFaces)this.faceToColorDualMap.set(t,e);l()&&this.verifySize()}addBlackEdge(e){if(l()&&h(e),this.blackEdges.has(e))return;if(this.redEdges.has(e)){debugger;throw new y(new m(e),[new g(e)])}this.size++,this.blackEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(i);let r=0;if(this.sectorsNotZero.has(t)&&(this.sectorsNotZero.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.blackEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new y(new m(e),[new g(i),new F(t)]);r++}if(this.sectorsNotTwo.has(t))if(this.redEdges.has(i))this.sectorsNotTwo.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new y(new m(e),[new m(i),new M(t)]);r++}if(this.sectorsOnlyOne.has(t))if(this.redEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new y(new m(e),[new m(i),new N(t)]);r++}r===0&&this.removeSector(t)}l()&&this.verifySize()}addRedEdge(e){if(l()&&h(e),this.redEdges.has(e))return;if(this.blackEdges.has(e))throw new y(new g(e),[new m(e)]);this.size++,this.redEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(i);let r=0;if(this.sectorsNotTwo.has(t)&&(this.sectorsNotTwo.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.redEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new y(new g(e),[new m(i),new F(t)]);r++}if(this.sectorsNotZero.has(t))if(this.blackEdges.has(i))this.sectorsNotZero.delete(t),this.size--;else{if(this.redEdges.has(i))throw new y(new g(e),[new g(i),new z(t)]);r++}if(this.sectorsOnlyOne.has(t))if(this.blackEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new y(new g(e),[new g(i),new N(t)]);r++}r===0&&this.removeSector(t)}l()&&this.verifySize()}addSectorNotZero(e){if(l()&&h(e),this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.redEdges.has(s),r=this.redEdges.has(t);if(i&&r)throw new y(new z(e),[new g(s),new g(t)]);this.blackEdges.has(s)||this.blackEdges.has(t)||(i?this.addBlackEdge(t):r?this.addBlackEdge(s):this.sectorsNotOne.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.size--,this.sectorsNotTwo.delete(e),this.addSectorOnlyOne(e)):(this.size++,this.sectorsNotZero.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotOne(e){if(l()&&h(e),this.sectorsNotOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),r=this.blackEdges.has(t),n=this.redEdges.has(s),a=this.redEdges.has(t);if(i&&a)throw new y(new F(e),[new m(s),new g(t)]);if(r&&n)throw new y(new F(e),[new m(t),new g(s)]);if(this.sectorsOnlyOne.has(e))throw new y(new F(e),[new N(e)]);i&&r||n&&a||(i?this.addBlackEdge(t):r?this.addBlackEdge(s):n?this.addRedEdge(t):a?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotOne.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotTwo(e){if(l()&&h(e),this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),r=this.blackEdges.has(t);if(i&&r)throw new y(new M(e),[new m(s),new m(t)]);this.redEdges.has(s)||this.redEdges.has(t)||(i?this.addRedEdge(t):r?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.size--,this.sectorsNotZero.delete(e),this.addSectorOnlyOne(e)):this.sectorsNotOne.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotTwo.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorOnlyOne(e){if(l()&&h(e),this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.blackEdges.has(s),r=this.blackEdges.has(t),n=this.redEdges.has(s),a=this.redEdges.has(t);if(i&&r)throw new y(new N(e),[new m(s),new m(t)]);if(n&&a)throw new y(new N(e),[new g(s),new g(t)]);if(this.sectorsNotOne.has(e))throw new y(new N(e),[new F(e)]);i&&a||r&&n||(i?this.addRedEdge(t):r?this.addRedEdge(s):n?this.addBlackEdge(t):a?this.addBlackEdge(s):this.sectorsNotZero.has(e)&&(this.size--,this.sectorsNotZero.delete(e)),this.sectorsNotTwo.has(e)&&(this.size--,this.sectorsNotTwo.delete(e)),this.size++,this.sectorsOnlyOne.add(e),this.ensureSector(e),l()&&this.verifySize())}addFeature(e){if(e instanceof A)this.addFaceValue(e.face,e.value);else if(e instanceof w)this.addFaceColorDual(e);else if(e instanceof m)this.addBlackEdge(e.edge);else if(e instanceof g)this.addRedEdge(e.edge);else if(e instanceof z)this.addSectorNotZero(e.sector);else if(e instanceof F)this.addSectorNotOne(e.sector);else if(e instanceof M)this.addSectorNotTwo(e.sector);else if(e instanceof N)this.addSectorOnlyOne(e.sector);else throw new Error(`unimplemented type of feature for FeatureSet: ${e}`);l()&&this.verifySize()}ensureSector(e){if(!this.sectors.has(e)){this.sectors.add(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);let i=this.edgeToSectorsMap.get(s);i?i.add(e):(i=new Set([e]),this.edgeToSectorsMap.set(s,i));let r=this.edgeToSectorsMap.get(t);r?r.add(e):(r=new Set([e]),this.edgeToSectorsMap.set(t,r))}}removeSector(e){if(this.sectors.has(e)){this.sectors.delete(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const i=this.edgeToSectorsMap.get(s);i&&(i.delete(e),i.size===0&&this.edgeToSectorsMap.delete(s));const r=this.edgeToSectorsMap.get(t);r&&(r.delete(e),r.size===0&&this.edgeToSectorsMap.delete(t))}}computeSize(){let e=this.faceValueMap.size+this.blackEdges.size+this.redEdges.size+this.sectorsNotZero.size+this.sectorsNotOne.size+this.sectorsNotTwo.size+this.sectorsOnlyOne.size;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}verifySize(){l()&&h(this.size===this.computeSize(),"size mismatch")}getInputDifficultyScoreA(){let e=0;e+=this.faceValueMap.size*.5,e+=this.blackEdges.size*1;for(const s of this.redEdges)e+=s.isExit?2.5:1.2;e+=this.sectorsOnlyOne.size*3,e+=this.sectorsNotOne.size*4,e+=this.sectorsNotTwo.size*4.1,e+=this.sectorsNotZero.size*4.2;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}getInputDifficultyScoreB(){let e=0;const s=1,t=.8;e+=1.3*this.patternBoard.faces.filter(i=>!i.isExit).length,this.patternBoard.vertices.length===0?e-=10:this.patternBoard.vertices.length===1&&(e-=4);for(const i of this.faceValueMap.values())i===null?e+=.01:i===0?e+=.4:e+=.5;e+=this.blackEdges.size*s;for(const i of this.redEdges)i.isExit?i.exitVertex.edges.length>=4?e+=t:e+=2*t:e+=t;e+=this.sectorsOnlyOne.size*1.5,e+=this.sectorsNotOne.size*1.6,e+=this.sectorsNotTwo.size*1.7,e+=this.sectorsNotZero.size*1.8;for(const i of this.faceColorDualFeatures)e+=i.allFaces.size-1;return e}static empty(e){return new C(e)}static emptyWithVertexOrderLimit(e,s){const t=C.empty(e);for(const i of e.vertices)i.isExit&&i.edges.length>s&&t.addRedEdge(i.exitEdge);return t}static fromFeatures(e,s){const t=new C(e);for(const i of s)t.addFeature(i);return t}static fromSolution(e,s){return C.fromFeatures(e,[...e.edges.filter(t=>!s.includes(t)||!t.isExit).map(t=>s.includes(t)?new m(t):new g(t))])}clone(){return new C(this.patternBoard,new Map(this.faceValueMap),new Set(this.blackEdges),new Set(this.redEdges),new Set(this.sectorsNotZero),new Set(this.sectorsNotOne),new Set(this.sectorsNotTwo),new Set(this.sectorsOnlyOne),new Set(this.faceColorDualFeatures),new Map(this.faceToColorDualMap),new Set(this.sectors),new Map(this.edgeToSectorsMap))}getFeaturesArray(){return[...[...this.faceValueMap.entries()].map(([e,s])=>new A(e,s)),...this.faceColorDualFeatures,...[...this.blackEdges].map(e=>new m(e)),...[...this.redEdges].map(e=>new g(e)),...[...this.sectorsNotZero].map(e=>new z(e)),...[...this.sectorsNotOne].map(e=>new F(e)),...[...this.sectorsNotTwo].map(e=>new M(e)),...[...this.sectorsOnlyOne].map(e=>new N(e))]}getHighlanderFeaturesArray(){return this.getFeaturesArray().filter(e=>e instanceof A||e instanceof g&&e.edge.isExit)}getFaceValue(e){return this.faceValueMap.get(e)}getFaceColorDualFromFace(e){return this.faceToColorDualMap.get(e)??null}impliesFaceValue(e,s){const t=this.faceValueMap.get(e);return t!==void 0&&t===s}impliesBlackEdge(e){return this.blackEdges.has(e)}impliesRedEdge(e){return this.redEdges.has(e)}impliesSectorNotZero(e){return this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])||this.blackEdges.has(e.edges[1])}impliesSectorNotOne(e){return this.sectorsNotOne.has(e)||this.blackEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])}impliesSectorNotTwo(e){return this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e)||this.redEdges.has(e.edges[0])||this.redEdges.has(e.edges[1])}impliesSectorOnlyOne(e){return this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])}impliesFaceColorDualFeature(e){for(const s of this.faceColorDualFeatures)if(e.isSubsetOf(s))return!0;return!1}impliesFeature(e){if(e instanceof w)return this.impliesFaceColorDualFeature(e);if(e instanceof m)return this.impliesBlackEdge(e.edge);if(e instanceof g)return this.impliesRedEdge(e.edge);if(e instanceof z)return this.impliesSectorNotZero(e.sector);if(e instanceof F)return this.impliesSectorNotOne(e.sector);if(e instanceof M)return this.impliesSectorNotTwo(e.sector);if(e instanceof N)return this.impliesSectorOnlyOne(e.sector);if(e instanceof A)return this.impliesFaceValue(e.face,e.value);throw new Error(`unimplemented type of feature for FeatureSet: ${e}`)}getAffectedEdges(){return new Set([...this.blackEdges,...this.redEdges,...this.edgeToSectorsMap.keys()])}getAffectedSectors(){return new Set([...this.sectorsNotZero.values(),...this.sectorsNotOne.values(),...this.sectorsNotTwo.values(),...this.sectorsOnlyOne.values()])}getAffectedFaces(){const e=new Set(this.faceValueMap.keys());for(const s of this.faceColorDualFeatures)for(const t of s.allFaces)e.add(t);return e}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.hasSameShapeAs(e))return!1;const s=X(this.patternBoard,this.patternBoard);for(const t of s)try{const i=this.embedded(this.patternBoard,t);if(i&&i.equals(e))return!0}catch(i){if(!(i instanceof y))throw i}return!1}isCanonicalWith(e){O.length=0;for(const s of e)l()&&h(s.isAutomorphism),s.isIdentityAutomorphism||O.push(s);if(O.length===0)return!0;if(this.faceValueMap.size)for(let s=0;s<this.patternBoard.faces.length&&O.length;s++){const t=this.patternBoard.faces[s],i=this.faceValueMap.get(t),r=i===void 0?-2:i===null?-1:i;for(let n=0;n<O.length;n++){const o=O[n].inverseMapFace(t);l()&&h(o);const u=this.faceValueMap.get(o),d=u===void 0?-2:u===null?-1:u;if(d<r)return!1;d>r&&(O.splice(n,1),n--)}}if(this.blackEdges.size||this.redEdges.size)for(let s=0;s<this.patternBoard.edges.length&&O.length;s++){const t=this.patternBoard.edges[s],i=this.blackEdges.has(t)?1:this.redEdges.has(t)?2:0;for(let r=0;r<O.length;r++){const a=O[r].inverseMapEdge(t);l()&&h(a);const o=this.blackEdges.has(a)?1:this.redEdges.has(a)?2:0;if(o<i)return!1;o>i&&(O.splice(r,1),r--)}}if(this.sectorsNotZero.size||this.sectorsNotOne.size||this.sectorsNotTwo.size||this.sectorsOnlyOne.size)for(let s=0;s<this.patternBoard.sectors.length&&O.length;s++){const t=this.patternBoard.sectors[s],i=(this.sectorsOnlyOne.has(t)?1:0)+(this.sectorsNotOne.has(t)?2:0)+(this.sectorsNotTwo.has(t)?4:0)+(this.sectorsNotZero.has(t)?8:0);for(let r=0;r<O.length;r++){const a=O[r].inverseMapSector(t);l()&&h(a);const o=(this.sectorsOnlyOne.has(a)?1:0)+(this.sectorsNotOne.has(a)?2:0)+(this.sectorsNotTwo.has(a)?4:0)+(this.sectorsNotZero.has(a)?8:0);if(o<i)return!1;o>i&&(O.splice(r,1),r--)}}return!(this.faceColorDualFeatures.size&&!w.areCanonicalWith([...this.faceColorDualFeatures],O))}embedded(e,s){try{return C.fromFeatures(e,this.getFeaturesArray().flatMap(t=>t.embedded(s)))}catch(t){if(t instanceof y)return null;throw t}}hasSameShapeAs(e){return this.faceValueMap.size===e.faceValueMap.size&&this.blackEdges.size===e.blackEdges.size&&this.redEdges.size===e.redEdges.size&&this.sectorsNotZero.size===e.sectorsNotZero.size&&this.sectorsNotOne.size===e.sectorsNotOne.size&&this.sectorsNotTwo.size===e.sectorsNotTwo.size&&this.sectorsOnlyOne.size===e.sectorsOnlyOne.size&&this.faceColorDualFeatures.size===e.faceColorDualFeatures.size}getBoardMatchState(e,s,t=!1){let i=!0;for(const[r,n]of this.faceValueMap)if(e.faceValues[s.mapFace(r).index]!==n)return c.INCOMPATIBLE;for(const r of this.blackEdges){l()&&h(!r.isExit);const n=s.mapNonExitEdge(r).index;if(!e.blackEdgeValues[n]){if(i=!1,e.redEdgeValues[n])return c.INCOMPATIBLE;if(t)return c.DORMANT}}for(const r of this.redEdges)if(r.isExit){const n=s.mapExitEdges(r);for(const a of n){const o=a.index;if(!e.redEdgeValues[o]){if(i=!1,e.blackEdgeValues[o])return c.INCOMPATIBLE;if(t)return c.DORMANT}}}else{const n=s.mapNonExitEdge(r).index;if(!e.redEdgeValues[n]){if(i=!1,e.blackEdgeValues[n])return c.INCOMPATIBLE;if(t)return c.DORMANT}}for(const r of this.sectorsNotZero){const n=s.mapSector(r).index;if(!e.sectorNotZeroValues[n]&&(i=!1,t))return c.DORMANT}for(const r of this.sectorsNotOne){const n=s.mapSector(r).index;if(!e.sectorNotOneValues[n]&&(i=!1,t))return c.DORMANT}for(const r of this.sectorsNotTwo){const n=s.mapSector(r).index;if(!e.sectorNotTwoValues[n]&&(i=!1,t))return c.DORMANT}for(const r of this.sectorsOnlyOne){const n=s.mapSector(r).index;if(!e.sectorOnlyOneValues[n]&&(i=!1,t))return c.DORMANT}for(const r of this.faceColorDualFeatures){const n=r.primaryFaces.map(u=>e.faceColors[s.mapFace(u).index]),a=n[0];l()&&h(a);for(const u of n)if(u!==a&&(i=!1,t))return c.DORMANT;const o=r.secondaryFaces.map(u=>e.faceColors[s.mapFace(u).index]);if(o.length>1){const u=o[0];for(const d of o)if(d!==u&&(i=!1,t))return c.DORMANT}if(o.length){const u=r.secondaryFaces.map(d=>e.oppositeFaceColors[s.mapFace(d).index]);for(const d of u)if(d!==a&&(i=!1,t))return c.DORMANT;if(!i&&!t){for(const d of u)if(o.includes(d))return c.INCOMPATIBLE}}if(!i&&!t){const u=r.primaryFaces.map(d=>e.oppositeFaceColors[s.mapFace(d).index]);for(const d of n)if(o.includes(d))return c.INCOMPATIBLE;for(const d of u)if(n.includes(d))return c.INCOMPATIBLE}}return i?c.MATCH:c.DORMANT}getShapeString(){return`${this.faceValueMap.size} ${this.blackEdges.size} ${this.redEdges.size} ${this.sectorsNotZero.size} ${this.sectorsNotOne.size} ${this.sectorsNotTwo.size} ${this.sectorsOnlyOne.size} ${this.faceColorDualFeatures.size}`}isSubsetOf(e){for(const s of this.blackEdges)if(!e.impliesBlackEdge(s))return!1;for(const s of this.redEdges)if(!e.impliesRedEdge(s))return!1;for(const[s,t]of this.faceValueMap)if(!e.impliesFaceValue(s,t))return!1;for(const s of this.sectorsNotZero)if(!e.impliesSectorNotZero(s))return!1;for(const s of this.sectorsNotOne)if(!e.impliesSectorNotOne(s))return!1;for(const s of this.sectorsNotTwo)if(!e.impliesSectorNotTwo(s))return!1;for(const s of this.sectorsOnlyOne)if(!e.impliesSectorOnlyOne(s))return!1;for(const s of this.faceColorDualFeatures)if(!e.impliesFaceColorDualFeature(s))return!1;return!0}equals(e){if(!this.hasSameShapeAs(e))return!1;for(const[t,i]of this.faceValueMap)if(e.faceValueMap.get(t)!==i)return!1;for(const t of this.blackEdges)if(!e.blackEdges.has(t))return!1;for(const t of this.redEdges)if(!e.redEdges.has(t))return!1;for(const t of this.sectorsNotZero)if(!e.sectorsNotZero.has(t))return!1;for(const t of this.sectorsNotOne)if(!e.sectorsNotOne.has(t))return!1;for(const t of this.sectorsNotTwo)if(!e.sectorsNotTwo.has(t))return!1;for(const t of this.sectorsOnlyOne)if(!e.sectorsOnlyOne.has(t))return!1;const s=new Set;e.faceColorDualFeatures.forEach(t=>s.add(t.toCanonicalString()));for(const t of this.faceColorDualFeatures)if(!s.has(t.toCanonicalString()))return!1;return!0}applyFeaturesFrom(e){e.getFeaturesArray().forEach(s=>this.addFeature(s))}union(e){if(this.size<e.size)return e.union(this);const s=this.clone();try{return s.applyFeaturesFrom(e),s}catch(t){if(t instanceof y)return null;throw t}}isCompatibleWith(e){return this.union(e)!==null}getQuickCompatibilityWith(e){let s=!0;for(const i of this.blackEdges){if(e.impliesRedEdge(i))return x.INCOMPATIBLE;s&&!e.impliesBlackEdge(i)&&(s=!1)}for(const i of this.redEdges){if(e.impliesBlackEdge(i))return x.INCOMPATIBLE;s&&!e.impliesRedEdge(i)&&(s=!1)}for(const i of this.sectorsNotZero)s&&!e.impliesSectorNotZero(i)&&(s=!1);for(const i of this.sectorsNotOne){if(e.impliesSectorOnlyOne(i))return x.INCOMPATIBLE;s&&!e.impliesSectorNotOne(i)&&(s=!1)}for(const i of this.sectorsNotTwo)s&&!e.impliesSectorNotTwo(i)&&(s=!1);for(const i of this.sectorsOnlyOne){if(e.impliesSectorNotOne(i))return x.INCOMPATIBLE;s&&!e.impliesSectorOnlyOne(i)&&(s=!1)}for(const i of this.faceColorDualFeatures)s&&!e.impliesFaceColorDualFeature(i)&&(s=!1);let t=!0;for(const[i,r]of this.faceValueMap){const n=e.getFaceValue(i);if(n===void 0)t=!1;else if(n!==r)return x.INCOMPATIBLE}return t?s?x.MATCH:x.NO_MATCH_NEEDS_STATE:x.NO_MATCH_NEEDS_FACE_VALUES}toCanonicalString(){return`feat:${I.sortBy(this.getFeaturesArray().map(e=>e.toCanonicalString())).join("/")}`}getSolutions(e=!1){const s=this.getFeaturesArray();let t=q.getSolutions(this.patternBoard,s);return t.length&&e&&(t=ge(t,pe(this.patternBoard,s)).highlanderSolutions),t}hasSolution(e=!1){return e?this.getSolutions(e).length>0:q.hasSolution(this.patternBoard,this.getFeaturesArray())}addSolvedEdgeFeatures(e){const s=new Array(this.patternBoard.edges.length).fill(!1),t=new Array(this.patternBoard.edges.length).fill(!1),i=new Set(this.patternBoard.edges),r=new Set(this.patternBoard.vertices.filter(n=>n.isExit));for(const n of e){const a=new Set(i);for(const o of n)s[o.index]=!0,a.delete(o);for(const o of a)t[o.index]=!0;for(const o of[...r])n.has(o.exitEdge)&&r.delete(o),o.edges.filter(u=>n.has(u)).length<2&&r.delete(o)}for(const n of this.patternBoard.edges)if(!n.isExit){const a=s[n.index],o=t[n.index];a&&!o&&this.addBlackEdge(n),!a&&o&&this.addRedEdge(n)}for(const n of r)this.addRedEdge(n.exitEdge)}addSolvedSectorFeatures(e){const s=new Array(this.patternBoard.sectors.length).fill(!1),t=new Array(this.patternBoard.sectors.length).fill(!1),i=new Array(this.patternBoard.sectors.length).fill(!1);for(const r of e)for(const n of this.patternBoard.sectors){const a=(r.has(n.edges[0])?1:0)+(r.has(n.edges[1])?1:0);a===0?s[n.index]=!0:a===1?t[n.index]=!0:a===2&&(i[n.index]=!0)}for(const r of this.patternBoard.sectors){const n=s[r.index],a=t[r.index],o=i[r.index];a&&!n&&!o?this.addSectorOnlyOne(r):n&&a&&!o?this.addSectorNotTwo(r):n&&o&&!a?this.addSectorNotOne(r):!n&&a&&o&&this.addSectorNotZero(r)}}addSolvedFaceColorDualFeatures(e){l()&&h(e.length>0);const s=H.get(this.patternBoard),t=new Set(s.connectedFacePairs.map(i=>new Ee(i)));for(const i of e)for(const r of[...t]){let n=!0;for(const a of r.pair.shortestPath)i.has(a)&&(n=!n);n?r.isOnlyOpposite=!1:r.isOnlySame=!1,!r.isOnlySame&&!r.isOnlyOpposite&&t.delete(r)}for(const i of t)i.isOnlySame?this.addSameColorFaces(i.pair.a,i.pair.b):i.isOnlyOpposite&&this.addOppositeColorFaces(i.pair.a,i.pair.b)}serialize(){const e={};return this.faceValueMap.size>0&&(e.faceValues=[...this.faceValueMap.entries()].map(([s,t])=>({face:s.index,value:t}))),this.blackEdges.size>0&&(e.blackEdges=[...this.blackEdges].map(s=>s.index)),this.redEdges.size>0&&(e.redEdges=[...this.redEdges].map(s=>s.index)),this.sectorsNotZero.size>0&&(e.sectorsNotZero=[...this.sectorsNotZero].map(s=>s.index)),this.sectorsNotOne.size>0&&(e.sectorsNotOne=[...this.sectorsNotOne].map(s=>s.index)),this.sectorsNotTwo.size>0&&(e.sectorsNotTwo=[...this.sectorsNotTwo].map(s=>s.index)),this.sectorsOnlyOne.size>0&&(e.sectorsOnlyOne=[...this.sectorsOnlyOne].map(s=>s.index)),this.faceColorDualFeatures.size>0&&(e.faceColorDualFeatures=[...this.faceColorDualFeatures].map(s=>s.serialize())),e}static deserialize(e,s){const t=new C(s);for(const i of e.faceValues||[])t.addFaceValue(s.faces[i.face],i.value);for(const i of e.blackEdges||[])t.addBlackEdge(s.edges[i]);for(const i of e.redEdges||[])t.addRedEdge(s.edges[i]);for(const i of e.sectorsNotZero||[])t.addSectorNotZero(s.sectors[i]);for(const i of e.sectorsNotOne||[])t.addSectorNotOne(s.sectors[i]);for(const i of e.sectorsNotTwo||[])t.addSectorNotTwo(s.sectors[i]);for(const i of e.sectorsOnlyOne||[])t.addSectorOnlyOne(s.sectors[i]);for(const i of e.faceColorDualFeatures||[])t.addFaceColorDual(w.deserialize(i,s));return t}}const xe={solveEdges:!0,solveSectors:!1,solveFaceColors:!1,highlander:!1};class Ee{constructor(e){p(this,"isOnlySame",!0);p(this,"isOnlyOpposite",!0);this.pair=e}}class Se{constructor(e){p(this,"featureArray",[]);p(this,"featureMatchers",[]);p(this,"featureSetMatchers",[]);this.patternBoard=e;for(const s of e.faces){const t=s.isExit?[null]:[...I.range(0,s.edges.length),null];for(const i of t)this.featureArray.push(new A(s,i)),this.featureMatchers.push((r,n)=>r.faceValues[n.mapFace(s).index]===i?c.MATCH:c.INCOMPATIBLE),this.featureSetMatchers.push((r,n)=>r.impliesFaceValue(n.mapFace(s),i)?c.MATCH:c.INCOMPATIBLE)}for(const s of e.edges)this.featureArray.push(new g(s)),this.featureMatchers.push((t,i)=>{if(s.isExit){const r=i.mapExitEdges(s);let n=!0;for(const a of r){const o=a.index;if(t.redEdgeValues[o])continue;if(n=!1,t.blackEdgeValues[o])return c.INCOMPATIBLE}return n?c.MATCH:c.DORMANT}else{const r=i.mapNonExitEdge(s).index;return t.redEdgeValues[r]?c.MATCH:t.blackEdgeValues[r]?c.INCOMPATIBLE:c.DORMANT}}),this.featureSetMatchers.push((t,i)=>{if(s.isExit){const r=i.mapExitEdges(s);let n=!0;for(const a of r){if(t.impliesRedEdge(a))continue;if(n=!1,t.impliesBlackEdge(a))return c.INCOMPATIBLE}return n?c.MATCH:c.DORMANT}else{const r=i.mapNonExitEdge(s);return t.impliesRedEdge(r)?c.MATCH:t.impliesBlackEdge(r)?c.INCOMPATIBLE:c.DORMANT}}),s.isExit||(this.featureArray.push(new m(s)),this.featureMatchers.push((t,i)=>{const r=i.mapNonExitEdge(s).index;return t.blackEdgeValues[r]?c.MATCH:t.redEdgeValues[r]?c.INCOMPATIBLE:c.DORMANT}),this.featureSetMatchers.push((t,i)=>{const r=i.mapNonExitEdge(s);return t.impliesBlackEdge(r)?c.MATCH:t.impliesRedEdge(r)?c.INCOMPATIBLE:c.DORMANT}));for(const s of e.sectors)this.featureArray.push(new z(s)),this.featureMatchers.push((t,i)=>t.sectorNotZeroValues[i.mapSector(s).index]?c.MATCH:c.DORMANT),this.featureSetMatchers.push((t,i)=>t.impliesSectorNotZero(i.mapSector(s))?c.MATCH:c.DORMANT),this.featureArray.push(new F(s)),this.featureMatchers.push((t,i)=>t.sectorNotOneValues[i.mapSector(s).index]?c.MATCH:c.DORMANT),this.featureSetMatchers.push((t,i)=>t.impliesSectorNotOne(i.mapSector(s))?c.MATCH:c.DORMANT),this.featureArray.push(new M(s)),this.featureMatchers.push((t,i)=>t.sectorNotTwoValues[i.mapSector(s).index]?c.MATCH:c.DORMANT),this.featureSetMatchers.push((t,i)=>t.impliesSectorNotTwo(i.mapSector(s))?c.MATCH:c.DORMANT),this.featureArray.push(new N(s)),this.featureMatchers.push((t,i)=>t.sectorOnlyOneValues[i.mapSector(s).index]?c.MATCH:c.DORMANT),this.featureSetMatchers.push((t,i)=>t.impliesSectorOnlyOne(i.mapSector(s))?c.MATCH:c.DORMANT);l()&&h(this.featureArray.length===this.featureMatchers.length),l()&&h(this.featureArray.length===this.featureSetMatchers.length),l()&&h(this.featureArray.length<=254,"Our limit for encoding in a byte")}}const K=new WeakMap,G=E=>{let e=K.get(E);return e||(e=new Se(E),K.set(E,e)),e},J=E=>{let e=te(E);if(e)return e;const s=ie(E);return e=re(s),e||new ne(s)},ye=E=>E.name?E.name:ae(E.descriptor),B=class B extends L{};p(B,"INCOMPATIBLE",new B),p(B,"INCONSEQUENTIAL",new B),p(B,"DORMANT",new B),p(B,"ACTIONABLE",new B),p(B,"enumeration",new $(B));let v=B;class D{constructor(e,s,t,i=!1){this.patternBoard=e,this.inputFeatureSet=s,this.outputFeatureSet=t,this.highlander=i}getInputDifficultyScoreA(){return this.inputFeatureSet.getInputDifficultyScoreA()+.75*this.patternBoard.vertices.length}getInputDifficultyScoreB(){return this.inputFeatureSet.getInputDifficultyScoreB()}embedded(e,s){const t=this.inputFeatureSet.embedded(e,s);if(t===null)return null;const i=this.outputFeatureSet.embedded(e,s);return i===null?null:new D(e,t,i,this.highlander)}getEmbeddedRules(e){return e.map(s=>this.embedded(s.targetPatternBoard,s)).filter(s=>s!==null)}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.inputFeatureSet.hasSameShapeAs(e.inputFeatureSet)||!this.outputFeatureSet.hasSameShapeAs(e.outputFeatureSet))return!1;const s=X(this.patternBoard,this.patternBoard);for(const t of s){const i=this.embedded(this.patternBoard,t);if(i&&i.inputFeatureSet.equals(e.inputFeatureSet)&&i.outputFeatureSet.equals(e.outputFeatureSet))return!0}return!1}isSubsetOf(e){return this.inputFeatureSet.isSubsetOf(e.inputFeatureSet)&&this.outputFeatureSet.isSubsetOf(e.outputFeatureSet)}matches(e){return this.inputFeatureSet.isSubsetOf(e)}getMatchState(e){const s=this.inputFeatureSet.getQuickCompatibilityWith(e);return s===x.INCOMPATIBLE||s===x.NO_MATCH_NEEDS_FACE_VALUES?v.INCOMPATIBLE:this.outputFeatureSet.isSubsetOf(e)?v.INCONSEQUENTIAL:s===x.NO_MATCH_NEEDS_STATE?v.DORMANT:v.ACTIONABLE}isRedundant(e){if(this.isTrivial())return!0;const s=this.outputFeatureSet,t=e.filter(i=>i.outputFeatureSet.isSubsetOf(s));return this.outputFeatureSet.isSubsetOf(D.withRulesApplied(this.patternBoard,this.inputFeatureSet,t))}hasApplication(e){return this.matches(e)&&!this.outputFeatureSet.isSubsetOf(e)}apply(e){l()&&h(this.hasApplication(e)),e.applyFeaturesFrom(this.outputFeatureSet)}isTrivial(){return this.outputFeatureSet.isSubsetOf(this.inputFeatureSet)}isCorrectSlow(){const e=q.countSolutions(this.patternBoard,this.inputFeatureSet.getFeaturesArray()),s=q.countSolutions(this.patternBoard,this.outputFeatureSet.getFeaturesArray());return e===s}toCanonicalString(){return`rule:${this.inputFeatureSet.toCanonicalString()}->${this.outputFeatureSet.toCanonicalString()}`}equals(e){return this.patternBoard===e.patternBoard&&this.inputFeatureSet.equals(e.inputFeatureSet)&&this.outputFeatureSet.equals(e.outputFeatureSet)&&this.highlander===e.highlander}getBinaryIdentifier(){const e=this.patternBoard.name;if(!e)throw new Error("Pattern board must have a name");const s=this.getBinary([this.patternBoard]).slice(1),t=btoa(String.fromCharCode.apply(null,[this.highlander?1:0,...s])),i=`${e}/${t}`;if(l()){const r=D.fromBinaryIdentifier(i);h(r.equals(this),"round-trip equality")}return i}static fromBinaryIdentifier(e){const s=e.indexOf("/"),t=e.slice(0,s),i=e.slice(s+1),r=atob(i).split("").map(a=>a.charCodeAt(0)),n=J(t);return D.fromBinary([n],[0,...r.slice(1)],0,r[0]!==0)}getBinary(e){const s=[],t=e.indexOf(this.patternBoard);l()&&h(t!==-1&&t<256,"pattern board index"),s.push(t);const i=G(this.patternBoard),r=this.inputFeatureSet.getFeaturesArray(),n=this.outputFeatureSet.getFeaturesArray().filter(o=>!r.some(u=>u.equals(o))),a=o=>{const u=o.filter(S=>!(S instanceof w)),d=o.filter(S=>S instanceof w);for(const S of u){const f=i.featureArray.findIndex(T=>T.equals(S));l()&&h(f!==-1,"feature index"),s.push(f)}for(const S of d){s.push(254);for(const f of S.primaryFaces)l()&&h(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),s.push(f.index);for(const f of S.secondaryFaces)l()&&h(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),s.push(f.index|128)}};if(a(r),s.push(255),a(n),s.push(255),l()){const o=new Uint8Array(s),u=D.fromBinary(e,o,0,this.highlander);h(u.equals(this),"round-trip equality")}return s}static fromBinary(e,s,t,i){const r=s[t++],n=e[r];l()&&h(n,"pattern board");const a=G(n),o=()=>{const S=C.empty(n);for(;;){const f=s[t++];if(f===255)return S;if(f===254){const T=[],R=[];for(;;){const V=s[t++];if(V===255||V===254){t--;break}V&128?R.push(n.faces[V&127]):T.push(n.faces[V])}S.addFeature(w.fromPrimarySecondaryFaces(T,R))}else S.addFeature(a.featureArray[f])}},u=o(),d=o().union(u);return l()&&h(d),new D(n,u,d,i)}serialize(){const e={patternBoard:ye(this.patternBoard),input:this.inputFeatureSet.serialize(),output:this.outputFeatureSet.serialize()};return this.highlander&&(e.highlander=!0),e}collectionSerialize(e){return{...this.serialize(),patternBoard:e}}static deserialize(e){const s=J(e.patternBoard);return new D(s,C.deserialize(e.input,s),C.deserialize(e.output,s),e.highlander??!1)}static collectionDeserialize(e,s){const t=e[s.patternBoard];return l()&&h(t,"pattern board"),new D(t,C.deserialize(s.input,t),C.deserialize(s.output,t),s.highlander??!1)}static withRulesApplied(e,s,t){l()&&h(t.every(o=>o.patternBoard===e),"embedding check");let i=t,r=[];const n=s.clone();let a=!0;for(;a;){a=!1;for(const o of i){const u=o.getMatchState(n);u===v.ACTIONABLE?(o.apply(n),a=!0):u===v.DORMANT&&r.push(o)}i=r,r=[]}return n}}export{m as B,C as F,y as I,D as P,g as R,N as S,A as a,z as b,F as c,M as d,w as e,H as f,pe as g,ge as h,J as i,xe as j,v as k,c as l,G as m,ye as s};
