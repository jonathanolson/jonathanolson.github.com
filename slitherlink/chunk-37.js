import{u as R,c as C}from"./chunk-23.js";import{o as v,O as M,B as k}from"./chunk-16.js";import{_ as P,S as u,L as x}from"./chunk-18.js";import{r as T,N as B,i as O,P as f,F as z}from"./chunk-17.js";import{al as I,E as V}from"./chunk-25.js";import{P as W}from"./chunk-19.js";class X extends T{constructor(c,e){const l=v()({font:R,fill:C.uiForegroundColorProperty,linkFill:C.uiLinkColorProperty},e);super(c,l)}}class F extends B{constructor(c,e,l,S=null){let o;const d=r=>{if(S){const p=new W(new X(r,{scale:.02,lineWrap:200}),{pickable:!1,xMargin:.2,yMargin:.2,lineWidth:.02,cornerRadius:.2,fill:C.uiBackgroundColorProperty,stroke:C.uiForegroundColorProperty});console.log(p.bounds);const i=o.reduce((m,h)=>m.union(h.bounds),k.NOTHING);F.adjustContentBounds(p,S,i),o.push(p)}},y=r=>u.circle(r.viewCoordinates,.2),w=r=>new u().moveToPoint(r.start.viewCoordinates).lineToPoint(r.end.viewCoordinates).getStrokedShape(new x({lineWidth:.2,lineCap:"round"})).getStrokedShape(new x({lineWidth:.02})),b=r=>{const p=[];for(const i of r){const h=new u().moveToPoint(i.start.viewCoordinates).lineToPoint(i.end.viewCoordinates).getStrokedShape(new x({lineWidth:.2,lineCap:"round"}));p.push(...h.subpaths)}return new u(p)},t=(r,p)=>new f(w(r),{fill:p}),g=[],a=[new O(4)],s=(r,p)=>new f(b(r),{fill:p,filters:a}),E=(r,p)=>new f(y(r),{fill:p,filters:a});if(e.type==="ForcedLine")o=[s(e.redEdges,l.theme.annotationBlueColorProperty),s([e.blackEdge],l.theme.annotationBlueColorProperty),s([e.whiteEdge],l.theme.annotationRedColorProperty),E(e.vertex,l.theme.annotationGreenColorProperty)],d("Only one path for this line to exit the dot");else if(e.type==="AlmostEmptyToRed")o=[s(e.redEdges,l.theme.annotationBlueColorProperty),s([e.whiteEdge],l.theme.annotationRedColorProperty),E(e.vertex,l.theme.annotationGreenColorProperty)],d("Cannot have two lines to this dot, must be an X");else if(e.type==="JointToRed")o=[s(e.blackEdges,l.theme.annotationBlueColorProperty),s(e.whiteEdges,l.theme.annotationRedColorProperty),E(e.vertex,l.theme.annotationGreenColorProperty)],d("Cannot have more than two lines to a dot, rest must be X's");else if(e.type==="FaceSatisfied")o=[s(e.blackEdges,l.theme.annotationBlueColorProperty),s(e.whiteEdges,l.theme.annotationRedColorProperty)],d("Cell has correct number of lines, rest must be X's");else if(e.type==="FaceAntiSatisfied")o=[s(e.redEdges,l.theme.annotationBlueColorProperty),s(e.whiteEdges,l.theme.annotationRedColorProperty)],d("Cell has maximum number of X's, rest must be lines");else if(e.type==="ForcedSolveLoop")o=[s(e.regionEdges,l.theme.annotationBlueColorProperty),s(e.pathEdges,l.theme.annotationRedColorProperty)],d("Lines would force a loop, and it completes the puzzle");else if(e.type==="PrematureForcedLoop")o=[s(e.regionEdges,l.theme.annotationBlueColorProperty),s(e.pathEdges,l.theme.annotationRedColorProperty)],d("Lines would force a loop without solving the puzzle, so must be X's");else if(e.type==="CompletingEdgesAfterSolve")o=[...e.whiteEdges.map(r=>t(r,"red"))];else if(e.type==="FaceColoringBlackEdge")o=[t(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")o=[t(e.edge,"red")];else if(e.type==="FaceColorToBlack")o=[s([e.edge],l.theme.annotationRedColorProperty)],d("Colors are opposites on each side, so it must be a line");else if(e.type==="FaceColorToRed")o=[s([e.edge],l.theme.annotationRedColorProperty)],d("Colors are the same on each side, so it must be an X");else if(e.type==="FaceColorNoTrivialLoop")o=[s(e.face.edges,l.theme.annotationRedColorProperty)],d("If all sides of a cell are one color, the inside needs to be the same color to prevent a loop");else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance"){if(o=[...e.balancedPairs.flatMap((r,p)=>{const i=["green","blue","black"][p%3],m=["magenta","orange","yellow"][p%3];return[...r[0].map(h=>t(h,i)),...r[1].map(h=>t(h,m))]})],e.type==="FaceColorMatchToRed"){o.push(s(e.matchingEdges,l.theme.annotationRedColorProperty));let r="The cell borders a color in too many places. If the cell were the opposite color, it would violate the number value";e.balancedPairs.length&&(r+=". Other colors show pairs with a minimum number of lines/X's each"),d(r)}else if(e.type==="FaceColorMatchToBlack"){o.push(s(e.matchingEdges,l.theme.annotationRedColorProperty));let r="The cell borders a color in too many places. If the cell were the same color, it would violate the number value";e.balancedPairs.length&&(r+=". Other colors show pairs with a minimum number of lines/X's each"),d(r)}else if(e.type==="FaceColorBalance"){o.push(s(e.matchingEdges,l.theme.annotationRedColorProperty),s(e.oppositeEdges,l.theme.annotationBlueColorProperty));let r="The cell is forced to have adjacent colors be opposites. If they were the same color, it would violate the number value";e.balancedPairs.length&&(r+=". Other colors show pairs with a minimum number of lines/X's each"),d(r)}}else if(e.type==="DoubleMinusOneFaces")o=[s([...e.toBlackEdges,...e.toRedEdges],l.theme.annotationRedColorProperty)],d("Adjacent N-1 cells");else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")o=[e.sector.edge,e.sector.next.edge].map(r=>t(r,"red"));else if(e.type==="ForcedSector"){const r=[...e.toRedEdges,...e.toBlackEdges];o=[e.sector.edge,e.sector.next.edge].map(p=>t(p,r.includes(p)?"red":"blue"))}else if(e.type==="StaticFaceSectors")o=P.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>t(r,"red"));else if(e.type==="VertexState")o=e.vertex.edges.map(r=>t(r,"blue"));else if(e.type==="VertexStateToEdge")o=[...e.toBlackEdges.map(r=>t(r,"red")),...e.toRedEdges.map(r=>t(r,"red"))];else if(e.type==="VertexStateToSector")o=P.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>t(r,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")o=P.uniq([...e.facesA,...e.facesB].flatMap(r=>r.edges)).map(r=>t(r,"red"));else if(e.type==="FaceState")o=e.face.edges.map(r=>t(r,"red"));else if(e.type==="FaceStateToEdge")o=[...e.toBlackEdges.map(r=>t(r,"red")),...e.toRedEdges.map(r=>t(r,"red"))];else if(e.type==="FaceStateToSector")o=P.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>t(r,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const r=new Set([...e.facesA,...e.facesB].flatMap(i=>i.edges)),p=e.face.edges.filter(i=>!r.has(i));o=[...[...r].map(i=>t(i,"red")),...p.map(i=>t(i,"blue"))]}else if(e.type==="FaceStateToVertexState")o=e.face.edges.filter(p=>e.vertices.includes(p.start)||e.vertices.includes(p.end)).map(p=>t(p,"red"));else if(e.type==="FaceColorDisconnection"){const r=u.polygon(e.disconnection.map(p=>{const i=p.reversed.face;if(i)return i.viewCoordinates;{const m=p.start.viewCoordinates.average(p.end.viewCoordinates),h=p.face.viewCoordinates;return m.timesScalar(2).minus(h)}}));o=[new f(r,{lineWidth:.05,lineCap:"round",lineJoin:"round",stroke:l.theme.annotationRedColorProperty})],d("If the two colors along this path were made the same, it would disconnect the puzzle into two loops. Must be opposite colors")}else if(e.type==="Pattern"){if(o=[],S){const r=I.getDisplayEmbeddingFromRule(e.rule,e.boardPatternBoard,e.embedding),p=new V(e.rule,r,{inputListeners:[new z({fire:()=>{console.log(e.rule.getBinaryIdentifier());const i=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");i&&i.focus()}})],cursor:"pointer"});F.adjustContentBounds(p,S,r.expandedBounds);{const i=r.tightBounds.dilated(.21),m=.3;o.push(new f(u.roundRectangle(i.x,i.y,i.width,i.height,m,m),{stroke:C.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const i=r.tightBounds.dilated(.21),m=.3;o.push(new f(u.roundRectangle(i.x,i.y,i.width,i.height,m,m),{stroke:C.blackLineColorProperty,lineWidth:.13,pickable:!1}))}o.push(p)}}else o=[],console.log(`unknown type: ${e.type}`);super({children:o,pickable:e.type==="Pattern"?null:!1}),this.board=c,this.annotation=e,this.style=l,this.disposeEmitter.addListener(()=>g.forEach(r=>r()))}static adjustContentBounds(c,e,l){const y=s=>l[s.minCoordinate]+.15-(e[s.minCoordinate]+.55),w=s=>e[s.maxCoordinate]-.55-(l[s.maxCoordinate]-.15),b=s=>Math.min((e[s.opposite.size]-1.1)/c[s.opposite.size],Math.max(y(s),w(s))/c[s.size],1),t=s=>{c[s.opposite.centerCoordinate]=l[s.opposite.centerCoordinate],y(s)>w(s)?(c[s.maxSide]=l[s.minCoordinate]-.15,c[s.minSide]<e[s.minCoordinate]+.1&&(c[s.minSide]=e[s.minCoordinate]+.1)):(c[s.minSide]=l[s.maxCoordinate]+.15,c[s.maxSide]>e[s.maxCoordinate]-.1&&(c[s.maxSide]=e[s.maxCoordinate]-.1)),c[s.opposite.minSide]<e[s.opposite.minCoordinate]+.1&&(c[s.opposite.minSide]=e[s.opposite.minCoordinate]+.1),c[s.opposite.maxSide]>e[s.opposite.maxCoordinate]-.1&&(c[s.opposite.maxSide]=e[s.opposite.maxCoordinate]-.1)};let g=M.VERTICAL,a=b(g);if(a<1){const s=b(g.opposite);s>a&&(g=g.opposite,a=s)}c.scale(Math.max(a,.3)),t(g)}}export{F as A,X as U};
