import{c as T}from"./chunk-22.js";import{ao as A,E as O}from"./chunk-24.js";import{O as V}from"./chunk-16.js";import{N as D,F as N,P as C,S as F,j as R}from"./chunk-17.js";import{_ as x}from"./chunk-20.js";let h=null,b=0;const a=()=>{if(h&&(b++,b>5)){const E=h;h=null,E(null)}},j=async function(E){return new Promise((i,e)=>{h=i,b=0,setTimeout(()=>{h===i&&(h=null,i(null))},E)})};class _ extends D{constructor(i,e,M,g=null){let r;const B=s=>new F().moveToPoint(s.start.viewCoordinates).lineToPoint(s.end.viewCoordinates).getStrokedShape(new R({lineWidth:.2,lineCap:"round"})).getStrokedShape(new R({lineWidth:.02})),p=(s,l)=>new C(B(s),{fill:l}),P=[];if(e.type==="ForcedLine")r=[p(e.whiteEdge,"red"),p(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")r=[p(e.whiteEdge,"red"),...e.redEdges.map(s=>p(s,"blue"))];else if(e.type==="JointToRed")r=[...e.whiteEdges.map(s=>p(s,"red")),...e.blackEdges.map(s=>p(s,"blue"))];else if(e.type==="FaceSatisfied")r=[...e.whiteEdges.map(s=>p(s,"red")),...e.blackEdges.map(s=>p(s,"blue"))];else if(e.type==="FaceAntiSatisfied")r=[...e.whiteEdges.map(s=>p(s,"red")),...e.redEdges.map(s=>p(s,"blue"))];else if(e.type==="ForcedSolveLoop")r=[...e.regionEdges.map(s=>p(s,"blue")),...e.pathEdges.map(s=>p(s,"red"))];else if(e.type==="PrematureForcedLoop")r=[...e.regionEdges.map(s=>p(s,"blue")),...e.pathEdges.map(s=>p(s,"red"))];else if(e.type==="CompletingEdgesAfterSolve")r=[...e.whiteEdges.map(s=>p(s,"red"))];else if(e.type==="FaceColoringBlackEdge")r=[p(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")r=[p(e.edge,"red")];else if(e.type==="FaceColorToBlack")r=[p(e.edge,"red")];else if(e.type==="FaceColorToRed")r=[p(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")r=[...e.face.edges.map(s=>p(s,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")r=[...e.balancedPairs.flatMap((s,l)=>{const c=["green","blue","black"][l%3],f=["magenta","orange","yellow"][l%3];return[...s[0].map(m=>p(m,c)),...s[1].map(m=>p(m,f))]})],e.type==="FaceColorMatchToRed"?r.push(...e.matchingEdges.map(s=>p(s,"red"))):e.type==="FaceColorMatchToBlack"?r.push(...e.matchingEdges.map(s=>p(s,"red"))):e.type==="FaceColorBalance"&&(r.push(...e.matchingEdges.map(s=>p(s,"orange"))),r.push(...e.oppositeEdges.map(s=>p(s,"red"))));else if(e.type==="DoubleMinusOneFaces")r=[...e.toBlackEdges.map(s=>p(s,"red")),...e.toRedEdges.map(s=>p(s,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")r=[e.sector.edge,e.sector.next.edge].map(s=>p(s,"red"));else if(e.type==="ForcedSector"){const s=[...e.toRedEdges,...e.toBlackEdges];r=[e.sector.edge,e.sector.next.edge].map(l=>p(l,s.includes(l)?"red":"blue"))}else if(e.type==="StaticFaceSectors")r=x.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>p(s,"red"));else if(e.type==="VertexState")r=e.vertex.edges.map(s=>p(s,"blue"));else if(e.type==="VertexStateToEdge")r=[...e.toBlackEdges.map(s=>p(s,"red")),...e.toRedEdges.map(s=>p(s,"red"))];else if(e.type==="VertexStateToSector")r=x.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>p(s,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")r=x.uniq([...e.facesA,...e.facesB].flatMap(s=>s.edges)).map(s=>p(s,"red"));else if(e.type==="FaceState")r=e.face.edges.map(s=>p(s,"red"));else if(e.type==="FaceStateToEdge")r=[...e.toBlackEdges.map(s=>p(s,"red")),...e.toRedEdges.map(s=>p(s,"red"))];else if(e.type==="FaceStateToSector")r=x.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>p(s,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const s=new Set([...e.facesA,...e.facesB].flatMap(c=>c.edges)),l=e.face.edges.filter(c=>!s.has(c));r=[...[...s].map(c=>p(c,"red")),...l.map(c=>p(c,"blue"))]}else if(e.type==="FaceStateToVertexState")r=e.face.edges.filter(l=>e.vertices.includes(l.start)||e.vertices.includes(l.end)).map(l=>p(l,"red"));else if(e.type==="Pattern"){if(r=[],g){const s=A.getDisplayEmbeddingFromRule(e.rule,e.boardPatternBoard,e.embedding),l=new O(e.rule,s,{inputListeners:[new N({fire:()=>{console.log(e.rule.getBinaryIdentifier());const d=self.open(`./rule?r=${encodeURIComponent(e.rule.getBinaryIdentifier())}`,"_blank");d&&d.focus()}})],cursor:"pointer"}),c=.5+.05,f=.15,m=.1,k=d=>s.expandedBounds[d.minCoordinate]+f-(g[d.minCoordinate]+c),t=d=>g[d.maxCoordinate]-c-(s.expandedBounds[d.maxCoordinate]-f),w=d=>Math.min((g[d.opposite.size]-2*c)/l[d.opposite.size],Math.max(k(d),t(d))/l[d.size],1),v=d=>{l[d.opposite.centerCoordinate]=s.expandedBounds[d.opposite.centerCoordinate],k(d)>t(d)?(l[d.maxSide]=s.expandedBounds[d.minCoordinate]-f,l[d.minSide]<g[d.minCoordinate]+m&&(l[d.minSide]=g[d.minCoordinate]+m)):(l[d.minSide]=s.expandedBounds[d.maxCoordinate]+f,l[d.maxSide]>g[d.maxCoordinate]-m&&(l[d.maxSide]=g[d.maxCoordinate]-m)),l[d.opposite.minSide]<g[d.opposite.minCoordinate]+m&&(l[d.opposite.minSide]=g[d.opposite.minCoordinate]+m),l[d.opposite.maxSide]>g[d.opposite.maxCoordinate]-m&&(l[d.opposite.maxSide]=g[d.opposite.maxCoordinate]-m)};let u=V.VERTICAL,y=w(u);if(y<1){const d=w(u.opposite);d>y&&(u=u.opposite,y=d)}l.scale(Math.max(y,.3)),v(u);{const d=s.tightBounds.dilated(.21),S=.3;r.push(new C(F.roundRectangle(d.x,d.y,d.width,d.height,S,S),{stroke:T.puzzleBackgroundColorProperty,lineWidth:.2,pickable:!1,opacity:.8}))}{const d=s.tightBounds.dilated(.21),S=.3;r.push(new C(F.roundRectangle(d.x,d.y,d.width,d.height,S,S),{stroke:T.blackLineColorProperty,lineWidth:.13,pickable:!1}))}r.push(l)}}else r=[],console.log(`unknown type: ${e.type}`);super({children:r,pickable:e.type==="Pattern"?null:!1}),this.board=i,this.annotation=e,this.style=M,this.disposeEmitter.addListener(()=>P.forEach(s=>s()))}}export{_ as A,j as s,a as w};
