var Le=Object.defineProperty;var Oe=(a,n,s)=>n in a?Le(a,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[n]=s;var d=(a,n,s)=>Oe(a,typeof n!="symbol"?n+"":n,s);import{E as z,n as Ae,q as ee,l as xe,m as ye,A as Te,o as ke,v as Ie,F as Se,s as M,B as Z}from"./chunk-28.js";import{c as q,a as te,b as ue,g as Ee}from"./chunk-38.js";import{d as O,e as A,_ as X}from"./chunk-18.js";import{I as R,h as L,i as J,C as U,S as W,b as K,c as j}from"./chunk-30.js";import{B as oe,R as de,b as ne,c as se,d as re,S as ie,e as fe,a as he}from"./chunk-20.js";import{S as Y,b as $,f as Q,a as ge}from"./chunk-31.js";import{E as Ve,f as Ne}from"./chunk-16.js";const Be=(a,n)=>{const s=new Set(a.faces.filter(i=>{const c=n.getFaceValue(i);return c!==null&&c!==0}));if(s.size===0)return 0;const e=new Set,t=new Set([[...s][0]]);let r=0;for(;t.size;){r+=1;const i=[...t];t.clear();for(const c of i)e.add(c);for(const c of i)for(const f of c.vertices)for(const g of f.faces)e.has(g)||t.add(g)}return r};class De{constructor(n,s){d(this,"faceValues",[]);d(this,"faceColors",[]);d(this,"oppositeFaceColors",[]);d(this,"redEdgeValues",[]);d(this,"blackEdgeValues",[]);d(this,"sectorNotZeroValues",[]);d(this,"sectorNotOneValues",[]);d(this,"sectorNotTwoValues",[]);d(this,"sectorOnlyOneValues",[]);this.boardPatternBoard=n,this.inputData=s;for(const e of n.faces){const t=n.getFace(e);t?this.faceValues.push(s.getFaceValue(t)):this.faceValues.push(null);const r=t?s.getFaceColor(t):s.getOutsideColor(),i=s.getOppositeFaceColor(r);this.faceColors.push(r),this.oppositeFaceColors.push(i)}for(const e of n.edges){const t=n.getEdge(e);O()&&A(t);const r=s.getEdgeState(t);this.redEdgeValues.push(r===z.RED),this.blackEdgeValues.push(r===z.BLACK)}for(const e of n.sectors){const t=n.getSector(e);O()&&A(t);const r=s.getSectorState(t);this.sectorNotZeroValues.push(!r.zero),this.sectorNotOneValues.push(!r.one),this.sectorNotTwoValues.push(!r.two),this.sectorOnlyOneValues.push(!r.zero&&r.one&&!r.two)}}}const Ge=(a,n,s,e,t)=>{const r=s.inputFeatureSet.getFeaturesArray(),i=s.outputFeatureSet.getFeaturesArray(),c=[],f=new Set,g=new Set,E=new Set;for(const o of i)if(o instanceof oe||o instanceof de){const h=o instanceof oe,l=a.getEdge(o.edge),x=n.getEdgeState(l);if(x===z.WHITE)c.push(new Ae(l,h?z.BLACK:z.RED)),f.add(l);else if(x===z.BLACK!==h)throw new R("Edge is not in the correct state")}else if(o instanceof ne||o instanceof se||o instanceof re||o instanceof ie){const h=a.getSector(o.sector),l=n.getSectorState(h);if(o instanceof ne){if(l.zero){if(!l.one&&!l.two)throw new R("Sector cannot be made impossible");c.push(new ee(h,l.withDisallowZero())),g.add(h)}}else if(o instanceof se){if(l.one){if(!l.zero&&!l.two)throw new R("Sector cannot be made impossible");c.push(new ee(h,l.withDisallowOne())),g.add(h)}}else if(o instanceof re){if(l.two){if(!l.zero&&!l.one)throw new R("Sector cannot be made impossible");c.push(new ee(h,l.withDisallowTwo())),g.add(h)}}else if(o instanceof ie&&(l.zero||l.two)){if(!l.one)throw new R("Sector cannot be made impossible");c.push(new ee(h,l.withDisallowZero().withDisallowTwo())),g.add(h)}}else if(o instanceof fe){const h=p=>X.uniq(p.map(V=>{const N=a.getFace(V);return N?n.getFaceColor(N):n.getOutsideColor()})),l=h(o.primaryFaces),x=h(o.secondaryFaces),Re=l.map(p=>n.getOppositeFaceColor(p)),we=x.map(p=>n.getOppositeFaceColor(p));for(const p of l){if(x.includes(p))throw new R("Cannot make primary and secondary colors the same");if(Re.includes(p))throw new R("Cannot make primary and opposite colors the same")}for(const p of x)if(we.includes(p))throw new R("Cannot make secondary and opposite colors the same");const Fe=(p,V)=>{[...o.allFaces].forEach(N=>{const B=a.getFace(N),Ce=B?n.getFaceColor(B):n.getOutsideColor();B&&(Ce===p||Ce===V)&&E.add(B)})};for(const p of[l,x])if(p.length>1)for(let V=1;V<p.length;V++){const N=p[0],B=p[V];c.push(new xe(L(n,N),L(n,B))),Fe(N,B)}x.length&&l[0]!==we[0]&&(c.push(new ye(L(n,l[0]),L(n,x[0]))),Fe(l[0],x[0]))}else O()&&A(o instanceof he);const S=r.filter(o=>o instanceof he).map(o=>({face:a.getFace(o.face),value:o.value})),k=i.filter(o=>o instanceof he).map(o=>({face:a.getFace(o.face),value:o.value})),H=r.filter(o=>o instanceof oe).map(o=>a.getEdge(o.edge)),_=i.filter(o=>o instanceof oe).map(o=>a.getEdge(o.edge)),ce=r.filter(o=>o instanceof de).map(o=>a.getEdge(o.edge)),D=i.filter(o=>o instanceof de).map(o=>a.getEdge(o.edge)),ae=r.filter(o=>o instanceof ne).map(o=>a.getSector(o.sector)),le=i.filter(o=>o instanceof ne).map(o=>a.getSector(o.sector)),b=r.filter(o=>o instanceof se).map(o=>a.getSector(o.sector)),pe=i.filter(o=>o instanceof se).map(o=>a.getSector(o.sector)),me=r.filter(o=>o instanceof re).map(o=>a.getSector(o.sector)),u=i.filter(o=>o instanceof re).map(o=>a.getSector(o.sector)),I=r.filter(o=>o instanceof ie).map(o=>a.getSector(o.sector)),T=i.filter(o=>o instanceof ie).map(o=>a.getSector(o.sector)),v=r.filter(o=>o instanceof fe),F=i.filter(o=>o instanceof fe),y=o=>({primaryFaces:o.primaryFaces.map(h=>a.getFace(h)),secondaryFaces:o.secondaryFaces.map(h=>a.getFace(h))}),C=v.map(y),G=F.map(y);return new Te(new ke(c),{type:"Pattern",rule:e,embedding:t,boardPatternBoard:a,input:{faceValues:S,blackEdges:H,redEdges:ce,sectorsNotZero:ae,sectorsNotOne:b,sectorsNotTwo:me,sectorsOnlyOne:I,faceColorDuals:C},output:{faceValues:k,blackEdges:_,redEdges:D,sectorsNotZero:le,sectorsNotOne:pe,sectorsNotTwo:u,sectorsOnlyOne:T,faceColorDuals:G},affectedEdges:f,affectedSectors:g,affectedFaces:E},a.board)};class m{constructor(n,s,e,t,r=0,i=0){d(this,"nextRuleIndex");d(this,"nextEmbeddingIndex");d(this,"dirtyListener");d(this,"quickSpanningCount");this.board=n,this.boardPatternBoard=s,this.state=e,this.binaryData=t,this.quickSpanningCount=Be(n,e),this.nextRuleIndex=r,this.nextEmbeddingIndex=i,this.dirtyListener=()=>{this.nextRuleIndex=0,this.nextEmbeddingIndex=0},this.state.faceValueChangedEmitter.addListener(this.dirtyListener),this.state.edgeStateChangedEmitter.addListener(this.dirtyListener),this.state.sectorStateChangedEmitter.addListener(this.dirtyListener),this.state.faceColorsChangedEmitter.addListener(this.dirtyListener)}get dirty(){return this.nextRuleIndex<this.binaryData.size}nextAction(){if(!this.dirty)return null;const n=new De(this.boardPatternBoard,this.state);for(;;){const s=this.binaryData.getNext(n.boardPatternBoard,n,this.nextRuleIndex,this.nextEmbeddingIndex);if(s){if(this.nextRuleIndex=s.ruleIndex,this.nextEmbeddingIndex=s.embeddingIndex+1,s.rule.patternBoard.faces.length>=this.quickSpanningCount){const e=s.rule.patternBoard.faces.map(r=>s.embedding.mapFace(r)),t=new Set(e.map(r=>this.boardPatternBoard.getFace(r)).filter(r=>r!==null));if(!Ie(this.board,this.state,t))continue}return Ge(this.boardPatternBoard,this.state,s.embeddedRule,s.rule,s.embedding)}else return this.nextRuleIndex=this.binaryData.size,this.nextEmbeddingIndex=0,null}}clone(n){return new m(this.board,this.boardPatternBoard,n,this.binaryData,this.nextRuleIndex)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.dirtyListener),this.state.edgeStateChangedEmitter.removeListener(this.dirtyListener),this.state.sectorStateChangedEmitter.removeListener(this.dirtyListener),this.state.faceColorsChangedEmitter.removeListener(this.dirtyListener)}static fromGroup(n,s,e,t,r=t.size){return O()&&A(r<=t.size),new m(n,s,e,{size:r,getNext:(i,c,f=0,g=0)=>t.collection.findNextActionableEmbeddedRuleFromData(i,c,f,g,E=>t.isRuleIndexHighlander(E),r)})}}const ze=(a,n,s)=>{const e=new Set(s??a.halfEdges),t=c=>c.face===null?n.getOutsideColor():n.getFaceColor(c.face),r=c=>t(c.reversed);let i=[];for(;e.size;){const c=e.values().next().value;e.delete(c);const f=r(c),g=t(c);if(f===g)continue;const E=u=>{O()&&A(r(u)===f);const I=u;for(;r(u.next)!==f;)u=u.next.reversed;return O()&&A(I!==u.next),u.next},S=[],k=new Set,H=new Set,_=u=>{S.push(u),k.add(u.face),H.add(u.reversed.face),e.delete(u)};let ce=0;_(c);let D=E(c);for(;D!==c;)if(_(D),D=E(D),ce++>a.edges.length)throw new Error("Infinite loop");if(H.size===1)continue;const ae=new Set(S.map(u=>u.edge)),le=(u,I,T)=>{if(I){for(const F of u)if(T(F))return}const v=new Set(u);for(;v.size;){const F=v.values().next().value;v.delete(F);const y=F===null?a.edges.filter(C=>C.faces.length===1):F.edges;for(const C of y)if(!ae.has(C)){const G=C.getOtherFace(F);if(!u.has(G)&&(u.add(G),v.add(G),T(G)))return}}},b=(u,I)=>{let T=!1,v=new Set([f]);return le(u,I,F=>{if(F!==null){const C=n.getFaceValue(F);if(C!==null&&C>0)return T=!0,!0}const y=F===null?n.getOutsideColor():n.getFaceColor(F);if(y!==f&&!v.has(y)){v.add(y);const C=n.getOppositeFaceColor(y);if(C&&v.has(C))return T=!0,!0}return!1}),T};if(!b(H,!1))continue;b(k,!0)&&i.push(S)}return i.length>0?X.minBy(i,c=>c.length):null};class P{constructor(n,s){d(this,"actions",null);d(this,"dirtyListener");this.board=n,this.state=s,this.dirtyListener=()=>{this.actions=null},this.state.faceValueChangedEmitter.addListener(this.dirtyListener),this.state.faceColorsChangedEmitter.addListener(this.dirtyListener)}get dirty(){return this.actions===null||this.actions.length!==0}nextAction(){if(!this.dirty)return null;if(this.actions===null){const s=this.getPairs().map(e=>this.getActionFromPair(e)).filter(e=>e!==null);this.actions=X.sortBy(s,e=>e.annotation.disconnection.length)}if(this.actions.length){const n=this.actions.shift();return O()&&A(n),n}return null}getPairs(){const n=[];for(const s of this.board.vertices){const e=X.uniq(s.incomingHalfEdges.map(t=>{const r=t.face;return r===null?this.state.getOutsideColor():this.state.getFaceColor(r)}));for(let t=0;t<e.length;t++){const r=e[t];for(let i=t+1;i<e.length;i++){const c=e[i];O()&&A(r!==c);const f=this.state.getOppositeFaceColor(r);if(f===c)continue;const g=this.state.getOppositeFaceColor(c),E=r.id<c.id,S={min:E?r:c,max:E?c:r};if(f&&g&&(f.id<S.min.id||g.id<S.min.id)){const k=f.id<g.id;S.min=k?f:g,S.max=k?g:f}n.push(S)}}}return X.uniqBy(n,s=>`${s.min.id}-${s.max.id}`)}getActionFromPair(n){const s=this.state.createDelta();new xe(L(s,n.min),L(s,n.max)).apply(s);const e=i=>this.state.getFacesWithColor(i).flatMap(c=>c.edges.flatMap(f=>[f.forwardHalf,f.reversedHalf])),t=[...e(n.min),...e(n.max)],r=ze(this.board,s,t);return r!==null?new Te(new ye(L(this.state,n.min),L(this.state,n.max)),{type:"FaceColorDisconnection",disconnection:r,facesA:n.min.colorState===Se.UNDECIDED?this.state.getFacesWithColor(n.min):[],facesB:n.max.colorState===Se.UNDECIDED?this.state.getFacesWithColor(n.max):[]},this.board):null}clone(n){return new P(this.board,n)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.dirtyListener),this.state.faceColorsChangedEmitter.removeListener(this.dirtyListener)}}const w=class w extends Ve{constructor(n){super(),this.canSolve=n}};d(w,"EASY",new w((n,s)=>(s=s.clone(),J((e,t,r)=>{const i=Z.get(e);return new U([new W(e,t),new K(e,t),new j(e,t),new Y(e,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $(e,t,{solveToRed:!0,solveToBlack:!0}),new Q(e,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),m.fromGroup(e,i,t,q,120)])},n,s,!0),M(s)))),d(w,"MEDIUM",new w((n,s)=>(s=s.clone(),J((e,t,r)=>{const i=Z.get(e);return new U([new W(e,t),new K(e,t),new j(e,t),new Y(e,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $(e,t,{solveToRed:!0,solveToBlack:!0}),new Q(e,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),m.fromGroup(e,i,t,te,50),m.fromGroup(e,i,t,q,360)])},n,s,!0),M(s)))),d(w,"HARD",new w((n,s)=>(s=s.clone(),J((e,t,r)=>{const i=Z.get(e);return new U([new W(e,t),new K(e,t),new j(e,t),new Y(e,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $(e,t,{solveToRed:!0,solveToBlack:!0}),new Q(e,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),ge(e,t),new P(e,t),m.fromGroup(e,i,t,ue,600),m.fromGroup(e,i,t,te,100),m.fromGroup(e,i,t,q,1e3)])},n,s,!0),M(s)))),d(w,"VERY_HARD",new w((n,s)=>(s=s.clone(),J((e,t,r)=>{const i=Z.get(e);return new U([new W(e,t),new K(e,t),new j(e,t),new Y(e,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $(e,t,{solveToRed:!0,solveToBlack:!0}),new Q(e,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),ge(e,t),new P(e,t),m.fromGroup(e,i,t,Ee,1e3),m.fromGroup(e,i,t,ue,2e3),m.fromGroup(e,i,t,te,1e3),m.fromGroup(e,i,t,q,3e3)])},n,s,!0),M(s)))),d(w,"FULL",new w((n,s)=>(s=s.clone(),J((e,t,r)=>{const i=Z.get(e);return new U([new W(e,t),new K(e,t),new j(e,t),new Y(e,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new $(e,t,{solveToRed:!0,solveToBlack:!0}),new Q(e,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),ge(e,t),new P(e,t),m.fromGroup(e,i,t,Ee),m.fromGroup(e,i,t,ue),m.fromGroup(e,i,t,te),m.fromGroup(e,i,t,q)])},n,s,!0),M(s)))),d(w,"NO_LIMIT",new w(()=>!0)),d(w,"enumeration",new Ne(w));let ve=w;export{m as B,ve as C,P as F};
