var z=Object.defineProperty;var T=(g,t,e)=>t in g?z(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var S=(g,t,e)=>T(g,typeof t!="symbol"?t+"":t,e);import{d as x,e as y,_ as A,U as M,ae as U,af as $}from"./chunk-18.js";import{g as q,P as v,k as E,l as b,m as P,s as N,i as W}from"./chunk-20.js";import{H as L,G}from"./chunk-40.js";import{P as O}from"./chunk-27.js";class V{constructor(t,e,s){S(this,"exitEdgeIndices");S(this,"solutionAttributeSetLists");this.initialFeatureSet=t,this.binaryFeatureMap=e,this.richSolutions=s;const n=t.patternBoard,a=n.edges.filter(i=>i.isExit);this.exitEdgeIndices=a.map(i=>e.getExitIndex(i)),this.solutionAttributeSetLists=new Array(1<<a.length).fill([]);const r=q(n,t.getFeaturesArray()),o=(i,c,d)=>{if(i===a.length){const l=L.filterWithInfo(s,r,d).map(p=>p.solutionAttributeSet);this.solutionAttributeSetLists[c]=l}else o(i+1,c,d),o(i+1,c|1<<i,[...d,a[i]])};o(0,0,[])}getSolutionAttributeSets(t){let e=0;for(let s=0;s<this.exitEdgeIndices.length;s++){const n=this.exitEdgeIndices[s];(t&1n<<BigInt(n))!==0n&&(e|=1<<s)}return this.solutionAttributeSetLists[e]}}const k=new WeakMap,j=(g,t=!1)=>{x()&&y(g);let e=k.get(g)??null;return e||(e=O.getSolutions(g,[]),t&&k.set(g,e)),e},H=new WeakMap,J=(g,t=!1)=>{x()&&y(g);let e=H.get(g)??null;return e||(e=j(g).map(s=>new G(g,s,!0),t),t&&H.set(g,e)),e},K=(g,t,e)=>{const s=g.inputFeatureSet.getFeaturesArray(),n=g.outputFeatureSet.getFeaturesArray();let a=e??J(g.patternBoard);t&&(a=V.filterWithFeatureSet(a,g.inputFeatureSet)),a=a.filter(r=>s.every(o=>o.isPossibleWith(r.isEdgeBlack)));for(const r of a)if(!n.every(o=>o.isPossibleWith(r.isEdgeBlack)))return!1;return!0};class Q{constructor(t,e,s,n,a){this.ruleIndex=t,this.embeddingIndex=e,this.rule=s,this.embeddedRule=n,this.embedding=a}}class R{constructor(t,e,s,n,a){if(this.patternBoards=t,this.data=e,this.ruleIndices=s,this.nextRuleIndex=n,this.highlander=a,x())for(let r=0;r<s.length;r++)y(e[s[r]]<t.length,"pattern board index")}clone(){return new R(this.patternBoards.slice(),new Uint8Array(this.data),this.ruleIndices.slice(),this.nextRuleIndex,this.highlander)}addRule(t){this.patternBoards.includes(t.patternBoard)||this.patternBoards.push(t.patternBoard);const e=t.getBinary(this.patternBoards);this.nextRuleIndex+e.length>this.data.length&&this.allocateMoreSpace(e.length),this.highlander||(this.highlander=t.highlander),this.data.set(e,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=e.length}addRuleSuffixBytes(t,e,s){this.patternBoards.includes(t)||this.patternBoards.push(t);const n=[this.patternBoards.indexOf(t),...e];this.nextRuleIndex+n.length>this.data.length&&this.allocateMoreSpace(n.length),this.highlander||(this.highlander=s),this.data.set(n,this.nextRuleIndex),this.ruleIndices.push(this.nextRuleIndex),this.nextRuleIndex+=n.length}getRules(){const t=[];return this.forEachRule(e=>t.push(e)),t}get size(){return this.ruleIndices.length}allocateMoreSpace(t){const e=Math.max(this.data.length*2,this.data.length+t),s=new Uint8Array(e);s.set(this.data,0),this.data=s}getRule(t,e){return v.fromBinary(this.patternBoards,this.data,this.ruleIndices[t],e===void 0?this.highlander:e)}getRuleBytes(t,e){const s=this.ruleIndices[t],n=t+1<this.ruleIndices.length?this.ruleIndices[t+1]:this.nextRuleIndex,a=[];for(let r=e?s:s+1;r<n;r++)a.push(this.data[r]);return a}getRulePatternBoard(t){return this.patternBoards[this.data[this.ruleIndices[t]]]}forEachRule(t){for(let e=0;e<this.ruleIndices.length;e++)t(this.getRule(e))}withPatternBoardFilter(t){const e=this.patternBoards.map(t),s=this.patternBoards.filter((o,i)=>e[i]),n=[],a=[];let r=0;for(let o=0;o<this.ruleIndices.length;o++){const i=this.ruleIndices[o],c=this.data[i];if(x()&&y(c<this.patternBoards.length,"pattern board index"),e[c]){const d=s.indexOf(this.patternBoards[c]);x()&&y(d!==-1,"pattern board index");const l=o+1<this.ruleIndices.length?this.ruleIndices[o+1]:this.data.length;n.push(d,...this.data.slice(i+1,l)),a.push(r),x()&&y(n[r]===d,"pattern board index"),r=n.length}}return new R(s,new Uint8Array(n),a,r,this.highlander)}withRules(t){const e=this.highlander||t.some(o=>o.highlander),s=A.uniq([...this.patternBoards,...t.map(o=>o.patternBoard)]),n=[...this.data],a=[...this.ruleIndices];let r=this.nextRuleIndex;for(const o of t)n.push(...o.getBinary(s)),a.push(r),r=n.length;return new R(s,new Uint8Array(n),a,r,e)}withCollection(t){const e=this.clone();return t.forEachRule(s=>{e.addRule(s)}),e}withCollectionNonequal(t){const e=this.clone();let s=0;const n=this.getRules();return t.forEachRule(a=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,n.every(r=>!a.equals(r))&&e.addRule(a)}),e}withCollectionNonredundant(t){const e=this.clone();let s=0;return t.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} + ${t.size}`),s++,e.isRuleRedundant(n)||e.addRule(n)}),e}withoutCollectionNonequal(t){const e=R.empty();let s=0;const n=t.getRules();return this.forEachRule(a=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,n.every(r=>!a.equals(r))&&e.addRule(a)}),e}withoutCollectionNonredundant(t){const e=R.empty();let s=0;return this.forEachRule(n=>{s%100===0&&console.log(s,`${this.size} - ${t.size}`),s++,t.isRuleRedundant(n)||e.addRule(n)}),e}withRulesApplied(t,e=()=>!1){const s=t.clone();for(;;){const n=s.clone();let a=null,r=[];for(let o=0;o<this.ruleIndices.length;o++){const i=this.ruleIndices[o],c=this.data[i],d=this.patternBoards[c];d!==a&&(a=d,r=M(d,t.patternBoard));const l=r;for(const p of l)if(this.isActionableEmbeddingFromFeatureSet(s,o,p)){const h=this.getRule(o).embedded(s.patternBoard,p);if(x()){self.isPatternRuleValid=K;const f=h.getMatchState(s);if(f===E.INCOMPATIBLE||f===E.DORMANT){debugger;throw new Error("Why would this happen")}}h.apply(s)}}if(e(s)||n.equals(s))break}return s}isRuleRedundant(t){return t.isTrivial()?!0:t.outputFeatureSet.isSubsetOf(this.withRulesApplied(t.inputFeatureSet,e=>t.outputFeatureSet.isSubsetOf(e)))}findNextActionableEmbeddedRuleFromData(t,e,s=0,n=0,a,r=this.size){let o=0;for(let i=s;i<r;i++){o%1e3===0&&console.log("search",o),o++;const c=this.ruleIndices[i],d=this.data[c],l=this.patternBoards[d],p=M(l,t);let u=n;for(n=0;u<p.length;u++){const h=p[u];if(this.isActionableEmbeddingFromData(t,e,i,h)){const f=a?this.getRule(i,a(i)):this.getRule(i),m=f.embedded(t,h);return x()&&(y(f.inputFeatureSet.getBoardMatchState(e,h,!0)===b.MATCH),y(f.outputFeatureSet.getBoardMatchState(e,h,!0)!==b.MATCH),y(!m||!!f.inputFeatureSet.embedded(l,h))),m?new Q(i,u,f,m,h):null}}}return null}isActionableEmbeddingFromData(t,e,s,n){let a=this.ruleIndices[s];const r=this.data[a++],o=this.patternBoards[r],i=P(o);for(;;){const c=this.data[a++];if(c===255)break;if(c===254){const d=this.data[a++];for(;;){const l=this.data[a++];if(l===255||l===254){a--;break}if(l&128){const p=l&127,u=e.oppositeFaceColors[n.mapFace(o.faces[d]).index],h=e.faceColors[n.mapFace(o.faces[p]).index];if(u!==h)return!1}else{const p=l,u=e.faceColors[n.mapFace(o.faces[d]).index],h=e.faceColors[n.mapFace(o.faces[p]).index];if(u!==h)return!1}}}else{const d=i.featureMatchers[c];if(d(e,n)!==b.MATCH)return!1}}for(;;){const c=this.data[a++];if(c===255)break;if(c===254){const d=this.data[a++];for(;;){const l=this.data[a++];if(l===255||l===254){a--;break}if(l&128){const p=l&127,u=e.oppositeFaceColors[n.mapFace(o.faces[d]).index],h=e.faceColors[n.mapFace(o.faces[p]).index];if(u!==h)return!0}else{const p=l,u=e.faceColors[n.mapFace(o.faces[d]).index],h=e.faceColors[n.mapFace(o.faces[p]).index];if(u!==h)return!0}}}else{const d=i.featureMatchers[c];if(d(e,n)!==b.MATCH)return!0}}return!1}isActionableEmbeddingFromFeatureSet(t,e,s){let n=this.ruleIndices[e];const a=this.data[n++],r=this.patternBoards[a];x()&&y(r,"pattern board");const o=P(r);for(;;){const i=this.data[n++];if(i===255)break;if(i===254){const c=this.data[n++];x()&&y(c<128);const d=s.mapFace(r.faces[c]),l=t.getFaceColorDualFromFace(d);if(!l)return!1;const p=l.secondaryFaces.includes(d);x()&&y(p||l.primaryFaces.includes(d));const u=p?l.secondaryFaces:l.primaryFaces,h=p?l.primaryFaces:l.secondaryFaces;for(;;){const f=this.data[n++];if(f===255||f===254){n--;break}if(f&128){const m=f&127,F=s.mapFace(r.faces[m]);if(!h.includes(F))return!1}else{const m=f,F=s.mapFace(r.faces[m]);if(!u.includes(F))return!1}}}else{const c=o.featureSetMatchers[i];if(c(t,s)!==b.MATCH)return!1}}for(;;){const i=this.data[n++];if(i===255)break;if(i===254){const c=this.data[n++];x()&&y(c<128);const d=s.mapFace(r.faces[c]),l=t.getFaceColorDualFromFace(d);if(!l)return!0;const p=l.secondaryFaces.includes(d);x()&&y(p||l.primaryFaces.includes(d));const u=p?l.secondaryFaces:l.primaryFaces,h=p?l.primaryFaces:l.secondaryFaces;for(;;){const f=this.data[n++];if(f===255||f===254){n--;break}if(f&128){const m=f&127,F=s.mapFace(r.faces[m]);if(!h.includes(F))return!0}else{const m=f,F=s.mapFace(r.faces[m]);if(!u.includes(F))return!0}}}else{const c=o.featureSetMatchers[i];if(c(t,s)!==b.MATCH)return!0}}return!1}getActionableEmbeddingsFromData(t,e,s){let n=this.ruleIndices[s];const a=this.data[n++],r=this.patternBoards[a];x()&&y(r,"pattern board");const o=P(r);let i=M(r,t),c=i.slice();for(;;){const p=this.data[n++];let u=0;if(p===255)break;if(p===254){const h=this.data[n++];for(x()&&y(h<128);;){const f=this.data[n++];if(f===255||f===254){n--;break}if(f&128){const F=f&127;for(let I=0;I<i.length;I++){const B=i[I],w=e.oppositeFaceColors[B.mapFace(r.faces[h]).index],C=e.faceColors[B.mapFace(r.faces[F]).index];w===C&&(c[u++]=B)}}else{const F=f;for(let I=0;I<i.length;I++){const B=i[I],w=e.faceColors[B.mapFace(r.faces[h]).index],C=e.faceColors[B.mapFace(r.faces[F]).index];w===C&&(c[u++]=B)}}if(c.length=u,u===0)return c;const m=i;i=c,c=m,u=0}}else{const h=o.featureMatchers[p];for(let m=0;m<i.length;m++){const F=i[m];h(e,F)===b.MATCH&&(c[u++]=F)}if(c.length=u,u===0)return c;const f=i;i=c,c=f,u=0}}const d=i.map(()=>!1);let l=0;for(;;){const p=this.data[n++];if(p===255)break;if(p===254){const u=this.data[n++];for(x()&&y(u<128);;){const h=this.data[n++];if(h===255||h===254){n--;break}if(h&128){const f=h&127;for(let m=0;m<i.length;m++)if(!d[m]){const F=i[m],I=e.oppositeFaceColors[F.mapFace(r.faces[u]).index],B=e.faceColors[F.mapFace(r.faces[f]).index];I!==B&&(d[m]=!0,l++)}}else{const f=h;for(let m=0;m<i.length;m++)if(!d[m]){const F=i[m],I=e.faceColors[F.mapFace(r.faces[u]).index],B=e.faceColors[F.mapFace(r.faces[f]).index];I!==B&&(d[m]=!0,l++)}}}}else{const u=o.featureMatchers[p];for(let h=0;h<i.length;h++)if(!d[h]){const f=i[h];u(e,f)!==b.MATCH&&(d[h]=!0,l++)}}}return l?i.filter((p,u)=>d[u]):[]}serialize(){return{patternBoards:this.patternBoards.map(N),rules:U(this.data.subarray(0,this.nextRuleIndex)),highlander:this.highlander}}static deserialize(t){const e=$(t.rules);if(!e)throw new Error("Failed to decompress rules!");let s=0;const n=[];for(;s<e.length;){n.push(s),x()&&y(e[s]!==254);let a=0;for(;a<2;)x()&&y(s<e.length,"Unexpected end of data"),e[s++]===255&&a++}return new R(t.patternBoards.map(W),e,n,e.length,t.highlander)}static empty(){return new R([],new Uint8Array(0),[],0,!1)}static fromRules(t){const e=t.some(o=>o.highlander),s=A.uniq(t.map(o=>o.patternBoard)),n=[];let a=0;const r=[];for(const o of t)n.push(...o.getBinary(s)),r.push(a),a=n.length;return new R(s,new Uint8Array(n),r,a,e)}}export{R as B,V as H,J as g,K as i};
