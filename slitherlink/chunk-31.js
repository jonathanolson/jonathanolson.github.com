var ne=Object.defineProperty;var ae=(g,e,r)=>e in g?ne(g,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):g[e]=r;var S=(g,e,r)=>ae(g,typeof e!="symbol"?e+"":e,r);import{I as v,h as R,l as ce,C as le,S as de,b as he,c as ge,d as fe,e as ue,V as pe}from"./chunk-30.js";import{E as h,v as ie,A as C,o as x,n as L,m as M,l as oe,S as T,q as H,V as we,w as Se,x as ye}from"./chunk-28.js";import{_ as z,d as b,e as O,P as me,n as Ce,H as Ee}from"./chunk-18.js";class I{constructor(e,r,o,s){S(this,"dirtyFaces",new Set);S(this,"edgeListener");S(this,"faceColorListener");this.board=e,this.state=r,this.options=o,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(i,l,a,c)=>{const t=n=>{this.dirtyFaces.add(n);for(const d of n.edges){const f=d.getOtherFace(n);f&&this.dirtyFaces.add(f)}};for(const n of c)t(n);for(const n of[...i,...a]){const d=this.state.getFacesWithColor(n);for(const f of d)t(f)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(i,l)=>{for(const a of i.faces)this.dirtyFaces.add(a)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new v("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,r=s=>{const i=s.getOtherFace(e),l=i?this.state.getFaceColor(i):this.state.getOutsideColor();return new Fe(l,s)},o=e.edges.filter(s=>this.state.getEdgeState(s)===h.WHITE).map(r);if(o.length){const s=this.state.getFaceValue(e);if(s===null){const i=o[0].color;if(e.edges.map(r).every(c=>c.color===i)&&this.options.solveToRed&&ie(this.board,this.state,new Set([e]))){const c=e.edges.map(n=>n.getOtherFace(e)).filter(n=>n!==null);if(this.board.faces.some(n=>n!==e&&this.state.getFaceValue(n)!==null&&!c.includes(n)))return new C(new x(o.map(n=>new L(n.edge,h.RED))),{type:"FaceColorNoTrivialLoop",face:e},this.board)}}else{const i=e.edges.filter(c=>this.state.getEdgeState(c)===h.BLACK).length,l=(c,t,n)=>{let d=[];for(const w of t){const A=w.color;let V=!1;for(const F of d)if(F.mainColor===A){F.mainColorSides.add(w),V=!0;break}else if(F.oppositeColor===A){F.oppositeColorSides.add(w),V=!0;break}if(!V){const F=this.state.getOppositeFaceColor(A),k=new ve(A,F,0,0);d.push(k),k.mainColorSides.add(w)}}d=z.sortBy(d,w=>-w.size);const p=z.sortBy(d.flatMap(w=>{const A=[new te(w.mainColor,w.mainCount,w.mainColorSides)];return w.oppositeColor&&w.oppositeColorSides.size&&A.push(new te(w.oppositeColor,w.oppositeCount,w.oppositeColorSides)),A}),w=>-w.size)[0],u=p.size,y=c,m=t.length-y,E=Math.max(y,m),B=u>y,N=u>m,re=u===E;if(B&&N)throw new v("Too many adjacent faces with the same color");const D=()=>{const w=A=>[A[0].map(V=>V.edge),A[1].map(V=>V.edge)];return{face:e,remainingValue:c,availableSideCount:t.length,balancedPairs:n.map(w)}};if(B&&this.options.solveToRed)return new C(new x([...p.sides].map(w=>new L(w.edge,h.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...p.sides].map(w=>w.edge),...D()},this.board);if(N&&this.options.solveToBlack)return new C(new x([...p.sides].map(w=>new L(w.edge,h.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...p.sides].map(w=>w.edge),...D()},this.board);if(re&&this.options.solveColors){const w=p.color,A=t.filter(F=>F.color!==w),V=z.uniq(A.map(F=>F.color)).filter(F=>F!==this.state.getOppositeFaceColor(w));if(V.length)return b()&&O(V.every(F=>this.state.getFaceColors().includes(F))),new C(new x(V.map(F=>new M(R(this.state,w),R(this.state,F)))),{type:"FaceColorBalance",matchingEdges:[...p.sides].map(F=>F.edge),oppositeEdges:[...A].map(F=>F.edge),...D()},this.board)}if(this.options.allowPartialReduction)for(const w of d){if(w.size<1)continue;const A=[...w.mainColorSides].slice(0,w.size),V=[...w.oppositeColorSides].slice(0,w.size),F=t.filter(k=>!A.includes(k)&&!V.includes(k));if(F.length){const k=l(y-w.size,F,n.concat([[A,V]]));if(k)return k}}return null},a=l(s-i,o,[]);if(a)return a}}this.dirtyFaces.delete(e)}return null}clone(e){return new I(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Fe{constructor(e,r){this.color=e,this.edge=r}}class ve{constructor(e,r,o,s){S(this,"mainColorSides",new Set);S(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=r,this.mainCount=o,this.oppositeCount=s}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class te{constructor(e,r,o){this.color=e,this.count=r,this.sides=o}get size(){return this.sides.size}}class K{constructor(e,r,o,s){S(this,"dirtyFaces",[]);S(this,"vertexListener");this.board=e,this.state=r,this.options=o,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.vertexListener=i=>{this.dirtyFaces.push(i)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),r=this.state.getFaceState(e);if(r.possibilityCount===0)throw new v("Face has no possibilities");const o=[],s=[];for(const i of e.edges)if(this.state.getEdgeState(i)===h.WHITE){const a=r.getFinalStatesOfEdge(i);if(a.size===1){const c=[...a][0];c===h.RED&&this.options.solveToRed&&o.push(i),c===h.BLACK&&this.options.solveToBlack&&s.push(i)}}if(o.length||s.length)return new C(new x([...o.map(i=>new L(i,h.RED)),...s.map(i=>new L(i,h.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:o,toBlackEdges:s},this.board)}return null}clone(e){return new K(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class P{constructor(e,r,o){S(this,"dirtyFaces",[]);S(this,"faceListener");this.board=e,this.state=r,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],r=this.state.getFaceState(e);if(r.possibilityCount===0)throw new v("Face has no possibilities");const o=new Map(e.edges.map(c=>{const t=c.getOtherFace(e);return[c,t?this.state.getFaceColor(t):this.state.getOutsideColor()]})),s=[e,...e.edges.map(c=>c.getOtherFace(e)).filter(z.identity)],i=this.state.getFaceColor(e),l=new Set([...o.values(),i]);if(l.size!==1){const c=new Map([...l].map(n=>[n,new Map([...l].map(d=>[d,!1]))])),t=new Map([...l].map(n=>[n,new Map([...l].map(d=>[d,!1]))]));for(const n of r.getAllowedCombinations()){const d=new Set([i]),f=new Set;for(const u of e.edges)n.includes(u)?f.add(o.get(u)):d.add(o.get(u));const p=u=>{for(let y=0;y<u.length;y++)for(let m=y+1;m<u.length;m++)c.get(u[y]).set(u[m],!0),c.get(u[m]).set(u[y],!0)};p([...d]),p([...f]);for(const u of d)for(const y of f)u!==y&&(t.get(u).set(y,!0),t.get(y).set(u,!0))}for(const n of l)for(const d of l){if(n===d)continue;const f=c.get(n).get(d),p=t.get(n).get(d);if(f&&!p)return new C(new oe(R(this.state,n),R(this.state,d)),{type:"FaceStateToSameFaceColor",face:e,facesA:s.filter(u=>this.state.getFaceColor(u)===n),facesB:s.filter(u=>this.state.getFaceColor(u)===d)},this.board);if(p&&!f&&this.state.getOppositeFaceColor(n)!==d)return new C(new M(R(this.state,n),R(this.state,d)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:s.filter(u=>this.state.getFaceColor(u)===n),facesB:s.filter(u=>this.state.getFaceColor(u)===d)},this.board)}}const a=this.dirtyFaces.pop();b()&&O(a===e)}return null}clone(e){return new P(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class j{constructor(e,r,o){S(this,"dirtyFaces",[]);S(this,"faceListener");this.board=e,this.state=r,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),r=this.state.getFaceState(e);if(r.possibilityCount===0)throw new v("Face has no possibilities");const o=e.halfEdges,s=o.map(t=>this.state.getSectorState(t)),i=o.map(t=>T.NONE);for(const t of r.getAllowedCombinations())for(let n=0;n<o.length;n++){const d=o[n],f=d.edge,p=d.next.edge,u=(t.includes(f)?1:0)+(t.includes(p)?1:0);i[n]=i[n].with(u)}for(let t=0;t<o.length;t++)i[t]=i[t].and(s[t]);for(const t of i)if(t===T.NONE)throw new v("Sector has no possibilities");const l=[],a=[],c=[];for(let t=0;t<o.length;t++)s[t]!==i[t]&&(l.push(o[t]),a.push(s[t]),c.push(i[t]));if(l.length)return new C(new x(l.map((t,n)=>new H(t,c[n]))),{type:"FaceStateToSector",face:e,sectors:l,beforeStates:a,afterStates:c},this.board)}return null}clone(e){return new j(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class q{constructor(e,r,o){S(this,"dirtyFaces",[]);S(this,"faceListener");this.board=e,this.state=r,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.faceListener=s=>{this.dirtyFaces.push(s)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),r=this.state.getFaceState(e);if(r.possibilityCount===0)throw new v("Face has no possibilities");const o=e.vertices.map(a=>this.state.getVertexState(a)),s=o.map(a=>{const c=a.vertex.edges.filter(t=>t.faces.includes(e));return b()&&O(c.length===2),{vertex:a.vertex,vertexState:a,edgeA:c[0],edgeB:c[1],...a.getBinaryCombinationsAllowed(c[0],c[1])}}),i=s.map(a=>({vertex:a.vertex,vertexState:a.vertexState,edgeA:a.edgeA,edgeB:a.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const a of r.getAllowedCombinations())for(const c of i){const t=a.includes(c.edgeA),n=a.includes(c.edgeB);t&&n&&(c.allowsBoth=!0),t&&!n&&(c.allowsAOnly=!0),!t&&n&&(c.allowsBOnly=!0),!t&&!n&&(c.allowsNone=!0)}const l=[];for(let a=0;a<i.length;a++){const c=s[a],t=i[a];if(t.allowsBoth&&(t.allowsBoth=c.allowsBoth),t.allowsAOnly&&(t.allowsAOnly=c.allowsAOnly),t.allowsBOnly&&(t.allowsBOnly=c.allowsBOnly),t.allowsNone&&(t.allowsNone=c.allowsNone),t.allowsBoth!==c.allowsBoth||t.allowsAOnly!==c.allowsAOnly||t.allowsBOnly!==c.allowsBOnly||t.allowsNone!==c.allowsNone){const n=c.vertexState,d=we.fromLookup(c.vertex,(f,p)=>{if(!n.allowsPair(f,p))return!1;const y=f===t.edgeA||p===t.edgeA,m=f===t.edgeB||p===t.edgeB;if(y&&m)return t.allowsBoth;if(y&&!m)return t.allowsAOnly;if(!y&&m)return t.allowsBOnly;if(!y&&!m)return t.allowsNone;throw new Error("Unreachable")},n.allowsEmpty()&&t.allowsNone);b()&&O(d.isSubsetOf(n)),n.equals(d)||l.push(d)}}if(l.length)return new C(new x(l.map(a=>new ce(a.vertex,a))),{type:"FaceStateToVertexState",face:e,vertices:l.map(a=>a.vertex),beforeStates:l.map(a=>o.find(c=>c.vertex===a.vertex)),afterStates:l},this.board)}return null}clone(e){return new q(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class ${constructor(e,r,o,s){S(this,"dirtyEdges",new Set);S(this,"faceColorListener");this.board=e,this.state=r,this.options=o,s?this.dirtyEdges=new Set(s):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(i,l,a,c)=>{for(const t of c)for(const n of t.edges)this.dirtyEdges.add(n);for(const t of a){const n=this.state.getFacesWithColor(t);for(const d of n)for(const f of d.edges)this.dirtyEdges.add(f)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new v("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===h.WHITE){const o=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),s=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),i=o===s,l=this.state.getOppositeFaceColor(o)===s;if(this.options.solveToBlack&&l)return new C(new L(e,h.BLACK),{type:"FaceColorToBlack",edge:e},this.board);if(this.options.solveToRed&&i)return new C(new L(e,h.RED),{type:"FaceColorToRed",edge:e},this.board)}this.dirtyEdges.delete(e)}return null}clone(e){return new $(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class Y{constructor(e,r,o,s){S(this,"dirtyFaces",[]);S(this,"faceListener");S(this,"edgeListener");this.board=e,this.state=r,this.options=o,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces.filter(i=>r.getFaceValue(i)!==null)),this.faceListener=(i,l)=>{this.dirtyFaces.push(i)},this.edgeListener=(i,l)=>{this.dirtyFaces.push(...i.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),r=this.state.getFaceValue(e);if(r!==null){const o=e.edges;let s=0,i=0,l=0;if(o.forEach(a=>{const c=this.state.getEdgeState(a);return c===h.BLACK?s++:c===h.RED?i++:l++,c}),s>r)throw new v("Too many black edges on face");if(i>e.edges.length-r)throw new v("Too many red edges on face");if(l>0){if(this.options.solveToRed&&s===r){const a=o.filter(t=>this.state.getEdgeState(t)===h.WHITE),c=o.filter(t=>this.state.getEdgeState(t)===h.BLACK);return new C(new x(a.map(t=>new L(t,h.RED))),{type:"FaceSatisfied",face:e,whiteEdges:a,blackEdges:c},this.board)}else if(this.options.solveToBlack&&i===e.edges.length-r){const a=o.filter(t=>this.state.getEdgeState(t)===h.WHITE),c=o.filter(t=>this.state.getEdgeState(t)===h.RED);return new C(new x(a.map(t=>new L(t,h.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:a,redEdges:c},this.board)}}}}return null}clone(e){return new Y(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Z{constructor(e,r,o,s){S(this,"dirtySimpleRegions");S(this,"hasDirtyWeirdEdges",!1);S(this,"simpleRegionListener");S(this,"edgeListener");this.board=e,this.state=r,this.options=o,s?this.dirtySimpleRegions=new Set(s):this.dirtySimpleRegions=new Set(r.getSimpleRegions()),this.simpleRegionListener=(i,l,a,c)=>{for(const t of l)this.dirtySimpleRegions.delete(t);for(const t of i)this.dirtySimpleRegions.add(t);this.hasDirtyWeirdEdges=r.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(i,l,a)=>{if(l===h.RED){const c=this.state.getSimpleRegions(),t=n=>{let d=n,f=null,p=0;do{if(p++>1e4)throw new Error("infinite loop detected");const u=d.edges.filter(E=>this.state.getEdgeState(E)===h.BLACK);if(u.length===1){for(const E of c)(E.a===d||E.b===d)&&this.dirtySimpleRegions.add(E);break}if(u.length!==0)break;const y=d.edges.filter(E=>this.state.getEdgeState(E)===h.WHITE);if(y.length!==2)break;const m=y[0].getOtherVertex(d)===f?y[1]:y[0];f=d,d=m.getOtherVertex(d)}while(d!==n)};t(i.start),t(i.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new v("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const r=e.values().next().value;if(!r.isSolved){const o=r.a,s=r.b,i=r.halfEdges[0].edge;for(const l of o.edges){if(l===i||this.state.getEdgeState(l)===h.RED)continue;const a=[l];let c=l,t=l.getOtherVertex(o);for(;t!==s;){let n=!1;const d=t.edges.filter(f=>{if(f===c)return!1;const p=this.state.getEdgeState(f);return p===h.BLACK&&(n=!0),p===h.WHITE});if(d.length!==1||n)break;c=d[0],a.push(c),t=c.getOtherVertex(t)}if(t===s){if(this.isSolvedWithAddedEdges(r,a)){if(this.options.solveToBlack)return new C(new x(a.map(n=>new L(n,h.BLACK))),{type:"ForcedSolveLoop",a:o,b:s,regionEdges:r.edges,pathEdges:a},this.board)}else if(this.options.solveToRed)return new C(new x(a.map(n=>new L(n,h.RED))),{type:"PrematureForcedLoop",a:o,b:s,regionEdges:r.edges,pathEdges:a},this.board)}}}e.delete(r)}return null}isSolvedWithAddedEdges(e,r){const o=new Set(e.edges);for(const s of r)o.add(s);for(const s of this.board.faces){const i=this.state.getFaceValue(s);if(i!==null&&s.edges.filter(a=>o.has(a)).length!==i)return!1}return!0}clone(e){return new Z(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class J{constructor(e,r,o){S(this,"dirtySectors");S(this,"edgeListener");S(this,"sectorListener");this.board=e,this.state=r,o?this.dirtySectors=new Set(o):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(s,i,l)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,i,l)=>{this.dirtySectors.add(s)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const r=e.edge,o=e.next.edge,s=this.state.getSectorState(e);if(s===T.NONE)throw new v(`invalid sector state: ${s}`);const i=this.state.getEdgeState(r),l=this.state.getEdgeState(o),a=(i===h.WHITE?1:0)+(l===h.WHITE?1:0),c=(i===h.BLACK?1:0)+(l===h.BLACK?1:0),t=(n,d)=>new C(new x([...n.map(f=>new L(f,h.BLACK)),...d.map(f=>new L(f,h.RED))]),{type:"ForcedSector",sector:e,sectorState:s,toRedEdges:d,toBlackEdges:n},this.board);if(a===0){if(!s.allows(c))throw new v(`invalid state: ${s} with ${c} black edges with no white`)}else if(a===1){const n=s.allows(c),d=s.allows(c+1);if(!n&&!d)throw new v(`invalid state: ${s} with ${c} black edges and 1 white`);if(n&&!d)return t([],[i===h.WHITE?r:o]);if(d&&!n)return t([i===h.WHITE?r:o],[])}else if(a===2){if(s===T.ONLY_ZERO)return t([],[r,o]);if(s===T.ONLY_TWO)return t([r,o],[])}else throw new v(`invalid white count: ${a}`)}return null}clone(e){return new J(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class G{constructor(e,r,o,s){S(this,"dirtyVertices",[]);S(this,"edgeListener");this.board=e,this.state=r,this.options=o,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.edgeListener=(i,l)=>{this.dirtyVertices.push(...i.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),r=e.edges;let o=0,s=0;if(r.forEach(i=>{const l=this.state.getEdgeState(i);return l===h.BLACK?o++:l===h.WHITE&&s++,l}),o>2)throw new v("Too many black edges on vertex");if(o===1&&s===0)throw new v("Nowhere for the single edge to go");if(s>0){if(this.options.solveJointToRed&&o===2){const i=r.filter(a=>this.state.getEdgeState(a)===h.WHITE),l=r.filter(a=>this.state.getEdgeState(a)===h.BLACK);return b()&&O(l.length===2),new C(new x(i.map(a=>new L(a,h.RED))),{type:"JointToRed",vertex:e,whiteEdges:i,blackEdges:l},this.board)}else if(this.options.solveForcedLineToBlack&&o===1&&s===1){const i=r.find(a=>this.state.getEdgeState(a)===h.WHITE),l=r.find(a=>this.state.getEdgeState(a)===h.BLACK);return b()&&O(i),b()&&O(l),new C(new L(i,h.BLACK),{type:"ForcedLine",vertex:e,blackEdge:l,whiteEdge:i,redEdges:r.filter(a=>this.state.getEdgeState(a)===h.RED)},this.board)}else if(this.options.solveAlmostEmptyToRed&&o===0&&s===1){const i=r.find(l=>this.state.getEdgeState(l)===h.WHITE);return b()&&O(i),new C(new L(i,h.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:i,redEdges:r.filter(l=>this.state.getEdgeState(l)===h.RED)},this.board)}}}return null}clone(e){return new G(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const se=(g,e)=>g.start===e||g.end===e,W=g=>{const e=[];for(const r of g.edges){const o=r.getOtherFace(g);o&&e.push(o)}return e};class U{constructor(e,r,o){S(this,"dirtyFaces");S(this,"faceListener");this.board=e,this.state=r,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceListener=(s,i)=>{this.dirtyFaces.add(s);for(const l of W(s))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,r=this.state.getFaceValue(e),o=e.edges.length;if(r===o-1)for(const s of e.edges){const i=s.getOtherFace(e);if(i){const l=this.state.getFaceValue(i),a=i.edges.length;if(l===a-1){const c=new Set([...W(e),...W(i)]);if(this.board.faces.some(t=>(this.state.getFaceValue(t)??0)>0&&!c.has(t))){const t=m=>!se(m,s.start)&&!se(m,s.end),n=e.edges.filter(t),d=i.edges.filter(t),f=m=>!m.faces.some(E=>E===e||E===i),p=[...s.start.edges.filter(f),...s.end.edges.filter(f)],u=[s,...n,...d].filter(m=>this.state.getEdgeState(m)!==h.BLACK),y=p.filter(m=>this.state.getEdgeState(m)!==h.RED);if((u.length||y.length)&&ie(this.board,this.state,new Set([e,i])))return new C(new x([...u.map(m=>new L(m,h.BLACK)),...y.map(m=>new L(m,h.RED))]),{type:"DoubleMinusOneFaces",faces:[e,i],toBlackEdges:u,toRedEdges:y},this.board)}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new U(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class Q{constructor(e,r,o){S(this,"dirtyFaces");S(this,"faceListener");this.board=e,this.state=r,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceListener=(s,i)=>{this.dirtyFaces.add(s);for(const l of W(s))this.dirtyFaces.add(l)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,r=this.state.getFaceValue(e),o=e.edges.length;let s=null;if(r===0?s=T.ONLY_ZERO:r===1?s=T.NOT_TWO:r===o-1?s=T.NOT_ZERO:r===o&&(s=T.ONLY_TWO),s){const i=e.halfEdges,l=[],a=[];for(const c of i){const t=this.state.getSectorState(c),n=t.and(s);if(n===T.NONE)throw new v(`invalid sector state: ${t}`);t!==n&&(l.push(new H(c,n)),a.push(c))}if(l.length)return new C(new x(l),{type:"StaticFaceSectors",face:e,sectors:a},this.board)}this.dirtyFaces.delete(e)}return null}clone(e){return new Q(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class X{constructor(e,r,o,s){S(this,"dirtyVertices",[]);S(this,"vertexListener");this.board=e,this.state=r,this.options=o,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=i=>{this.dirtyVertices.push(i)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),r=this.state.getVertexState(e);if(r.possibilityCount===0)throw new v("Vertex has no possibilities");const o=[],s=[];for(const i of e.edges)if(this.state.getEdgeState(i)===h.WHITE){const a=r.getFinalStatesOfEdge(i);if(a.size===1){const c=[...a][0];c===h.RED&&this.options.solveToRed&&o.push(i),c===h.BLACK&&this.options.solveToBlack&&s.push(i)}}if(o.length||s.length)return new C(new x([...o.map(i=>new L(i,h.RED)),...s.map(i=>new L(i,h.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:o,toBlackEdges:s},this.board)}return null}clone(e){return new X(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class _{constructor(e,r,o){S(this,"dirtyVertices",[]);S(this,"vertexListener");this.board=e,this.state=r,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=s=>{this.dirtyVertices.push(s)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],r=this.state.getVertexState(e);if(r.possibilityCount===0)throw new v("Vertex has no possibilities");const s=Se(e).map(a=>a.face?this.state.getFaceColor(a.face):this.state.getOutsideColor()),i=new Set(s);if(i.size!==1){const a=new Map([...i].map(t=>[t,new Map([...i].map(n=>[n,!1]))])),c=new Map([...i].map(t=>[t,new Map([...i].map(n=>[n,!1]))]));for(const t of r.getAllowedPairs()){const n=e.edges.indexOf(t[0]),d=e.edges.indexOf(t[1]),f=Math.min(n,d),p=Math.max(n,d),u=s.slice(f,p),y=[...s.slice(p),...s.slice(0,f)],m=E=>{for(let B=0;B<E.length;B++)for(let N=B+1;N<E.length;N++)a.get(E[B]).set(E[N],!0),a.get(E[N]).set(E[B],!0)};m(u),m(y);for(const E of u)for(const B of y)E!==B&&(c.get(E).set(B,!0),c.get(B).set(E,!0))}for(const t of i)for(const n of i){if(t===n)continue;const d=r.allowsEmpty()||a.get(t).get(n),f=c.get(t).get(n);if(d&&!f)return new C(new oe(R(this.state,t),R(this.state,n)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(p=>this.state.getFaceColor(p)===t),facesB:e.faces.filter(p=>this.state.getFaceColor(p)===n)},this.board);if(f&&!d&&this.state.getOppositeFaceColor(t)!==n)return new C(new M(R(this.state,t),R(this.state,n)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(p=>this.state.getFaceColor(p)===t),facesB:e.faces.filter(p=>this.state.getFaceColor(p)===n)},this.board)}}const l=this.dirtyVertices.pop();b()&&O(l===e)}return null}clone(e){return new _(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class ee{constructor(e,r,o){S(this,"dirtyVertices",[]);S(this,"vertexListener");this.board=e,this.state=r,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=s=>{this.dirtyVertices.push(s)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),r=this.state.getVertexState(e);if(r.possibilityCount===0)throw new v("Vertex has no possibilities");const o=ye(e),s=o.map(t=>this.state.getSectorState(t)),i=o.map(t=>T.NONE);for(const t of r.getAllowedPairs())for(let n=0;n<o.length;n++){const d=o[n],f=d.edge,p=d.next.edge,u=t[0],y=t[1],m=(f===u||f===y?1:0)+(p===u||p===y?1:0);i[n]=i[n].with(m)}if(r.allowsEmpty())for(let t=0;t<o.length;t++)i[t]=i[t].withZero(!0);for(let t=0;t<o.length;t++)i[t]=i[t].and(s[t]);for(const t of i)if(t===T.NONE)throw new v("Sector has no possibilities");const l=[],a=[],c=[];for(let t=0;t<o.length;t++)s[t]!==i[t]&&(l.push(o[t]),a.push(s[t]),c.push(i[t]));if(l.length)return new C(new x(l.map((t,n)=>new H(t,c[n]))),{type:"VertexStateToSector",vertex:e,sectors:l,beforeStates:a,afterStates:c},this.board)}return null}clone(e){return new ee(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}const Be=(g,e,r)=>new le([new de(g,e),new he(g,e),new ge(g,e),new G(g,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new Y(g,e,{solveToRed:!0,solveToBlack:!0}),new Z(g,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new U(g,e),new fe(g,e),new Q(g,e),new J(g,e),new ue(g,e),new X(g,e,{solveToRed:!0,solveToBlack:!0}),new ee(g,e),new $(g,e,{solveToRed:!0,solveToBlack:!0}),new I(g,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new _(g,e),new pe(g,e),new K(g,e,{solveToRed:!0,solveToBlack:!0}),new j(g,e),new P(g,e),new q(g,e)]),Te=g=>g instanceof me?{type:"PolygonGeneratorBoard",generator:g.generator.name,parameters:g.parameters}:g instanceof Ce?{type:"SquareBoard",width:g.width,height:g.height}:g instanceof Ee?{type:"HexagonalBoard",radius:g.radius,scale:g.scale,isPointyTop:g.isPointyTop,holeRadius:g.holeRadius}:{type:"BaseBoard",vertices:g.vertices.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vx:e.viewCoordinates.x,vy:e.viewCoordinates.y})),faces:g.faces.map(e=>({x:e.logicalCoordinates.x,y:e.logicalCoordinates.y,vertices:e.vertices.map(r=>g.vertices.indexOf(r))}))};export{I as F,G as S,X as V,Be as a,Y as b,U as c,Q as d,J as e,Z as f,ee as g,$ as h,_ as i,K as j,j as k,P as l,q as m,Te as s};
