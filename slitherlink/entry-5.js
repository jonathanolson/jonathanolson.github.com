import"./chunk-16.js";import{N as E,D as x,B as H}from"./chunk-17.js";import{n as D,H as F,f as W,_ as h,d as k,e as G,P as L}from"./chunk-18.js";import{P as M,am as V,ai as y}from"./chunk-25.js";import{E as z,s as u}from"./chunk-28.js";import{g as I,a as q}from"./chunk-43.js";import{B as K}from"./chunk-29.js";import{f as O}from"./chunk-30.js";import{a as v}from"./chunk-31.js";import{s as i}from"./chunk-22.js";import{A as S}from"./chunk-37.js";import"./chunk-23.js";import"./chunk-19.js";import"./chunk-32.js";import"./chunk-20.js";import"./chunk-27.js";self.assertions.enableAssert();const A=new E,R=new E({renderer:"svg",children:[A]}),d=new x(R,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(d.domElement);d.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");const T=o=>L.get(o,o.defaultParameterValues),P=[new D(10,10),new F(4,1,!0),...W.map(T)];(async()=>{let o=null;const w=new H(!1);for(;;){console.log("board loaded");const t=P[Math.floor(Math.random()*P.length)],b=await I(t,w),c=await q(b,()=>!0,w),s=c.cleanState.clone();c.blackEdges.forEach(g=>s.setEdgeState(g,z.BLACK)),O(t,s);const p=K.fromSolvedPuzzle(c);o&&o.dispose(),o=new M(p,{scale:30,left:20,top:20}),A.addChild(o),d.updateDisplay(),await i(50);const e=p.stateProperty.value.clone(),m=v(t,e),f=()=>{p.stateProperty.value=e.clone(),d.updateDisplay()};let B=0;for(;!u(e);){if(o.clearAnnotationNodes(),B++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const g=e.clone(),N=m.clone(g),n=m.nextAction();if(n){console.log(n);const r=new V(t,e,s);o.addAnnotationNode(new S(t,n.annotation,y)),f(),await i(0);try{n.apply(r)}catch(l){console.error(l);debugger;const a=N.nextAction();a&&a.apply(r)}n.apply(e)}else if(!u(e)){const r=v(t,e),l=r.nextAction();if(l)throw o.addAnnotationNode(new S(t,l.annotation,y)),f(),await i(0),new Error("Fresh solver should not have any actions");r.dispose();const a=h.find(h.shuffle(t.edges),C=>e.getEdgeState(C)===z.WHITE);if(k()&&G(a),e.setEdgeState(a,s.getEdgeState(a)),console.log("setting white edge to red/black",a),!m.dirty)throw new Error("Solver should be dirty after setting edge state")}f(),await i(0)}if(!u(e))throw new Error("Solver did not solve the puzzle")}})();
