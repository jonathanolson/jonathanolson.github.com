var _e=Object.defineProperty;var et=(n,e,t)=>e in n?_e(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var g=(n,e,t)=>et(n,typeof e!="symbol"?e+"":e,t);import{E as be,f as ke,a as v,k as tt}from"./chunk-16.js";import{d as h,e as c,_ as Oe,N as st,ag as at}from"./chunk-18.js";import"./chunk-17.js";import{P as ot}from"./chunk-20.js";const it=(n,e)=>{if(n.forwardHalf.next.edge===e)return n.forwardHalf;if(n.reversedHalf.next.edge===e)return n.reversedHalf;if(e.forwardHalf.next.edge===n)return e.forwardHalf;if(e.reversedHalf.next.edge===n)return e.reversedHalf;throw new Error("Edges are not connected")},V=class V extends be{};g(V,"WHITE",new V),g(V,"BLACK",new V),g(V,"RED",new V),g(V,"enumeration",new ke(V));let w=V;const N=(n,e)=>{const t=n.edges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return h()&&c(t),t},P=n=>({start:{x:n.start.logicalCoordinates.x,y:n.start.logicalCoordinates.y},end:{x:n.end.logicalCoordinates.x,y:n.end.logicalCoordinates.y}});class j{constructor(e,t=new Map){this.board=e,this.edgeStateMap=t}apply(e){for(const[t,s]of this.edgeStateMap)e.setEdgeState(t,s)}getUndo(e){const t=new Map;for(const s of this.edgeStateMap.keys())t.set(s,e.getEdgeState(s));return new j(this.board,t)}isEmpty(){return this.edgeStateMap.size===0}serializeAction(){return{type:"GeneralEdgeAction",edges:Array.from(this.edgeStateMap.entries()).map(([e,t])=>({edge:P(e),state:t.name}))}}static deserializeAction(e,t){return new j(e,new Map(t.edges.map(s=>[N(e,s.edge),w.enumeration.getValue(s.state)])))}}const Be=(n,e)=>({type:"EdgeData",edges:n.edges.filter(t=>e.getEdgeState(t)!==w.WHITE).map(t=>({edge:P(t),state:e.getEdgeState(t).name}))});class ne extends j{constructor(t,s,a=new Map){super(t,a);g(this,"edgeStateChangedEmitter",new v);this.parentState=s}getEdgeState(t){return this.edgeStateMap.has(t)?this.edgeStateMap.get(t):this.parentState.getEdgeState(t)}setEdgeState(t,s){const a=this.getEdgeState(t);a!==s&&(this.edgeStateMap.set(t,s),this.edgeStateChangedEmitter.emit(t,s,a))}clone(){return new ne(this.board,this.parentState,new Map(this.edgeStateMap))}createDelta(){return new ne(this.board,this,new Map)}serializeState(t){return Be(t,this)}}class J{constructor(e,t){g(this,"edgeStateChangedEmitter",new v);g(this,"edgeStateMap",new Map);this.board=e,e.edges.forEach(s=>{this.edgeStateMap.set(s,t(s))})}getEdgeState(e){return h()&&c(this.edgeStateMap.has(e)),this.edgeStateMap.get(e)}setEdgeState(e,t){h()&&c(this.edgeStateMap.has(e));const s=this.edgeStateMap.get(e);s!==t&&(this.edgeStateMap.set(e,t),this.edgeStateChangedEmitter.emit(e,t,s))}clone(){return new J(this.board,e=>this.getEdgeState(e))}createDelta(){return new ne(this.board,this)}serializeState(e){return Be(e,this)}static deserializeState(e,t){const s=new Map(t.edges.map(a=>[N(e,a.edge),w.enumeration.getValue(a.state)]));return new J(e,a=>s.get(a)??w.WHITE)}}const B=(n,e)=>{const t=n.faces.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return h()&&c(t),t};class ae{constructor(e,t){this.id=e,this.colorState=t}}class nt{constructor(e,t,s,a,o,i){this.board=e,this.addedFaceColors=t,this.removedFaceColors=s,this.faceChangeMap=a,this.oppositeChangeMap=o,this.invalidFaceColor=i,h()&&c(s.size<=a.size)}apply(e){e.modifyFaceColors(this.addedFaceColors,this.removedFaceColors,this.faceChangeMap,this.oppositeChangeMap,this.invalidFaceColor)}getUndo(e){throw new Error("getUndo unimplemented in GeneralFaceColorAction")}isEmpty(){return this.addedFaceColors.size===0&&this.removedFaceColors.size===0&&this.faceChangeMap.size===0&&this.oppositeChangeMap.size===0}serializeAction(){throw new Error("serializeAction unimplemented in GeneralFaceColorAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in GeneralFaceColorAction")}}const I=n=>({x:n.logicalCoordinates.x,y:n.logicalCoordinates.y}),T=class T extends be{};g(T,"OUTSIDE",new T),g(T,"INSIDE",new T),g(T,"UNDECIDED",new T),g(T,"enumeration",new ke(T));let A=T;const rt=(n,e,t)=>({id:n.id,colorState:n.colorState.toString(),faces:e.map(I),oppositeFaceColorId:t}),Ie=n=>({type:"FaceColorData",colors:n.getFaceColors().map(e=>{var t;return rt(e,n.getFacesWithColor(e),((t=n.getOppositeFaceColor(e))==null?void 0:t.id)??null)}),invalidFaceColor:n.hasInvalidFaceColors()});class re extends nt{constructor(t,s,a=new Set,o=new Set,i=new Map,l=new Map,r=!1){super(t,a,o,i,l,r);g(this,"faceColorsChangedEmitter",new v);this.parentState=s}getFaceColors(){return[...[...this.parentState.getFaceColors()].filter(t=>!this.removedFaceColors.has(t)),...this.addedFaceColors]}getInsideColor(){return this.parentState.getInsideColor()}getOutsideColor(){return this.parentState.getOutsideColor()}getFaceColor(t){return this.faceChangeMap.has(t)?this.faceChangeMap.get(t):this.parentState.getFaceColor(t)}getFacesWithColor(t){let s;this.addedFaceColors.has(t)?s=new Set:s=new Set(this.parentState.getFacesWithColor(t));for(const[a,o]of this.faceChangeMap.entries())o===t?s.add(a):s.has(a)&&s.delete(a);return[...s]}getFaceColorMap(){const t=new Map(this.parentState.getFaceColorMap());for(const[s,a]of this.faceChangeMap.entries())t.set(s,a);return t}getOppositeFaceColor(t){const s=this.oppositeChangeMap.get(t);return s!==void 0?s:this.parentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.invalidFaceColor||this.parentState.hasInvalidFaceColors()}modifyFaceColors(t,s,a,o,i){for(const f of t)this.addedFaceColors.add(f);const l=new Set;for(const f of s)l.add(f),this.addedFaceColors.has(f)?this.addedFaceColors.delete(f):this.removedFaceColors.add(f);for(const[f,u]of a.entries())this.faceChangeMap.set(f,u);for(const[f,u]of o.entries())l.has(f)||this.oppositeChangeMap.set(f,u);const r=new Set(s);for(const f of this.oppositeChangeMap.keys()){const u=this.oppositeChangeMap.get(f);u&&r.has(u)&&this.oppositeChangeMap.set(f,null)}if(h()){const f=[...o.values()].filter(x=>x!==null),u=Oe.uniq(f);c(f.length===u.length)}const d=new Set(o.keys());this.invalidFaceColor=i,this.faceColorsChangedEmitter.emit(t,s,d,[...a.keys()])}clone(){return new re(this.board,this.parentState,new Set(this.addedFaceColors),new Set(this.removedFaceColors),new Map(this.faceChangeMap),new Map(this.oppositeChangeMap),this.invalidFaceColor||this.parentState.hasInvalidFaceColors())}createDelta(){return new re(this.board,this)}serializeState(t){return Ie(this)}}const Ve=()=>tt.nextInt(Number.MAX_SAFE_INTEGER);class U{constructor(e,t,s,a,o,i,l,r){g(this,"faceColorsChangedEmitter",new v);g(this,"faceColors");g(this,"colorMap");g(this,"colorInverseMap");g(this,"oppositeColorMap");g(this,"outsideColor");g(this,"insideColor");g(this,"invalidFaceColor");this.board=e,h()&&c(!t||l,"Provide all or none of the optional arguments"),this.outsideColor=i||new ae(Ve(),A.OUTSIDE),this.insideColor=l||new ae(Ve(),A.INSIDE),this.colorMap=new Map(s||[...e.faces].map(d=>[d,new ae(Ve(),A.UNDECIDED)])),this.faceColors=new Set(t||[this.outsideColor,this.insideColor,...e.faces.map(d=>this.colorMap.get(d))]),h()&&c(this.board.faces.every(d=>this.colorMap.has(d))),h()&&c(this.board.faces.every(d=>this.faceColors.has(this.colorMap.get(d)))),this.colorInverseMap=new Map(a?[...a.keys()].map(d=>[d,new Set([...a.get(d)])]):[...this.faceColors].map(d=>[d,new Set([...this.colorMap.keys()].filter(f=>this.colorMap.get(f)===d))])),this.oppositeColorMap=new Map(o||[[this.outsideColor,this.insideColor],[this.insideColor,this.outsideColor]]),this.invalidFaceColor=!!r}getFaceColors(){return[...this.faceColors]}getInsideColor(){return this.insideColor}getOutsideColor(){return this.outsideColor}getFaceColor(e){const t=this.colorMap.get(e);return h()&&c(t),t}getFacesWithColor(e){h()&&c(this.faceColors.has(e));const t=this.colorInverseMap.get(e);return h()&&c(t),[...t]}getFaceColorMap(){return new Map(this.colorMap)}getOppositeFaceColor(e){return this.oppositeColorMap.get(e)??null}hasInvalidFaceColors(){return this.invalidFaceColor}modifyFaceColors(e,t,s,a,o){for(const r of e)this.faceColors.add(r),this.colorInverseMap.set(r,new Set);for(const[r,d]of s.entries()){const f=this.colorMap.get(r);h()&&c(f),this.colorMap.set(r,d),this.colorInverseMap.get(f).delete(r),this.colorInverseMap.get(d).add(r)}const i=new Set;for(const r of t)i.add(r),this.faceColors.delete(r),this.colorInverseMap.delete(r),this.oppositeColorMap.delete(r);for(const[r,d]of a.entries())d===null?this.oppositeColorMap.delete(r):i.has(r)||(this.oppositeColorMap.set(r,d),this.oppositeColorMap.set(d,r));for(const r of this.faceColors)this.oppositeColorMap.has(r)&&i.has(this.oppositeColorMap.get(r))&&this.oppositeColorMap.delete(r);const l=new Set(a.keys());if(this.invalidFaceColor=o,h()&&c(this.board.faces.every(r=>this.colorMap.has(r))),h()&&c(this.board.faces.every(r=>this.faceColors.has(this.colorMap.get(r)))),h()){const r=new Set(this.getFaceColors());for(const d of r){const f=this.getOppositeFaceColor(d);f&&!r.has(f)&&c(!1,`opposite color ${f} of color ${d} is not in the set of colors`)}for(const d of this.oppositeColorMap.keys())c(this.oppositeColorMap.has(this.oppositeColorMap.get(d)))}this.faceColorsChangedEmitter.emit(e,t,l,[...s.keys()])}clone(){return new U(this.board,this.faceColors,this.colorMap,this.colorInverseMap,this.oppositeColorMap,this.outsideColor,this.insideColor,this.invalidFaceColor)}createDelta(){return new re(this.board,this)}serializeState(e){return Ie(this)}static deserializeState(e,t){const s=t.colors.map(d=>{const f=d.id,u=A.enumeration.getValue(d.colorState);return h()&&c(u),new ae(f,u)}),a=new Map,o=new Map,i=new Map;s.forEach((d,f)=>{const u=t.colors[f].faces.map(M=>B(e,M));u.forEach(M=>a.set(M,d)),o.set(d,new Set(u));const x=t.colors[f].oppositeFaceColorId;if(x!==null){const M=s.find(y=>y.id===x);h()&&c(M),i.set(d,M)}});const l=s.find(d=>d.colorState===A.OUTSIDE);h()&&c(l);const r=s.find(d=>d.colorState===A.INSIDE);return h()&&c(r),new U(e,new Set(s),a,o,i,l,r,t.invalidFaceColor)}}const ct=(n,e,t)=>{for(const s of n.faces){if(t.has(s))continue;const a=e.getFaceValue(s);if(!(a===0||a===null)){for(const o of s.edges){const i=o.getOtherFace(s);!i||t.has(i)}return!0}}return!1},W=[],je=n=>{for(;W.length<=n;)W.push(W.length===0?1:W[W.length-1]*W.length);return W},Je=(n,e,t)=>t[n]/(t[e]*t[n-e]),oe=(n,e)=>{n=Oe.sortBy(n);const t=je(e);let s=0;const a=n.length;for(let o=0;o<a;o++){const i=n[o-1]+1,l=n[o];for(let r=o==0?0:i;r<l;r++)s+=Je(e-r-1,a-o-1,t)}return s},lt=(n,e)=>Je(n,e,je(n)),ie=(n,e)=>{let t=0;for(let s=0;s<n.length;s++)t+=1<<e-n[s]-1;return t},ht=n=>1<<n,Qe=n=>{const e=new Uint8Array(Math.ceil(n.length/8));for(let s=0;s<n.length;s++)n[s]&&(e[Math.floor(s/8)]|=1<<7-s%8);const t=btoa(String.fromCharCode(...e));if(h()){const s=We(t,n.length);c(n.length===s.length&&n.every((a,o)=>a===s[o]))}return t},We=(n,e)=>{const t=Uint8Array.from(atob(n),a=>a.charCodeAt(0)),s=[];for(let a=0;a<t.length*8;a++)s.push((t[Math.floor(a/8)]&1<<7-a%8)!==0);return s.slice(0,e)};class S{constructor(e,t,s,a){g(this,"order");g(this,"possibilityCount");g(this,"matrix");this.face=e,this.faceValue=t,this.order=e.edges.length,s?this.matrix=s:this.matrix=Oe.range(0,S.getMatrixSize(this.order,this.faceValue)).map(()=>!0),a!==void 0?this.possibilityCount=a:this.possibilityCount=this.matrix.filter(o=>o).length,h()&&c(this.matrix.length===S.getMatrixSize(this.order,this.faceValue)),h()&&c(this.possibilityCount===this.matrix.filter(o=>o).length)}isAny(){return this.possibilityCount===S.getMatrixSize(this.order,this.faceValue)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.allowsBlackEdges([])}allowsBlackEdges(e){return this.matrix[this.getBlackEdgesIndex(e)]}getAllowedCombinations(){const e=[];return S.forEachEdgeCombination(this.face.edges,this.faceValue,(t,s)=>{this.matrix[this.getIndexFromIndices(t)]&&e.push(s.slice())}),h()&&c(e.length===this.possibilityCount),e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedCombinations())s.includes(e)?t.add(w.BLACK):t.add(w.RED);return this.allowsEmpty()&&t.add(w.RED),t}getBlackEdgesIndex(e){const t=e.map(s=>this.face.edges.indexOf(s));return h()&&c(t.every(s=>s>=0)),this.getIndexFromIndices(t)}getIndexFromIndices(e){return this.faceValue===null?ie(e,this.order):oe(e,this.order)}equals(e){return this.face===e.face&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return h()&&c(this.face===e.face),new S(this.face,this.faceValue,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return h()&&c(this.face===e.face),new S(this.face,this.faceValue,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withBlackEdges(e,t){const s=this.getBlackEdgesIndex(e);return new S(this.face,this.faceValue,this.matrix.slice(0,s).concat(t,this.matrix.slice(s+1)))}serialize(){if(this.isAny())return{faceValue:this.faceValue,matrix:"",isAny:!0};const e={faceValue:this.faceValue,matrix:Qe(this.matrix),isAny:!1};return h()&&c(this.equals(S.deserialize(this.face,e))),e}static getMatrixSize(e,t){return t===null?ht(e):lt(e,t)}static forEachIndexCombination(e,t,s){let a=[];const o=()=>{if(t!==null){if(a.length===t){s(a);return}}else s(a);const i=a.length>0?a[a.length-1]+1:0;for(let l=i;l<e;l++)a.push(l),o(),a.pop()};o()}static forEachEdgeCombination(e,t,s){let a=[],o=[];const i=()=>{if(t!==null){if(a.length===t){s(a,o);return}}else s(a,o);const l=a.length>0?a[a.length-1]+1:0;for(let r=l;r<e.length;r++)a.push(r),o.push(e[r]),i(),a.pop(),o.pop()};i()}static fromLookup(e,t,s){const a=e.edges.length,o=new Array(S.getMatrixSize(a,t)).fill(!1);return S.forEachEdgeCombination(e.edges,t,(i,l)=>{if(s(l)){const d=t===null?ie(i,a):oe(i,a);o[d]=!0}}),new S(e,t,o)}static none(e,t){const s=S.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!1);return new S(e,t,a,0)}static any(e,t){const s=S.getMatrixSize(e.edges.length,t),a=new Array(s).fill(!0);return new S(e,t,a,s)}static withOnlyBlackEdges(e,t,s){const a=S.getMatrixSize(e.edges.length,t),o=new Array(a).fill(!1),i=s.map(r=>e.edges.indexOf(r)),l=t===null?ie(i,e.edges.length):oe(i,e.edges.length);return o[l]=!0,new S(e,t,o,1)}static withoutBlackEdges(e,t,s){const a=S.getMatrixSize(e.edges.length,t),o=new Array(a).fill(!0),i=s.map(r=>e.edges.indexOf(r)),l=t===null?ie(i,e.edges.length):oe(i,e.edges.length);return o[l]=!1,new S(e,t,o,a-1)}static fromVertexAndColorData(e,t,s){const o=e.vertices.map(f=>s.getVertexState(f)).map(f=>{const u=f.vertex.edges.filter(x=>x.faces.includes(e));return h()&&c(u.length===2),{edgeA:u[0],edgeB:u[1],...f.getBinaryCombinationsAllowed(u[0],u[1])}}),i=new Map(e.edges.map(f=>{const u=f.getOtherFace(e);return[f,u?s.getFaceColor(u):s.getOutsideColor()]})),l=s.getFaceColor(e),r=new Set([...i.values(),l]),d=new Map([...r].map(f=>[f,s.getOppositeFaceColor(f)]));return S.fromLookup(e,s.getFaceValue(e),f=>{const u=new Set(f);for(const y of o){const p=u.has(y.edgeA),E=u.has(y.edgeB);if(p&&E&&!y.allowsBoth||p&&!E&&!y.allowsAOnly||!p&&E&&!y.allowsBOnly||!p&&!E&&!y.allowsNone)return!1}const x=new Set([l]),M=new Set;for(const y of e.edges){const p=i.get(y);h()&&c(p),u.has(y)?M.add(p):x.add(p)}for(const y of x){if(M.has(y))return!1;const p=d.get(y);if(p&&x.has(p))return!1}for(const y of M){const p=d.get(y);if(p&&M.has(p))return!1}if(u.size===e.edges.length&&ct(t,s,new Set([e]))){for(const y of t.faces)if(s.getFaceValue(y)!==null){for(const p of y.edges)if(!u.has(p))return!1}}return!0})}static deserialize(e,t){return t.isAny?S.any(e,t.faceValue):new S(e,t.faceValue,We(t.matrix,S.getMatrixSize(e.edges.length,t.faceValue)))}}class ce{constructor(e,t=new Map){this.board=e,this.faceStateMap=t}apply(e){for(const[t,s]of this.faceStateMap)e.setFaceState(t,s)}getUndo(e){const t=new Map;for(const s of this.faceStateMap.keys())t.set(s,e.getFaceState(s));return new ce(this.board,t)}isEmpty(){return this.faceStateMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceStateMap.entries()).map(([e,t])=>({face:I(e),state:t.serialize()}))}}static deserializeAction(e,t){return new ce(e,new Map(t.faces.map(s=>[B(e,s.face),S.deserialize(B(e,s.face),s.state)])))}}const ze=(n,e)=>({type:"FaceStateData",faces:n.faces.map(t=>({face:I(t),state:e.getFaceState(t).serialize()}))});class le extends ce{constructor(t,s,a=new Map){super(t,a);g(this,"faceStateChangedEmitter",new v);this.parentState=s}getFaceState(t){return this.faceStateMap.has(t)?this.faceStateMap.get(t):this.parentState.getFaceState(t)}setFaceState(t,s){const a=this.getFaceState(t);a.equals(s)||(this.faceStateMap.set(t,s),this.faceStateChangedEmitter.emit(t,s,a))}clone(){return new le(this.board,this.parentState,new Map(this.faceStateMap))}createDelta(){return new le(this.board,this,new Map)}serializeState(t){return ze(t,this)}}class q{constructor(e,t){g(this,"faceStateChangedEmitter",new v);g(this,"faceStateMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceStateMap.set(s,t(s))})}getFaceState(e){return h()&&c(this.faceStateMap.has(e)),this.faceStateMap.get(e)}setFaceState(e,t){h()&&c(this.faceStateMap.has(e));const s=this.faceStateMap.get(e);s.equals(t)||(this.faceStateMap.set(e,t),this.faceStateChangedEmitter.emit(e,t,s))}clone(){return new q(this.board,e=>this.getFaceState(e))}createDelta(){return new le(this.board,this)}serializeState(e){return ze(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>{const o=B(e,a.face);return[o,S.deserialize(o,a.state)]}));return new q(e,a=>{const o=s.get(a);return h()&&c(o),o})}}class Q{constructor(e,t=new Map){this.board=e,this.faceValueMap=t}apply(e){for(const[t,s]of this.faceValueMap)e.setFaceValue(t,s)}getUndo(e){const t=new Map;for(const s of this.faceValueMap.keys())t.set(s,e.getFaceValue(s));return new Q(this.board,t)}isEmpty(){return this.faceValueMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceValueMap.entries()).map(([e,t])=>({face:I(e),state:t}))}}static deserializeAction(e,t){return new Q(e,new Map(t.faces.map(s=>[B(e,s.face),s.state])))}}const Le=(n,e)=>({type:"FaceValueData",faces:n.faces.filter(t=>e.getFaceValue(t)!==null).map(t=>({face:I(t),state:e.getFaceValue(t)}))});class he extends Q{constructor(t,s,a=new Map){super(t,a);g(this,"faceValueChangedEmitter",new v);this.parentState=s}getFaceValue(t){return this.faceValueMap.has(t)?this.faceValueMap.get(t):this.parentState.getFaceValue(t)}setFaceValue(t,s){this.getFaceValue(t)!==s&&(this.faceValueMap.set(t,s),this.faceValueChangedEmitter.emit(t,s))}clone(){return new he(this.board,this.parentState,new Map(this.faceValueMap))}createDelta(){return new he(this.board,this,new Map)}serializeState(t){return Le(t,this)}}class X{constructor(e,t){g(this,"faceValueChangedEmitter",new v);g(this,"faceValueMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceValueMap.set(s,t(s))})}getFaceValue(e){return h()&&c(this.faceValueMap.has(e)),this.faceValueMap.get(e)}setFaceValue(e,t){h()&&c(this.faceValueMap.has(e)),this.faceValueMap.get(e)!==t&&(this.faceValueMap.set(e,t),this.faceValueChangedEmitter.emit(e,t))}clone(){return new X(this.board,e=>this.getFaceValue(e))}createDelta(){return new he(this.board,this)}serializeState(e){return Le(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(a=>[B(e,a.face),a.state]));return new X(e,a=>s.get(a)??null)}}const Re=(n,e)=>{const t=n.halfEdges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return h()&&c(t),t},De=n=>({start:{x:n.start.logicalCoordinates.x,y:n.start.logicalCoordinates.y},end:{x:n.end.logicalCoordinates.x,y:n.end.logicalCoordinates.y}}),m=class m extends be{constructor(e,t,s,a){super(),this.zero=e,this.one=t,this.two=s,this.serializedValue=a}allows(e){return h()&&c(e===0||e===1||e===2),e===0&&this.zero||e===1&&this.one||e===2&&this.two}isSubsetOf(e){return(!this.zero||e.zero)&&(!this.one||e.one)&&(!this.two||e.two)}and(e){return m.getWithValue(this.zero&&e.zero,this.one&&e.one,this.two&&e.two)}or(e){return m.getWithValue(this.zero||e.zero,this.one||e.one,this.two||e.two)}withZero(e){return m.getWithValue(e,this.one,this.two)}withOne(e){return m.getWithValue(this.zero,e,this.two)}withTwo(e){return m.getWithValue(this.zero,this.one,e)}with(e){return h()&&c(e===0||e===1||e===2),m.getWithValue(e===0?!0:this.zero,e===1?!0:this.one,e===2?!0:this.two)}withAllowZero(){return this.withZero(!0)}withAllowOne(){return this.withOne(!0)}withAllowTwo(){return this.withTwo(!0)}withDisallowZero(){return this.withZero(!1)}withDisallowOne(){return this.withOne(!1)}withDisallowTwo(){return this.withTwo(!1)}serialize(){return this.serializedValue}static getWithValue(e,t,s){return m.enumeration.values.find(a=>a.zero===e&&a.one===t&&a.two===s)}static getOnly(e){return h()&&c(e===0||e===1||e===2),m.getWithValue(e===0,e===1,e===2)}static getNot(e){return h()&&c(e===0||e===1||e===2),m.getWithValue(e!==0,e!==1,e!==2)}static deserialize(e){const t=dt.get(e);return h()&&c(t,`invalid serialized value: ${e}`),t}};g(m,"NONE",new m(!1,!1,!1,0)),g(m,"ONLY_ZERO",new m(!0,!1,!1,1)),g(m,"ONLY_ONE",new m(!1,!0,!1,2)),g(m,"ONLY_TWO",new m(!1,!1,!0,3)),g(m,"NOT_ZERO",new m(!1,!0,!0,4)),g(m,"NOT_ONE",new m(!0,!1,!0,5)),g(m,"NOT_TWO",new m(!0,!0,!1,6)),g(m,"ANY",new m(!0,!0,!0,7)),g(m,"enumeration",new ke(m)),g(m,"trivialStates",[m.NONE,m.ONLY_ZERO,m.ONLY_TWO,m.ANY]);let F=m;const dt=new Map(F.enumeration.values.map(n=>[n.serializedValue,n]));class de{constructor(e,t=new Map){this.board=e,this.sectorStateMap=t}apply(e){for(const[t,s]of this.sectorStateMap)e.setSectorState(t,s)}getUndo(e){const t=new Map;for(const s of this.sectorStateMap.keys())t.set(s,e.getSectorState(s));return new de(this.board,t)}isEmpty(){return this.sectorStateMap.size===0}serializeAction(){return{type:"GeneralSectorAction",sectors:Array.from(this.sectorStateMap.entries()).map(([e,t])=>({sector:De(e),state:t.serialize()}))}}static deserializeAction(e,t){return new de(e,new Map(t.sectors.map(s=>[Re(e,s.sector),F.deserialize(s.state)])))}}const Ne=(n,e)=>({type:"SectorStateData",sectors:n.halfEdges.filter(t=>e.getSectorState(t)!==F.ANY).map(t=>({sector:De(t),state:e.getSectorState(t).serialize()}))});class ge extends de{constructor(t,s,a=new Map){super(t,a);g(this,"sectorStateChangedEmitter",new v);this.parentState=s}getSectorState(t){return this.sectorStateMap.has(t)?this.sectorStateMap.get(t):this.parentState.getSectorState(t)}setSectorState(t,s){const a=this.getSectorState(t);a!==s&&(this.sectorStateMap.set(t,s),this.sectorStateChangedEmitter.emit(t,s,a))}clone(){return new ge(this.board,this.parentState,new Map(this.sectorStateMap))}createDelta(){return new ge(this.board,this,new Map)}serializeState(t){return Ne(t,this)}}class H{constructor(e,t=()=>F.ANY){g(this,"sectorStateChangedEmitter",new v);g(this,"sectorStateMap",new Map);this.board=e,e.halfEdges.forEach(s=>{this.sectorStateMap.set(s,t(s))})}getSectorState(e){return h()&&c(this.sectorStateMap.has(e)),this.sectorStateMap.get(e)}setSectorState(e,t){h()&&c(this.sectorStateMap.has(e));const s=this.sectorStateMap.get(e);s!==t&&(this.sectorStateMap.set(e,t),this.sectorStateChangedEmitter.emit(e,t,s))}clone(){return new H(this.board,e=>this.getSectorState(e))}createDelta(){return new ge(this.board,this)}serializeState(e){return Ne(e,this)}static deserializeState(e,t){const s=new Map(t.sectors.map(a=>[Re(e,a.sector),F.deserialize(a.state)]));return new H(e,a=>s.get(a)??F.ANY)}}class G{constructor(e,t,s=!1){g(this,"edges");g(this,"a");g(this,"b");if(this.id=e,this.halfEdges=t,this.isSolved=s,this.a=t[0].start,this.b=t[t.length-1].end,this.edges=t.map(a=>a.edge),h()){c(t.length>0);for(let a=0;a<t.length-1;a++)c(t[a].end===t[a+1].start)}}static deserializeSimpleRegion(e,t){return new G(t.id,t.halfEdges.map(s=>Re(e,s)),t.isSolved)}}const Te=n=>({id:n.id,halfEdges:n.halfEdges.map(De),isSolved:n.isSolved}),Ct=n=>{const e=n.getSimpleRegions();return e.length===1&&e[0].isSolved&&n.getWeirdEdges().length===0},Pe=n=>({type:"SimpleRegionData",simpleRegions:n.getSimpleRegions().map(Te),weirdEdges:n.getWeirdEdges().map(P)});class _{constructor(e,t=new Set,s=new Set,a=new Set,o=new Set){this.board=e,this.addedRegions=t,this.removedRegions=s,this.addedWeirdEdges=a,this.removedWeirdEdges=o}apply(e){e.modifyRegions(this.addedRegions,this.removedRegions,this.addedWeirdEdges,this.removedWeirdEdges)}getUndo(e){return new _(this.board,this.removedRegions,this.addedRegions,this.removedWeirdEdges,this.addedWeirdEdges)}isEmpty(){return this.addedRegions.size===0&&this.removedRegions.size===0&&this.addedWeirdEdges.size===0&&this.removedWeirdEdges.size===0}serializeAction(){return{type:"GeneralSimpleRegionAction",addedRegions:Array.from(this.addedRegions).map(Te),removedRegions:Array.from(this.removedRegions).map(Te),addedWeirdEdges:Array.from(this.addedWeirdEdges).map(P),removedWeirdEdges:Array.from(this.removedWeirdEdges).map(P)}}static deserializeAction(e,t){return new _(e,new Set(t.addedRegions.map(s=>G.deserializeSimpleRegion(e,s))),new Set(t.removedRegions.map(s=>G.deserializeSimpleRegion(e,s))),new Set(t.addedWeirdEdges.map(s=>N(e,s))),new Set(t.removedWeirdEdges.map(s=>N(e,s))))}}class fe extends _{constructor(t,s,a=new Set,o=new Set,i=new Set,l=new Set){super(t,a,o,i,l);g(this,"simpleRegionsChangedEmitter",new v);this.parentState=s}getSimpleRegions(){return[...this.parentState.getSimpleRegions().filter(t=>!this.removedRegions.has(t)),...this.addedRegions]}getSimpleRegionWithVertex(t){for(const s of this.getSimpleRegions())if(s.a===t||s.b===t)return s;return null}getSimpleRegionWithEdge(t){for(const s of this.getSimpleRegions())if(s.edges.includes(t))return s;return null}getSimpleRegionWithId(t){for(const s of this.getSimpleRegions())if(s.id===t)return s;return null}getWeirdEdges(){return[...this.parentState.getWeirdEdges().filter(t=>!this.removedWeirdEdges.has(t)),...this.addedWeirdEdges]}modifyRegions(t,s,a,o){for(const i of s)this.addedRegions.has(i)?this.addedRegions.delete(i):this.removedRegions.add(i);for(const i of t)this.addedRegions.add(i);for(const i of o)this.addedWeirdEdges.has(i)?this.addedWeirdEdges.delete(i):this.removedWeirdEdges.add(i);for(const i of a)this.addedWeirdEdges.add(i);this.simpleRegionsChangedEmitter.emit(t,s,a,o)}clone(){return new fe(this.board,this.parentState,new Set(this.addedRegions),new Set(this.removedRegions),new Set(this.addedWeirdEdges),new Set(this.removedWeirdEdges))}createDelta(){return new fe(this.board,this)}serializeState(t){return Pe(this)}}class Z{constructor(e,t,s){g(this,"simpleRegionsChangedEmitter",new v);g(this,"simpleRegions");g(this,"weirdEdges");this.board=e,this.simpleRegions=new Set(t),this.weirdEdges=new Set(s)}getSimpleRegions(){return[...this.simpleRegions]}getSimpleRegionWithVertex(e){for(const t of this.simpleRegions)if(t.a===e||t.b===e)return t;return null}getSimpleRegionWithEdge(e){for(const t of this.simpleRegions)if(t.edges.includes(e))return t;return null}getSimpleRegionWithId(e){for(const t of this.simpleRegions)if(t.id===e)return t;return null}getWeirdEdges(){return[...this.weirdEdges]}modifyRegions(e,t,s,a){for(const o of t)this.simpleRegions.delete(o);for(const o of e)this.simpleRegions.add(o);for(const o of a)this.weirdEdges.delete(o);for(const o of s)this.weirdEdges.add(o);this.simpleRegionsChangedEmitter.emit(e,t,s,a)}clone(){return new Z(this.board,this.simpleRegions,this.weirdEdges)}createDelta(){return new fe(this.board,this)}serializeState(e){return Pe(this)}static deserializeState(e,t){return new Z(e,t.simpleRegions.map(s=>G.deserializeSimpleRegion(e,s)),t.weirdEdges.map(s=>N(e,s)))}}const Ae=(n,e)=>{const t=n.vertices.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return h()&&c(t),t},Xe=n=>({x:n.logicalCoordinates.x,y:n.logicalCoordinates.y}),gt=n=>n.incomingHalfEdges,ft=n=>{let e=gt(n);return e=[...e.slice(1),e[0]],h()&&c(e[0].edge===n.edges[1]&&e[0].next.edge===n.edges[0]),e};class C{constructor(e,t,s){g(this,"order");g(this,"possibilityCount");g(this,"matrix");this.vertex=e,this.order=e.edges.length,t?this.matrix=t:this.matrix=Oe.range(0,C.getMatrixSize(this.order)).map(()=>!0),s!==void 0?this.possibilityCount=s:this.possibilityCount=this.matrix.filter(a=>a).length,h()&&c(this.matrix.length===C.getMatrixSize(this.order)),h()&&c(this.possibilityCount===this.matrix.filter(a=>a).length)}isAny(){return this.possibilityCount===C.getMatrixSize(this.order)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.matrix[C.getMatrixSize(this.order)-1]}allowsPair(e,t){return this.matrix[this.getPairIndex(e,t)]}getBinaryCombinationsAllowed(e,t){let s=this.allowsEmpty(),a=!1,o=!1,i=!1;for(const l of this.getAllowedPairs()){const r=l[0]===e||l[1]===e,d=l[0]===t||l[1]===t;r&&d?a=!0:r?o=!0:d?i=!0:s=!0}return{allowsNone:s,allowsBoth:a,allowsAOnly:o,allowsBOnly:i}}getAllowedPairs(){const e=[];let t=0;for(let s=0;s<this.order;s++)for(let a=s+1;a<this.order;a++)this.matrix[t++]&&e.push([this.vertex.edges[s],this.vertex.edges[a]]);return e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedPairs())s[0]===e||s[1]===e?t.add(w.BLACK):t.add(w.RED);return this.allowsEmpty()&&t.add(w.RED),t}getPairIndex(e,t){const s=this.vertex.edges.indexOf(e),a=this.vertex.edges.indexOf(t),o=Math.min(s,a),i=Math.max(s,a);return C.getIndex(o,i,this.order)}equals(e){return this.vertex===e.vertex&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return h()&&c(this.vertex===e.vertex),new C(this.vertex,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return h()&&c(this.vertex===e.vertex),new C(this.vertex,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withEmpty(e){return new C(this.vertex,this.matrix.slice(0,-1).concat(e))}withPair(e,t,s){const a=this.getPairIndex(e,t);return new C(this.vertex,this.matrix.slice(0,a).concat(s,this.matrix.slice(a+1)))}serialize(){const e=Qe(this.matrix);return h()&&c(this.equals(C.deserialize(this.vertex,e))),e}static getIndex(e,t,s){return e*(2*s-e-1)/2+(t-e-1)}static getMatrixSize(e){return e*(e-1)/2+1}static fromLookup(e,t,s){const a=e.edges.length,o=[];for(let i=0;i<a;i++)for(let l=i+1;l<a;l++)o.push(t(e.edges[i],e.edges[l]));return o.push(s),new C(e,o)}static none(e){return C.fromLookup(e,()=>!1,!1)}static any(e){return C.fromLookup(e,()=>!0,!0)}static withOnlyEmpty(e){return C.fromLookup(e,()=>!1,!0)}static withOnlyPair(e,t,s){return C.fromLookup(e,(a,o)=>a===t&&o===s||a===s&&o===t,!1)}static withoutEmpty(e){return C.fromLookup(e,()=>!0,!1)}static withoutPair(e,t,s){return C.fromLookup(e,(a,o)=>a!==t&&a!==s||o!==t&&o!==s,!0)}static fromEdgeColorSectorData(e,t){const s=e.edges.length,a=[],o=e.edges.filter(p=>t.getEdgeState(p)===w.BLACK);if(o.length>2)return C.none(e);if(o.length===2)return C.withOnlyPair(e,o[0],o[1]);const i=o.length?o[0]:null,l=new Set(e.edges.filter(p=>t.getEdgeState(p)===w.RED));if(l.size===s)return C.withOnlyEmpty(e);const r=ft(e),d=r.map(p=>t.getSectorState(p)),f=d.every(p=>p.zero),u=r.map(p=>p.face?t.getFaceColor(p.face):t.getOutsideColor()),x=new Set(u),M=new Map([...x].map(p=>[p,t.getOppositeFaceColor(p)])),y=[...M.values()].every(p=>!p||!x.has(p));for(let p=0;p<s;p++){const E=e.edges[p];if(l.has(E)){for(let O=p+1;O<s;O++)a.push(!1);continue}for(let O=p+1;O<s;O++){let R=!0;const se=e.edges[O];if(R&&l.has(se)&&(R=!1),R&&i&&E!==i&&se!==i&&(R=!1),R&&(R=R&&d.every(($,K)=>{const D=r[K];let b=0;return(E===D.edge||E===D.next.edge)&&b++,(se===D.edge||se===D.next.edge)&&b++,$.allows(b)})),R){const $=u.slice(p,O),K=[...u.slice(O),...u.slice(0,p)];$.some(D=>K.includes(D))&&(R=!1),R&&$.some(D=>{const b=M.get(D);return b&&$.includes(b)})&&(R=!1),R&&K.some(D=>{const b=M.get(D);return b&&K.includes(b)})&&(R=!1)}a.push(R)}}return a.push(o.length===0&&f&&y),new C(e,a)}static deserialize(e,t){return new C(e,We(t,C.getMatrixSize(e.edges.length)))}}class pe{constructor(e,t=new Map){this.board=e,this.vertexStateMap=t}apply(e){for(const[t,s]of this.vertexStateMap)e.setVertexState(t,s)}getUndo(e){const t=new Map;for(const s of this.vertexStateMap.keys())t.set(s,e.getVertexState(s));return new pe(this.board,t)}isEmpty(){return this.vertexStateMap.size===0}serializeAction(){return{type:"GeneralVertexAction",vertices:Array.from(this.vertexStateMap.entries()).map(([e,t])=>({vertex:Xe(e),state:t.serialize()}))}}static deserializeAction(e,t){return new pe(e,new Map(t.vertices.map(s=>[Ae(e,s.vertex),C.deserialize(Ae(e,s.vertex),s.state)])))}}const Ue=(n,e)=>({type:"VertexStateData",vertices:n.vertices.filter(t=>!e.getVertexState(t).isAny()).map(t=>({vertex:Xe(t),state:e.getVertexState(t).serialize()}))});class ue extends pe{constructor(t,s,a=new Map){super(t,a);g(this,"vertexStateChangedEmitter",new v);this.parentState=s}getVertexState(t){return this.vertexStateMap.has(t)?this.vertexStateMap.get(t):this.parentState.getVertexState(t)}setVertexState(t,s){const a=this.getVertexState(t);a.equals(s)||(this.vertexStateMap.set(t,s),this.vertexStateChangedEmitter.emit(t,s,a))}clone(){return new ue(this.board,this.parentState,new Map(this.vertexStateMap))}createDelta(){return new ue(this.board,this,new Map)}serializeState(t){return Ue(t,this)}}class Y{constructor(e,t=C.any){g(this,"vertexStateChangedEmitter",new v);g(this,"vertexStateMap",new Map);this.board=e,e.vertices.forEach(s=>{this.vertexStateMap.set(s,t(s))})}getVertexState(e){return h()&&c(this.vertexStateMap.has(e)),this.vertexStateMap.get(e)}setVertexState(e,t){h()&&c(this.vertexStateMap.has(e));const s=this.vertexStateMap.get(e);s.equals(t)||(this.vertexStateMap.set(e,t),this.vertexStateChangedEmitter.emit(e,t,s))}clone(){return new Y(this.board,e=>this.getVertexState(e))}createDelta(){return new ue(this.board,this)}serializeState(e){return Ue(e,this)}static deserializeState(e,t){const s=new Map(t.vertices.map(a=>{const o=Ae(e,a.vertex);return[o,C.deserialize(o,a.state)]}));return new Y(e,a=>s.get(a)??C.any(a))}}class te{apply(e){}getUndo(e){return this}isEmpty(){return!0}serializeAction(){return{type:"NoOpAction"}}static deserializeAction(e,t){return new te}}class qe extends te{constructor(){super(...arguments);g(this,"isUserLoadPuzzleAutoSolveAction",!0)}serializeAction(){return{type:"UserLoadPuzzleAutoSolveAction"}}static deserializeAction(t,s){return new qe}}class He extends te{constructor(){super(...arguments);g(this,"isUserRequestSolveAction",!0)}serializeAction(){return{type:"UserRequestSolveAction"}}static deserializeAction(t,s){return new He}}class me{constructor(e,t=!0){this.edge=e,this.forward=t}apply(e){const t=e.getEdgeState(this.edge);t===w.WHITE?e.setEdgeState(this.edge,this.forward?w.BLACK:w.RED):t===w.BLACK?e.setEdgeState(this.edge,this.forward?w.RED:w.WHITE):e.setEdgeState(this.edge,this.forward?w.WHITE:w.BLACK)}getUndo(e){return new me(this.edge,!this.forward)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateCycleAction",edge:P(this.edge),forward:this.forward}}static deserializeAction(e,t){return new me(N(e,t.edge),t.forward)}}class Se{constructor(e,t){this.edge=e,this.state=t}apply(e){e.setEdgeState(this.edge,this.state)}getUndo(e){const t=e.getEdgeState(this.edge);return new Se(this.edge,t)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateSetAction",edge:P(this.edge),state:this.state.name}}static deserializeAction(e,t){return new Se(N(e,t.edge),w.enumeration.getValue(t.state))}}const Ee=(n,e)=>e.type==="face"?n.getFaceColor(e.face):e.isOutside?n.getOutsideColor():n.getInsideColor(),Ce=(n,e)=>e.type==="face"?{type:"face",face:B(n,e.face)}:{type:"absolute",isOutside:e.isOutside},we=n=>n.type==="face"?{type:"face",face:I(n.face)}:{type:"absolute",isOutside:n.isOutside};class L{constructor(e,t){this.a=e,this.b=t,h()&&c(e),h()&&c(t)}apply(e){const t=Ee(e,this.a),s=Ee(e,this.b);if(t===s)return;const a=e.getOppositeFaceColor(t),o=e.getOppositeFaceColor(s);if(h()){const x=new Set(e.getFaceColors());c(x.has(t)),c(x.has(s)),a&&c(x.has(a)),o&&c(x.has(o))}if(a&&a===s||o&&o===t){e.modifyFaceColors([],[],new Map,new Map,!0);return}const i=[],l=new Map,r=new Map,d=L.combineFaces(t,s,e,i,l),f=a&&o?L.combineFaces(a,o,e,i,l):a||o;d===t&&f===a||d===s&&f===o||(r.set(d,f),f&&r.set(f,d)),e.modifyFaceColors([],i,l,r,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeSameAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeSameAction",a:we(this.a),b:we(this.b)}}static deserializeAction(e,t){return new L(Ce(e,t.a),Ce(e,t.b))}static combineFaces(e,t,s,a,o){let i=null;if(e.colorState!==A.UNDECIDED)i=t;else if(t.colorState!==A.UNDECIDED)i=e;else{const r=s.getFacesWithColor(e),d=s.getFacesWithColor(t);i=r.length>d.length?t:e}const l=i===e?t:e;a.push(i);for(const r of s.getFacesWithColor(i))o.set(r,l);return l}}class Ze{constructor(e,t){this.a=e,this.b=t,h()&&c(e),h()&&c(t)}apply(e){const t=Ee(e,this.a),s=Ee(e,this.b);if(t===s){e.modifyFaceColors([],[],new Map,new Map,!0);return}const a=e.getOppositeFaceColor(t),o=e.getOppositeFaceColor(s);if(h()){const u=new Set(e.getFaceColors());c(u.has(t)),c(u.has(s)),a&&c(u.has(a)),o&&c(u.has(o))}if(a&&a===s||o&&o===t)return;if(a&&a===o){e.modifyFaceColors([],[],new Map,new Map,!0);return}const i=[],l=new Map,r=new Map,d=o?L.combineFaces(t,o,e,i,l):t,f=a?L.combineFaces(s,a,e,i,l):s;r.set(d,f),r.set(f,d),e.modifyFaceColors([],i,l,r,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeOppositeAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorMakeOppositeAction",a:we(this.a),b:we(this.b)}}static deserializeAction(e,t){return new Ze(Ce(e,t.a),Ce(e,t.b))}}class Ye{constructor(e,t){this.face=e,this.isInside=t,h()&&c(e)}apply(e){const t=e.getOutsideColor(),s=e.getInsideColor(),a=this.isInside?s:t,o=this.isInside?t:s,i=e.getFaceColor(this.face),l=e.getOppositeFaceColor(i);if(h()){const r=new Set(e.getFaceColors());c(r.has(i)),l&&c(r.has(l))}if(i!==a)if(i===o)e.modifyFaceColors([],[],new Map([[this.face,a]]),new Map,!1);else{const r=[i,...l?[l]:[]],d=new Map;for(const f of e.getFacesWithColor(i))d.set(f,a);if(l)for(const f of e.getFacesWithColor(l))d.set(f,o);e.modifyFaceColors([],r,d,new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in FaceColorSetAbsoluteAction")}isEmpty(){return!1}serializeAction(){return{type:"FaceColorSetAbsoluteAction",face:I(this.face),isInside:this.isInside}}static deserializeAction(e,t){const s=B(e,t.face),a=t.isInside;return new Ye(s,a)}}class ye{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceValue(this.face,this.state)}getUndo(e){const t=e.getFaceValue(this.face);return new ye(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceValueSetAction",edge:I(this.face),state:this.state}}static deserializeAction(e,t){return new ye(B(e,t.edge),t.state)}}class xe{constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new xe(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:De(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new xe(Re(e,t.sector),F.deserialize(t.state))}}const Ke=new WeakMap;class $e extends st{constructor(t){const s=new Map(t.vertices.map((o,i)=>[o,i])),a=o=>{const i=s.get(o);return h()&&c(i!==void 0),i};super({numNonExitVertices:t.vertices.length,numExitVertices:0,type:"faces",vertexLists:[...t.faces.map(o=>o.vertices.map(a)),t.outerBoundary.map(o=>a(o.start)),...t.innerBoundaries.map(o=>o.map(i=>a(i.start)))]});g(this,"vertexToIndexMap");g(this,"edgeToPatternEdgeMap",new Map);g(this,"patternEdgeToEdgeMap",new Map);g(this,"sectorToPatternSectorMap",new Map);g(this,"patternSectorToSectorMap",new Map);g(this,"outsidePatternFace",null);g(this,"faceToPatternFaceMap",new Map);g(this,"patternFaceToFaceMap",new Map);this.board=t,h()&&c(this.vertices.length===t.vertices.length),h()&&c(this.edges.length===t.edges.length),h()&&c(this.faces.length===t.faces.length+1+t.innerBoundaries.length),this.vertexToIndexMap=s,this.edges.forEach((o,i)=>{h()&&c(o.vertices.length===2);const l=this.getVertex(o.vertices[0]),r=this.getVertex(o.vertices[1]),d=l.getEdgeTo(r);h()&&c(d),this.edgeToPatternEdgeMap.set(d,o),this.patternEdgeToEdgeMap.set(o,d)}),this.sectors.forEach(o=>{h()&&c(o.edges.length===2);const i=this.getEdge(o.edges[0]),l=this.getEdge(o.edges[1]),r=it(i,l);this.sectorToPatternSectorMap.set(r,o),this.patternSectorToSectorMap.set(o,r)}),this.faces.forEach(o=>{h()&&c(o.sectors.length>=3);const l=this.getSector(o.sectors[0]).face;l===null?this.outsidePatternFace=o:this.faceToPatternFaceMap.set(l,o),this.patternFaceToFaceMap.set(o,l)})}getVertex(t){const s=t.index;return h()&&c(s>=0&&s<this.vertices.length),this.board.vertices[s]}getPatternVertex(t){const s=this.vertexToIndexMap.get(t);return h()&&c(s!==void 0),this.vertices[s]}getEdge(t){const s=this.patternEdgeToEdgeMap.get(t);return h()&&c(s!==void 0),s}getPatternEdge(t){const s=this.edgeToPatternEdgeMap.get(t);return h()&&c(s!==void 0),s}getSector(t){const s=this.patternSectorToSectorMap.get(t);return h()&&c(s!==void 0),s}getPatternSector(t){const s=this.sectorToPatternSectorMap.get(t);return h()&&c(s!==void 0),s}getFace(t){const s=this.patternFaceToFaceMap.get(t);return h()&&c(s!==void 0),s}getPatternFace(t){const s=this.faceToPatternFaceMap.get(t);return h()&&c(s!==void 0),s}getOutsidePatternFace(){return h()&&c(this.outsidePatternFace!==null),this.outsidePatternFace}static get(t){let s=Ke.get(t);return s||(s=new $e(t),Ke.set(t,s)),s}}class Fe{constructor(e,t,s){this.action=e,this.annotation=t,this.board=s}apply(e){this.action.apply(e)}getUndo(e){return new Fe(this.action.getUndo(e),this.annotation,this.board)}isEmpty(){return this.action.isEmpty()}serializeAction(){let e=null;if(this.annotation.type==="Pattern"){const t=a=>({faceValues:a.faceValues.map(o=>({face:o.face===null?null:s.faces.indexOf(o.face),value:o.value})),blackEdges:a.blackEdges.map(o=>s.edges.indexOf(o)),redEdges:a.redEdges.map(o=>s.edges.indexOf(o)),sectorsNotZero:a.sectorsNotZero.map(o=>s.halfEdges.indexOf(o)),sectorsNotOne:a.sectorsNotOne.map(o=>s.halfEdges.indexOf(o)),sectorsNotTwo:a.sectorsNotTwo.map(o=>s.halfEdges.indexOf(o)),sectorsOnlyOne:a.sectorsOnlyOne.map(o=>s.halfEdges.indexOf(o)),faceColorDuals:a.faceColorDuals.map(o=>({primaryFaces:o.primaryFaces.map(i=>i===null?null:s.faces.indexOf(i)),secondaryFaces:o.secondaryFaces.map(i=>i===null?null:s.faces.indexOf(i))}))}),s=this.annotation.boardPatternBoard.board;e={type:"Pattern",rule:this.annotation.rule.serialize(),embedding:this.annotation.embedding.serialize(),input:t(this.annotation.input),output:t(this.annotation.output),affectedEdges:[...this.annotation.affectedEdges].map(a=>s.edges.indexOf(a)),affectedSectors:[...this.annotation.affectedSectors].map(a=>s.halfEdges.indexOf(a)),affectedFaces:[...this.annotation.affectedFaces].map(a=>s.faces.indexOf(a))}}else this.annotation.type==="ForcedSolveLoop"?e={type:"ForcedSolveLoop",a:this.board.vertices.indexOf(this.annotation.a),b:this.board.vertices.indexOf(this.annotation.b),regionEdges:[...this.annotation.regionEdges].map(t=>this.board.edges.indexOf(t)),pathEdges:[...this.annotation.pathEdges].map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="PrematureForcedLoop"?e={type:"PrematureForcedLoop",a:this.board.vertices.indexOf(this.annotation.a),b:this.board.vertices.indexOf(this.annotation.b),regionEdges:[...this.annotation.regionEdges].map(t=>this.board.edges.indexOf(t)),pathEdges:[...this.annotation.pathEdges].map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="FaceColorDisconnection"?e={type:"FaceColorDisconnection",disconnection:this.annotation.disconnection.map(t=>this.board.halfEdges.indexOf(t)),facesA:this.annotation.facesA.map(t=>this.board.faces.indexOf(t)),facesB:this.annotation.facesB.map(t=>this.board.faces.indexOf(t))}:this.annotation.type==="ForcedLine"?e={type:"ForcedLine",vertex:this.board.vertices.indexOf(this.annotation.vertex),blackEdge:this.board.edges.indexOf(this.annotation.blackEdge),whiteEdge:this.board.edges.indexOf(this.annotation.whiteEdge),redEdges:this.annotation.redEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="AlmostEmptyToRed"?e={type:"AlmostEmptyToRed",vertex:this.board.vertices.indexOf(this.annotation.vertex),whiteEdge:this.board.edges.indexOf(this.annotation.whiteEdge),redEdges:this.annotation.redEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="JointToRed"?e={type:"JointToRed",vertex:this.board.vertices.indexOf(this.annotation.vertex),whiteEdges:this.annotation.whiteEdges.map(t=>this.board.edges.indexOf(t)),blackEdges:[this.board.edges.indexOf(this.annotation.blackEdges[0]),this.board.edges.indexOf(this.annotation.blackEdges[1])]}:this.annotation.type==="FaceSatisfied"?e={type:"FaceSatisfied",face:this.board.faces.indexOf(this.annotation.face),whiteEdges:this.annotation.whiteEdges.map(t=>this.board.edges.indexOf(t)),blackEdges:this.annotation.blackEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="FaceAntiSatisfied"?e={type:"FaceAntiSatisfied",face:this.board.faces.indexOf(this.annotation.face),whiteEdges:this.annotation.whiteEdges.map(t=>this.board.edges.indexOf(t)),redEdges:this.annotation.redEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="CompletingEdgesAfterSolve"?e={type:"CompletingEdgesAfterSolve",whiteEdges:this.annotation.whiteEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="FaceColoringBlackEdge"?e={type:"FaceColoringBlackEdge",edge:this.board.edges.indexOf(this.annotation.edge)}:this.annotation.type==="FaceColoringRedEdge"?e={type:"FaceColoringRedEdge",edge:this.board.edges.indexOf(this.annotation.edge)}:this.annotation.type==="FaceColorToBlack"?e={type:"FaceColorToBlack",edge:this.board.edges.indexOf(this.annotation.edge)}:this.annotation.type==="FaceColorToRed"?e={type:"FaceColorToRed",edge:this.board.edges.indexOf(this.annotation.edge)}:this.annotation.type==="FaceColorNoTrivialLoop"?e={type:"FaceColorNoTrivialLoop",face:this.board.faces.indexOf(this.annotation.face)}:this.annotation.type==="FaceColorMatchToRed"||this.annotation.type==="FaceColorMatchToBlack"||this.annotation.type==="FaceColorBalance"?(e={type:this.annotation.type,face:this.board.faces.indexOf(this.annotation.face),remainingValue:this.annotation.remainingValue,availableSideCount:this.annotation.availableSideCount,balancedPairs:this.annotation.balancedPairs.map(t=>[t[0].map(s=>this.board.edges.indexOf(s)),t[1].map(s=>this.board.edges.indexOf(s))]),matchingEdges:this.annotation.matchingEdges.map(t=>this.board.edges.indexOf(t))},this.annotation.type==="FaceColorBalance"&&(e.oppositeEdges=this.annotation.oppositeEdges.map(t=>this.board.edges.indexOf(t)))):this.annotation.type==="DoubleMinusOneFaces"?e={type:"DoubleMinusOneFaces",faces:this.annotation.faces.map(t=>this.board.faces.indexOf(t)),toBlackEdges:this.annotation.toBlackEdges.map(t=>this.board.edges.indexOf(t)),toRedEdges:this.annotation.toRedEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="SingleEdgeToSector"?e={type:"SingleEdgeToSector",sector:this.board.halfEdges.indexOf(this.annotation.sector),beforeState:this.annotation.beforeState.serialize(),afterState:this.annotation.afterState.serialize()}:this.annotation.type==="DoubleEdgeToSector"?e={type:"DoubleEdgeToSector",sector:this.board.halfEdges.indexOf(this.annotation.sector),beforeState:this.annotation.beforeState.serialize(),afterState:this.annotation.afterState.serialize()}:this.annotation.type==="ForcedSector"?e={type:"ForcedSector",sector:this.board.halfEdges.indexOf(this.annotation.sector),sectorState:this.annotation.sectorState.serialize(),toRedEdges:this.annotation.toRedEdges.map(t=>this.board.edges.indexOf(t)),toBlackEdges:this.annotation.toBlackEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="StaticFaceSectors"?e={type:"StaticFaceSectors",face:this.board.faces.indexOf(this.annotation.face),sectors:this.annotation.sectors.map(t=>this.board.halfEdges.indexOf(t))}:this.annotation.type==="VertexState"?e={type:"VertexState",vertex:this.board.vertices.indexOf(this.annotation.vertex),beforeState:this.annotation.beforeState.serialize(),afterState:this.annotation.afterState.serialize()}:this.annotation.type==="VertexStateToEdge"?e={type:"VertexStateToEdge",vertex:this.board.vertices.indexOf(this.annotation.vertex),toRedEdges:this.annotation.toRedEdges.map(t=>this.board.edges.indexOf(t)),toBlackEdges:this.annotation.toBlackEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="VertexStateToSector"?e={type:"VertexStateToSector",vertex:this.board.vertices.indexOf(this.annotation.vertex),sectors:this.annotation.sectors.map(t=>this.board.halfEdges.indexOf(t)),beforeStates:this.annotation.beforeStates.map(t=>t.serialize()),afterStates:this.annotation.afterStates.map(t=>t.serialize())}:this.annotation.type==="VertexStateToSameFaceColor"?e={type:"VertexStateToSameFaceColor",vertex:this.board.vertices.indexOf(this.annotation.vertex),facesA:this.annotation.facesA.map(t=>this.board.faces.indexOf(t)),facesB:this.annotation.facesB.map(t=>this.board.faces.indexOf(t))}:this.annotation.type==="VertexStateToOppositeFaceColor"?e={type:"VertexStateToOppositeFaceColor",vertex:this.board.vertices.indexOf(this.annotation.vertex),facesA:this.annotation.facesA.map(t=>this.board.faces.indexOf(t)),facesB:this.annotation.facesB.map(t=>this.board.faces.indexOf(t))}:this.annotation.type==="FaceState"?e={type:"FaceState",face:this.board.faces.indexOf(this.annotation.face),beforeState:this.annotation.beforeState.serialize(),afterState:this.annotation.afterState.serialize()}:this.annotation.type==="FaceStateToEdge"?e={type:"FaceStateToEdge",face:this.board.faces.indexOf(this.annotation.face),toRedEdges:this.annotation.toRedEdges.map(t=>this.board.edges.indexOf(t)),toBlackEdges:this.annotation.toBlackEdges.map(t=>this.board.edges.indexOf(t))}:this.annotation.type==="FaceStateToSector"?e={type:"FaceStateToSector",face:this.board.faces.indexOf(this.annotation.face),sectors:this.annotation.sectors.map(t=>this.board.halfEdges.indexOf(t)),beforeStates:this.annotation.beforeStates.map(t=>t.serialize()),afterStates:this.annotation.afterStates.map(t=>t.serialize())}:this.annotation.type==="FaceStateToSameFaceColor"?e={type:"FaceStateToSameFaceColor",face:this.board.faces.indexOf(this.annotation.face),facesA:this.annotation.facesA.map(t=>this.board.faces.indexOf(t)),facesB:this.annotation.facesB.map(t=>this.board.faces.indexOf(t))}:this.annotation.type==="FaceStateToOppositeFaceColor"?e={type:"FaceStateToOppositeFaceColor",face:this.board.faces.indexOf(this.annotation.face),facesA:this.annotation.facesA.map(t=>this.board.faces.indexOf(t)),facesB:this.annotation.facesB.map(t=>this.board.faces.indexOf(t))}:this.annotation.type==="FaceStateToVertexState"&&(e={type:"FaceStateToVertexState",face:this.board.faces.indexOf(this.annotation.face),vertices:this.annotation.vertices.map(t=>this.board.vertices.indexOf(t)),beforeStates:this.annotation.beforeStates.map(t=>t.serialize()),afterStates:this.annotation.afterStates.map(t=>t.serialize())});if(e!==null)return{type:"AnnotatedAction",action:this.action.serializeAction(),annotation:e};throw new Error("unimplemented")}static deserializeAction(e,t){h()&&c(t.type==="AnnotatedAction");const s=t.annotation.type,a=k(e,t.action);let o=null;if(s==="Pattern"){const i=p=>({faceValues:p.faceValues.map(E=>({face:E.face===null?null:e.faces[E.face],value:E.value})),blackEdges:p.blackEdges.map(E=>e.edges[E]),redEdges:p.redEdges.map(E=>e.edges[E]),sectorsNotZero:p.sectorsNotZero.map(E=>e.halfEdges[E]),sectorsNotOne:p.sectorsNotOne.map(E=>e.halfEdges[E]),sectorsNotTwo:p.sectorsNotTwo.map(E=>e.halfEdges[E]),sectorsOnlyOne:p.sectorsOnlyOne.map(E=>e.halfEdges[E]),faceColorDuals:p.faceColorDuals.map(E=>({primaryFaces:E.primaryFaces.map(O=>O===null?null:e.faces[O]),secondaryFaces:E.secondaryFaces.map(O=>O===null?null:e.faces[O])}))}),l=ot.deserialize(t.annotation.rule),r=$e.get(e),d=at.deserialize(l.patternBoard,r,t.annotation.embedding),f=i(t.annotation.input),u=i(t.annotation.output),x=new Set(t.annotation.affectedEdges.map(p=>e.edges[p])),M=new Set(t.annotation.affectedSectors.map(p=>e.halfEdges[p])),y=new Set(t.annotation.affectedFaces.map(p=>e.faces[p]));o={type:"Pattern",rule:l,boardPatternBoard:r,embedding:d,input:f,output:u,affectedEdges:x,affectedSectors:M,affectedFaces:y}}else if(s==="ForcedSolveLoop")o={type:"ForcedSolveLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(i=>e.edges[i]),pathEdges:t.annotation.pathEdges.map(i=>e.edges[i])};else if(s==="PrematureForcedLoop")o={type:"PrematureForcedLoop",a:e.vertices[t.annotation.a],b:e.vertices[t.annotation.b],regionEdges:t.annotation.regionEdges.map(i=>e.edges[i]),pathEdges:t.annotation.pathEdges.map(i=>e.edges[i])};else if(s==="FaceColorDisconnection")o={type:"FaceColorDisconnection",disconnection:t.annotation.disconnection.map(i=>e.halfEdges[i]),facesA:t.annotation.facesA.map(i=>e.faces[i]),facesB:t.annotation.facesB.map(i=>e.faces[i])};else if(s==="ForcedLine")o={type:"ForcedLine",vertex:e.vertices[t.annotation.vertex],blackEdge:e.edges[t.annotation.blackEdge],whiteEdge:e.edges[t.annotation.whiteEdge],redEdges:t.annotation.redEdges.map(i=>e.edges[i])};else if(s==="AlmostEmptyToRed")o={type:"AlmostEmptyToRed",vertex:e.vertices[t.annotation.vertex],whiteEdge:e.edges[t.annotation.whiteEdge],redEdges:t.annotation.redEdges.map(i=>e.edges[i])};else if(s==="JointToRed")o={type:"JointToRed",vertex:e.vertices[t.annotation.vertex],whiteEdges:t.annotation.whiteEdges.map(i=>e.edges[i]),blackEdges:[e.edges[t.annotation.blackEdges[0]],e.edges[t.annotation.blackEdges[1]]]};else if(s==="FaceSatisfied")o={type:"FaceSatisfied",face:e.faces[t.annotation.face],whiteEdges:t.annotation.whiteEdges.map(i=>e.edges[i]),blackEdges:t.annotation.blackEdges.map(i=>e.edges[i])};else if(s==="FaceAntiSatisfied")o={type:"FaceAntiSatisfied",face:e.faces[t.annotation.face],whiteEdges:t.annotation.whiteEdges.map(i=>e.edges[i]),redEdges:t.annotation.redEdges.map(i=>e.edges[i])};else if(s==="CompletingEdgesAfterSolve")o={type:"CompletingEdgesAfterSolve",whiteEdges:t.annotation.whiteEdges.map(i=>e.edges[i])};else if(s==="FaceColoringBlackEdge")o={type:"FaceColoringBlackEdge",edge:e.edges[t.annotation.edge]};else if(s==="FaceColoringRedEdge")o={type:"FaceColoringRedEdge",edge:e.edges[t.annotation.edge]};else if(s==="FaceColorToBlack")o={type:"FaceColorToBlack",edge:e.edges[t.annotation.edge]};else if(s==="FaceColorToRed")o={type:"FaceColorToRed",edge:e.edges[t.annotation.edge]};else if(s==="FaceColorNoTrivialLoop")o={type:"FaceColorNoTrivialLoop",face:e.faces[t.annotation.face]};else if(s==="FaceColorMatchToRed"||s==="FaceColorMatchToBlack"||s==="FaceColorBalance")o={type:s,face:e.faces[t.annotation.face],remainingValue:t.annotation.remainingValue,availableSideCount:t.annotation.availableSideCount,balancedPairs:t.annotation.balancedPairs.map(i=>[i[0].map(l=>e.edges[l]),i[1].map(l=>e.edges[l])]),matchingEdges:t.annotation.matchingEdges.map(i=>e.edges[i])},s==="FaceColorBalance"&&(o.oppositeEdges=t.annotation.oppositeEdges.map(i=>e.edges[i]));else if(s==="DoubleMinusOneFaces")o={type:"DoubleMinusOneFaces",faces:t.annotation.faces.map(i=>e.faces[i]),toBlackEdges:t.annotation.toBlackEdges.map(i=>e.edges[i]),toRedEdges:t.annotation.toRedEdges.map(i=>e.edges[i])};else if(s==="SingleEdgeToSector")o={type:"SingleEdgeToSector",sector:e.halfEdges[t.annotation.sector],beforeState:F.deserialize(t.annotation.beforeState),afterState:F.deserialize(t.annotation.afterState)};else if(s==="DoubleEdgeToSector")o={type:"DoubleEdgeToSector",sector:e.halfEdges[t.annotation.sector],beforeState:F.deserialize(t.annotation.beforeState),afterState:F.deserialize(t.annotation.afterState)};else if(s==="ForcedSector")o={type:"ForcedSector",sector:e.halfEdges[t.annotation.sector],sectorState:F.deserialize(t.annotation.sectorState),toRedEdges:t.annotation.toRedEdges.map(i=>e.edges[i]),toBlackEdges:t.annotation.toBlackEdges.map(i=>e.edges[i])};else if(s==="StaticFaceSectors")o={type:"StaticFaceSectors",face:e.faces[t.annotation.face],sectors:t.annotation.sectors.map(i=>e.halfEdges[i])};else if(s==="VertexState")o={type:"VertexState",vertex:e.vertices[t.annotation.vertex],beforeState:t.annotation.beforeState,afterState:t.annotation.afterState};else if(s==="VertexStateToEdge")o={type:"VertexStateToEdge",vertex:e.vertices[t.annotation.vertex],toRedEdges:t.annotation.toRedEdges.map(i=>e.edges[i]),toBlackEdges:t.annotation.toBlackEdges.map(i=>e.edges[i])};else if(s==="VertexStateToSector")o={type:"VertexStateToSector",vertex:e.vertices[t.annotation.vertex],sectors:t.annotation.sectors.map(i=>e.halfEdges[i]),beforeStates:t.annotation.beforeStates.map(i=>F.deserialize(i)),afterStates:t.annotation.afterStates.map(i=>F.deserialize(i))};else if(s==="VertexStateToSameFaceColor")o={type:"VertexStateToSameFaceColor",vertex:e.vertices[t.annotation.vertex],facesA:t.annotation.facesA.map(i=>e.faces[i]),facesB:t.annotation.facesB.map(i=>e.faces[i])};else if(s==="VertexStateToOppositeFaceColor")o={type:"VertexStateToOppositeFaceColor",vertex:e.vertices[t.annotation.vertex],facesA:t.annotation.facesA.map(i=>e.faces[i]),facesB:t.annotation.facesB.map(i=>e.faces[i])};else if(s==="FaceState"){const i=e.faces[t.annotation.face];o={type:"FaceState",face:i,beforeState:S.deserialize(i,t.annotation.beforeState),afterState:S.deserialize(i,t.annotation.afterState)}}else s==="FaceStateToEdge"?o={type:"FaceStateToEdge",face:e.faces[t.annotation.face],toRedEdges:t.annotation.toRedEdges.map(i=>e.edges[i]),toBlackEdges:t.annotation.toBlackEdges.map(i=>e.edges[i])}:s==="FaceStateToSector"?o={type:"FaceStateToSector",face:e.faces[t.annotation.face],sectors:t.annotation.sectors.map(i=>e.halfEdges[i]),beforeStates:t.annotation.beforeStates.map(i=>F.deserialize(i)),afterStates:t.annotation.afterStates.map(i=>F.deserialize(i))}:s==="FaceStateToSameFaceColor"?o={type:"FaceStateToSameFaceColor",face:e.faces[t.annotation.face],facesA:t.annotation.facesA.map(i=>e.faces[i]),facesB:t.annotation.facesB.map(i=>e.faces[i])}:s==="FaceStateToOppositeFaceColor"?o={type:"FaceStateToOppositeFaceColor",face:e.faces[t.annotation.face],facesA:t.annotation.facesA.map(i=>e.faces[i]),facesB:t.annotation.facesB.map(i=>e.faces[i])}:s==="FaceStateToVertexState"&&(o={type:"FaceStateToVertexState",face:e.faces[t.annotation.face],vertices:t.annotation.vertices.map(i=>e.vertices[i]),beforeStates:t.annotation.beforeStates.map(i=>F.deserialize(i)),afterStates:t.annotation.afterStates.map(i=>F.deserialize(i))});if(o!==null)return new Fe(a,o,e);throw new Error("unimplemented deserializeAction on AnnotatedAction")}}class Me{constructor(e){this.actions=e}apply(e){for(let t=0;t<this.actions.length;t++)this.actions[t].apply(e)}getUndo(e){return new Me(this.actions.map(t=>t.getUndo(e)).reverse())}isEmpty(){return this.actions.some(e=>!e.isEmpty())}serializeAction(){return{type:"CompositeAction",actions:this.actions.map(e=>e.serializeAction())}}static deserializeAction(e,t){return new Me(t.actions.map(s=>k(e,s)))}}const k=(n,e)=>{const t=e.type;if(t==="CompositeAction")return Me.deserializeAction(n,e);if(t==="AnnotatedAction")return Fe.deserializeAction(n,e);if(t==="CompleteAction")return ee.deserializeAction(n,e);if(t==="EdgeStateCycleAction")return me.deserializeAction(n,e);if(t==="EdgeStateSetAction")return Se.deserializeAction(n,e);if(t==="GeneralEdgeAction")return j.deserializeAction(n,e);if(t==="FaceValueSetAction")return ye.deserializeAction(n,e);if(t==="GeneralFaceAction")return Q.deserializeAction(n,e);if(t==="GeneralSimpleRegionAction")return _.deserializeAction(n,e);if(t==="NoOpAction")return te.deserializeAction(n,e);if(t==="UserLoadPuzzleAutoSolveAction")return qe.deserializeAction(n,e);if(t==="UserRequestSolveAction")return He.deserializeAction(n,e);if(t==="FaceColorMakeOppositeAction")return Ze.deserializeAction(n,e);if(t==="FaceColorMakeSameAction")return L.deserializeAction(n,e);if(t==="FaceColorSetAbsoluteAction")return Ye.deserializeAction(n,e);if(t==="SectorStateSetAction")return xe.deserializeAction(n,e);throw new Error(`Unknown action type: ${t}, could not deserialize`)};class ee{constructor(e,t,s,a,o,i,l){this.faceValueAction=e,this.edgeStateAction=t,this.simpleRegionAction=s,this.faceColorAction=a,this.sectorStateAction=o,this.vertexStateAction=i,this.faceStateAction=l}apply(e){this.faceValueAction.apply(e),this.edgeStateAction.apply(e),this.simpleRegionAction.apply(e),this.faceColorAction.apply(e),this.sectorStateAction.apply(e),this.vertexStateAction.apply(e),this.faceStateAction.apply(e)}getUndo(e){return new ee(this.faceValueAction.getUndo(e),this.edgeStateAction.getUndo(e),this.simpleRegionAction.getUndo(e),this.faceColorAction.getUndo(e),this.sectorStateAction.getUndo(e),this.vertexStateAction.getUndo(e),this.faceStateAction.getUndo(e))}isEmpty(){return this.faceValueAction.isEmpty()&&this.edgeStateAction.isEmpty()&&this.simpleRegionAction.isEmpty()&&this.faceColorAction.isEmpty()&&this.sectorStateAction.isEmpty()&&this.vertexStateAction.isEmpty()&&this.faceStateAction.isEmpty()}serializeAction(){return{type:"CompleteAction",faceValueAction:this.faceValueAction.serializeAction(),edgeStateAction:this.edgeStateAction.serializeAction(),simpleRegionAction:this.simpleRegionAction.serializeAction(),faceColorAction:this.faceColorAction.serializeAction(),sectorStateAction:this.sectorStateAction.serializeAction(),vertexStateAction:this.vertexStateAction.serializeAction(),faceStateAction:this.faceStateAction.serializeAction()}}static deserializeAction(e,t){return new ee(k(e,t.faceStateAction),k(e,t.edgeStateAction),k(e,t.simpleRegionAction),k(e,t.faceColorAction),k(e,t.sectorStateAction),k(e,t.vertexStateAction),k(e,t.faceStateAction))}}const Ge=(n,e)=>({type:"CompleteData",faceValueData:Le(n,e),edgeStateData:Be(n,e),simpleRegionData:Pe(e),faceColorData:Ie(e),sectorStateData:Ne(n,e),vertexStateData:Ue(n,e),faceStateData:ze(n,e)});class ve extends ee{constructor(t,s,a,o,i,l,r){super(t,s,a,o,i,l,r);g(this,"anyStateChangedEmitter",new v);this.faceValueDelta=t,this.edgeStateDelta=s,this.simpleRegionDelta=a,this.faceColorDelta=o,this.sectorStateDelta=i,this.vertexStateDelta=l,this.faceStateDelta=r;const d=()=>this.anyStateChangedEmitter.emit();t.faceValueChangedEmitter.addListener(d),s.edgeStateChangedEmitter.addListener(d),a.simpleRegionsChangedEmitter.addListener(d),o.faceColorsChangedEmitter.addListener(d),i.sectorStateChangedEmitter.addListener(d),l.vertexStateChangedEmitter.addListener(d),r.faceStateChangedEmitter.addListener(d)}getFaceValue(t){return this.faceValueDelta.getFaceValue(t)}setFaceValue(t,s){this.faceValueDelta.setFaceValue(t,s)}get faceValueChangedEmitter(){return this.faceValueDelta.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateDelta.getEdgeState(t)}setEdgeState(t,s){this.edgeStateDelta.setEdgeState(t,s)}get edgeStateChangedEmitter(){return this.edgeStateDelta.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDelta.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDelta.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDelta.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDelta.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDelta.getWeirdEdges()}modifyRegions(t,s,a,o){this.simpleRegionDelta.modifyRegions(t,s,a,o)}get simpleRegionsChangedEmitter(){return this.simpleRegionDelta.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorDelta.getFaceColors()}getInsideColor(){return this.faceColorDelta.getInsideColor()}getOutsideColor(){return this.faceColorDelta.getOutsideColor()}getFaceColor(t){return this.faceColorDelta.getFaceColor(t)}getFacesWithColor(t){return this.faceColorDelta.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorDelta.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorDelta.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorDelta.hasInvalidFaceColors()}modifyFaceColors(t,s,a,o,i){this.faceColorDelta.modifyFaceColors(t,s,a,o,i)}get faceColorsChangedEmitter(){return this.faceColorDelta.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateDelta.getSectorState(t)}setSectorState(t,s){this.sectorStateDelta.setSectorState(t,s)}get sectorStateChangedEmitter(){return this.sectorStateDelta.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateDelta.getVertexState(t)}setVertexState(t,s){this.vertexStateDelta.setVertexState(t,s)}get vertexStateChangedEmitter(){return this.vertexStateDelta.vertexStateChangedEmitter}getFaceState(t){return this.faceStateDelta.getFaceState(t)}setFaceState(t,s){this.faceStateDelta.setFaceState(t,s)}get faceStateChangedEmitter(){return this.faceStateDelta.faceStateChangedEmitter}clone(){return new ve(this.faceValueDelta.clone(),this.edgeStateDelta.clone(),this.simpleRegionDelta.clone(),this.faceColorDelta.clone(),this.sectorStateDelta.clone(),this.vertexStateDelta.clone(),this.faceStateDelta.clone())}createDelta(){return new ve(this.faceValueDelta.createDelta(),this.edgeStateDelta.createDelta(),this.simpleRegionDelta.createDelta(),this.faceColorDelta.createDelta(),this.sectorStateDelta.createDelta(),this.vertexStateDelta.createDelta(),this.faceStateDelta.createDelta())}serializeState(t){return Ge(t,this)}}class z{constructor(e,t,s,a,o,i,l){g(this,"anyStateChangedEmitter",new v);this.faceValueData=e,this.edgeStateData=t,this.simpleRegionData=s,this.faceColorData=a,this.sectorStateData=o,this.vertexStateData=i,this.faceStateData=l;const r=()=>this.anyStateChangedEmitter.emit();e.faceValueChangedEmitter.addListener(r),t.edgeStateChangedEmitter.addListener(r),s.simpleRegionsChangedEmitter.addListener(r),a.faceColorsChangedEmitter.addListener(r),o.sectorStateChangedEmitter.addListener(r),i.vertexStateChangedEmitter.addListener(r),l.faceStateChangedEmitter.addListener(r)}static fromFacesEdges(e,t,s){const a=new X(e,t);return new z(a,new J(e,s),new Z(e),new U(e),new H(e),new Y(e),new q(e,o=>S.any(o,a.getFaceValue(o))))}static fromFaces(e,t){return z.fromFacesEdges(e,t,()=>w.WHITE)}static fromFaceValueData(e,t){return z.fromFaces(e,s=>t.getFaceValue(s))}static empty(e){return z.fromFaces(e,()=>null)}static faceMapLookup(e){const t=new Map(Array.from(e.entries()).map(([s,a])=>[`${s.x},${s.y}`,a]));return s=>{const a=t.get(`${s.logicalCoordinates.x},${s.logicalCoordinates.y}`);return a!==void 0?a:null}}getFaceValue(e){return this.faceValueData.getFaceValue(e)}setFaceValue(e,t){this.faceValueData.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueData.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateData.getEdgeState(e)}setEdgeState(e,t){this.edgeStateData.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateData.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionData.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionData.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionData.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionData.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionData.getWeirdEdges()}modifyRegions(e,t,s,a){this.simpleRegionData.modifyRegions(e,t,s,a)}get simpleRegionsChangedEmitter(){return this.simpleRegionData.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorData.getFaceColors()}getInsideColor(){return this.faceColorData.getInsideColor()}getOutsideColor(){return this.faceColorData.getOutsideColor()}getFaceColor(e){return this.faceColorData.getFaceColor(e)}getFacesWithColor(e){return this.faceColorData.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorData.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorData.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorData.hasInvalidFaceColors()}modifyFaceColors(e,t,s,a,o){this.faceColorData.modifyFaceColors(e,t,s,a,o)}get faceColorsChangedEmitter(){return this.faceColorData.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateData.getSectorState(e)}setSectorState(e,t){this.sectorStateData.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateData.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateData.getVertexState(e)}setVertexState(e,t){this.vertexStateData.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateData.vertexStateChangedEmitter}getFaceState(e){return this.faceStateData.getFaceState(e)}setFaceState(e,t){this.faceStateData.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateData.faceStateChangedEmitter}clone(){return new z(this.faceValueData.clone(),this.edgeStateData.clone(),this.simpleRegionData.clone(),this.faceColorData.clone(),this.sectorStateData.clone(),this.vertexStateData.clone(),this.faceStateData.clone())}createDelta(){return new ve(this.faceValueData.createDelta(),this.edgeStateData.createDelta(),this.simpleRegionData.createDelta(),this.faceColorData.createDelta(),this.sectorStateData.createDelta(),this.vertexStateData.createDelta(),this.faceStateData.createDelta())}serializeState(e){return Ge(e,this)}static deserializeState(e,t){const s=X.deserializeState(e,t.faceValueData);return new z(s,J.deserializeState(e,t.edgeStateData),t.simpleRegionData?Z.deserializeState(e,t.simpleRegionData):new Z(e),t.faceColorData?U.deserializeState(e,t.faceColorData):new U(e),t.sectorStateData?H.deserializeState(e,t.sectorStateData):new H(e),t.vertexStateData?Y.deserializeState(e,t.vertexStateData):new Y(e),t.faceStateData?q.deserializeState(e,t.faceStateData):new q(e,a=>S.any(a,s.getFaceValue(a))))}}export{Fe as A,$e as B,z as C,nt as D,w as E,A as F,X as G,G as H,_ as I,F as S,qe as U,C as V,J as a,Z as b,S as c,P as d,N as e,ae as f,Ve as g,I as h,B as i,De as j,Re as k,L as l,Ze as m,Se as n,Me as o,Ye as p,xe as q,He as r,Ct as s,k as t,it as u,ct as v,ft as w,gt as x,Xe as y,Ae as z};
