var no=Object.defineProperty;var lo=(h,e,t)=>e in h?no(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var f=(h,e,t)=>lo(h,typeof e!="symbol"?e+"":e,t);import{K as ht,u as co,c as he,V as ut,L as R,W as ho,X as uo,Y as po,Z as go,f as fo,g as So,h as yt,J as wo,s as Ct,i as yo,j as Co,v as Et,k as Eo,m as Pt,w as Po,n as ue,o as mo,q as vo,x as Fo,y as Vo,I as pe,G as To,E as Do,A as Oo,C as bo,M as Ao,_ as Io,T as No,r as ko}from"./chunk-23.js";import{E as ye,f as Ce,b as Lo,V as Z,k as Ke,o as Ue,a as ge,T as d,P as Me,l as xo,c as Ut,C as Ro,B as ot}from"./chunk-16.js";import{a as Y,N as W,F as Le,t as mt,P as _,d as we,u as vt,T as zt,G as Mo,C as Yt,h as z,B as Ie,r as Bo,R as Wo,H as Gt,L as Ho}from"./chunk-17.js";import{S as U,d as k,e as L,_ as fe,J as jt,K as Uo,i as Ft,L as Vt,M as zo,l as Yo,q as Go,m as jo,j as Ko}from"./chunk-18.js";import{E as V,F as b,S as B,V as pt,c as Kt,d as it,e as nt,f as lt,g as ct,h as Xe,i as _e,j as Xo,k as _o,l as qe,m as gt,U as rt,n as Tt,o as qo,p as Dt,q as Jo,s as Zo,r as Ot,t as $o,C as Qo}from"./chunk-28.js";import{I as te,C as Ve,a as Xt,V as _t,i as Je,S as er,b as tr,c as or,d as rr,e as sr,h as re,w as bt,s as ar}from"./chunk-30.js";import{S as qt,b as Jt,c as ir,d as Zt,e as nr,f as $t,V as lr,g as cr,h as et,F as dr,i as hr,j as ur,k as pr,l as gr,m as fr,s as Sr,a as wr}from"./chunk-31.js";import{a as yr,P as Qt}from"./chunk-19.js";import{A as Cr}from"./chunk-32.js";import{B as At}from"./chunk-29.js";import{a as Er,B as Pr,R as mr,b as vr,c as Fr,d as Vr,S as Tr,e as Dr}from"./chunk-20.js";const ve=class ve extends ye{};f(ve,"PAN_ONLY",new ve),f(ve,"DRAG_ONLY",new ve),f(ve,"enumeration",new Ce(ve));let Be=ve;const eo=new ht("panDragModeProperty",Be.PAN_ONLY),to=new Y([eo],h=>h===Be.DRAG_ONLY);class ft extends W{constructor(t,o,r,s){super();f(this,"triggerDrag");const a=new Set;if(s!=null&&s.delayInteractionEmitter){const p=s==null?void 0:s.delayInteractionEmitter,g=S=>{a.add(S),setTimeout(()=>{a.delete(S)},700)};p.addListener(g),this.disposeEmitter.addListener(()=>p.removeListener(g))}const n=new U,i=t.map(p=>{const g=o(p);return g.makeImmutable(),n.subpaths.push(...g.subpaths),g});this.mouseArea=this.touchArea=n.makeImmutable();const l=p=>{const g=p.trail.globalToLocalPoint(p.pointer.point);for(let S=0;S<i.length;S++){const y=i[S];if(y.bounds.containsPoint(g)&&y.containsPoint(g)){const E=t[S];if(!a.has(E))return E}}return!1},c=(p,g)=>{const S=l(p);S!==!1&&r(S,g)};this.cursor="pointer";const u=new Le({mouseButton:0,fire:p=>{var g;return c(p,(g=p.domEvent)!=null&&g.shiftKey?2:0)}}),C=new Le({mouseButton:2,fire:p=>{var g;return c(p,(g=p.domEvent)!=null&&g.shiftKey?0:2)}}),w=new Le({mouseButton:1,fire:p=>c(p,1)});if(this.disposeEmitter.addListener(()=>{u.dispose(),C.dispose(),w.dispose()}),s!=null&&s.isDragModeProperty){const p=s.isDragModeProperty,g=(F,T)=>{var A,D;const O=l(F);O!==!1?(A=s.onDragStart)==null||A.call(s,O,T):s.noItemItem!==void 0&&((D=s.onDragStart)==null||D.call(s,s.noItemItem,T))},S=F=>{var A,D;const T=F.trail.globalToLocalPoint(F.pointer.point),O=l(F);O!==!1?(A=s.onDrag)==null||A.call(s,O,T):s.noItemItem!==void 0&&((D=s.onDrag)==null||D.call(s,s.noItemItem,T))},y=()=>{var F;(F=s.onDragEnd)==null||F.call(s)},E=F=>F?l(F)!==!1||s.noItemItem!==void 0:!1,P=new mt({mouseButton:0,start:F=>{var T;return g(F,(T=F.domEvent)!=null&&T.shiftKey?2:0)},drag:S,end:y,canStartPress:E}),v=new mt({mouseButton:2,start:F=>{var T;return g(F,(T=F.domEvent)!=null&&T.shiftKey?0:2)},drag:S,end:y,canStartPress:E});this.triggerDrag=F=>{F.domEvent.button===2?v.press(F,this):P.press(F,this)},this.disposeEmitter.addListener(()=>{P.dispose(),v.dispose()});const x=F=>{this.inputListeners=F?[P,v]:[u,C,w]};p.link(x),this.disposeEmitter.addListener(()=>p.unlink(x))}else this.addInputListener(u),this.addInputListener(C),this.addInputListener(w)}}class Or extends ft{constructor(e,t,o){super(e.edges,r=>{const s=r.start.viewCoordinates,a=r.end.viewCoordinates,n=new U;let i;if(r.faces.length===2)i=[s,r.faces[0].viewCoordinates,a,r.faces[1].viewCoordinates];else{k()&&L(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const l=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;k()&&L(l.previous.face===null),k()&&L(l.next.face===null);const c=l.start.viewCoordinates,u=l.end.viewCoordinates,C=l.previous.start.viewCoordinates,w=l.next.end.viewCoordinates,p=(y,E,P)=>{const v=E.minus(y).normalized(),x=P.minus(E).normalized();let F=v.minus(x);return F.getMagnitude()<1e-6?F=v.getPerpendicular():F=F.normalized(),Lo.triangleAreaSigned(y,E,E.plus(F))<0&&(F=F.negated()),F},g=p(C,c,u),S=p(c,u,w);i=[c,r.faces[0].viewCoordinates,u,u.plus(S.times(o.backgroundOffsetDistance)),c.plus(g.times(o.backgroundOffsetDistance))]}return n.polygon(i),n.makeImmutable(),n},o.edgePressListener,{delayInteractionEmitter:t,isDragModeProperty:to,onDragStart:o.onEdgeDragStart,onDrag:o.onEdgeDrag,onDragEnd:o.onEdgeDragEnd})}}class br extends W{constructor(e,t,o,r){const s=new _(null,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty}),a=new _(null,{stroke:r.theme.xColorProperty,lineWidth:.025}),n=new _(null,{lineWidth:.02,fill:r.theme.redLineColorProperty});super({children:[s,a,n],pickable:!1});const i=e.edges.map(g=>V.BLACK);let l=!1,c=!1,u=!1,C=!1,w=null;const p=we.multilink([t,o,r.whiteLineVisibleProperty,r.redXsVisibleProperty,r.redXsAlignedProperty,r.redLineVisibleProperty,r.redLineStyleProperty],(g,S,y,E,P,v,x)=>{if(this.visible=!S,s.visible=y,a.visible=E,n.visible=v,this.visible){let F=!1;for(let T=0;T<e.edges.length;T++){const O=g.getEdgeState(e.edges[T]);O!==i[T]&&(F=!0,i[T]=O)}if(l!==P&&(F=!0,l=P),c!==y&&(F=!0,c=y),u!==E&&(F=!0,u=E),C!==v&&(F=!0,C=v),w!==x&&(F=!0,w=x),F){const T=new U,O=new U,A=new U;for(let D=0;D<e.edges.length;D++){const M=i[D];if(y&&M===V.WHITE){const m=e.edges[D];T.moveTo(m.start.viewCoordinates.x,m.start.viewCoordinates.y),T.lineTo(m.end.viewCoordinates.x,m.end.viewCoordinates.y)}if(M===V.RED){if(E){const m=e.edges[D],I=.07;let N=m.start.viewCoordinates.blend(m.end.viewCoordinates,.5);if(P){const j=m.end.viewCoordinates.minus(m.start.viewCoordinates).getAngle(),q=new Z(-I,-I).rotate(j).add(N),oe=new Z(I,I).rotate(j).add(N),ne=new Z(-I,I).rotate(j).add(N),Te=new Z(I,-I).rotate(j).add(N);O.moveTo(q.x,q.y),O.lineTo(oe.x,oe.y),O.moveTo(ne.x,ne.y),O.lineTo(Te.x,Te.y)}else O.moveTo(N.x-I,N.y-I),O.lineTo(N.x+I,N.y+I),O.moveTo(N.x-I,N.y+I),O.lineTo(N.x+I,N.y-I)}if(v){const m=e.edges[D],I=.4,N=.017,j=m.start.viewCoordinates.blend(m.end.viewCoordinates,.5),q=j.blend(m.start.viewCoordinates,I),oe=j.blend(m.end.viewCoordinates,I);for(let ne=0;ne<5;ne++){const Te=q.blend(oe,ne/4);A.moveTo(Te.x+N,Te.y),A.arc(Te.x,Te.y,N,0,2*Math.PI,!1)}}}}T.makeImmutable(),O.makeImmutable(),A.makeImmutable(),s.shape=T,a.shape=O,n.shape=A}}});this.disposeEmitter.addListener(()=>p.dispose())}}class Ar extends W{constructor(t,o,r){const s=new W;super({pickable:!1,children:[s]});f(this,"faceColorNodeMap",new Map);f(this,"faceColorIdMap",new Map);f(this,"adjacentFacesMap",new Map);f(this,"faceColorNodeContainer");f(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,t.faces.forEach(l=>{this.adjacentFacesMap.set(l,l.edges.map(c=>c.getOtherFace(l)).filter(c=>c!==null))});{const l=o.value.getFaceColors();for(const c of l)this.addFaceColor(c,o.value.getFacesWithColor(c));this.addDualColorViews(o.value,l)}this.updateHues();let a=o.value.clone();const n=l=>{const c=a;a=l.clone();const u=c.getFaceColors(),C=l.getFaceColors(),w=[],p=[],g=[];jt(u,C,w,p,g);const S=new Set(w),y=this.removeInvalidDualColorViews(l),E=[...y];for(const P of p)if(y.add(P),this.faceColorIdMap.has(P.id)){const v=this.faceColorIdMap.get(P.id);this.replaceFaceColor(v,P,l.getFacesWithColor(P)),S.delete(v)}else this.addFaceColor(P,l.getFacesWithColor(P));for(const P of g)this.updateFaceColor(P,l.getFacesWithColor(P));for(const P of S)y.delete(P),this.removeFaceColor(P);this.addDualColorViews(l,[...y]),(p.length||w.length||E.length)&&this.updateHues()};o.lazyLink(n),this.disposeEmitter.addListener(()=>o.unlink(n)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const i=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(i),r.theme.faceColorLightHueLUTProperty.lazyLink(i),r.theme.faceColorDarkHueLUTProperty.lazyLink(i),r.theme.faceColorInsideColorProperty.lazyLink(i),r.theme.faceColorOutsideColorProperty.lazyLink(i),r.theme.faceColorDefaultColorProperty.lazyLink(i),r.faceColorThresholdProperty.lazyLink(i),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(i),r.theme.faceColorLightHueLUTProperty.unlink(i),r.theme.faceColorDarkHueLUTProperty.unlink(i),r.theme.faceColorInsideColorProperty.unlink(i),r.theme.faceColorOutsideColorProperty.unlink(i),r.theme.faceColorDefaultColorProperty.unlink(i),r.faceColorThresholdProperty.unlink(i)})}addFaceColor(t,o){const r=new Re(t,o,this.style);this.faceColorNodeMap.set(t,r),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(t,o,r){k()&&L(t.id===o.id);const s=this.faceColorNodeMap.get(t);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const r=this.faceColorNodeMap.get(t);let s=r.faces.length!==o.length;if(!s)for(let a=0;a<o.length;a++){const n=r.faces[a],i=o[a];if(n!==i){s=!0;break}}s&&r.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const a=this.faceColorNodeMap.get(s);k()&&L(a);const n=t.getOppositeFaceColor(s);if(n){k()&&L(r.has(n)),r.delete(n);const i=this.faceColorNodeMap.get(n);k()&&L(i),this.dualColorViews.add(new It([a,i],this.style))}else this.dualColorViews.add(new It([a],this.style))}}removeInvalidDualColorViews(t){const o=new Set,r=new Set(t.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const a of s.colorNodes)o.add(a.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==b.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new Z(0,0),r=()=>{for(const c of t)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(Ke.nextDouble()-.5,Ke.nextDouble()-.5).normalize()},s=new Map,a=[];this.board.faces.forEach(c=>{s.set(c,[])});for(const c of t){const u=new Set;for(const w of c.faces)u.add(w);const C=new Set;for(const w of u){C.add(w);for(const p of this.adjacentFacesMap.get(w))C.add(p)}for(const w of C){const p=s.get(w);if(p){if(p.length)for(const g of p){let S=!1;for(const y of a)if(y.a===g&&y.b===c){y.weight++,S=!0;break}S||a.push({a:g,b:c,weight:1})}p.push(c)}}}const n=new Map;for(const c of t)n.set(c,Z.ZERO.copy());const i=(c,u,C)=>{const w=n.get(c),p=n.get(u),g=c.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(c.hueVector);S.magnitudeSquared>1e-11&&S.normalize();const y=.2,E=Math.abs(g),P=C*((Math.max(y,E)-y)/(1-y))**3;S.multiplyScalar(P),w.subtract(S),p.add(S)};let l=1;for(let c=0;c<100;c++){l*=.99;for(const u of t)n.get(u).setXY(0,0);for(const u of a){const C=u.a,w=u.b,p=u.weight;i(C,w,p)}if(t.length<8)for(let u=0;u<t.length;u++){const C=t[u];for(let w=u+1;w<t.length;w++)i(C,t[w],.2)}for(const u of t){const C=n.get(u);C.multiplyScalar(l/u.faceCount),u.hueVector.add(C),n.get(u).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}getDualColorViews(){return this.dualColorViews}}const ce=class ce extends ye{};f(ce,"BASIC",new ce),f(ce,"PRIMARY",new ce),f(ce,"SECONDARY",new ce),f(ce,"enumeration",new Ce(ce));let ae=ce;class It{constructor(e,t){f(this,"hueVector");f(this,"faceCount");f(this,"hueVectorOverride",null);if(this.colorNodes=e,this.style=t,k()&&L(e.length===1||e.length===2),this.faceCount=fe.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=ae.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],r=o===e[0]?e[1]:e[0];let s;o.type===ae.PRIMARY?s=o:r.type===ae.PRIMARY||o.type===ae.SECONDARY?s=r:(r.type,ae.SECONDARY,s=o);const a=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=ae.PRIMARY,a.type=ae.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVectorOverride??this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}overrideHueVector(e){this.hueVectorOverride=e,this.updateHue()}isUndecided(){return this.colorNodes.every(e=>e.faceColor.colorState===b.UNDECIDED)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class Re extends _{constructor(t,o,r){const s=Z.createPolar(1,Ke.nextDoubleBetween(0,2*Math.PI));super(Re.toShape(o));f(this,"hueVector");f(this,"faceCount");f(this,"dualColorView",null);f(this,"type",ae.BASIC);this.faceColor=t,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==b.UNDECIDED?this.fill=Re.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Z.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const r=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=Re.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(t,o,r,s){const a=r===ae.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===ae.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,n=(Math.round(t.getAngle()*180/Math.PI)+360)%360;k()&&L(n>=0&&n<a.length);const i=a[n];if(o===b.UNDECIDED)return i;{const c=(o===b.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,u=c.alpha,C=new vt(i);return new vt((1-u)*C.red+u*c.red,(1-u)*C.green+u*c.green,(1-u)*C.blue+u*c.blue).toCSS()}}static toShape(t){const o=new U;for(const r of t)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}class Ir extends zt{constructor(e,t){const o=Ue()({font:co,fill:he.uiForegroundColorProperty},t);super(e,o)}}class Nr extends W{constructor(e,t,o){super({translation:e.viewCoordinates}),this.face=e;const s=t.value.getFaceState(e),a=s.possibilityCount===0||s.possibilityCount>9;let n;const i=s.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(a)n=new Ir(s.possibilityCount,{font:ut,maxWidth:.4,maxHeight:.4});else{const l=new Set(e.vertices);n=new Mo({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(s.possibilityCount)),children:s.getAllowedCombinations().map(c=>{const u=new W,C=new Set(c.map(g=>g.start)),w=new Set(c.map(g=>g.end)),p=g=>g.minus(e.viewCoordinates);if(u.addChild(new _(U.polygon(e.vertices.map(g=>p(g.viewCoordinates))),{stroke:i,lineWidth:.03,opacity:.2})),C.size){const g=new U;if(c.length===e.edges.length)g.polygon(e.vertices.map(S=>p(S.viewCoordinates)));else{const S=new Set(c);for(;S.size;){const y=[...l].find(v=>[...S].filter(x=>x.start===v||x.end===v).length===1);k()&&L(y);let E=y,P=[...S].find(v=>v.start===E||v.end===E)??null;for(g.moveToPoint(p(E.viewCoordinates));P;)S.delete(P),E=P.getOtherVertex(E),g.lineToPoint(p(E.viewCoordinates)),P=[...S].find(v=>v.start===E||v.end===E)??null}}u.addChild(new _(g,{stroke:i,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of e.vertices)!C.has(g)&&!w.has(g)&&u.addChild(new Yt(.1,{fill:i,translation:p(g.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}n.center=Z.ZERO,this.addChild(n)}}class kr extends W{constructor(e,t,o,r){super({pickable:!1});const s=we.multilink([t,r.faceStateVisibleProperty],(n,i)=>{this.children.forEach(l=>l.dispose()),this.children=[],i&&e.faces.forEach(l=>{this.addChild(new Nr(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const a=n=>{this.visible=!n};o.link(a),this.disposeEmitter.addListener(()=>{o.unlink(a),this.children.forEach(n=>n.dispose())})}}class Lr extends ft{constructor(e,t){super(e.faces,o=>o?U.polygon(o.vertices.map(r=>r.viewCoordinates)):new U,t.facePressListener,{isDragModeProperty:to,onDragStart:t.onFaceDragStart,onDrag:t.onFaceDrag,onDragEnd:t.onFaceDragEnd,noItemItem:null})}}const ke=class ke{constructor(e,t){this.incorrectEdges=e,this.incorrectFaces=t}isCorrect(){return this.incorrectEdges.size===0&&this.incorrectFaces.size===0}with(e){return this.isCorrect()?e:e.isCorrect()?this:new ke(new Set([...this.incorrectEdges,...e.incorrectEdges]),new Set([...this.incorrectFaces,...e.incorrectFaces]))}static with(e){return e.reduce((t,o)=>t.with(o),ke.CORRECT)}};f(ke,"CORRECT",new ke(new Set,new Set));let xe=ke;class Nt{constructor(e,t,o){f(this,"edgeStateChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(k()&&L(this.board.edges.includes(e)),t!==V.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new te(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.edges){const a=t.getEdgeState(s);a!==V.WHITE&&a!==o.getEdgeState(s)&&r.add(s)}return new xe(r,new Set)}}class kt{constructor(e,t,o){f(this,"faceColorsChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){if(s)throw new te("invalid face color?");const a=new Set([...o.values(),...r.keys(),...o.values()]),n=new Map(this.currentState.getFaceColorMap());for(const c of o.keys())n.set(c,o.get(c));const i=c=>r.has(c)?r.get(c):[...e].includes(c)?this.currentState.getOppositeFaceColor(c):null,l=new Map;for(const c of n.keys()){const u=n.get(c);l.has(u)||l.set(u,new Set([c])),l.get(u).add(c)}for(const c of a){const u=l.get(c);if(!u)continue;const C=[...u];k()&&L(C.length>0);const w=this.solvedState.getFaceColor(C[0]);for(const g of C)if(this.solvedState.getFaceColor(g)!==w)throw new te("invalid face color");const p=i(c);if(p){let g;if(p.colorState===b.INSIDE?g=this.solvedState.getInsideColor():p.colorState===b.OUTSIDE?g=this.solvedState.getOutsideColor():g=this.solvedState.getFaceColor([...l.get(p)][0]),w===g)throw new te("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set,s=new Set,a=t.getOutsideColor(),n=t.getInsideColor(),i=o.getOutsideColor(),l=o.getInsideColor();for(const c of t.getFaceColors()){if(s.has(c))continue;const u=t.getOppositeFaceColor(c);s.add(c),u&&s.add(u);const C=t.getFacesWithColor(c),w=u?t.getFacesWithColor(u):[],p=(g,S)=>{o.getFaceColor(g)!==S&&r.add(g)};if(c===a)C.forEach(g=>p(g,i)),w.forEach(g=>p(g,l));else if(c===n)C.forEach(g=>p(g,l)),w.forEach(g=>p(g,i));else if(C.length){let g=C.filter(y=>o.getFaceColor(y)===i).length+w.filter(y=>o.getFaceColor(y)===l).length,S=C.length+w.length;if(g>0&&g<S){const y=g>S/2,E=y?i:l,P=y?l:i;C.forEach(v=>p(v,E)),w.forEach(v=>p(v,P))}}}return new xe(new Set,r)}}class xr{constructor(e,t,o){f(this,"faceStateChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){k()&&L(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new te(`Attempt to make face ${t} when it should be ${o}`);const r=this.currentState.getFaceState(e);if(!t.isSubsetOf(r))throw new te("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Rr{constructor(e,t,o){f(this,"faceValueChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new te("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Lt{constructor(e,t,o){f(this,"sectorStateChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){k()&&L(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new te(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){const r=new Set;for(const s of e.halfEdges){const a=s.edge,n=s.next.edge,i=t.getSectorState(s),l=(o.getEdgeState(a)===V.BLACK?1:0)+(o.getEdgeState(n)===V.BLACK?1:0);i.allows(l)||(r.add(a),r.add(n))}return new xe(r,new Set)}}class Mr{constructor(e,t,o){f(this,"simpleRegionsChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,r){if([...o].length)throw new te("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Br{constructor(e,t,o){f(this,"vertexStateChangedEmitter",new ge);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){k()&&L(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new te(`Attempt to make vertex ${t} when it should be ${o}`);const r=this.currentState.getVertexState(e);if(!t.isSubsetOf(r))throw new te("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Wr{constructor(e,t,o){f(this,"anyStateChangedEmitter",new ge);f(this,"edgeStateValidator");f(this,"faceValueValidator");f(this,"simpleRegionDataValidator");f(this,"faceColorValidator");f(this,"sectorStateValidator");f(this,"vertexStateValidator");f(this,"faceStateValidator");k()&&L(e),k()&&L(o),this.edgeStateValidator=new Nt(e,t,o),this.faceValueValidator=new Rr(e,t,o),this.simpleRegionDataValidator=new Mr(e,t,o),this.faceColorValidator=new kt(e,t,o),this.sectorStateValidator=new Lt(e,t,o),this.vertexStateValidator=new Br(e,t,o),this.faceStateValidator=new xr(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,r){this.simpleRegionDataValidator.modifyRegions(e,t,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){this.faceColorValidator.modifyFaceColors(e,t,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}static getCorrectnessState(e,t,o){return xe.with([Nt.getCorrectnessState(e,t,o),kt.getCorrectnessState(e,t,o),Lt.getCorrectnessState(e,t,o)])}}const Hr=h=>[h.forwardHalf,h.reversedHalf,h.forwardHalf.previous,h.reversedHalf.previous];class We{constructor(e){this.edge=e,k()&&L(e)}apply(e){e.getEdgeState(this.edge)!==V.WHITE&&e.setEdgeState(this.edge,V.WHITE);const o=this.edge.forwardFace,r=this.edge.reversedFace,s=e.getOutsideColor(),a=e.getInsideColor(),n=o?e.getFaceColor(o):s,i=r?e.getFaceColor(r):s,l=e.getOppositeFaceColor(n);if(n===i||l===i){const c=[...e.getFacesWithColor(n),...n===s?[null]:[]],u=l?[...e.getFacesWithColor(l),...l===s?[null]:[]]:[],C=[...c,...u],w=g=>{const S=new Set,y=new Set([g]);for(;y.size>0;){const E=y.values().next().value;if(y.delete(E),S.add(E),E){for(const P of E.edges)if(e.getEdgeState(P)!==V.WHITE){const v=P.getOtherFace(E),x=v?e.getFaceColor(v):s;(x===n||x===l)&&!S.has(v)&&y.add(v)}}else for(const P of C)if(P&&!S.has(P))for(const v of P.edges)v.getOtherFace(P)===null&&e.getEdgeState(v)!==V.WHITE&&y.add(P)}return S},p=w(o);if(!p.has(r)){const g=w(r);k()&&L(p.size>0&&g.size>0),k()&&L([...p].every(A=>!g.has(A)));const S=C.filter(A=>!p.has(A)&&!g.has(A)),y=[],E=[],P=new Map,v=new Map,x=(A,D,M)=>{const m=A.filter(N=>(N?e.getFaceColor(N):s)===n),I=A.filter(N=>(N?e.getFaceColor(N):s)===l);if(D!==null)D!==s&&D!==a&&(m.length||E.push(D),M&&!I.length&&E.push(M));else if(k()&&L(A.every(N=>N)),D=new lt(ct(),b.UNDECIDED),y.push(D),m.length&&I.length){M=new lt(ct(),b.UNDECIDED),y.push(M),v.set(D,M),v.set(M,D);for(const N of m)k()&&L(N),P.set(N,D);for(const N of I)k()&&L(N),P.set(N,M)}else{const N=m.length?m:I;k()&&L(N.length);for(const j of N)k()&&L(j),P.set(j,D)}},F=[...p],T=[...g],O=fe.sortBy([...S.length?[S]:[],F,T],A=>-A.length+(A.some(D=>!D)?-1e7:0));for(let A=0;A<O.length;A++)x(O[A],A===0?n:null,A===0?l:null);e.modifyFaceColors(y,E,P,v,!1)}}for(const c of Hr(this.edge))e.setSectorState(c,B.ANY);for(const c of this.edge.vertices)e.setVertexState(c,pt.any(c));for(const c of this.edge.faces)e.setFaceState(c,Kt.any(c,e.getFaceValue(c)))}getUndo(e){throw new Error("getUndo unimplemented in EraseEdgeCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseEdgeCompleteAction",edge:it(this.edge)}}static deserializeAction(e,t){const o=nt(e,t.edge);return new We(o)}}class He{constructor(e){this.face=e,k()&&L(e)}apply(e){this.face.edges.forEach(t=>{new We(t).apply(e)})}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceCompleteAction",face:Xe(this.face)}}static deserializeAction(e,t){const o=_e(e,t.face);return new He(o)}}class St{constructor(e){this.sector=e,k()&&L(e)}apply(e){e.setSectorState(this.sector,B.ANY);const t=this.sector.end;e.setVertexState(t,pt.any(t));const o=this.sector.face;o&&e.setFaceState(o,Kt.any(o,e.getFaceValue(o)))}getUndo(e){throw new Error("getUndo unimplemented in EraseSectorCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseSectorCompleteAction",sector:Xo(this.sector)}}static deserializeAction(e,t){const o=_o(e,t.sector);return new St(o)}}const Ur=new R("autoSolveEnabledProperty",!0),zr=new R("autoSolveToBlackProperty",!1),Yr=new R("autoSolveSimpleLoopsProperty",!1),Gr=new R("autoSolveSimpleVertexJointToRedProperty",!0),jr=new R("autoSolveSimpleVertexForcedLineToBlackProperty",!0),Kr=new R("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),Xr=new R("autoSolveSimpleFaceToRedProperty",!0),_r=new R("autoSolveSimpleFaceToBlackProperty",!0),qr=new R("autoSolveSimpleLoopToRedProperty",!0),Jr=new R("autoSolveSimpleLoopToBlackProperty",!1),Zr=new R("autoSolveDoubleMinusOneFacesProperty",!1),$r=new R("autoSolveStaticFaceSectorProperty",!0),Qr=new R("autoSolveSimpleSectorProperty",!1),es=new R("autoSolveVertexToRedEdgeProperty",!1),ts=new R("autoSolveVertexToBlackEdgeProperty",!1),os=new R("autoSolveVertexToSectorsProperty",!1),rs=new R("autoSolveVertexToFaceColorProperty",!1),ss=new R("autoSolveFaceColorToRedProperty",!1),as=new R("autoSolveFaceColorToBlackProperty",!1),is=new R("autoSolveFaceColorParityToRedProperty",!1),ns=new R("autoSolveFaceColorParityToBlackProperty",!1),ls=new R("autoSolveFaceColorParityColorsProperty",!1),cs=new R("autoSolveFaceColorParityPartialReductionProperty",!1),ds=new R("autoSolveVertexColorToFaceProperty",!1),hs=new R("autoSolveFaceToRedProperty",!1),us=new R("autoSolveFaceToBlackProperty",!1),ps=new R("autoSolveFaceToSectorsProperty",!1),gs=new R("autoSolveFaceToFaceColorsProperty",!1),fs=new R("autoSolveFaceToVertexProperty",!1),Ss=new Y([Gr,jr,Kr,Xr,_r,qr,Jr,Zr,$r,Qr,es,ts,os,rs,ss,as,is,ns,ls,cs,ds,hs,us,ps,gs,fs],(h,e,t,o,r,s,a,n,i,l,c,u,C,w,p,g,S,y,E,P,v,x,F,T,O,A)=>(D,M,m)=>new Ve([...h||e||t?[new qt(D,M,{solveJointToRed:h,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},m?void 0:[])]:[],...o||r?[new Jt(D,M,{solveToRed:o,solveToBlack:r},m?void 0:[])]:[],...n?[new ir(D,M,m?void 0:[])]:[],Xt(D,M),...i?[new Zt(D,M,m?void 0:[])]:[],...l?[new nr(D,M,m?void 0:[])]:[],...s||a?[new $t(D,M,{solveToRed:s,solveToBlack:a,resolveAllRegions:!1},m?void 0:[])]:[],...c||u?[new lr(D,M,{solveToRed:c,solveToBlack:u},m?void 0:[])]:[],...C?[new cr(D,M,m?void 0:[])]:[],...p||g?[new et(D,M,{solveToRed:p,solveToBlack:g},m?void 0:[])]:[],...S||y||E?[new dr(D,M,{solveToRed:S,solveToBlack:y,solveColors:E,allowPartialReduction:P},m?void 0:[])]:[],...w?[new hr(D,M,m?void 0:[])]:[],...v?[new _t(D,M,m?void 0:[])]:[],...x||F?[new ur(D,M,{solveToRed:x,solveToBlack:F},m?void 0:[])]:[],...T?[new pr(D,M,m?void 0:[])]:[],...O?[new gr(D,M,m?void 0:[])]:[],...A?[new fr(D,M,m?void 0:[])]:[]]));class st extends Error{constructor(e){super(e)}}const xt=(h,e,t)=>{Je(t,h,e,!0)},oo=(h,e,t,o)=>(r,s,a)=>{const n=[new er(r,s),new tr(r,s)];return(h||e||t||o)&&(n.push(new or(r,s)),(e||t||o)&&(n.push(new rr(r,s)),(t||o)&&(n.push(new sr(r,s)),o&&n.push(new _t(r,s))))),new Ve(n)},ws={allowEdgeEditProperty:ho,allowAbsoluteFaceColorEditProperty:uo,allowFaceColorEditProperty:po,allowSectorEditProperty:go,edgesVisibleProperty:fo,edgesHaveColorsProperty:So,faceColorsVisibleProperty:yt,faceColorThresholdProperty:wo,sectorsVisibleProperty:Ct,sectorsNextToEdgesVisibleProperty:yo,sectorsTrivialVisibleProperty:Co,vertexStateVisibleProperty:Et,allVertexStateVisibleProperty:Eo,faceStateVisibleProperty:Pt,whiteLineVisibleProperty:Po,redLineVisibleProperty:ue,verticesVisibleProperty:mo,smallVertexProperty:vo,redXsVisibleProperty:Fo,redXsAlignedProperty:Vo,faceValueStyleProperty:pe,redLineStyleProperty:To,vertexStyleProperty:Do,joinedLinesJoinProperty:Oo,joinedLinesCapProperty:bo,safeSolverFactoryProperty:new Y([yt,Ct,Et,Pt],(h,e,t,o)=>oo(h,e,t,o)),autoSolverFactoryProperty:Ss,theme:he},Ee=(h,e,t,o,r)=>{const s=oo(h,e,t,o);return{faceColorsVisibleProperty:new Ie(h),sectorsVisibleProperty:new Ie(e),vertexStateVisibleProperty:new Ie(t),faceStateVisibleProperty:new Ie(o),safeSolverFactoryProperty:new Me(s),autoSolverFactoryProperty:r?new Y([r],a=>(n,i,l)=>new Ve([s(n,i,l),a(n,i,l)])):new Me(s)}},De=new Y([zr,Yr],(h,e)=>(t,o,r)=>new Ve([new qt(t,o,{solveJointToRed:!0,solveForcedLineToBlack:h,solveAlmostEmptyToRed:!0},r?void 0:[]),new Jt(t,o,{solveToRed:!0,solveToBlack:h},r?void 0:[]),...e?[new $t(t,o,{solveToRed:!0,solveToBlack:h,resolveAllRegions:!1},r?void 0:[])]:[]])),ys=new Y([De],h=>(e,t,o)=>new Ve([h(e,t,o),new et(e,t,{solveToRed:!0,solveToBlack:!0})])),ro=new Y([De],h=>(e,t,o)=>new Ve([h(e,t,o),new Zt(e,t,o?void 0:[])])),Cs=new Y([ro],h=>(e,t,o)=>new Ve([h(e,t,o),new et(e,t,{solveToRed:!0,solveToBlack:!0})])),Es=h=>({...Ee(!0,!1,!1,!1,De),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!0),allowFaceColorEditProperty:new d(!1),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),Ps=h=>({...Ee(!0,!1,!1,!1,ys),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!0),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),ms=h=>({...Ee(!0,!1,!1,!1,new Me((e,t,o)=>new Ve([new et(e,t,{solveToRed:!0,solveToBlack:!0},o?void 0:[])]))),theme:h,allowEdgeEditProperty:new d(!1),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!0),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!1),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),vs=h=>({...Ee(!1,!1,!1,!1,De),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!1),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!0),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!0),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("square"),joinedLinesJoinProperty:new d("miter"),joinedLinesCapProperty:new d("square")}),ma=h=>({...Ee(!1,!0,!1,!1,De),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!1),allowSectorEditProperty:new d(!0),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!0),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!0),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("square"),joinedLinesJoinProperty:new d("miter"),joinedLinesCapProperty:new d("square")}),Fs=h=>({...Ee(!0,!0,!1,!1,ro),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!0),allowFaceColorEditProperty:new d(!1),allowSectorEditProperty:new d(!0),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),Vs=h=>({...Ee(!0,!0,!1,!1,Cs),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!0),allowSectorEditProperty:new d(!0),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),Ts=h=>({...Ee(!0,!1,!0,!1,De),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!0),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),Ds=h=>({...Ee(!0,!1,!1,!0,De),theme:h,allowEdgeEditProperty:new d(!0),allowAbsoluteFaceColorEditProperty:new d(!1),allowFaceColorEditProperty:new d(!0),allowSectorEditProperty:new d(!1),edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ue,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:pe,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")}),Os=Es(he),bs=Ps(he),As=ms(he),so=vs(he),Is=Fs(he),Ns=Vs(he),ks=Ts(he),Ls=Ds(he),at={basicLines:Os,basicFaceColoring:bs,pureFaceColor:As,classic:so,basicSectors:Is,sectorsWithColors:Ns,vertexState:ks,faceState:Ls,custom:ws},Rt=so,xs=h=>({allowEdgeEditProperty:new z(h,{derive:"allowEdgeEditProperty"}),allowAbsoluteFaceColorEditProperty:new z(h,{derive:"allowAbsoluteFaceColorEditProperty"}),allowFaceColorEditProperty:new z(h,{derive:"allowFaceColorEditProperty"}),allowSectorEditProperty:new z(h,{derive:"allowSectorEditProperty"}),edgesVisibleProperty:new z(h,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new z(h,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new z(h,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new z(h,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new z(h,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new z(h,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new z(h,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new z(h,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new z(h,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new z(h,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new z(h,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new z(h,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new z(h,{derive:"verticesVisibleProperty"}),smallVertexProperty:new z(h,{derive:"smallVertexProperty"}),redXsVisibleProperty:new z(h,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new z(h,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new z(h,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new z(h,{derive:"redLineStyleProperty"}),vertexStyleProperty:new z(h,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new z(h,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new z(h,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new z(h,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new z(h,{derive:"autoSolverFactoryProperty"}),theme:Io(new Y([h],e=>e.theme))}),Rs=new Ao("puzzleStyle",{serialize:h=>Object.keys(at).find(e=>at[e]===h),deserialize:h=>h?at[h]??Rt:Rt}),J=xs(Rs),va=new R("showPuzzleStyleProperty",!0),Fa=new R("showPuzzleTimerProperty",!1),Va=new R("showSectorViewModesProperty",!1),G=class G extends ye{constructor(e){super(),this.isEnabledProperty=e}};f(G,"EDGE_STATE",new G(J.allowEdgeEditProperty)),f(G,"EDGE_STATE_REVERSED",new G(J.allowEdgeEditProperty)),f(G,"FACE_COLOR_INSIDE",new G(J.allowAbsoluteFaceColorEditProperty)),f(G,"FACE_COLOR_OUTSIDE",new G(J.allowAbsoluteFaceColorEditProperty)),f(G,"FACE_COLOR_MATCH",new G(J.allowFaceColorEditProperty)),f(G,"FACE_COLOR_OPPOSITE",new G(J.allowFaceColorEditProperty)),f(G,"SECTOR_STATE",new G(J.allowSectorEditProperty)),f(G,"VERTEX_STATE",new G(J.vertexStateVisibleProperty)),f(G,"FACE_STATE",new G(J.faceStateVisibleProperty)),f(G,"FACE_VALUE",new G(new Ie(!1))),f(G,"DELETE_FACE",new G(new Ie(!1))),f(G,"enumeration",new Ce(G));let H=G;const K=new ht("editModeProperty",H.EDGE_STATE);H.enumeration.values.forEach(h=>{h.isEnabledProperty.lazyLink(e=>{if(!K.value.isEnabledProperty.value){const t=H.enumeration.values.find(o=>o.isEnabledProperty.value)??null;t&&(K.value=t)}})});const ze=new R("eraserEnabledProperty",!1),Ta=h=>{h.isEnabledProperty.value&&(K.value=h)},Ms=new Y([K],h=>h===H.EDGE_STATE||h===H.EDGE_STATE_REVERSED),wt=new Y([K],h=>h===H.FACE_COLOR_MATCH||h===H.FACE_COLOR_OPPOSITE),Da=wt,Bs=new Y([K],h=>h===H.FACE_COLOR_OUTSIDE||h===H.FACE_COLOR_INSIDE),Ws=new Y([K],h=>h===H.SECTOR_STATE),Hs=new Y([K],h=>h===H.VERTEX_STATE),Us=new Y([K,wt,Bs],(h,e,t)=>e||t||h===H.FACE_STATE||h===H.FACE_VALUE||h===H.DELETE_FACE),se=class se extends ye{};f(se,"NONE",new se),f(se,"ABSOLUTE_PAINT",new se),f(se,"MAKE_SAME",new se),f(se,"MAKE_OPPOSITE",new se),f(se,"enumeration",new Ce(se));let $=se;class zs{constructor(e){f(this,"paintFaceSet",new Set);f(this,"paintFaceOppositeSet",new Set);f(this,"absolutePaintState",b.INSIDE);f(this,"lastFace",null);f(this,"faceDragStateProperty",new d($.NONE));f(this,"dragIndex",0);this.board=e}isNoOpSingleFace(){return(this.faceDragStateProperty.value===$.MAKE_SAME||this.faceDragStateProperty.value===$.MAKE_OPPOSITE)&&this.paintFaceSet.size===1&&this.paintFaceOppositeSet.size===0}onAbsolutePaintStart(e,t){this.faceDragStateProperty.value=$.ABSOLUTE_PAINT,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeSameStart(e){this.faceDragStateProperty.value=$.MAKE_SAME,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=b.UNDECIDED,this.dragIndex=Math.ceil(Math.random()*1e10)}onMakeOppositeStart(e){this.faceDragStateProperty.value=$.MAKE_OPPOSITE,this.paintFaceSet.clear(),this.paintFaceSet.add(e),this.paintFaceOppositeSet.clear(),this.absolutePaintState=b.UNDECIDED,this.lastFace=e,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(e){const r=e.viewCoordinates.distance(t),s=e.vertices.map(a=>a.viewCoordinates.distance(t)).reduce((a,n)=>Math.min(a,n),Number.POSITIVE_INFINITY);if(r>.3&&s/r<.7)return!1}const o=this.lastFace;return this.lastFace=e,!this.paintFaceSet.has(e)&&!this.paintFaceOppositeSet.has(e)?(this.faceDragStateProperty.value===$.MAKE_OPPOSITE&&this.paintFaceSet.has(o)?(k()&&L(!this.paintFaceSet.has(e)),this.paintFaceOppositeSet.add(e)):(k()&&L(!this.paintFaceOppositeSet.has(e)),this.paintFaceSet.add(e)),!0):!1}onDragEnd(){this.faceDragStateProperty.value=$.NONE}}const Q=class Q extends ye{};f(Q,"DEFAULT",new Q),f(Q,"LOADING",new Q),f(Q,"SEARCHING",new Q),f(Q,"FOUND",new Q),f(Q,"NOT_FOUND",new Q),f(Q,"enumeration",new Ce(Q));let le=Q;const de=class de extends ye{};f(de,"NONE",new de),f(de,"LINE_DRAG",new de),f(de,"EDGE_PAINT",new de),f(de,"enumeration",new Ce(de));let ie=de;class Ys{constructor(e){f(this,"firstEdge");f(this,"edgeStack",[]);f(this,"vertexStack",[]);f(this,"paintEdgeSet",new Set);f(this,"paintEdgeState",V.WHITE);f(this,"lineDragStateProperty",new d(ie.NONE));f(this,"dragIndex",0);this.board=e}onLineDragStart(e){this.firstEdge=e,this.lineDragStateProperty.value=ie.LINE_DRAG,this.edgeStack.length=0,this.edgeStack.push(e),this.vertexStack.length=0,this.dragIndex=Math.ceil(Math.random()*1e10)}onPaintDragStart(e,t){this.firstEdge=e,this.lineDragStateProperty.value=ie.EDGE_PAINT,this.paintEdgeSet.clear(),this.paintEdgeSet.add(e),this.paintEdgeState=t,this.dragIndex=Math.ceil(Math.random()*1e10)}onDrag(e,t){if(this.lineDragStateProperty.value===ie.LINE_DRAG){const o=this.edgeStack[this.edgeStack.length-1],r=this.edgeStack.length>1?this.edgeStack[this.edgeStack.length-2]:null;if(e===o)return!1;if(e===r)return this.edgeStack.pop(),this.vertexStack.pop(),!0;if(this.edgeStack.includes(e))return!1;if(this.vertexStack.length===0){const s=o.vertices.find(a=>e.vertices.includes(a))??null;return s?(this.edgeStack.push(e),this.vertexStack.push(s),!0):!1}else{const s=this.vertexStack[this.vertexStack.length-1];if(e.vertices.includes(s))return this.edgeStack.pop(),this.edgeStack.push(e),!0;{const a=o.getOtherVertex(s);return e.vertices.includes(a)?(this.edgeStack.push(e),this.vertexStack.push(a),!0):!1}}}else if(this.lineDragStateProperty.value===ie.EDGE_PAINT){const o=e.start.viewCoordinates.distance(e.end.viewCoordinates),r=Math.min(...e.vertices.map(a=>a.viewCoordinates.distance(t))),s=Math.min(...e.faces.map(a=>a.viewCoordinates.distance(t)));if(Math.min(r,s)/o<.3)return!1;if(!this.paintEdgeSet.has(e))return this.paintEdgeSet.add(e),!0}return!1}onDragEnd(){this.lineDragStateProperty.value=ie.NONE}}const X=class X extends ye{constructor(e,t,o){super(),this.fromWhite=e,this.fromBlack=t,this.fromRed=o}apply(e){return e===V.WHITE?this.fromWhite:e===V.BLACK?this.fromBlack:this.fromRed}};f(X,"CYCLE",new X(V.BLACK,V.RED,V.WHITE)),f(X,"REVERSE_CYCLE",new X(V.RED,V.WHITE,V.BLACK)),f(X,"BLACK_TOGGLE",new X(V.BLACK,V.WHITE,V.BLACK)),f(X,"RED_TOGGLE",new X(V.RED,V.RED,V.WHITE)),f(X,"WHITE_SET",new X(V.WHITE,V.WHITE,V.WHITE)),f(X,"BLACK_SET",new X(V.BLACK,V.BLACK,V.BLACK)),f(X,"RED_SET",new X(V.RED,V.RED,V.RED)),f(X,"enumeration",new Ce(X));let Pe=X;const ee=class ee extends ye{constructor(e,t,o){super(),this.fromUndecided=e,this.fromInside=t,this.fromOutside=o}apply(e){return e===b.UNDECIDED?this.fromUndecided:e===b.OUTSIDE?this.fromOutside:this.fromInside}};f(ee,"CYCLE",new ee(b.INSIDE,b.OUTSIDE,b.UNDECIDED)),f(ee,"REVERSE_CYCLE",new ee(b.OUTSIDE,b.UNDECIDED,b.INSIDE)),f(ee,"INSIDE_TOGGLE",new ee(b.INSIDE,b.UNDECIDED,b.INSIDE)),f(ee,"OUTSIDE_TOGGLE",new ee(b.OUTSIDE,b.OUTSIDE,b.UNDECIDED)),f(ee,"UNDECIDED_SET",new ee(b.UNDECIDED,b.UNDECIDED,b.UNDECIDED)),f(ee,"enumeration",new Ce(ee));let me=ee;const Fe=class Fe extends ye{constructor(e,t){super(),this.edgePressStyles=e,this.faceColorPressStyles=t}};f(Fe,"CYCLIC",new Fe([Pe.CYCLE,Pe.WHITE_SET,Pe.REVERSE_CYCLE],[me.CYCLE,me.UNDECIDED_SET,me.REVERSE_CYCLE])),f(Fe,"TOGGLE",new Fe([Pe.BLACK_TOGGLE,Pe.WHITE_SET,Pe.RED_TOGGLE],[me.INSIDE_TOGGLE,me.UNDECIDED_SET,me.OUTSIDE_TOGGLE])),f(Fe,"enumeration",new Ce(Fe));let dt=Fe;const Ye=new ht("stateTransitionModeProperty",dt.CYCLIC);class Ze{constructor(e,t,o,r){this.firstEdge=e,this.edges=t,this.state=o,this.dragIndex=r}apply(e){for(const t of this.edges)e.setEdgeState(t,this.state)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.edges.length===0}serializeAction(){return{type:"UserEdgeDragAction",firstEdge:it(this.firstEdge),edges:this.edges.map(e=>it(e)),state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new Ze(nt(e,t.firstEdge),t.edges.map(o=>nt(e,o)),V.enumeration.getValue(t.state),t.dragIndex)}}class $e{constructor(e){this.face=e,k()&&L(e)}apply(e){const t=e.getFaceColor(this.face),o=e.getOppositeFaceColor(t),r=e.getFacesWithColor(t);for(const s of this.face.edges)e.getEdgeState(s)!==V.WHITE&&e.setEdgeState(s,V.WHITE);if(t.colorState!==b.UNDECIDED||o||r.length>1)if(t.colorState===b.UNDECIDED&&r.length===1)k()&&L(o),e.modifyFaceColors([],[],new Map,new Map([[t,null],[o,null]]),!1);else{const s=new lt(ct(),b.UNDECIDED);e.modifyFaceColors([s],[],new Map([[this.face,s]]),new Map,!1)}}getUndo(e){throw new Error("getUndo unimplemented in EraseFaceOnlyCompleteAction")}isEmpty(){return!1}serializeAction(){return{type:"EraseFaceOnlyCompleteAction",face:Xe(this.face)}}static deserializeAction(e,t){const o=_e(e,t.face);return new $e(o)}}class Qe{constructor(e,t,o,r,s){this.primaryFaces=e,this.secondaryFaces=t,this.isAbsolute=o,this.state=r,this.dragIndex=s}apply(e){console.log(this.state,this.primaryFaces,this.secondaryFaces);const t=(r,s,a)=>r&&(e.getOppositeFaceColor(s)===a||e.getOppositeFaceColor(a)===s)?(new $e(r).apply(e),!0):!1,o=(r,s,a)=>r&&s===a?(new $e(r).apply(e),!0):!1;if(this.state!==b.UNDECIDED){const r=this.state===b.OUTSIDE;console.log("absolute",r?"outside":"inside");const s=r?e.getOutsideColor():e.getInsideColor();for(const a of this.primaryFaces){let n=a?e.getFaceColor(a):e.getOutsideColor();s!==n&&(t(a,n,s),n=a?e.getFaceColor(a):e.getOutsideColor(),new qe(re(e,n),{type:"absolute",isOutside:r}).apply(e))}}else if(this.isAbsolute){console.log("absolute erase");for(const r of this.primaryFaces)r&&new He(r).apply(e)}else{if(console.log("normal"),this.primaryFaces.length&&this.secondaryFaces.length){const s=this.primaryFaces[0],a=this.secondaryFaces[0];let n=s?e.getFaceColor(s):e.getOutsideColor(),i=a?e.getFaceColor(a):e.getOutsideColor();o(a,n,i),n=s?e.getFaceColor(s):e.getOutsideColor(),i=a?e.getFaceColor(a):e.getOutsideColor(),new gt(re(e,n),re(e,i)).apply(e)}const r=s=>{for(let a=1;a<s.length;a++){const n=s[a-1],i=s[a];let l=n?e.getFaceColor(n):e.getOutsideColor(),c=i?e.getFaceColor(i):e.getOutsideColor();l!==c&&(t(i,l,c)&&(l=n?e.getFaceColor(n):e.getOutsideColor(),c=i?e.getFaceColor(i):e.getOutsideColor()),new qe(re(e,l),re(e,c)).apply(e))}};r(this.primaryFaces),r(this.secondaryFaces)}}getUndo(e){throw new Error("unimplemented")}isEmpty(){return(this.primaryFaces.length===0||this.state===b.UNDECIDED&&this.primaryFaces.length===1)&&this.secondaryFaces.length===0}serializeAction(){return{type:"UserFaceDragAction",primaryFaces:this.primaryFaces.map(e=>e?Xe(e):null),secondaryFaces:this.secondaryFaces.map(e=>e?Xe(e):null),isAbsolute:this.isAbsolute,state:this.state.name,dragIndex:this.dragIndex}}static deserializeAction(e,t){return new Qe(t.primaryFaces.map(o=>o?_e(e,o):null),t.secondaryFaces.map(o=>o?_e(e,o):null),t.isAbsolute,b.enumeration.getValue(t.state),t.dragIndex)}}class Gs{constructor(e){this.hintAction=e}get annotation(){return this.hintAction.annotation}apply(e){this.hintAction.apply(e)}getUndo(e){throw new Error("unimplemented")}isEmpty(){return this.hintAction.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}const ao=h=>({version:1,board:Sr(h.board),state:h.stateProperty.value.serializeState(h.board)}),js=h=>{const e=ao(h);return Uo(JSON.stringify(e))},Ks=h=>{const e=ao(h),t=h.solution.cleanState.serializeState(h.board),o=h.solution.solvedState.serializeState(h.board),r=[...h.solution.blackEdges].map(s=>h.board.edges.indexOf(s));return{puzzle:e,cleanState:t,solvedState:o,blackEdges:r}};function Xs(h){return new Worker(""+new URL("assets/hintWorker-DfhsT2TP.js",import.meta.url).href,{name:h==null?void 0:h.name})}let Oe=null;const je=new d(!1),io=()=>(Oe||(Oe=new Xs,Oe==null||Oe.addEventListener("message",h=>{h.data.type==="hint-worker-loaded"&&(je.value=!0)})),Oe);io();const _s=new R("uiHintUsesBuiltInSolve",!1),Oa=new R("showUndoRedoAllProperty",!1),Mt=new R("dimCompletedNumbersProperty",!0),Bt=new R("highlightIncorrectNumbersProperty",!0),ba=new R("highlightIncorrectMovesProperty",!0),qs=new R("highlightIntersectionsProperty",!0),Aa=new No("highlightIncorrectMovesDelayProperty",.7);class Ia extends xo{constructor(t,o){const r=Ue()({style:J,initialTimeElapsed:0},o),s=r.style;super();f(this,"timeElapsedProperty",new d(0));f(this,"hintStateProperty",new d(le.DEFAULT));f(this,"edgeAutoSolvedEmitter",new ge);f(this,"stack");f(this,"stackLengthProperty",new d(0));f(this,"stackPositionProperty",new d(0));f(this,"undoPossibleProperty");f(this,"redoPossibleProperty");f(this,"currentSnapshotProperty");f(this,"hasErrorProperty");f(this,"correctnessStateProperty");f(this,"isSolvedProperty");f(this,"hintWorkerMessageID",0);f(this,"addedHintListener",!1);f(this,"pendingHintActionProperty",new d(null));f(this,"displayedAnnotationProperty");f(this,"pendingActionFaceColorProperty",new d(null));f(this,"pendingActionSectorProperty",new d(null));f(this,"selectedFaceColorHighlightProperty");f(this,"selectedSectorEditProperty");f(this,"autoSolverFactoryProperty");f(this,"style");f(this,"lineDrag");f(this,"faceDrag");this.puzzle=t,this.style=s,this.timeElapsedProperty.value=r.initialTimeElapsed,this.lineDrag=new Ys(t.board),this.faceDrag=new zs(t.board),this.autoSolverFactoryProperty=new Y([Ur,s.safeSolverFactoryProperty,s.autoSolverFactoryProperty],(i,l,c)=>i?c:l),this.displayedAnnotationProperty=new Y([this.pendingHintActionProperty],i=>i?i.annotation:null);const a=this.clearPendingAction.bind(this);this.stackPositionProperty.lazyLink(a),K.lazyLink(a),this.disposeEmitter.addListener(()=>K.unlink(a)),this.selectedFaceColorHighlightProperty=new Y([t.stateProperty,K,this.pendingActionFaceColorProperty],(i,l,c)=>{if((l===H.FACE_COLOR_MATCH||l===H.FACE_COLOR_OPPOSITE)&&c){const u=i.getFacesWithColor(c.color);return{faceColor:c.color,face:c.face,faces:u}}return null}),this.disposeEmitter.addListener(()=>this.selectedFaceColorHighlightProperty.dispose()),this.selectedSectorEditProperty=new Y([t.stateProperty,K,this.pendingActionSectorProperty],(i,l,c)=>l===H.SECTOR_STATE&&c?{sector:c,currentState:i.getSectorState(c)}:null),this.disposeEmitter.addListener(()=>this.selectedSectorEditProperty.dispose());{const i=t.stateProperty.value.clone();xt(t.board,i,this.style.safeSolverFactoryProperty.value),t.stateProperty.value=i}this.stack=[this.getSnapshot(null,t.stateProperty.value)],this.stackLengthProperty.value=1,this.currentSnapshotProperty=new Y([this.stackLengthProperty,this.stackPositionProperty],()=>this.stack[this.stackPositionProperty.value]),this.hasErrorProperty=new Y([this.currentSnapshotProperty],i=>!i.correctnessState.isCorrect()),this.correctnessStateProperty=new Y([this.currentSnapshotProperty],i=>i.correctnessState),this.isSolvedProperty=new Y([this.currentSnapshotProperty],i=>{if(i.state.getWeirdEdges().length||i.state.hasInvalidFaceColors())return!1;const l=i.state.getSimpleRegions();return l.length===1&&l[0].isSolved}),this.addAutoSolveDelta(),this.updateState(),this.undoPossibleProperty=new Y([this.stackPositionProperty],i=>i>0),this.redoPossibleProperty=new Y([this.stackPositionProperty,this.stackLengthProperty],(i,l)=>i<l-1);const n=()=>this.onAutoSolveChange();this.autoSolverFactoryProperty.lazyLink(n),this.style.safeSolverFactoryProperty.lazyLink(n),this.disposeEmitter.addListener(()=>{this.autoSolverFactoryProperty.unlink(n),this.style.safeSolverFactoryProperty.unlink(n)})}clearPendingAction(){this.pendingActionFaceColorProperty.value=null,this.pendingActionSectorProperty.value=null}step(t){this.isSolvedProperty.value||(this.timeElapsedProperty.value+=Math.min(t,5),localStorage.setItem("timeElapsedProperty",JSON.stringify(this.timeElapsedProperty.value)))}updateState(){this.clearPendingHint(),this.puzzle.stateProperty.value=this.stack[this.stackPositionProperty.value].state,setTimeout(()=>{localStorage.setItem("puzzleString",js(this.puzzle))},0)}wipeStackTop(){for(;this.stack.length>this.stackPositionProperty.value+1;)this.stack.pop();this.stackLengthProperty.value=this.stack.length}pushTransitionAtCurrentPosition(t){this.wipeStackTop(),this.stack.push(t),this.stackLengthProperty.value=this.stack.length,this.stackPositionProperty.value++}applyUserActionToStack(t,o){const r=(o==null?void 0:o.forceDirty)||t instanceof rt;let a=this.stack[this.stackPositionProperty.value].state;o!=null&&o.erase&&(a=a.clone(),o.erase(a));let n=new Set;const i=u=>{n.add(u)};let l=a.createDelta();try{if(l.edgeStateChangedEmitter.addListener(i),bt(this.autoSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(i),o!=null&&o.checkAutoSolve&&!(o!=null&&o.checkAutoSolve(l)))throw new st("Auto-solver did not respect user action")}catch(u){if(n=new Set,u instanceof te||u instanceof st)u instanceof te?console.log("error"):u instanceof st&&console.log("skipping autosolve due to undo"),l=a.createDelta(),l.edgeStateChangedEmitter.addListener(i),bt(this.style.safeSolverFactoryProperty.value,this.puzzle.board,l,()=>{t.apply(l)},r),l.edgeStateChangedEmitter.removeListener(i);else throw u}const c=a.clone();l.apply(c),this.pushTransitionAtCurrentPosition(this.getSnapshot(t,c));for(const u of n)(!(o!=null&&o.excludedEdges)||!o.excludedEdges.has(u))&&(console.log("autosolved an edge"),this.edgeAutoSolvedEmitter.emit(u))}computeCorrectnessState(t=this.puzzle.stateProperty.value){return Wr.getCorrectnessState(this.puzzle.board,t,this.puzzle.solution.solvedState)}getSnapshot(t,o){return new Js(this.puzzle.board,t,o,this.computeCorrectnessState(o))}addAutoSolveDelta(){const t=this.puzzle.stateProperty.value.createDelta();try{if(Je(this.autoSolverFactoryProperty.value,this.puzzle.board,t,!0),!t.isEmpty()){const o=this.puzzle.stateProperty.value.clone();t.apply(o),this.pushTransitionAtCurrentPosition(this.getSnapshot(new rt,o))}}catch(o){if(!(o instanceof te))throw o}}onAutoSolveChange(){const t=this.stack[this.stackPositionProperty.value];t.action&&this.stackPositionProperty.value--,this.applyUserActionToStack(t.action||new rt,{forceDirty:!0}),this.updateState()}onUserUndo(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value--,this.updateState())}onUserRedo(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value++,this.updateState())}onUserUndoAll(){this.stackPositionProperty.value>0&&(this.stackPositionProperty.value=0,this.updateState())}onUserRedoAll(){this.stackPositionProperty.value<this.stackLengthProperty.value-1&&(this.stackPositionProperty.value=this.stackLengthProperty.value-1,this.updateState())}onUserEscape(){this.clearPendingAction(),this.clearPendingHint()}getNewEdgeState(t,o,r){r&&(o=2-o);const s=Ye.value.edgePressStyles[o];return console.log(Ye.value,s,o,t),s.apply(t)}getNewFaceColorState(t,o,r){r&&(o=2-o);const s=Ye.value.faceColorPressStyles[o];return console.log(Ye.value,s,o,t),s.apply(t)}getNextEdgeState(t,o){const r=ze.value,s=this.puzzle.stateProperty.value.getEdgeState(t);return r?V.WHITE:this.getNewEdgeState(s,o,K.value===H.EDGE_STATE_REVERSED)}getNextFaceColorState(t,o){const r=this.puzzle.stateProperty.value.getOutsideColor(),s=this.puzzle.stateProperty.value.getInsideColor(),a=this.puzzle.stateProperty.value.getFaceColor(t),n=a===r?b.OUTSIDE:a===s?b.INSIDE:b.UNDECIDED;return this.getNewFaceColorState(n,o,K.value===H.FACE_COLOR_OUTSIDE)}onUserEdgePress(t,o){const r=this.puzzle.stateProperty.value.getEdgeState(t),s=this.getNextEdgeState(t,o);if(r!==s){const a=this.stack[this.stackPositionProperty.value];a.action&&a.action instanceof Tt&&a.action.edge===t&&this.stackPositionProperty.value--;let n;r!==V.WHITE&&(n=l=>{new We(t).apply(l)});const i=new Tt(t,s);this.applyUserActionToStack(i,{erase:n,checkAutoSolve:l=>l.getEdgeState(t)===s,excludedEdges:new Set([t])}),this.updateState()}}onUserEdgeDragStart(t,o){if(this.lineDrag.lineDragStateProperty.value!==ie.NONE)return;const r=this.getNextEdgeState(t,o);r===V.BLACK?this.lineDrag.onLineDragStart(t):this.lineDrag.onPaintDragStart(t,r),this.updateEdgeDrag()}onUserEdgeDrag(t,o){this.lineDrag.onDrag(t,o)&&this.updateEdgeDrag()}onUserEdgeDragEnd(){this.lineDrag.onDragEnd()}updateEdgeDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof Ze&&(t.action.dragIndex===this.lineDrag.dragIndex||t.action.firstEdge===this.lineDrag.firstEdge)&&this.stackPositionProperty.value--,k()&&L(this.lineDrag.lineDragStateProperty.value!==ie.NONE,"line drag state should not be NONE");const o=this.lineDrag.lineDragStateProperty.value===ie.LINE_DRAG?this.lineDrag.edgeStack.slice():Array.from(this.lineDrag.paintEdgeSet),r=this.lineDrag.lineDragStateProperty.value===ie.LINE_DRAG?V.BLACK:this.lineDrag.paintEdgeState,s=o.filter(i=>this.puzzle.stateProperty.value.getEdgeState(i)!==V.WHITE),a=new qo(s.map(i=>new We(i))),n=new Ze(this.lineDrag.firstEdge,o,r,this.lineDrag.dragIndex);this.applyUserActionToStack(n,{erase:i=>a.apply(i),checkAutoSolve:i=>o.every(l=>i.getEdgeState(l)===r),excludedEdges:new Set(this.puzzle.board.edges)}),this.updateState()}onUserFacePress(t,o){const r=ze.value,s=K.value;if(r){if(t){const a=new He(t);this.applyUserActionToStack(a,{erase:n=>a.apply(n)}),this.updateState()}}else if(s===H.FACE_COLOR_MATCH||s===H.FACE_COLOR_OPPOSITE){let a=K.value===H.FACE_COLOR_MATCH;o===2&&(a=!a);const n=t?this.puzzle.stateProperty.value.getFaceColor(t):this.puzzle.stateProperty.value.getOutsideColor(),i=this.pendingActionFaceColorProperty.value;if(i){if(t!==i.face){const l=i.color;l!==n&&(a?this.applyUserActionToStack(new qe(re(this.puzzle.stateProperty.value,n),re(this.puzzle.stateProperty.value,l))):this.applyUserActionToStack(new gt(re(this.puzzle.stateProperty.value,n),re(this.puzzle.stateProperty.value,l))))}this.pendingActionFaceColorProperty.value=null,this.updateState()}else this.pendingActionFaceColorProperty.value={face:t,color:n}}else if((s===H.FACE_COLOR_OUTSIDE||s===H.FACE_COLOR_INSIDE)&&t){const a=this.puzzle.stateProperty.value.getOutsideColor(),n=this.puzzle.stateProperty.value.getInsideColor(),i=this.puzzle.stateProperty.value.getFaceColor(t),l=i===a?b.OUTSIDE:i===n?b.INSIDE:b.UNDECIDED,c=this.getNewFaceColorState(l,o,s===H.FACE_COLOR_OUTSIDE);if(l!==c){const u=this.stack[this.stackPositionProperty.value];u.action&&u.action instanceof Dt&&u.action.face===t&&this.stackPositionProperty.value--;let C;const w=new He(t);l!==b.UNDECIDED&&(C=p=>{w.apply(p)}),c===b.UNDECIDED?this.applyUserActionToStack(w,{erase:C}):this.applyUserActionToStack(new Dt(t,c===b.INSIDE),{erase:C}),this.updateState()}}}onUserFaceDragStart(t,o){if(this.faceDrag.faceDragStateProperty.value!==$.NONE)return;const r=K.value;if(ze.value)this.faceDrag.onAbsolutePaintStart(t,b.UNDECIDED);else if(r===H.FACE_COLOR_MATCH||r===H.FACE_COLOR_OPPOSITE)r===H.FACE_COLOR_MATCH==(o===0)?this.faceDrag.onMakeSameStart(t):this.faceDrag.onMakeOppositeStart(t);else if(r===H.FACE_COLOR_INSIDE||r===H.FACE_COLOR_OUTSIDE){const s=t?this.getNextFaceColorState(t,o):H.FACE_COLOR_OUTSIDE;this.faceDrag.onAbsolutePaintStart(t,s)}this.updateFaceDrag()}onUserFaceDrag(t,o){this.faceDrag.onDrag(t,o)&&this.updateFaceDrag()}onUserFaceDragEnd(){if(this.faceDrag.isNoOpSingleFace()){const t=K.value===H.FACE_COLOR_MATCH==(this.faceDrag.faceDragStateProperty.value===$.MAKE_SAME);this.onUserFacePress([...this.faceDrag.paintFaceSet][0],t?0:2)}this.faceDrag.onDragEnd()}updateFaceDrag(){const t=this.stack[this.stackPositionProperty.value];t.action&&t.action instanceof Qe&&t.action.dragIndex===this.faceDrag.dragIndex&&this.stackPositionProperty.value--;const o=this.faceDrag.faceDragStateProperty.value;if(k()&&L(o!==$.NONE,"line drag state should not be NONE"),this.faceDrag.isNoOpSingleFace())return;const r=[...this.faceDrag.paintFaceSet],s=o===$.MAKE_OPPOSITE?[...this.faceDrag.paintFaceOppositeSet]:[],a=this.faceDrag.absolutePaintState,n=o===$.ABSOLUTE_PAINT,i=new Qe(r,s,n,a,this.faceDrag.dragIndex);this.applyUserActionToStack(i,{checkAutoSolve:l=>{if(r.length){const c=r[0]?l.getFaceColor(r[0]):l.getOutsideColor();if(r.some(u=>(u?l.getFaceColor(u):l.getOutsideColor())!==c))return!1;if(s.length){const u=s[0]?l.getFaceColor(s[0]):l.getOutsideColor();if(s.some(C=>(C?l.getFaceColor(C):l.getOutsideColor())!==u)||l.getOppositeFaceColor(c)!==u)return!1}}return!0}}),this.updateState()}onUserSectorPress(t,o){if(ze.value){const s=new St(t);this.applyUserActionToStack(s,{erase:a=>s.apply(a)}),this.updateState()}else this.pendingActionSectorProperty.value=t}onUserSectorSet(t,o){this.applyUserActionToStack(new Jo(t,o)),this.pendingActionSectorProperty.value=null,this.updateState()}onUserRequestSolve(){const t=this.puzzle.stateProperty.value;if(!Zo(t))if(_s.value){const o=t.clone();Je(wr,this.puzzle.board,o,!0),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Ot,o)),this.updateState()}else{const o=ar(this.puzzle.board,this.puzzle.stateProperty.value,{maxIterations:1e4,failOnMultipleSolutions:!0});if(o.length===1){const r=this.puzzle.stateProperty.value.clone();o[0].forEach(s=>{r.setEdgeState(s,V.BLACK)}),xt(this.puzzle.board,r,this.style.safeSolverFactoryProperty.value),this.pushTransitionAtCurrentPosition(this.getSnapshot(new Ot,r)),this.updateState()}else o.length===0?console.log("No solution found"):console.log("Multiple solution found?!?")}}clearPendingHint(){this.hintStateProperty.value=le.DEFAULT,this.pendingHintActionProperty.value=null,this.hintWorkerMessageID=0}onUserClearHint(){this.clearPendingHint()}onHintReceived(t){this.hintStateProperty.value=t?le.FOUND:le.NOT_FOUND,t&&(this.pendingHintActionProperty.value=t)}onUserRequestHint(){if(this.clearPendingAction(),this.isSolvedProperty.value||this.pendingHintActionProperty.value)return;const t=J.allowEdgeEditProperty.value,o=J.allowFaceColorEditProperty.value,r=J.allowSectorEditProperty.value,s=J.vertexStateVisibleProperty.value,a=J.faceStateVisibleProperty.value;this.hintWorkerMessageID=Math.random();const n=io();if(!this.addedHintListener){this.addedHintListener=!0;const i=l=>{if(l.data.type==="hint-response"&&l.data.id===this.hintWorkerMessageID){const c=l.data.action?$o(this.puzzle.board,l.data.action):null;this.onHintReceived(c)}};n.addEventListener("message",i),this.disposeEmitter.addListener(()=>self.removeEventListener("message",i))}if(n.postMessage({type:"hint-request",id:this.hintWorkerMessageID,solveEdges:t,solveColors:o,solveSectors:r,solveVertexState:s,solveFaceState:a,serializedSolvablePuzzle:Ks(this.puzzle)}),je.value)this.hintStateProperty.value=le.SEARCHING;else{this.hintStateProperty.value=le.LOADING;const i=l=>{l&&(this.hintStateProperty.value===le.LOADING&&(this.hintStateProperty.value=le.SEARCHING),je.unlink(i))};je.link(i)}}onUserApplyHint(){const t=this.pendingHintActionProperty.value;t&&(this.clearPendingHint(),this.applyUserActionToStack(new Gs(t)),this.updateState())}onUserHintKey(){this.pendingHintActionProperty.value?this.onUserApplyHint():this.onUserRequestHint()}}class Js{constructor(e,t,o,r){this.board=e,this.action=t,this.state=o,this.correctnessState=r}}class Zs extends W{constructor(e,t,o,r){super({pickable:!1}),this.board=e;const s=e.faces.map(l=>null),a=()=>{const l=[],c=o.faceValueStyleProperty.value,u=o.theme.faceValueColorProperty.value,C=o.theme.faceValueCompletedColorProperty.value,w=o.theme.faceValueErrorColorProperty.value,p=o.theme.faceValueRatioColorProperty.value,g=o.faceStateVisibleProperty.value,S=Mt.value,y=Bt.value;this.visible=!g;for(let E=0;E<e.faces.length;E++){const P=s[E];if(P!==null){const v=e.faces[E],x=new Bo("",Ut({subScale:.7},r==null?void 0:r.textOptions)),F=we.multilink([t],T=>{let O,A,D=!1,M=!1;if(P===null)O="",A=null;else{let m=0,I=0;for(const N of v.edges){const j=T.getEdgeState(N);j===V.BLACK?m++:j===V.WHITE&&I++}if(c==="static"||P===0)O=`${P}`;else if(c==="remaining")O=`${P-m}`,D=m>0;else if(c==="ratio")P-m===0?O="0":(O=`${P-m}<sub style="color: ${p.toCSS()};">/<sub>${I}</sub></sub>`,M=!0),D=m>0;else throw new Error(`unhandled faceValueStyle: ${c}`);m>P&&y?A=w:m===P&&S?A=C:A=u}x.string=O,x.fill=A,x.maxWidth=M?.8:.9,x.maxHeight=M?.8:.9,x.center=v.viewCoordinates});x.disposeEmitter.addListener(()=>F.dispose()),l.push(x)}}this.children.forEach(E=>E.dispose()),this.children=l},n=we.multilink([t],l=>{let c=!1;for(let u=0;u<e.faces.length;u++){const C=l.getFaceValue(e.faces[u]);C!==s[u]&&(c=!0,s[u]=C)}c&&a()}),i=we.multilinkAny([o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty,Mt,Bt],a);this.disposeEmitter.addListener(()=>{n.dispose(),i.dispose(),this.children.forEach(l=>l.dispose())})}}const $s=(h,e,t)=>{const o=new Le({mouseButton:0,fire:a=>{var n;return e&&e((n=a.domEvent)!=null&&n.shiftKey?2:0)}}),r=new Le({mouseButton:2,fire:a=>{var n;return e&&e((n=a.domEvent)!=null&&n.shiftKey?0:2)}}),s=new Le({mouseButton:1,fire:a=>e&&e(1)});h.addInputListener({down:a=>{eo.value===Be.DRAG_ONLY&&t&&t(a)}}),h.addInputListener(o),h.addInputListener(r),h.addInputListener(s),h.cursor="pointer",h.disposeEmitter.addListener(()=>{o.dispose(),r.dispose(),s.dispose()})};class tt extends W{constructor(e,t,o,r){const s=Ue()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceBackgroundDragStartListener:()=>{},noninteractive:!1},r);super({pickableProperty:wt}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!s.noninteractive&&$s(this,p=>s.facePressListener(null,p),s.faceBackgroundDragStartListener);const a=e.map(p=>p.start.viewCoordinates),n=s.useBackgroundOffsetStroke,i=s.backgroundOffsetDistance,c=Ft(a)>0?-i:i,u=p=>{const g=new zo;g.addShape(0,p),g.computeSimplifiedFaces(),g.computeFaceInclusion(E=>E[0]>0);const S=g.createFilledSubGraph(),y=S.facesToShape();return g.dispose(),S.dispose(),y},C=tt.getOffsetBackgroundShape(e,n,i),w=t.map(p=>{const g=p.map(y=>y.start.viewCoordinates),S=U.polygon(g);if(n)return u(S.getOffsetShape(c));{const E=S.getStrokedShape(new Vt({lineWidth:2*i})).subpaths.map(P=>new U([P]));return u(fe.minBy(E,P=>P.getArea()))}});this.children=[new _(C,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...w.map(p=>new _(p,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const r=e.map(i=>i.start.viewCoordinates),s=U.polygon(r),n=Ft(r)>0?-o:o;if(t)return s.getOffsetShape(n).getSimplifiedAreaShape();{const i=s.getStrokedShape(new Vt({lineWidth:2*o})),l=i.subpaths.map(c=>new U([c]));try{return i.bounds.width===9.718028227819117?U.bounds(i.bounds):fe.maxBy(l,c=>c.getArea()).getSimplifiedAreaShape()}catch{return U.bounds(i.bounds)}}}}class Se extends W{static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,a=o.minus(r),n=s.minus(r),i=a.normalized(),c=n.normalized().minus(i).angle+Math.PI/2,u=e.face?e.face.viewCoordinates:Z.createPolar(t,c).plus(r),C=o.average(r),w=s.average(r);return U.polygon([C,r,w,u]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,a=o.minus(r),n=s.minus(r),i=a.normalized(),l=a.angle;let c=n.angle;return c<l&&(c+=2*Math.PI),new U().moveToPoint(r).lineToPoint(i.timesScalar(t).plus(r)).arcPoint(r,t,l,c,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===B.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===B.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===B.NOT_ONE?t.theme.sectorNotOneColorProperty:e===B.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}}f(Se,"nameMap",new Map([[B.NONE,"Invalid"],[B.ONLY_ZERO,"No Lines"],[B.ONLY_ONE,"Only One Line"],[B.ONLY_TWO,"Both Lines"],[B.NOT_ZERO,"At Least One Line"],[B.NOT_ONE,"Zero or Two Lines"],[B.NOT_TWO,"Less Than Two Lines"],[B.ANY,"Any Lines"]]));class Qs extends ft{constructor(e,t){super(e.halfEdges,o=>Se.getSectorBaseShape(o,t.backgroundOffsetDistance),t.sectorPressListener)}}const Wt=[.02,.02],be=.2,Ge=.02;class ea extends W{constructor(e,t,o){const r=new _(null,{lineWidth:.025,lineCap:"butt",stroke:Se.getStrokeFromStyle(B.NOT_ZERO,o)}),s=new _(null,{lineWidth:.025,lineCap:"butt",stroke:Se.getStrokeFromStyle(B.NOT_ONE,o)}),a=new _(null,{lineWidth:.025,lineCap:"butt",stroke:Se.getStrokeFromStyle(B.NOT_TWO,o)}),n=new _(null,{lineWidth:.025,lineCap:"butt",stroke:Se.getStrokeFromStyle(B.ONLY_ONE,o)});super({pickable:!1,visibleProperty:o.sectorsVisibleProperty,children:[r,s,a,n]}),this.board=e;const i=e.halfEdges.map(u=>B.NONE),l=e.edges.map(u=>V.BLACK),c=we.multilink([t,o.sectorsVisibleProperty],(u,C)=>{if(C){let w=!1;for(let p=0;p<e.halfEdges.length;p++){const g=u.getSectorState(e.halfEdges[p]);g!==i[p]&&(w=!0,i[p]=g)}for(let p=0;p<e.edges.length;p++){const g=u.getEdgeState(e.edges[p]);g!==l[p]&&(w=!0,l[p]=g)}if(w){const p=new U,g=new U,S=new U,y=new U;for(let E=0;E<e.halfEdges.length;E++){const P=i[E];if(P!==B.NOT_ZERO&&P!==B.NOT_ONE&&P!==B.NOT_TWO&&P!==B.ONLY_ONE)continue;const v=e.halfEdges[E],x=u.getEdgeState(v.edge),F=u.getEdgeState(v.next.edge);if(x!==V.WHITE||F!==V.WHITE)continue;if(P===B.NOT_ONE){const q=v.end.edges.filter(ne=>u.getEdgeState(ne)===V.BLACK),oe=v.end.edges.filter(ne=>u.getEdgeState(ne)===V.WHITE);if(q.length===0&&oe.length===2)continue}const T=v.start.viewCoordinates,O=v.end.viewCoordinates,A=v.next.end.viewCoordinates,D=T.minus(O),M=A.minus(O),m=D.normalized(),I=D.angle;let N=M.angle;N<I&&(N+=2*Math.PI);const j=(q,oe)=>(q.moveToPoint(m.timesScalar(oe).add(O)),q.arcPoint(O,oe,I,N,!0),q);if(P===B.ONLY_ONE)j(y,be);else if(P===B.NOT_ONE)j(g,be-Ge),j(g,be+Ge);else if(P===B.NOT_ZERO){const q=new U;j(q,be-Ge),j(q,be+Ge);const oe=q.getDashedShape(Wt,0);p.subpaths.push(...oe.subpaths)}else if(P===B.NOT_TWO){const q=new U;j(q,be);const oe=q.getDashedShape(Wt,0);S.subpaths.push(...oe.subpaths)}}r.shape=p.makeImmutable(),s.shape=g.makeImmutable(),a.shape=S.makeImmutable(),n.shape=y.makeImmutable()}}});this.disposeEmitter.addListener(()=>c.dispose())}}class ta extends W{constructor(e,t,o,r){let s=[];try{let a=new U;for(const i of e.faces)a.polygon(i.vertices.map(l=>l.viewCoordinates));if(e.faceColor.colorState===b.OUTSIDE)try{const i=U.polygon(t.outerBoundary.map(u=>u.start.viewCoordinates)),c=tt.getOffsetBackgroundShape(t.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(i);a=a.bounds.isValid()?a.shapeUnion(c):c}catch(i){console.error(i)}const n=new _(a.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(n)}catch(a){console.error(a)}super({children:s}),this.selectedFaceColorHighlight=e}}class oa extends W{constructor(e,t,o,r){const s=[],a=[],n=e.sector,i=e.currentState,l=Se.getSectorArcShape(n,.5),c=new _(l.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(c);const u=[];if(i===B.ANY&&(u.push(B.NOT_ZERO),u.push(B.NOT_ONE),u.push(B.NOT_TWO)),i.one&&i!==B.ONLY_ONE&&u.push(B.ONLY_ONE),u.length){const C=u.map(g=>{const S=Se.getStrokeFromStyle(g,o);return new yr({accessibleName:Se.nameMap.get(g),content:new Wo(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(n,g)},buttonAppearanceStrategy:ko,baseColor:S,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});a.push(...C);const w=new Qt(new Gt({children:C,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});a.push(w);const p=.1;s.push(w),w.centerBottom=c.centerTop.plusXY(0,-.15),w.top<t.top+p&&(w.centerTop=c.centerBottom.plusXY(0,.15)),w.left<t.left+p&&(w.left=t.left+p),w.right>t.right-p&&(w.right=t.right-p)}super({children:s}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{a.forEach(C=>C.dispose())})}}class ra extends W{constructor(t,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});f(this,"simpleRegionNodeMap",new Map);f(this,"regionIdMap",new Map);f(this,"weirdEdgeNodeMap",new Map);f(this,"regionContainer",new W);f(this,"weirdEdgeContainer",new W);f(this,"adjacentFacesMap",new Map);f(this,"weirdEdgeColorProperty");this.board=t,this.style=r,this.weirdEdgeColorProperty=new Y([this.style.theme.edgeWeirdColorProperty,this.style.theme.blackLineColorProperty,qs],(n,i,l)=>l?n:i),this.disposeEmitter.addListener(()=>this.weirdEdgeColorProperty.dispose()),t.faces.forEach(n=>{this.adjacentFacesMap.set(n,n.edges.map(i=>i.getOtherFace(n)).filter(i=>i!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(n=>this.addRegion(n)),o.value.getWeirdEdges().forEach(n=>this.addWeirdEdge(n)),this.updateHues();const s=(n,i)=>{const l=i.getSimpleRegions(),c=n.getSimpleRegions(),u=i.getWeirdEdges(),C=n.getWeirdEdges(),w=[],p=[];jt(l,c,w,p,[]);const S=new Set(w);for(const y of p)if(this.regionIdMap.has(y.id)){const E=this.regionIdMap.get(y.id);this.replaceRegion(E,y),S.delete(E)}else this.addRegion(y);for(const y of S)this.removeRegion(y);for(const y of u)C.includes(y)||this.removeWeirdEdge(y);for(const y of C)u.includes(y)||this.addWeirdEdge(y);(p.length||w.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const a=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(a),r.edgesHaveColorsProperty.lazyLink(a),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(a),r.edgesHaveColorsProperty.unlink(a)})}addRegion(t){const o=new Ne(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){k()&&L(t.id===o.id);const r=this.simpleRegionNodeMap.get(t);r.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=new Ho(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.weirdEdgeColorProperty});{const a=n=>{s.lineCap=n};this.style.joinedLinesCapProperty.link(a),s.disposeEmitter.addListener(()=>this.style.joinedLinesCapProperty.unlink(a))}this.weirdEdgeNodeMap.set(t,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(t){this.weirdEdgeNodeMap.get(t).dispose(),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new Z(0,0),r=()=>{for(const c of t)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(1,0)},s=new Map,a=[];this.board.faces.forEach(c=>{s.set(c,[])});for(const c of t){const u=new Set;for(const w of c.simpleRegion.edges)for(const p of w.faces)u.add(p);const C=new Set;for(const w of u){C.add(w);for(const p of this.adjacentFacesMap.get(w))C.add(p)}for(const w of C){const p=s.get(w);if(p.length)for(const g of p){let S=!1;for(const y of a)if(y.a===g&&y.b===c){y.weight++,S=!0;break}S||a.push({a:g,b:c,weight:1})}p.push(c)}}const n=new Map;for(const c of t)n.set(c,Z.ZERO.copy());const i=(c,u,C)=>{const w=n.get(c),p=n.get(u),g=c.hueVector.dot(u.hueVector),S=o.set(u.hueVector).subtract(c.hueVector);if(S.magnitude>1e-9){S.normalize();const y=.3,E=C*((Math.max(y,g)-y)/(1-y))**3;S.multiplyScalar(E),w.subtract(S),p.add(S)}};let l=1;for(let c=0;c<100;c++){l*=.99;for(const u of t)n.get(u).setXY(0,0);for(const u of a){const C=u.a,w=u.b,p=u.weight;i(C,w,p)}if(t.length<8)for(let u=0;u<t.length;u++){const C=t[u];for(let w=u+1;w<t.length;w++)i(C,t[w],.2)}for(const u of t){const C=n.get(u);C.multiplyScalar(l/u.edgeCount),u.hueVector.add(C),n.get(u).setXY(0,0)}r()}for(const c of t)c.updateHue()}}class Ne extends _{constructor(t,o){const r=Z.createPolar(1,Ke.nextDoubleBetween(0,2*Math.PI));super(Ne.toShape(t),{stroke:Ne.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});f(this,"hueVector");f(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=r,this.edgeCount=t.edges.length;const s=n=>{this.lineJoin=n};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const a=n=>{this.lineCap=n};o.joinedLinesCapProperty.link(a),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(a))}updateHue(){this.stroke=Ne.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:Z.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=Ne.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return k()&&L(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(t){const o=new U;let r=!0;for(const s of t.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class sa extends W{constructor(e,t,o){super({pickable:!1}),this.vertex=e;const r=.12,a=e.edges.map(w=>w.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(w=>w.times(r)),i=U.polygon(Ro.grahamScan([Z.ZERO,...a],!1)).getOffsetShape(-.05),l=new _(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),c=new _(i,{translation:e.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[l,...a.map(w=>new Yt({radius:.02,translation:w,fill:o.theme.vertexStatePointProperty}))]});let u=null;const C=we.multilink([t,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(w,p,g)=>{const S=()=>{this.children=[]};if(!p){S();return}const y=w.getVertexState(e);if(!g){let E=!1,P=!1;const v=new Set;for(const F of e.edges){const T=w.getEdgeState(F);E=E||T===V.BLACK,P=P||T===V.WHITE,T===V.WHITE&&v.add(F)}if(E||!P){S();return}if(pt.fromLookup(e,(F,T)=>v.has(F)&&v.has(T),!0).equals(y)){S();return}}if(!u||!u.equals(y)){u=y;const E=new U;for(const P of y.getAllowedPairs()){const v=x=>x.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(r);E.moveToPoint(v(P[0])),E.lineToPoint(v(P[1]))}y.allowsEmpty()&&(E.moveTo(.03,0),E.circle(Z.ZERO,.03),E.close()),E.makeImmutable(),l.shape=E}this.children=[c]});this.disposeEmitter.addListener(()=>C.dispose())}}class aa extends W{constructor(e,t,o,r){super({pickable:!1});const s=we.multilink([t,r.vertexStateVisibleProperty],(n,i)=>{this.children.forEach(l=>l.dispose()),this.children=[],i&&e.vertices.forEach(l=>{this.addChild(new sa(l,t,r))})});this.disposeEmitter.addListener(()=>s.dispose());const a=n=>{this.visible=!n};o.link(a),this.disposeEmitter.addListener(()=>{o.unlink(a),this.children.forEach(n=>n.dispose())})}}const ia=.03,na=.05;class la extends _{constructor(e,t,o,r){super(null,{pickable:!1,fill:r.theme.vertexColorProperty});const s=e.edges.map(l=>V.BLACK);let a=r.vertexStyleProperty.value,n=r.smallVertexProperty.value;const i=we.multilink([t,o,r.verticesVisibleProperty,r.vertexStyleProperty,r.smallVertexProperty],(l,c,u,C,w)=>{if(this.visible=!c&&u,this.visible){let p=!1;for(let g=0;g<e.edges.length;g++){const S=l.getEdgeState(e.edges[g]);S!==s[g]&&(p=!0,s[g]=S)}if(a!==C&&(a=C,p=!0),n!==w&&(n=w,p=!0),p){const g=new U;for(let S=0;S<e.vertices.length;S++){const y=e.vertices[S];if(y.edges.every(E=>l.getEdgeState(E)!==V.BLACK)){const E=y.viewCoordinates,P=w?ia:na;C==="round"?(g.moveTo(E.x+P,E.y),g.arc(E.x,E.y,P,0,2*Math.PI,!1)):C==="square"?g.rect(E.x-P,E.y-P,2*P,2*P):k()&&L(!1,`unhandled vertex style: ${C}`)}}this.shape=g}}});this.disposeEmitter.addListener(()=>i.dispose())}}class Ht extends W{constructor(t,o){const r=Ue()({textOptions:{font:ut,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},onEdgeDragStart:()=>{},onEdgeDrag:()=>{},onEdgeDragEnd:()=>{},facePressListener:()=>{},faceBackgroundDragStartListener:T=>this.onFaceBackgroundDragStart(T),onFaceDragStart:()=>{},onFaceDrag:()=>{},onFaceDragEnd:()=>{},sectorPressListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,selectedFaceColorHighlightProperty:new Me(null),selectedSectorEditProperty:new Me(null),style:J,noninteractive:!1,delayEdgeInteractionEmitter:new ge},o),s=r.style,a=new W({visibleProperty:s.faceColorsVisibleProperty}),n=new W({pickableProperty:Us}),i=new W({pickableProperty:Ws}),l=new W({pickableProperty:Ms}),c=new W({pickableProperty:Hs}),u=new W,C=new W({pickable:!1}),w=new W({pickable:!1}),p=new W({renderer:Yo.chromium?"canvas":null,pickable:null}),g=new W({pickable:!1}),S=new W,y=new Y([t.stateProperty],T=>{if(T.getWeirdEdges().length||T.hasInvalidFaceColors())return!1;const O=T.getSimpleRegions();return O.length===1&&O[0].isSolved});n.addChild(new Zs(t.board,t.stateProperty,s,r));let E=null;r.noninteractive||(E=new Lr(t.board,r),n.addChild(E)),w.addChild(new kr(t.board,t.stateProperty,y,s));const P=new tt(t.board.outerBoundary,t.board.innerBoundaries,s,r);c.addChild(new la(t.board,t.stateProperty,y,s)),C.addChild(new aa(t.board,t.stateProperty,y,s)),l.addChild(new br(t.board,t.stateProperty,y,s)),r.noninteractive||l.addChild(new Or(t.board,r.delayEdgeInteractionEmitter,r)),i.addChild(new ea(t.board,t.stateProperty,s)),r.noninteractive||i.addChild(new Qs(t.board,r)),u.addChild(new ra(t.board,t.stateProperty,s));super(Ut({children:[P,a,n,i,l,c,u,C,w,g,S,p]},r));f(this,"annotationContainer");f(this,"backgroundNode");f(this,"onFaceBackgroundDragStart");f(this,"faceColorViewNode",null);this.puzzle=t;const v=T=>{T?(this.faceColorViewNode=new Ar(t.board,t.stateProperty,s),a.addChild(this.faceColorViewNode)):this.faceColorViewNode&&(this.faceColorViewNode.dispose(),this.faceColorViewNode=null)};s.faceColorsVisibleProperty.link(v),E?this.onFaceBackgroundDragStart=T=>{var O;return(O=E.triggerDrag)==null?void 0:O.call(E,T)}:this.onFaceBackgroundDragStart=()=>{},this.annotationContainer=p;const x=T=>{g.children.forEach(O=>O.dispose()),T&&g.addChild(new ta(T,t.board,s,r))};r.selectedFaceColorHighlightProperty.link(x),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(x));const F=T=>{S.children.forEach(O=>O.dispose()),T&&S.addChild(new oa(T,P,s,r))};r.selectedSectorEditProperty.link(F),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(F)),this.disposeEmitter.addListener(()=>{s.faceColorsVisibleProperty.unlink(v),[a,n,l,c,u,C,w,i].forEach(O=>{O.children.forEach(A=>A.dispose()),O.dispose()}),y.dispose(),P.dispose()}),this.backgroundNode=P}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}getDualColorViews(){var t;return((t=this.faceColorViewNode)==null?void 0:t.getDualColorViews())??null}}class Na extends W{constructor(e,t,o){const r=Ue()({style:J},o),s=t.getEmbeddedCompleteData(e.inputFeatureSet),a=t.getEmbeddedCompleteData(e.outputFeatureSet),n=new Ht(new At(t.smallBoard,s),{noninteractive:!0,style:r.style}),i=new Ht(new At(t.smallBoard,a),{noninteractive:!0,style:r.style}),l=n.getDualColorViews(),c=i.getDualColorViews();if(l&&c){const P=m=>m.faceCount>=r.style.faceColorThresholdProperty.value&&m.isUndecided(),v=m=>Math.min(...m.faces.map(I=>t.smallBoard.faces.indexOf(I))),x=fe.sortBy([...l].filter(P),v),F=fe.sortBy([...c].filter(P),v),T=new Map;for(const m of x)P(m)&&m.faces.forEach(I=>T.set(I,m));const O=[],A=new Map;for(const m of F){const I=m.faces.map(j=>T.get(j)).filter(fe.identity),N=fe.minBy(I,j=>j.faces.length*20+x.indexOf(j));N?A.set(m,N):(A.set(m,null),O.push(m))}const D=[...x,...fe.sortBy(O,v)],M=m=>{const I=D.indexOf(m);return k()&&L(I>=0,"view must be in the list"),Z.createPolar(1,5.5+2*Math.PI*I/D.length)};for(const m of x)m.overrideHueVector(M(m));for(const m of F){const I=A.get(m);I?m.overrideHueVector(M(I)):m.overrideHueVector(M(m))}}const u=e.highlander?new W({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(P=>new zt("?",{font:ut,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?r.style.theme.faceValueColorProperty:r.style.theme.faceValueCompletedColorProperty,center:P.viewCoordinates}))}):new W,w=t.tightBounds.dilated(.5),p=.5,g=U.roundRectangle(w.x,w.y,w.width,w.height,p,p),S=new W({children:[n,u],clipArea:g,localBounds:w}),y=new W({children:[i,u],clipArea:g,localBounds:w}),E=new Qt(new Gt({spacing:.2,children:[S,new Cr(0,0,20,0,{fill:r.style.theme.uiForegroundColorProperty,stroke:r.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),y]}),{cornerRadius:p*1.4,xMargin:.3,yMargin:.3,lineWidth:.05,stroke:null,fill:r.style.theme.patternAnnotationBackgroundColorProperty});r.children=[E],super(r),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{n.dispose(),i.dispose()})}}const ca=(h,e)=>{Je(Xt,h,e,!0)};class Ae{constructor(e,t,o,r,s,a,n,i,l,c){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=a,this.toSmallEdgeMap=n,this.toSmallSectorMap=i,this.tightBounds=l,this.expandedBounds=c}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const r=this.toSmallFaceMap.get(o);return k()&&L(r),r}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return k()&&L(s),s})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),r=this.toSmallSectorMap.get(o);return k()&&L(r),r}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&t.add(r)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=Qo.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof Er)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof Pr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,V.BLACK));else if(o instanceof mr)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,V.RED));else if(o instanceof vr)t.setSectorState(this.mapSector(o.sector),B.NOT_ZERO);else if(o instanceof Fr)t.setSectorState(this.mapSector(o.sector),B.NOT_ONE);else if(o instanceof Vr)t.setSectorState(this.mapSector(o.sector),B.NOT_TWO);else if(o instanceof Tr)t.setSectorState(this.mapSector(o.sector),B.ONLY_ONE);else if(o instanceof Dr){const r=(a,n)=>{const i=this.mapFace(a),l=this.mapFace(n),c=i?t.getFaceColor(i):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new qe(re(t,c),re(t,u)).apply(t)},s=(a,n)=>{const i=this.mapFace(a),l=this.mapFace(n),c=i?t.getFaceColor(i):t.getOutsideColor(),u=l?t.getFaceColor(l):t.getOutsideColor();new gt(re(t,c),re(t,u)).apply(t)};for(let a=1;a<o.primaryFaces.length;a++)r(o.primaryFaces[a-1],o.primaryFaces[a]);for(let a=1;a<o.secondaryFaces.length;a++)r(o.secondaryFaces[a-1],o.secondaryFaces[a]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return ca(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o,r){const s=ot.NOTHING.copy(),a=i=>{s.addPoint(t.getVertex(o.mapVertex(i)).viewCoordinates)};e.vertices.forEach(a);const n=i=>{if(r!=null&&r.sourceFaceFilter&&!r.sourceFaceFilter(i))return;const l=t.getFace(o.mapFace(i));l&&l.vertices.forEach(c=>s.addPoint(c.viewCoordinates))};return e.faces.forEach(n),e.edges.forEach(i=>{let l;if(i.isExit){if(r!=null&&r.sourceExitEdgeFilter&&!r.sourceExitEdgeFilter(i))return;l=o.mapExitEdges(i).map(c=>t.getEdge(c))}else l=[t.getEdge(o.mapNonExitEdge(i))];l.forEach(c=>{s.addPoint(c.start.viewCoordinates),s.addPoint(c.end.viewCoordinates)})}),s}static findBestEmbedding(e,t,o){const r=Go(e,t);if(r.length===0)return null;const s=ot.NOTHING.copy();o.vertices.forEach(l=>s.addPoint(l.viewCoordinates));const a=s.center;let n=null,i=Number.POSITIVE_INFINITY;for(let l=0;l<r.length;l++){const c=r[l],C=Ae.getEmbeddingBounds(e,t,c).center,w=a.distance(C);w<i&&(i=w,n=c)}return n}static getDisplayEmbedding(e,t,o,r,s){const a=Ae.getEmbeddingBounds(e,t,r,s),n=a.dilated(.5),i=o.faces.filter(S=>{const y=ot.NOTHING.copy();return S.vertices.forEach(E=>y.addPoint(E.viewCoordinates)),n.intersectsBounds(y)}),l=o.vertices.filter(S=>S.faces.some(y=>i.includes(y))),c=jo({vertices:l.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates})),faces:i.map(S=>({logicalCoordinates:S.logicalCoordinates,vertices:S.vertices.map(y=>({logicalCoordinates:y.logicalCoordinates,viewCoordinates:y.viewCoordinates}))}))}),u=new Ko(c),C=1e-6,w=new Map(i.map((S,y)=>{const E=u.faces.find(P=>P.viewCoordinates.equalsEpsilon(S.viewCoordinates,C));return k()&&L(E),[S,E]})),p=new Map(o.edges.map(S=>{const y=u.edges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,C)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,C)||E.start.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,C)&&E.end.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,C))??null;return y?[S,y]:null}).filter(S=>S!==null)),g=new Map(o.halfEdges.map(S=>{const y=u.halfEdges.find(E=>E.start.viewCoordinates.equalsEpsilon(S.start.viewCoordinates,C)&&E.end.viewCoordinates.equalsEpsilon(S.end.viewCoordinates,C))??null;return y?[S,y]:null}).filter(S=>S!==null));return k()&&L(r),new Ae(e,t,o,r,u,w,p,g,a,n)}static getOptionsForRule(e){const t=e.outputFeatureSet.getAffectedFaces(),o=e.outputFeatureSet.getAffectedEdges();return{sourceFaceFilter:r=>t.has(r),sourceExitEdgeFilter:r=>o.has(r)}}static getDisplayEmbeddingFromRule(e,t,o){return Ae.getDisplayEmbedding(e.patternBoard,t,t.board,o,Ae.getOptionsForRule(e))}}export{ba as $,$r as A,Qr as B,es as C,ts as D,Na as E,Nr as F,os as G,rs as H,ss as I,as as J,is as K,ns as L,ls as M,cs as N,ds as O,Ht as P,hs as Q,us as R,ps as S,gs as T,Ir as U,sa as V,Ur as W,zr as X,Yr as Y,Mt as Z,Bt as _,ma as a,qs as a0,Ye as a1,dt as a2,va as a3,Fa as a4,Oa as a5,_s as a6,ca as a7,K as a8,H as a9,ze as aa,eo as ab,Be as ac,js as ad,le as ae,Aa as af,Da as ag,$s as ah,J as ai,Ta as aj,xs as ak,Ae as al,Wr as am,Es as b,Ps as c,ms as d,Vs as e,Ia as f,vs as g,so as h,Os as i,bs as j,As as k,Is as l,Ns as m,Ls as n,ws as o,Rs as p,Gr as q,jr as r,Va as s,Kr as t,Xr as u,ks as v,_r as w,qr as x,Jr as y,Zr as z};
