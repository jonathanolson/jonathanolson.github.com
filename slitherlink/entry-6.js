var be=Object.defineProperty;var Fe=(w,h,r)=>h in w?be(w,h,{enumerable:!0,configurable:!0,writable:!0,value:r}):w[h]=r;var ne=(w,h,r)=>Fe(w,typeof h!="symbol"?h+"":h,r);import"./chunk-16.js";import{N as _,P as re,S as U,R as Pe,L as ae,T as K,D as Be,V as ce,H as j,A as se}from"./chunk-17.js";import{a6 as u,d as M,e as S,_ as k,a7 as pe,P as xe,a8 as q,S as Q,a9 as Me,p as Se,H as Ge,G as A,aa as le,I as qe,J as Le,L as He,K as Te,M as ze}from"./chunk-20.js";import{l as De,P as de,F as We,T as oe}from"./chunk-26.js";import{f as je,e as ie,F as O,a as L,B as Ae,R as T,S as Oe,g as Re,h as ke}from"./chunk-19.js";import{J as Je,B as $e,c as ge}from"./chunk-28.js";import{d as ue,s as Ue}from"./chunk-39.js";import{V as X}from"./chunk-22.js";import{P as R}from"./chunk-31.js";import{P as Y}from"./chunk-40.js";import"./chunk-18.js";class P extends u{constructor(r,n){const t=new Set,s=new Set;n.forEach(e=>{e.vertices.forEach(g=>{t.add(g)}),e.edges.forEach(g=>{s.add(g)})});const i=Array.from(s),a=[],c=[];for(const e of t)e.faces.every(g=>n.includes(g))?c.push(e):a.push(e);const d=[...c,...a];super({numNonExitVertices:c.length,numExitVertices:a.length,type:"faces",vertexLists:n.map(e=>e.vertices.map(g=>d.indexOf(g)))});ne(this,"patternBoard");ne(this,"planarPatternMap");this.originalBoard=r,this.originalBoardFaces=n;const m=new Map(d.map((e,g)=>[this.vertices[g],e.viewCoordinates])),C=new Map;this.edges.forEach(e=>{if(!e.isExit){const g=d[e.vertices[0].index],l=d[e.vertices[1].index];C.set(e,[g.viewCoordinates,l.viewCoordinates])}});const f=new Map;this.sectors.forEach(e=>{M()&&S(e.edges.length===2);const g=d[e.edges[0].vertices[0].index],l=d[e.edges[0].vertices[1].index],V=d[e.edges[1].vertices[0].index],x=d[e.edges[1].vertices[1].index],b=i.find(H=>H.vertices.includes(g)&&H.vertices.includes(l)),B=i.find(H=>H.vertices.includes(V)&&H.vertices.includes(x));M()&&S(b&&B);const F=Je(b,B);M()&&S(F);const J=F.start.viewCoordinates,$=F.end.viewCoordinates,D=F.next.end.viewCoordinates;f.set(e,[J,$,D])});const p=new Map;this.faces.forEach(e=>{if(!e.isExit){const g=e.vertices.map(x=>d[x.index]),l=n.find(x=>x.vertices.every(b=>g.includes(b)));M()&&S(l);const V=l.vertices.map(x=>x.viewCoordinates);p.set(e,V)}}),this.faces.forEach(e=>{if(e.isExit){M()&&S(e.edges.length===1);const g=e.edges[0],l=d[g.vertices[0].index],V=d[g.vertices[1].index];M()&&S(l&&V);const x=i.find(F=>F.vertices.includes(l)&&F.vertices.includes(V));M()&&S(x);const b=n.includes(x.faces[0])?x.faces[1]:x.faces[0];M()&&S(b,"Did we hit null as in --- edge of board? can we expand the search pattern?");const B=[l.viewCoordinates,V.viewCoordinates,l.viewCoordinates.average(V.viewCoordinates).average(b.viewCoordinates)];p.set(e,B)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:m,edgeMap:C,sectorMap:f,faceMap:p}}static getSemiAdjacentFaces(r,n){const t=new Set;return n.vertices.forEach(s=>{s.faces.forEach(i=>{i!==n&&t.add(i)})}),t}static getFirstGeneration(r){const n=k.uniq(r.faces.map(s=>s.vertices.length)),t=r.vertices.map(s=>s.viewCoordinates).reduce((s,i)=>s.plus(i)).timesScalar(1/r.vertices.length);return n.map(s=>{const i=k.minBy(r.faces.filter(a=>a.vertices.length===s),a=>a.viewCoordinates.distanceSquared(t));return M()&&S(i),new P(r,[i])})}static getNextGeneration(r){const n=[];return r.forEach(t=>{const s=new Set;t.originalBoardFaces.forEach(i=>{P.getSemiAdjacentFaces(t.originalBoard,i).forEach(a=>{t.originalBoardFaces.includes(a)||s.add(a)})}),s.forEach(i=>{const a=[...t.originalBoardFaces,i],c=new P(t.originalBoard,a);n.some(d=>pe(d,c))||n.push(c)})}),n}static getFirstNGenerations(r,n){const s=[P.getFirstGeneration(r)];for(let i=0;i<n-1;i++)s.push(P.getNextGeneration(s[s.length-1]));return s}static getUniformTilingGenerations(r,n){const t=xe.get(r,{width:15,height:15});return P.getFirstNGenerations(t,n)}}const Z=w=>{const h=new Map,r=je.get(w).connectedComponents,n=a=>r.findIndex(c=>c.includes(a)),t=(a,c)=>{const d=a.length>c.length||a.length===c.length&&a[0]<c[0],m=d?a:c,C=d?c:a,f=`${m.join(",")}-${C.join(",")}`;if(h.has(f))return h.get(f);{const p=ie.fromPrimarySecondaryFaces(a.map(e=>w.faces[e]),c.map(e=>w.faces[e]));return h.set(f,p),p}},s=w.faces.length,i=he(s).flatMap(a=>{const c=[];if(a.some(f=>{const p=f.map(e=>n(w.faces[e]));return p.some(e=>e!==p[0])}))return c;const d=a.map(f=>fe(f.length).map(p=>{const e=p[0].map(l=>f[l]),g=p[1].map(l=>f[l]);return t(e,g)})),m=[],C=f=>{if(f===d.length){c.push(m.slice());return}else for(let p=0;p<d[f].length;p++)m.push(d[f][p]),C(f+1),m.pop()};return C(0),c});return k.sortBy(i,a=>a.length*1e4+a.reduce((c,d)=>c+d.allFaces.size,0))},Ke=w=>{let h=[];const r=(n,t,s)=>{if(t===n.length){h.push(s.map(i=>i.slice()));return}r(n,t+1,s),r(n,t+1,[...s,[n[t]]]);for(let i=0;i<s.length;i++)s[i].push(n[t]),r(n,t+1,s),s[i].pop()};return r(Array.from({length:w},(n,t)=>t),0,[]),h},he=w=>Ke(w).filter(h=>h.every(r=>r.length>1)),fe=w=>{const h=[],r=(n,t,s)=>{if(n===w){(t.length===0||s.length===0||Math.min(...t)<Math.min(...s))&&t.length&&h.push([t.slice(),s.slice()]);return}t.push(n),r(n+1,t,s),t.pop(),s.push(n),r(n+1,t,s),s.pop()};return r(0,[],[]),h};class Qe extends _{constructor(h,r,n){super(),this.pattern=h,this.targetBoard=r,this.embedding=n;const t=new _({scale:30});this.addChild(t),r.board.faces.forEach(i=>{t.addChild(new re(U.polygon(i.vertices.map(a=>a.viewCoordinates)),{stroke:"#888",lineWidth:.02}))});const s=t.localBounds;this.addChild(Pe.bounds(t.bounds.dilated(5)));for(const[i,a]of n.getExitEdgeMap()){const c=i.index;for(const d of a){const m=r.getEdge(d),C=new ae(m.vertices[0].viewCoordinates,m.vertices[1].viewCoordinates,{stroke:"#066",lineWidth:.03});t.addChild(C);const f=new K(c,{font:X,maxWidth:.4,maxHeight:.4,center:m.vertices[0].viewCoordinates.average(m.vertices[1].viewCoordinates),fill:"rgba(128,255,255,0.5)"});t.addChild(f)}}for(const[i,a]of n.getNonExitEdgeMap()){const c=r.getEdge(a),d=i.index,m=new ae(c.vertices[0].viewCoordinates,c.vertices[1].viewCoordinates,{stroke:"#f00",lineWidth:.03});t.addChild(m);const C=new K(d,{font:X,maxWidth:.4,maxHeight:.4,center:c.vertices[0].viewCoordinates.average(c.vertices[1].viewCoordinates),fill:"#fff"});t.addChild(C)}for(const[i,a]of n.getFaceMap()){const c=r.getFace(a),d=i.index,m=i.isExit,C=c?U.polygon(c.vertices.map(p=>p.viewCoordinates)):U.bounds(s.dilated(.13)).shapeDifference(U.bounds(s)),f=new re(C,{fill:m?"rgba(0,0,0,0.2)":"rgba(50,0,0,0.5)"});if(t.addChild(f),c){const p=()=>{const g=r.getEdge(n.getNonExitEdgeMap().get(i.edges[0])).vertices.map(l=>l.viewCoordinates);return c.viewCoordinates.average(g[0].average(g[1]))},e=new K(d,{font:X,maxWidth:.4,maxHeight:.4,center:m?p():c.viewCoordinates,fill:m?"#f88":"#8f8"});t.addChild(e)}}for(const[i,a]of n.getVertexMap()){const c=r.getVertex(a),d=i.index,m=i.isExit,C=new K(d,{font:X,maxWidth:.4,maxHeight:.4,center:c.viewCoordinates,fill:m?"#0ff":"#88f"});t.addChild(C)}}}self.assertions.enableAssert();const I=new _,Xe=new _({renderer:"svg",children:[I]}),ee=new Be(Xe,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(ee.domElement);ee.setWidthHeight(self.innerWidth,self.innerHeight);console.log("test");(async()=>{const w=new We,h=new oe("a","a"),r=new oe("b","b"),n=new oe("c","c");w.addFormula(De([h,r,n]));let t;do t=w.getNextSolution(),console.log(t);while(t!==null);const s=new u({numNonExitVertices:0,numExitVertices:0,type:"edge"});console.log("edgeBoard",s),console.log(q(s.descriptor));const i=new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3});console.log("nonExitVertexBoard",i),console.log(q(i.descriptor));const a=new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]});console.log("exitVertexBoard",a),console.log(q(a.descriptor));const c=new u({numNonExitVertices:0,numExitVertices:3,type:"faces",vertexLists:[[0,1,2]]});console.log("facesBoard",c),console.log(q(c.descriptor));const d=new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2],[0,1,3]]});console.log("facesBoard2",d),console.log(q(d.descriptor));const m=$e.loadDefaultPuzzle(),C=ge.get(m.board);console.log("boardPatternBoard",C),console.log(q(C.descriptor));const f=new Q(2,3),p=ge.get(f);console.log("simplePatternBoard",p),console.log(q(p.descriptor));const e=new ce({x:10,y:10,align:"left"});I.addChild(e);const g=V=>{e.addChild(new se(V,{margin:5}))},l=(V,x)=>{console.log("----------"),console.log(V),console.log("pattern",q(x.descriptor),x);const b=le(x,p);console.log("embeddings",b),e.addChild(new j({children:b.map(B=>new Qe(x,p,B))}))};l("edge pattern",new u({numNonExitVertices:0,numExitVertices:0,type:"edge"})),l("2-count exit-vertex no sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]})),l("2-count exit-vertex one sector",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]})),l("3-count exit-vertex two adjacent sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]})),l("4-count exit-vertex two opposite sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]})),l("4-count exit-vertex three-adjacent sectors",new u({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]})),l("2-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2})),l("3-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3})),l("4-count non-exit-vertex",new u({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4})),l("square pattern",new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]})),l("2 adjacent squares pattern",new u({numNonExitVertices:0,numExitVertices:6,type:"faces",vertexLists:[[0,1,4,3],[1,2,5,4]]})),l("2 diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]})),l("L square pattern",new u({numNonExitVertices:0,numExitVertices:8,type:"faces",vertexLists:[[0,1,2,3],[0,3,4,5],[0,5,6,7]]})),l("4-square pattern",new u({numNonExitVertices:1,numExitVertices:8,type:"faces",vertexLists:[[0,1,2,3],[0,3,4,5],[0,5,6,7],[0,7,8,1]]})),l("3 diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:10,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6],[5,7,8,9]]})),l("3 semi-diagonal squares pattern",new u({numNonExitVertices:0,numExitVertices:10,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6],[4,7,8,9]]}));{g(new j({spacing:10,align:"origin",children:Me.map(V=>new Y({patternBoard:V,planarPatternMap:Se.get(V)}))}));{const V=o=>new se(new j({spacing:10,children:o.map(v=>new Y(v))}),{margin:5}),x=o=>new ce({spacing:10,align:"left",children:o.map(v=>V(v))}),b=o=>{const v=k.uniq(o.faces.map(y=>y.vertices.length)),E=o.vertices.map(y=>y.viewCoordinates).reduce((y,N)=>y.plus(N)).timesScalar(1/o.vertices.length);return v.map(y=>{const N=k.minBy(o.faces.filter(G=>G.vertices.length===y),G=>G.viewCoordinates.distanceSquared(E));return M()&&S(N),new P(o,[N])})},B=(o,v)=>{const y=[b(o)];for(let N=0;N<v-1;N++)y.push(P.getNextGeneration(y[y.length-1]));return y},F=(o,v)=>{const E=xe.get(o,{width:15,height:15});return B(E,v)};console.log("---- square ----");const J=ue('{"patternBoard":"[0,9,\\"faces\\",[[0,1,2,3],[4,5,0,6],[1,7,8,2]]]","planarPatternMap":"[[[9,9],[10,9],[10,10],[9,10],[8,8],[9,8],[8,9],[11,9],[11,10]],[[0,1],[1,2],[2,3],[0,3],[4,5],[0,5],[0,6],[4,6],[1,7],[7,8],[2,8]],[[[9,9],[10,9],[10,10]],[[10,9],[10,10],[9,10]],[[10,10],[9,10],[9,9]],[[9,10],[9,9],[10,9]],[[8,8],[9,8],[9,9]],[[9,8],[9,9],[8,9]],[[9,9],[8,9],[8,8]],[[8,9],[8,8],[9,8]],[[10,9],[11,9],[11,10]],[[11,9],[11,10],[10,10]],[[11,10],[10,10],[10,9]],[[10,10],[10,9],[11,9]]],[[[9,9],[10,9],[10,10],[9,10]],[[8,8],[9,8],[9,9],[8,9]],[[10,9],[11,9],[11,10],[10,10]],[[9,9],[10,9],[9.5,8.75]],[[10,10],[9,10],[9.5,10.25]],[[9,9],[9,10],[8.75,9.5]],[[8,8],[9,8],[8.5,7.75]],[[9,9],[9,8],[9.25,8.5]],[[9,9],[8,9],[8.5,9.25]],[[8,8],[8,9],[7.75,8.5]],[[10,9],[11,9],[10.5,8.75]],[[11,9],[11,10],[11.25,9.5]],[[10,10],[11,10],[10.5,10.25]]]]"}'),$=ue('{"patternBoard":"[0,9,\\"faces\\",[[0,1,2,3],[4,5,0,6],[3,2,7,8]]]","planarPatternMap":"[[[9,9],[10,9],[10,10],[9,10],[8,8],[9,8],[8,9],[10,11],[9,11]],[[0,1],[1,2],[2,3],[0,3],[4,5],[0,5],[0,6],[4,6],[2,7],[7,8],[3,8]],[[[9,9],[10,9],[10,10]],[[10,9],[10,10],[9,10]],[[10,10],[9,10],[9,9]],[[9,10],[9,9],[10,9]],[[8,8],[9,8],[9,9]],[[9,8],[9,9],[8,9]],[[9,9],[8,9],[8,8]],[[8,9],[8,8],[9,8]],[[9,10],[10,10],[10,11]],[[10,10],[10,11],[9,11]],[[10,11],[9,11],[9,10]],[[9,11],[9,10],[10,10]]],[[[9,9],[10,9],[10,10],[9,10]],[[8,8],[9,8],[9,9],[8,9]],[[9,10],[10,10],[10,11],[9,11]],[[9,9],[10,9],[9.5,8.75]],[[10,9],[10,10],[10.25,9.5]],[[9,9],[9,10],[8.75,9.5]],[[8,8],[9,8],[8.5,7.75]],[[9,9],[9,8],[9.25,8.5]],[[9,9],[8,9],[8.5,9.25]],[[8,8],[8,9],[7.75,8.5]],[[10,10],[10,11],[10.25,10.5]],[[10,11],[9,11],[9.5,11.25]],[[9,10],[9,11],[8.75,10.5]]]]"}');e.addChild(new j({spacing:10,children:[new Y(J,{labels:!0}),new Y($,{labels:!0})]})),console.log(pe(J.patternBoard,$.patternBoard));const D=B(new Q(20,20),5);e.addChild(x(D)),D.forEach((o,v)=>{console.log(`-- ${v} --`),o.forEach(E=>{console.log(JSON.stringify(Ue(E)))})}),console.log("---- hex ----");const H=B(new Ge(5,1,!0),4);e.addChild(x(H)),console.log("---- rhombille ----");const me=F(A(qe,{width:8,height:8}),4);e.addChild(x(me)),console.log("---- cairo ----");const we=F(A(Le,{width:8,height:8,squareRegion:!0}),4);e.addChild(x(we)),console.log("---- triangular ----");const ve=F(A(He,{width:6,height:5}),4);e.addChild(x(ve)),console.log("---- snub square ----");const Ee=F(A(Te,{width:5,height:6,squareRegion:!0}),4);e.addChild(x(Ee)),console.log("---- trihexagonal ----");const Ce=F(A(ze,{width:9,height:9}),4);e.addChild(x(Ce)),console.log(he(5).map(o=>JSON.stringify(o))),console.log(fe(5).map(o=>JSON.stringify(o))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]})).map(o=>o.map(v=>v.toCanonicalString()))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:4,type:"faces",vertexLists:[[0,1,2,3]]}))),console.log(Z(new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]})));const te=new u({numNonExitVertices:0,numExitVertices:7,type:"faces",vertexLists:[[0,1,2,3],[0,4,5,6]]}),Ve=le(te,te);console.log(Z(te).filter(o=>ie.areCanonicalWith(o,Ve)));{const o=b(new Q(20,20))[0],v=P.getNextGeneration(P.getNextGeneration(P.getNextGeneration(b(new Q(20,20)))))[0];e.addChild(new R(o,O.fromSolution(o,[o.edges[0],o.edges[1],o.edges[4]]),o.planarPatternMap)),[[],[new L(o.faces[0],2)],[new Ae(o.edges[0])],[new T(o.edges[0])],[ie.fromPrimarySecondaryFaces([o.faces[0],o.faces[1]],[o.faces[2]])],[new Oe(o.sectors[3])]].forEach(N=>{const G=new de(o);N.forEach(z=>G.addFeature(z));const W=G.getRemainingSolutions();console.log(W),e.addChild(new se(new j({spacing:10,children:W.map(z=>new R(o,O.fromSolution(o,z),o.planarPatternMap))}),{margin:5}))}),g(new R(v,O.fromFeatures(v,[new L(v.faces[0],3),new L(v.faces[1],3),new T(v.edges.filter(N=>N.isExit)[1]),new T(v.edges.filter(N=>N.isExit)[3])]),v.planarPatternMap));const E=D[4][7],y=[new L(E.faces[0],null),new L(E.faces[1],null),new L(E.faces[2],2),new L(E.faces[3],null),new L(E.faces[4],null),new T(E.edges[1]),new T(E.edges[12]),new T(E.edges[17]),new T(E.edges[21])];g(new R(E,O.fromFeatures(E,y),E.planarPatternMap,{labels:!0})),g(new R(o,O.empty(o),o.planarPatternMap,{labels:!0}));{const N=new de(E),G=y;G.forEach(ye=>N.addFeature(ye));const W=N.getRemainingSolutions();console.log(W);const z=Re(E,G);console.log(z);const Ne=ke(W,z);console.log(Ne)}}}}ee.setWidthHeight(Math.ceil(I.right+10),Math.ceil(I.bottom+10)),ee.updateDisplay()})();
