var K=Object.defineProperty;var w=(E,e,i)=>e in E?K(E,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):E[e]=i;var o=(E,e,i)=>(w(E,typeof e!="symbol"?e+"":e,i),i);import{a as p,b as A,_ as y}from"./createBoardDescriptor-DQiPBFka.js";import{g as m}from"./FeatureSet-CUuwAkcj.js";import{E as L,d as T}from"./Vector2Property-DCXaH-JP.js";class S{constructor(e,i){this.minVertexIndex=e,this.maxVertexIndex=i}}const a=class a extends L{};o(a,"NON_EXIT_RED",new a),o(a,"NON_EXIT_BLACK",new a),o(a,"EXIT_HARD_RED",new a),o(a,"EXIT_BLACK",new a),o(a,"EXIT_SOFT_RED_DOUBLE_BLACK",new a),o(a,"enumeration",new T(a));let d=a;class v{constructor(e,i,r){o(this,"solutionSet");o(this,"isEdgeBlack");o(this,"richEdgeStateMap",new Map);o(this,"vertexConnection",null);o(this,"vertexConnectionKey",null);this.patternBoard=e,this.solution=i,this.solutionSet=new Set(i),this.isEdgeBlack=t=>this.solutionSet.has(t);for(const t of e.edges){let s;t.isExit?this.isEdgeBlack(t)?s=d.EXIT_BLACK:t.exitVertex.edges.every(l=>!this.isEdgeBlack(l))?s=d.EXIT_SOFT_RED_DOUBLE_BLACK:s=d.EXIT_HARD_RED:s=this.isEdgeBlack(t)?d.NON_EXIT_BLACK:d.NON_EXIT_RED,this.richEdgeStateMap.set(t,s)}if(r)if(e.faces.some(t=>!t.isExit)){const t=new Set(this.solutionSet),s=[];for(;t.size;){let n;for(const u of t)if(u.isExit){n=u;break}p()&&A(n);const c=u=>{for(const C of u.vertices)for(const B of C.edges)if(t.has(B))return B;throw new Error("no next edge found")};t.delete(n);let x=n;for(;x===n||!x.isExit;){const u=c(x);t.delete(u),x=u}const h=x,f=Math.min(n.exitVertex.index,h.exitVertex.index),I=Math.max(n.exitVertex.index,h.exitVertex.index);s.push(new S(f,I))}const l=y.sortBy(s,n=>n.minVertexIndex);this.vertexConnection=l,this.vertexConnectionKey=l.map(n=>`c${n.minVertexIndex}-${n.maxVertexIndex}`).join(",")}else this.vertexConnection=[],this.vertexConnectionKey=""}isCompatibleWithFeature(e){return e.isPossibleWith(this.isEdgeBlack)}isCompatibleWithFeatureSet(e){return e.getFeaturesArray().every(i=>this.isCompatibleWithFeature(i))}toDebugString(){return`[${this.patternBoard.edges.map(e=>this.isEdgeBlack(e)?"1":"0")}] ${this.vertexConnectionKey??""}`}}class g{static filterWithFeatureSet(e,i){const r=m(i.patternBoard,i.getFeaturesArray()),t=i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s));return g.filterWithInfo(e,r,t)}static getHighlanderKeyWithFeatureSet(e,i){const r=m(i.patternBoard,i.getFeaturesArray()),t=new Set(i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s)));return g.getHighlanderKeyWithInfo(e,r,t)}static getHighlanderKeyWithInfo(e,i,r){return i.map(t=>{const s=e.richEdgeStateMap.get(t);return p()&&A(s),t.isExit?r.has(t)?s===d.EXIT_BLACK?"1":"0":s===d.EXIT_SOFT_RED_DOUBLE_BLACK?"2":s===d.EXIT_BLACK?"1":"0":s===d.NON_EXIT_BLACK?"1":"0"}).join("")+"/"+e.vertexConnectionKey}static filterWithInfo(e,i,r){const t=new Map,s=new Set(r);for(const l of e){const n=g.getHighlanderKeyWithInfo(l,i,s);t.has(n)?t.set(n,null):t.set(n,l)}return[...t.values()].filter(l=>{if(l===null)return!1;for(const n of r)if(l.solutionSet.has(n))return!1;return!0})}}class D{constructor(e,i,r){o(this,"exitEdgeIndices");o(this,"solutionAttributeSetLists");this.initialFeatureSet=e,this.binaryFeatureMap=i,this.richSolutions=r;const t=e.patternBoard,s=t.edges.filter(c=>c.isExit);this.exitEdgeIndices=s.map(c=>i.getExitIndex(c)),this.solutionAttributeSetLists=new Array(1<<s.length).fill([]);const l=m(t,e.getFeaturesArray()),n=(c,x,h)=>{if(c===s.length){const f=g.filterWithInfo(r,l,h).map(I=>I.solutionAttributeSet);this.solutionAttributeSetLists[x]=f}else n(c+1,x,h),n(c+1,x|1<<c,[...h,s[c]])};n(0,0,[])}getSolutionAttributeSets(e){let i=0;for(let r=0;r<this.exitEdgeIndices.length;r++){const t=this.exitEdgeIndices[r];(e&1n<<BigInt(t))!==0n&&(i|=1<<r)}return this.solutionAttributeSetLists[i]}}export{v as G,D as H};
