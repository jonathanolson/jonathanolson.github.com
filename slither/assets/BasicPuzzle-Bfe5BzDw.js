var $e=Object.defineProperty;var je=(r,e,t)=>e in r?$e(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var h=(r,e,t)=>(je(r,typeof e!="symbol"?e+"":e,t),t);import{a as g,b as d,_ as Fe,j as Be,H as Pe}from"./getCoordinateClusteredMap-DCjAm76-.js";import{E as ve,d as De,T as F,g as Qe,f as Xe,O as ye}from"./Vector2Property-DCXaH-JP.js";import"./PhetioControlledVisibilityProperty-BRVDbtg_.js";import"./TextPushButton-CXcXt4ga.js";const z=class z extends ve{};h(z,"WHITE",new z),h(z,"BLACK",new z),h(z,"RED",new z),h(z,"enumeration",new De(z));let E=z;const U=r=>({start:{x:r.start.logicalCoordinates.x,y:r.start.logicalCoordinates.y},end:{x:r.end.logicalCoordinates.x,y:r.end.logicalCoordinates.y}}),N=(r,e)=>{const t=r.edges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return g()&&d(t),t};class oe{constructor(e,t){this.edge=e,this.state=t}apply(e){e.setEdgeState(this.edge,this.state)}getUndo(e){const t=e.getEdgeState(this.edge);return new oe(this.edge,t)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateSetAction",edge:U(this.edge),state:this.state.name}}static deserializeAction(e,t){return new oe(N(e,t.edge),E.enumeration.getValue(t.state))}}class j{constructor(e,t,s,i,a,n,c){this.faceValueAction=e,this.edgeStateAction=t,this.simpleRegionAction=s,this.faceColorAction=i,this.sectorStateAction=a,this.vertexStateAction=n,this.faceStateAction=c}apply(e){this.faceValueAction.apply(e),this.edgeStateAction.apply(e),this.simpleRegionAction.apply(e),this.faceColorAction.apply(e),this.sectorStateAction.apply(e),this.vertexStateAction.apply(e),this.faceStateAction.apply(e)}getUndo(e){return new j(this.faceValueAction.getUndo(e),this.edgeStateAction.getUndo(e),this.simpleRegionAction.getUndo(e),this.faceColorAction.getUndo(e),this.sectorStateAction.getUndo(e),this.vertexStateAction.getUndo(e),this.faceStateAction.getUndo(e))}isEmpty(){return this.faceValueAction.isEmpty()&&this.edgeStateAction.isEmpty()&&this.simpleRegionAction.isEmpty()&&this.faceColorAction.isEmpty()&&this.sectorStateAction.isEmpty()&&this.vertexStateAction.isEmpty()&&this.faceStateAction.isEmpty()}serializeAction(){return{type:"CompleteAction",faceValueAction:this.faceValueAction.serializeAction(),edgeStateAction:this.edgeStateAction.serializeAction(),simpleRegionAction:this.simpleRegionAction.serializeAction(),faceColorAction:this.faceColorAction.serializeAction(),sectorStateAction:this.sectorStateAction.serializeAction(),vertexStateAction:this.vertexStateAction.serializeAction(),faceStateAction:this.faceStateAction.serializeAction()}}static deserializeAction(e,t){return new j(O(e,t.faceStateAction),O(e,t.edgeStateAction),O(e,t.simpleRegionAction),O(e,t.faceColorAction),O(e,t.sectorStateAction),O(e,t.vertexStateAction),O(e,t.faceStateAction))}}class ne{constructor(e,t=!0){this.edge=e,this.forward=t}apply(e){const t=e.getEdgeState(this.edge);t===E.WHITE?e.setEdgeState(this.edge,this.forward?E.BLACK:E.RED):t===E.BLACK?e.setEdgeState(this.edge,this.forward?E.RED:E.WHITE):e.setEdgeState(this.edge,this.forward?E.WHITE:E.BLACK)}getUndo(e){return new ne(this.edge,!this.forward)}isEmpty(){return!1}serializeAction(){return{type:"EdgeStateCycleAction",edge:U(this.edge),forward:this.forward}}static deserializeAction(e,t){return new ne(N(e,t.edge),t.forward)}}class Q{constructor(e,t=new Map){this.board=e,this.edgeStateMap=t}apply(e){for(const[t,s]of this.edgeStateMap)e.setEdgeState(t,s)}getUndo(e){const t=new Map;for(const s of this.edgeStateMap.keys())t.set(s,e.getEdgeState(s));return new Q(this.board,t)}isEmpty(){return this.edgeStateMap.size===0}serializeAction(){return{type:"GeneralEdgeAction",edges:Array.from(this.edgeStateMap.entries()).map(([e,t])=>({edge:U(e),state:t.name}))}}static deserializeAction(e,t){return new Q(e,new Map(t.edges.map(s=>[N(e,s.edge),E.enumeration.getValue(s.state)])))}}const Y=r=>({x:r.logicalCoordinates.x,y:r.logicalCoordinates.y}),T=(r,e)=>{const t=r.faces.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return g()&&d(t),t};class le{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceValue(this.face,this.state)}getUndo(e){const t=e.getFaceValue(this.face);return new le(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceValueSetAction",edge:Y(this.face),state:this.state}}static deserializeAction(e,t){return new le(T(e,t.edge),t.state)}}class X{constructor(e,t=new Map){this.board=e,this.faceValueMap=t}apply(e){for(const[t,s]of this.faceValueMap)e.setFaceValue(t,s)}getUndo(e){const t=new Map;for(const s of this.faceValueMap.keys())t.set(s,e.getFaceValue(s));return new X(this.board,t)}isEmpty(){return this.faceValueMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceValueMap.entries()).map(([e,t])=>({face:Y(e),state:t}))}}static deserializeAction(e,t){return new X(e,new Map(t.faces.map(s=>[T(e,s.face),s.state])))}}const Re=r=>({start:{x:r.start.logicalCoordinates.x,y:r.start.logicalCoordinates.y},end:{x:r.end.logicalCoordinates.x,y:r.end.logicalCoordinates.y}}),xe=r=>({id:r.id,halfEdges:r.halfEdges.map(Re),isSolved:r.isSolved}),ct=r=>{const e=r.getSimpleRegions();return e.length===1&&e[0].isSolved&&r.getWeirdEdges().length===0},ze=r=>({type:"SimpleRegionData",simpleRegions:r.getSimpleRegions().map(xe),weirdEdges:r.getWeirdEdges().map(U)}),Ve=(r,e)=>{const t=r.halfEdges.find(s=>s.start.logicalCoordinates.x===e.start.x&&s.start.logicalCoordinates.y===e.start.y&&s.end.logicalCoordinates.x===e.end.x&&s.end.logicalCoordinates.y===e.end.y);return g()&&d(t),t};class J{constructor(e,t,s=!1){h(this,"edges");h(this,"a");h(this,"b");if(this.id=e,this.halfEdges=t,this.isSolved=s,this.a=t[0].start,this.b=t[t.length-1].end,this.edges=t.map(i=>i.edge),g()){d(t.length>0);for(let i=0;i<t.length-1;i++)d(t[i].end===t[i+1].start)}}static deserializeSimpleRegion(e,t){return new J(t.id,t.halfEdges.map(s=>Ve(e,s)),t.isSolved)}}class G{constructor(e,t=new Set,s=new Set,i=new Set,a=new Set){this.board=e,this.addedRegions=t,this.removedRegions=s,this.addedWeirdEdges=i,this.removedWeirdEdges=a}apply(e){e.modifyRegions(this.addedRegions,this.removedRegions,this.addedWeirdEdges,this.removedWeirdEdges)}getUndo(e){return new G(this.board,this.removedRegions,this.addedRegions,this.removedWeirdEdges,this.addedWeirdEdges)}isEmpty(){return this.addedRegions.size===0&&this.removedRegions.size===0&&this.addedWeirdEdges.size===0&&this.removedWeirdEdges.size===0}serializeAction(){return{type:"GeneralSimpleRegionAction",addedRegions:Array.from(this.addedRegions).map(xe),removedRegions:Array.from(this.removedRegions).map(xe),addedWeirdEdges:Array.from(this.addedWeirdEdges).map(U),removedWeirdEdges:Array.from(this.removedWeirdEdges).map(U)}}static deserializeAction(e,t){return new G(e,new Set(t.addedRegions.map(s=>J.deserializeSimpleRegion(e,s))),new Set(t.removedRegions.map(s=>J.deserializeSimpleRegion(e,s))),new Set(t.addedWeirdEdges.map(s=>N(e,s))),new Set(t.removedWeirdEdges.map(s=>N(e,s))))}}class te{apply(e){}getUndo(e){return this}isEmpty(){return!0}serializeAction(){return{type:"NoOpAction"}}static deserializeAction(e,t){return new te}}class Ie extends te{constructor(){super(...arguments);h(this,"isUserLoadPuzzleAutoSolveAction",!0)}serializeAction(){return{type:"UserLoadPuzzleAutoSolveAction"}}static deserializeAction(t,s){return new Ie}}class Oe extends te{constructor(){super(...arguments);h(this,"isUserRequestSolveAction",!0)}serializeAction(){return{type:"UserRequestSolveAction"}}static deserializeAction(t,s){return new Oe}}const O=(r,e)=>{const t=e.type;if(t==="CompositeAction")return ce.deserializeAction(r,e);if(t==="CompleteAction")return j.deserializeAction(r,e);if(t==="EdgeStateCycleAction")return ne.deserializeAction(r,e);if(t==="EdgeStateSetAction")return oe.deserializeAction(r,e);if(t==="GeneralEdgeAction")return Q.deserializeAction(r,e);if(t==="FaceValueSetAction")return le.deserializeAction(r,e);if(t==="GeneralFaceAction")return X.deserializeAction(r,e);if(t==="GeneralSimpleRegionAction")return G.deserializeAction(r,e);if(t==="NoOpAction")return te.deserializeAction(r,e);if(t==="UserLoadPuzzleAutoSolveAction")return Ie.deserializeAction(r,e);if(t==="UserRequestSolveAction")return Oe.deserializeAction(r,e);throw new Error(`Unknown action type: ${t}, could not deserialize`)};class ce{constructor(e){this.actions=e}apply(e){for(let t=0;t<this.actions.length;t++)this.actions[t].apply(e)}getUndo(e){return new ce(this.actions.map(t=>t.getUndo(e)).reverse())}isEmpty(){return this.actions.some(e=>!e.isEmpty())}serializeAction(){return{type:"CompositeAction",actions:this.actions.map(e=>e.serializeAction())}}static deserializeAction(e,t){return new ce(t.actions.map(s=>O(e,s)))}}const V=class V extends ve{};h(V,"OUTSIDE",new V),h(V,"INSIDE",new V),h(V,"UNDECIDED",new V),h(V,"enumeration",new De(V));let W=V;const Je=(r,e,t)=>({id:r.id,colorState:r.colorState.toString(),faces:e.map(Y),oppositeFaceColorId:t}),We=r=>({type:"FaceColorData",colors:r.getFaceColors().map(e=>{var t;return Je(e,r.getFacesWithColor(e),((t=r.getOppositeFaceColor(e))==null?void 0:t.id)??null)}),invalidFaceColor:r.hasInvalidFaceColors()}),m=class m extends ve{constructor(e,t,s,i){super(),this.zero=e,this.one=t,this.two=s,this.serializedValue=i}allows(e){return g()&&d(e===0||e===1||e===2),e===0&&this.zero||e===1&&this.one||e===2&&this.two}isSubsetOf(e){return(!this.zero||e.zero)&&(!this.one||e.one)&&(!this.two||e.two)}and(e){return m.getWithValue(this.zero&&e.zero,this.one&&e.one,this.two&&e.two)}or(e){return m.getWithValue(this.zero||e.zero,this.one||e.one,this.two||e.two)}withZero(e){return m.getWithValue(e,this.one,this.two)}withOne(e){return m.getWithValue(this.zero,e,this.two)}withTwo(e){return m.getWithValue(this.zero,this.one,e)}with(e){return g()&&d(e===0||e===1||e===2),m.getWithValue(e===0?!0:this.zero,e===1?!0:this.one,e===2?!0:this.two)}withAllowZero(){return this.withZero(!0)}withAllowOne(){return this.withOne(!0)}withAllowTwo(){return this.withTwo(!0)}withDisallowZero(){return this.withZero(!1)}withDisallowOne(){return this.withOne(!1)}withDisallowTwo(){return this.withTwo(!1)}serialize(){return this.serializedValue}static getWithValue(e,t,s){return m.enumeration.values.find(i=>i.zero===e&&i.one===t&&i.two===s)}static getOnly(e){return g()&&d(e===0||e===1||e===2),m.getWithValue(e===0,e===1,e===2)}static getNot(e){return g()&&d(e===0||e===1||e===2),m.getWithValue(e!==0,e!==1,e!==2)}static deserialize(e){const t=Ge.get(e);return g()&&d(t,`invalid serialized value: ${e}`),t}};h(m,"NONE",new m(!1,!1,!1,0)),h(m,"ONLY_ZERO",new m(!0,!1,!1,1)),h(m,"ONLY_ONE",new m(!1,!0,!1,2)),h(m,"ONLY_TWO",new m(!1,!1,!0,3)),h(m,"NOT_ZERO",new m(!1,!0,!0,4)),h(m,"NOT_ONE",new m(!0,!1,!0,5)),h(m,"NOT_TWO",new m(!0,!0,!1,6)),h(m,"ANY",new m(!0,!0,!0,7)),h(m,"enumeration",new De(m)),h(m,"trivialStates",[m.NONE,m.ONLY_ZERO,m.ONLY_TWO,m.ANY]);let L=m;const Ge=new Map(L.enumeration.values.map(r=>[r.serializedValue,r])),_e=r=>r.incomingHalfEdges,et=r=>{let e=_e(r);return e=[...e.slice(1),e[0]],g()&&d(e[0].edge===r.edges[1]&&e[0].next.edge===r.edges[0]),e},qe=r=>{const e=new Uint8Array(Math.ceil(r.length/8));for(let s=0;s<r.length;s++)r[s]&&(e[Math.floor(s/8)]|=1<<7-s%8);const t=btoa(String.fromCharCode(...e));if(g()){const s=Le(t,r.length);d(r.length===s.length&&r.every((i,a)=>i===s[a]))}return t},Le=(r,e)=>{const t=Uint8Array.from(atob(r),i=>i.charCodeAt(0)),s=[];for(let i=0;i<t.length*8;i++)s.push((t[Math.floor(i/8)]&1<<7-i%8)!==0);return s.slice(0,e)},b=[],He=r=>{for(;b.length<=r;)b.push(b.length===0?1:b[b.length-1]*b.length);return b},Ze=(r,e,t)=>t[r]/(t[e]*t[r-e]),ie=(r,e)=>{r=Fe.sortBy(r);const t=He(e);let s=0;const i=r.length;for(let a=0;a<i;a++){const n=r[a-1]+1,c=r[a];for(let o=a==0?0:n;o<c;o++)s+=Ze(e-o-1,i-a-1,t)}return s},tt=(r,e)=>Ze(r,e,He(r)),ae=(r,e)=>{let t=0;for(let s=0;s<r.length;s++)t+=1<<e-r[s]-1;return t},st=r=>1<<r;class w{constructor(e,t,s,i){h(this,"order");h(this,"possibilityCount");h(this,"matrix");this.face=e,this.faceValue=t,this.order=e.edges.length,s?this.matrix=s:this.matrix=Fe.range(0,w.getMatrixSize(this.order,this.faceValue)).map(()=>!0),i!==void 0?this.possibilityCount=i:this.possibilityCount=this.matrix.filter(a=>a).length,g()&&d(this.matrix.length===w.getMatrixSize(this.order,this.faceValue)),g()&&d(this.possibilityCount===this.matrix.filter(a=>a).length)}isAny(){return this.possibilityCount===w.getMatrixSize(this.order,this.faceValue)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.allowsBlackEdges([])}allowsBlackEdges(e){return this.matrix[this.getBlackEdgesIndex(e)]}getAllowedCombinations(){const e=[];return w.forEachEdgeCombination(this.face.edges,this.faceValue,(t,s)=>{this.matrix[this.getIndexFromIndices(t)]&&e.push(s.slice())}),g()&&d(e.length===this.possibilityCount),e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedCombinations())s.includes(e)?t.add(E.BLACK):t.add(E.RED);return this.allowsEmpty()&&t.add(E.RED),t}getBlackEdgesIndex(e){const t=e.map(s=>this.face.edges.indexOf(s));return g()&&d(t.every(s=>s>=0)),this.getIndexFromIndices(t)}getIndexFromIndices(e){return this.faceValue===null?ae(e,this.order):ie(e,this.order)}equals(e){return this.face===e.face&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return g()&&d(this.face===e.face),new w(this.face,this.faceValue,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return g()&&d(this.face===e.face),new w(this.face,this.faceValue,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withBlackEdges(e,t){const s=this.getBlackEdgesIndex(e);return new w(this.face,this.faceValue,this.matrix.slice(0,s).concat(t,this.matrix.slice(s+1)))}serialize(){if(this.isAny())return{faceValue:this.faceValue,matrix:"",isAny:!0};const e={faceValue:this.faceValue,matrix:qe(this.matrix),isAny:!1};return g()&&d(this.equals(w.deserialize(this.face,e))),e}static getMatrixSize(e,t){return t===null?st(e):tt(e,t)}static forEachIndexCombination(e,t,s){let i=[];const a=()=>{if(t!==null){if(i.length===t){s(i);return}}else s(i);const n=i.length>0?i[i.length-1]+1:0;for(let c=n;c<e;c++)i.push(c),a(),i.pop()};a()}static forEachEdgeCombination(e,t,s){let i=[],a=[];const n=()=>{if(t!==null){if(i.length===t){s(i,a);return}}else s(i,a);const c=i.length>0?i[i.length-1]+1:0;for(let o=c;o<e.length;o++)i.push(o),a.push(e[o]),n(),i.pop(),a.pop()};n()}static fromLookup(e,t,s){const i=e.edges.length,a=new Array(w.getMatrixSize(i,t)).fill(!1);return w.forEachEdgeCombination(e.edges,t,(n,c)=>{if(s(c)){const l=t===null?ae(n,i):ie(n,i);a[l]=!0}}),new w(e,t,a)}static none(e,t){const s=w.getMatrixSize(e.edges.length,t),i=new Array(s).fill(!1);return new w(e,t,i,0)}static any(e,t){const s=w.getMatrixSize(e.edges.length,t),i=new Array(s).fill(!0);return new w(e,t,i,s)}static withOnlyBlackEdges(e,t,s){const i=w.getMatrixSize(e.edges.length,t),a=new Array(i).fill(!1),n=s.map(o=>e.edges.indexOf(o)),c=t===null?ae(n,e.edges.length):ie(n,e.edges.length);return a[c]=!0,new w(e,t,a,1)}static withoutBlackEdges(e,t,s){const i=w.getMatrixSize(e.edges.length,t),a=new Array(i).fill(!0),n=s.map(o=>e.edges.indexOf(o)),c=t===null?ae(n,e.edges.length):ie(n,e.edges.length);return a[c]=!1,new w(e,t,a,i-1)}static fromVertexAndColorData(e,t,s){const a=e.vertices.map(f=>s.getVertexState(f)).map(f=>{const S=f.vertex.edges.filter(x=>x.faces.includes(e));return g()&&d(S.length===2),{edgeA:S[0],edgeB:S[1],...f.getBinaryCombinationsAllowed(S[0],S[1])}}),n=new Map(e.edges.map(f=>{const S=f.getOtherFace(e);return[f,S?s.getFaceColor(S):s.getOutsideColor()]})),c=s.getFaceColor(e),o=new Set([...n.values(),c]),l=new Map([...o].map(f=>[f,s.getOppositeFaceColor(f)]));return w.fromLookup(e,s.getFaceValue(e),f=>{const S=new Set(f);for(const u of a){const p=S.has(u.edgeA),y=S.has(u.edgeB);if(p&&y&&!u.allowsBoth||p&&!y&&!u.allowsAOnly||!p&&y&&!u.allowsBOnly||!p&&!y&&!u.allowsNone)return!1}const x=new Set([c]),M=new Set;for(const u of e.edges){const p=n.get(u);g()&&d(p),S.has(u)?M.add(p):x.add(p)}for(const u of x){if(M.has(u))return!1;const p=l.get(u);if(p&&x.has(p))return!1}for(const u of M){const p=l.get(u);if(p&&M.has(p))return!1}if(S.size===e.edges.length){for(const u of t.faces)if(s.getFaceValue(u)!==null){for(const p of u.edges)if(!S.has(p))return!1}}return!0})}static deserialize(e,t){return t.isAny?w.any(e,t.faceValue):new w(e,t.faceValue,Le(t.matrix,w.getMatrixSize(e.edges.length,t.faceValue)))}}class C{constructor(e,t,s){h(this,"order");h(this,"possibilityCount");h(this,"matrix");this.vertex=e,this.order=e.edges.length,t?this.matrix=t:this.matrix=Fe.range(0,C.getMatrixSize(this.order)).map(()=>!0),s!==void 0?this.possibilityCount=s:this.possibilityCount=this.matrix.filter(i=>i).length,g()&&d(this.matrix.length===C.getMatrixSize(this.order)),g()&&d(this.possibilityCount===this.matrix.filter(i=>i).length)}isAny(){return this.possibilityCount===C.getMatrixSize(this.order)}isForced(){return this.possibilityCount===1}allowsEmpty(){return this.matrix[C.getMatrixSize(this.order)-1]}allowsPair(e,t){return this.matrix[this.getPairIndex(e,t)]}getBinaryCombinationsAllowed(e,t){let s=this.allowsEmpty(),i=!1,a=!1,n=!1;for(const c of this.getAllowedPairs()){const o=c[0]===e||c[1]===e,l=c[0]===t||c[1]===t;o&&l?i=!0:o?a=!0:l?n=!0:s=!0}return{allowsNone:s,allowsBoth:i,allowsAOnly:a,allowsBOnly:n}}getAllowedPairs(){const e=[];let t=0;for(let s=0;s<this.order;s++)for(let i=s+1;i<this.order;i++)this.matrix[t++]&&e.push([this.vertex.edges[s],this.vertex.edges[i]]);return e}getFinalStatesOfEdge(e){const t=new Set;for(const s of this.getAllowedPairs())s[0]===e||s[1]===e?t.add(E.BLACK):t.add(E.RED);return this.allowsEmpty()&&t.add(E.RED),t}getPairIndex(e,t){const s=this.vertex.edges.indexOf(e),i=this.vertex.edges.indexOf(t),a=Math.min(s,i),n=Math.max(s,i);return C.getIndex(a,n,this.order)}equals(e){return this.vertex===e.vertex&&this.matrix.every((t,s)=>t===e.matrix[s])}and(e){return g()&&d(this.vertex===e.vertex),new C(this.vertex,this.matrix.map((t,s)=>t&&e.matrix[s]))}or(e){return g()&&d(this.vertex===e.vertex),new C(this.vertex,this.matrix.map((t,s)=>t||e.matrix[s]))}isSubsetOf(e){return this.matrix.every((t,s)=>!t||e.matrix[s])}withEmpty(e){return new C(this.vertex,this.matrix.slice(0,-1).concat(e))}withPair(e,t,s){const i=this.getPairIndex(e,t);return new C(this.vertex,this.matrix.slice(0,i).concat(s,this.matrix.slice(i+1)))}serialize(){const e=qe(this.matrix);return g()&&d(this.equals(C.deserialize(this.vertex,e))),e}static getIndex(e,t,s){return e*(2*s-e-1)/2+(t-e-1)}static getMatrixSize(e){return e*(e-1)/2+1}static fromLookup(e,t,s){const i=e.edges.length,a=[];for(let n=0;n<i;n++)for(let c=n+1;c<i;c++)a.push(t(e.edges[n],e.edges[c]));return a.push(s),new C(e,a)}static none(e){return C.fromLookup(e,()=>!1,!1)}static any(e){return C.fromLookup(e,()=>!0,!0)}static withOnlyEmpty(e){return C.fromLookup(e,()=>!1,!0)}static withOnlyPair(e,t,s){return C.fromLookup(e,(i,a)=>i===t&&a===s||i===s&&a===t,!1)}static withoutEmpty(e){return C.fromLookup(e,()=>!0,!1)}static withoutPair(e,t,s){return C.fromLookup(e,(i,a)=>i!==t&&i!==s||a!==t&&a!==s,!0)}static fromEdgeColorSectorData(e,t){const s=e.edges.length,i=[],a=e.edges.filter(p=>t.getEdgeState(p)===E.BLACK);if(a.length>2)return C.none(e);if(a.length===2)return C.withOnlyPair(e,a[0],a[1]);const n=a.length?a[0]:null,c=new Set(e.edges.filter(p=>t.getEdgeState(p)===E.RED));if(c.size===s)return C.withOnlyEmpty(e);const o=et(e),l=o.map(p=>t.getSectorState(p)),f=l.every(p=>p.zero),S=o.map(p=>p.face?t.getFaceColor(p.face):t.getOutsideColor()),x=new Set(S),M=new Map([...x].map(p=>[p,t.getOppositeFaceColor(p)])),u=[...M.values()].every(p=>!p||!x.has(p));for(let p=0;p<s;p++){const y=e.edges[p];if(c.has(y)){for(let v=p+1;v<s;v++)i.push(!1);continue}for(let v=p+1;v<s;v++){let A=!0;const se=e.edges[v];if(A&&c.has(se)&&(A=!1),A&&n&&y!==n&&se!==n&&(A=!1),A&&(A=A&&l.every((K,$)=>{const R=o[$];let I=0;return(y===R.edge||y===R.next.edge)&&I++,(se===R.edge||se===R.next.edge)&&I++,K.allows(I)})),A){const K=S.slice(p,v),$=[...S.slice(v),...S.slice(0,p)];K.some(R=>$.includes(R))&&(A=!1),A&&K.some(R=>{const I=M.get(R);return I&&K.includes(I)})&&(A=!1),A&&$.some(R=>{const I=M.get(R);return I&&$.includes(I)})&&(A=!1)}i.push(A)}}return i.push(a.length===0&&f&&u),new C(e,i)}static deserialize(e,t){return new C(e,Le(t,C.getMatrixSize(e.edges.length)))}}const Ye=r=>({x:r.logicalCoordinates.x,y:r.logicalCoordinates.y}),Ae=(r,e)=>{const t=r.vertices.find(s=>s.logicalCoordinates.x===e.x&&s.logicalCoordinates.y===e.y);return g()&&d(t),t};class re{constructor(e,t){this.id=e,this.colorState=t}}class it{constructor(e,t,s,i,a,n){this.board=e,this.addedFaceColors=t,this.removedFaceColors=s,this.faceChangeMap=i,this.oppositeChangeMap=a,this.invalidFaceColor=n,g()&&d(s.size<=i.size)}apply(e){e.modifyFaceColors(this.addedFaceColors,this.removedFaceColors,this.faceChangeMap,this.oppositeChangeMap,this.invalidFaceColor)}getUndo(e){throw new Error("getUndo unimplemented in GeneralFaceColorAction")}isEmpty(){return this.addedFaceColors.size===0&&this.removedFaceColors.size===0&&this.faceChangeMap.size===0&&this.oppositeChangeMap.size===0}serializeAction(){throw new Error("serializeAction unimplemented in GeneralFaceColorAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in GeneralFaceColorAction")}}class he extends it{constructor(t,s,i=new Set,a=new Set,n=new Map,c=new Map,o=!1){super(t,i,a,n,c,o);h(this,"faceColorsChangedEmitter",new F);this.parentState=s}getFaceColors(){return[...[...this.parentState.getFaceColors()].filter(t=>!this.removedFaceColors.has(t)),...this.addedFaceColors]}getInsideColor(){return this.parentState.getInsideColor()}getOutsideColor(){return this.parentState.getOutsideColor()}getFaceColor(t){return this.faceChangeMap.has(t)?this.faceChangeMap.get(t):this.parentState.getFaceColor(t)}getFacesWithColor(t){let s;this.addedFaceColors.has(t)?s=new Set:s=new Set(this.parentState.getFacesWithColor(t));for(const[i,a]of this.faceChangeMap.entries())a===t?s.add(i):s.has(i)&&s.delete(i);return[...s]}getFaceColorMap(){const t=new Map(this.parentState.getFaceColorMap());for(const[s,i]of this.faceChangeMap.entries())t.set(s,i);return t}getOppositeFaceColor(t){const s=this.oppositeChangeMap.get(t);return s!==void 0?s:this.parentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.invalidFaceColor||this.parentState.hasInvalidFaceColors()}modifyFaceColors(t,s,i,a,n){for(const l of t)this.addedFaceColors.add(l);for(const l of s)this.addedFaceColors.has(l)?this.addedFaceColors.delete(l):this.removedFaceColors.add(l);for(const[l,f]of i.entries())this.faceChangeMap.set(l,f);for(const[l,f]of a.entries())this.oppositeChangeMap.set(l,f);const c=new Set(s);for(const l of this.oppositeChangeMap.keys()){const f=this.oppositeChangeMap.get(l);f&&c.has(f)&&this.oppositeChangeMap.set(l,null)}const o=new Set(a.keys());this.invalidFaceColor=n,this.faceColorsChangedEmitter.emit(t,s,o,[...i.keys()])}clone(){return new he(this.board,this.parentState,new Set(this.addedFaceColors),new Set(this.removedFaceColors),new Map(this.faceChangeMap),new Map(this.oppositeChangeMap),this.invalidFaceColor||this.parentState.hasInvalidFaceColors())}createDelta(){return new he(this.board,this)}serializeState(t){return We(this)}}const Me=()=>Qe.nextInt(Number.MAX_SAFE_INTEGER);class B{constructor(e,t,s,i,a,n,c,o){h(this,"faceColorsChangedEmitter",new F);h(this,"faceColors");h(this,"colorMap");h(this,"colorInverseMap");h(this,"oppositeColorMap");h(this,"outsideColor");h(this,"insideColor");h(this,"invalidFaceColor");this.board=e,g()&&d(!t||c,"Provide all or none of the optional arguments"),this.outsideColor=n||new re(Me(),W.OUTSIDE),this.insideColor=c||new re(Me(),W.INSIDE),this.colorMap=new Map(s||[...e.faces].map(l=>[l,new re(Me(),W.UNDECIDED)])),this.faceColors=new Set(t||[this.outsideColor,this.insideColor,...e.faces.map(l=>this.colorMap.get(l))]),g()&&d(this.board.faces.every(l=>this.colorMap.has(l))),g()&&d(this.board.faces.every(l=>this.faceColors.has(this.colorMap.get(l)))),this.colorInverseMap=new Map(i?[...i.keys()].map(l=>[l,new Set([...i.get(l)])]):[...this.faceColors].map(l=>[l,new Set([...this.colorMap.keys()].filter(f=>this.colorMap.get(f)===l))])),this.oppositeColorMap=new Map(a||[[this.outsideColor,this.insideColor],[this.insideColor,this.outsideColor]]),this.invalidFaceColor=!!o}getFaceColors(){return[...this.faceColors]}getInsideColor(){return this.insideColor}getOutsideColor(){return this.outsideColor}getFaceColor(e){const t=this.colorMap.get(e);return g()&&d(t),t}getFacesWithColor(e){g()&&d(this.faceColors.has(e));const t=this.colorInverseMap.get(e);return g()&&d(t),[...t]}getFaceColorMap(){return new Map(this.colorMap)}getOppositeFaceColor(e){return this.oppositeColorMap.get(e)??null}hasInvalidFaceColors(){return this.invalidFaceColor}modifyFaceColors(e,t,s,i,a){for(const o of e)this.faceColors.add(o),this.colorInverseMap.set(o,new Set);for(const[o,l]of s.entries()){const f=this.colorMap.get(o);g()&&d(f),this.colorMap.set(o,l),this.colorInverseMap.get(f).delete(o),this.colorInverseMap.get(l).add(o)}for(const[o,l]of i.entries())this.oppositeColorMap.set(o,l),this.oppositeColorMap.set(l,o);const n=new Set;for(const o of t)n.add(o),this.faceColors.delete(o),this.colorInverseMap.delete(o),this.oppositeColorMap.delete(o);for(const o of this.faceColors)this.oppositeColorMap.has(o)&&n.has(this.oppositeColorMap.get(o))&&this.oppositeColorMap.delete(o);const c=new Set(i.keys());if(this.invalidFaceColor=a,g()&&d(this.board.faces.every(o=>this.colorMap.has(o))),g()&&d(this.board.faces.every(o=>this.faceColors.has(this.colorMap.get(o)))),g()){const o=new Set(this.getFaceColors());for(const l of o){const f=this.getOppositeFaceColor(l);f&&!o.has(f)&&d(!1,`opposite color ${f} of color ${l} is not in the set of colors`)}}this.faceColorsChangedEmitter.emit(e,t,c,[...s.keys()])}clone(){return new B(this.board,this.faceColors,this.colorMap,this.colorInverseMap,this.oppositeColorMap,this.outsideColor,this.insideColor,this.invalidFaceColor)}createDelta(){return new he(this.board,this)}serializeState(e){return We(this)}static deserializeState(e,t){const s=t.colors.map(l=>{const f=l.id,S=W.enumeration.getValue(l.colorState);return g()&&d(S),new re(f,S)}),i=new Map,a=new Map,n=new Map;s.forEach((l,f)=>{const S=t.colors[f].faces.map(M=>T(e,M));S.forEach(M=>i.set(M,l)),a.set(l,new Set(S));const x=t.colors[f].oppositeFaceColorId;if(x!==null){const M=s.find(u=>u.id===x);g()&&d(M),n.set(l,M)}});const c=s.find(l=>l.colorState===W.OUTSIDE);g()&&d(c);const o=s.find(l=>l.colorState===W.INSIDE);return g()&&d(o),new B(e,new Set(s),i,a,n,c,o,t.invalidFaceColor)}}const be=(r,e)=>({type:"FaceValueData",faces:r.faces.filter(t=>e.getFaceValue(t)!==null).map(t=>({face:Y(t),state:e.getFaceValue(t)}))}),ke=(r,e)=>({type:"EdgeData",edges:r.edges.filter(t=>e.getEdgeState(t)!==E.WHITE).map(t=>({edge:U(t),state:e.getEdgeState(t).name}))}),Ue=(r,e)=>({type:"SectorStateData",sectors:r.halfEdges.filter(t=>e.getSectorState(t)!==L.ANY).map(t=>({sector:Re(t),state:e.getSectorState(t).serialize()}))}),Ne=(r,e)=>({type:"VertexStateData",vertices:r.vertices.filter(t=>!e.getVertexState(t).isAny()).map(t=>({vertex:Ye(t),state:e.getVertexState(t).serialize()}))}),Te=(r,e)=>({type:"FaceStateData",faces:r.faces.map(t=>({face:Y(t),state:e.getFaceState(t).serialize()}))}),Ke=(r,e)=>({type:"CompleteData",faceValueData:be(r,e),edgeStateData:ke(r,e),simpleRegionData:ze(e),faceColorData:We(e),sectorStateData:Ue(r,e),vertexStateData:Ne(r,e),faceStateData:Te(r,e)});class de extends X{constructor(t,s,i=new Map){super(t,i);h(this,"faceValueChangedEmitter",new F);this.parentState=s}getFaceValue(t){return this.faceValueMap.has(t)?this.faceValueMap.get(t):this.parentState.getFaceValue(t)}setFaceValue(t,s){this.getFaceValue(t)!==s&&(this.faceValueMap.set(t,s),this.faceValueChangedEmitter.emit(t,s))}clone(){return new de(this.board,this.parentState,new Map(this.faceValueMap))}createDelta(){return new de(this.board,this,new Map)}serializeState(t){return be(t,this)}}class _{constructor(e,t){h(this,"faceValueChangedEmitter",new F);h(this,"faceValueMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceValueMap.set(s,t(s))})}getFaceValue(e){return g()&&d(this.faceValueMap.has(e)),this.faceValueMap.get(e)}setFaceValue(e,t){g()&&d(this.faceValueMap.has(e)),this.faceValueMap.get(e)!==t&&(this.faceValueMap.set(e,t),this.faceValueChangedEmitter.emit(e,t))}clone(){return new _(this.board,e=>this.getFaceValue(e))}createDelta(){return new de(this.board,this)}serializeState(e){return be(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(i=>[T(e,i.face),i.state]));return new _(e,i=>s.get(i)??null)}}class ge extends Q{constructor(t,s,i=new Map){super(t,i);h(this,"edgeStateChangedEmitter",new F);this.parentState=s}getEdgeState(t){return this.edgeStateMap.has(t)?this.edgeStateMap.get(t):this.parentState.getEdgeState(t)}setEdgeState(t,s){const i=this.getEdgeState(t);i!==s&&(this.edgeStateMap.set(t,s),this.edgeStateChangedEmitter.emit(t,s,i))}clone(){return new ge(this.board,this.parentState,new Map(this.edgeStateMap))}createDelta(){return new ge(this.board,this,new Map)}serializeState(t){return ke(t,this)}}class ee{constructor(e,t){h(this,"edgeStateChangedEmitter",new F);h(this,"edgeStateMap",new Map);this.board=e,e.edges.forEach(s=>{this.edgeStateMap.set(s,t(s))})}getEdgeState(e){return g()&&d(this.edgeStateMap.has(e)),this.edgeStateMap.get(e)}setEdgeState(e,t){g()&&d(this.edgeStateMap.has(e));const s=this.edgeStateMap.get(e);s!==t&&(this.edgeStateMap.set(e,t),this.edgeStateChangedEmitter.emit(e,t,s))}clone(){return new ee(this.board,e=>this.getEdgeState(e))}createDelta(){return new ge(this.board,this)}serializeState(e){return ke(e,this)}static deserializeState(e,t){const s=new Map(t.edges.map(i=>[N(e,i.edge),E.enumeration.getValue(i.state)]));return new ee(e,i=>s.get(i)??E.WHITE)}}class ue extends j{constructor(t,s,i,a,n,c,o){super(t,s,i,a,n,c,o);h(this,"anyStateChangedEmitter",new F);this.faceValueDelta=t,this.edgeStateDelta=s,this.simpleRegionDelta=i,this.faceColorDelta=a,this.sectorStateDelta=n,this.vertexStateDelta=c,this.faceStateDelta=o;const l=()=>this.anyStateChangedEmitter.emit();t.faceValueChangedEmitter.addListener(l),s.edgeStateChangedEmitter.addListener(l),i.simpleRegionsChangedEmitter.addListener(l),a.faceColorsChangedEmitter.addListener(l),n.sectorStateChangedEmitter.addListener(l),c.vertexStateChangedEmitter.addListener(l),o.faceStateChangedEmitter.addListener(l)}getFaceValue(t){return this.faceValueDelta.getFaceValue(t)}setFaceValue(t,s){this.faceValueDelta.setFaceValue(t,s)}get faceValueChangedEmitter(){return this.faceValueDelta.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateDelta.getEdgeState(t)}setEdgeState(t,s){this.edgeStateDelta.setEdgeState(t,s)}get edgeStateChangedEmitter(){return this.edgeStateDelta.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDelta.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDelta.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDelta.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDelta.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDelta.getWeirdEdges()}modifyRegions(t,s,i,a){this.simpleRegionDelta.modifyRegions(t,s,i,a)}get simpleRegionsChangedEmitter(){return this.simpleRegionDelta.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorDelta.getFaceColors()}getInsideColor(){return this.faceColorDelta.getInsideColor()}getOutsideColor(){return this.faceColorDelta.getOutsideColor()}getFaceColor(t){return this.faceColorDelta.getFaceColor(t)}getFacesWithColor(t){return this.faceColorDelta.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorDelta.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorDelta.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorDelta.hasInvalidFaceColors()}modifyFaceColors(t,s,i,a,n){this.faceColorDelta.modifyFaceColors(t,s,i,a,n)}get faceColorsChangedEmitter(){return this.faceColorDelta.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateDelta.getSectorState(t)}setSectorState(t,s){this.sectorStateDelta.setSectorState(t,s)}get sectorStateChangedEmitter(){return this.sectorStateDelta.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateDelta.getVertexState(t)}setVertexState(t,s){this.vertexStateDelta.setVertexState(t,s)}get vertexStateChangedEmitter(){return this.vertexStateDelta.vertexStateChangedEmitter}getFaceState(t){return this.faceStateDelta.getFaceState(t)}setFaceState(t,s){this.faceStateDelta.setFaceState(t,s)}get faceStateChangedEmitter(){return this.faceStateDelta.faceStateChangedEmitter}clone(){return new ue(this.faceValueDelta.clone(),this.edgeStateDelta.clone(),this.simpleRegionDelta.clone(),this.faceColorDelta.clone(),this.sectorStateDelta.clone(),this.vertexStateDelta.clone(),this.faceStateDelta.clone())}createDelta(){return new ue(this.faceValueDelta.createDelta(),this.edgeStateDelta.createDelta(),this.simpleRegionDelta.createDelta(),this.faceColorDelta.createDelta(),this.sectorStateDelta.createDelta(),this.vertexStateDelta.createDelta(),this.faceStateDelta.createDelta())}serializeState(t){return Ke(t,this)}}class pe extends G{constructor(t,s,i=new Set,a=new Set,n=new Set,c=new Set){super(t,i,a,n,c);h(this,"simpleRegionsChangedEmitter",new F);this.parentState=s}getSimpleRegions(){return[...this.parentState.getSimpleRegions().filter(t=>!this.removedRegions.has(t)),...this.addedRegions]}getSimpleRegionWithVertex(t){for(const s of this.getSimpleRegions())if(s.a===t||s.b===t)return s;return null}getSimpleRegionWithEdge(t){for(const s of this.getSimpleRegions())if(s.edges.includes(t))return s;return null}getSimpleRegionWithId(t){for(const s of this.getSimpleRegions())if(s.id===t)return s;return null}getWeirdEdges(){return[...this.parentState.getWeirdEdges().filter(t=>!this.removedWeirdEdges.has(t)),...this.addedWeirdEdges]}modifyRegions(t,s,i,a){for(const n of s)this.addedRegions.has(n)?this.addedRegions.delete(n):this.removedRegions.add(n);for(const n of t)this.addedRegions.add(n);for(const n of a)this.addedWeirdEdges.has(n)?this.addedWeirdEdges.delete(n):this.removedWeirdEdges.add(n);for(const n of i)this.addedWeirdEdges.add(n);this.simpleRegionsChangedEmitter.emit(t,s,i,a)}clone(){return new pe(this.board,this.parentState,new Set(this.addedRegions),new Set(this.removedRegions),new Set(this.addedWeirdEdges),new Set(this.removedWeirdEdges))}createDelta(){return new pe(this.board,this)}serializeState(t){return ze(this)}}class P{constructor(e,t,s){h(this,"simpleRegionsChangedEmitter",new F);h(this,"simpleRegions");h(this,"weirdEdges");this.board=e,this.simpleRegions=new Set(t),this.weirdEdges=new Set(s)}getSimpleRegions(){return[...this.simpleRegions]}getSimpleRegionWithVertex(e){for(const t of this.simpleRegions)if(t.a===e||t.b===e)return t;return null}getSimpleRegionWithEdge(e){for(const t of this.simpleRegions)if(t.edges.includes(e))return t;return null}getSimpleRegionWithId(e){for(const t of this.simpleRegions)if(t.id===e)return t;return null}getWeirdEdges(){return[...this.weirdEdges]}modifyRegions(e,t,s,i){for(const a of t)this.simpleRegions.delete(a);for(const a of e)this.simpleRegions.add(a);for(const a of i)this.weirdEdges.delete(a);for(const a of s)this.weirdEdges.add(a);this.simpleRegionsChangedEmitter.emit(e,t,s,i)}clone(){return new P(this.board,this.simpleRegions,this.weirdEdges)}createDelta(){return new pe(this.board,this)}serializeState(e){return ze(this)}static deserializeState(e,t){return new P(e,t.simpleRegions.map(s=>J.deserializeSimpleRegion(e,s)),t.weirdEdges.map(s=>N(e,s)))}}class fe{constructor(e,t=new Map){this.board=e,this.sectorStateMap=t}apply(e){for(const[t,s]of this.sectorStateMap)e.setSectorState(t,s)}getUndo(e){const t=new Map;for(const s of this.sectorStateMap.keys())t.set(s,e.getSectorState(s));return new fe(this.board,t)}isEmpty(){return this.sectorStateMap.size===0}serializeAction(){return{type:"GeneralSectorAction",sectors:Array.from(this.sectorStateMap.entries()).map(([e,t])=>({sector:Re(e),state:t.serialize()}))}}static deserializeAction(e,t){return new fe(e,new Map(t.sectors.map(s=>[Ve(e,s.sector),L.deserialize(s.state)])))}}class me extends fe{constructor(t,s,i=new Map){super(t,i);h(this,"sectorStateChangedEmitter",new F);this.parentState=s}getSectorState(t){return this.sectorStateMap.has(t)?this.sectorStateMap.get(t):this.parentState.getSectorState(t)}setSectorState(t,s){const i=this.getSectorState(t);i!==s&&(this.sectorStateMap.set(t,s),this.sectorStateChangedEmitter.emit(t,s,i))}clone(){return new me(this.board,this.parentState,new Map(this.sectorStateMap))}createDelta(){return new me(this.board,this,new Map)}serializeState(t){return Ue(t,this)}}class q{constructor(e,t=()=>L.ANY){h(this,"sectorStateChangedEmitter",new F);h(this,"sectorStateMap",new Map);this.board=e,e.halfEdges.forEach(s=>{this.sectorStateMap.set(s,t(s))})}getSectorState(e){return g()&&d(this.sectorStateMap.has(e)),this.sectorStateMap.get(e)}setSectorState(e,t){g()&&d(this.sectorStateMap.has(e));const s=this.sectorStateMap.get(e);s!==t&&(this.sectorStateMap.set(e,t),this.sectorStateChangedEmitter.emit(e,t,s))}clone(){return new q(this.board,e=>this.getSectorState(e))}createDelta(){return new me(this.board,this)}serializeState(e){return Ue(e,this)}static deserializeState(e,t){const s=new Map(t.sectors.map(i=>[Ve(e,i.sector),L.deserialize(i.state)]));return new q(e,i=>s.get(i)??L.ANY)}}class Se{constructor(e,t=new Map){this.board=e,this.vertexStateMap=t}apply(e){for(const[t,s]of this.vertexStateMap)e.setVertexState(t,s)}getUndo(e){const t=new Map;for(const s of this.vertexStateMap.keys())t.set(s,e.getVertexState(s));return new Se(this.board,t)}isEmpty(){return this.vertexStateMap.size===0}serializeAction(){return{type:"GeneralVertexAction",vertices:Array.from(this.vertexStateMap.entries()).map(([e,t])=>({vertex:Ye(e),state:t.serialize()}))}}static deserializeAction(e,t){return new Se(e,new Map(t.vertices.map(s=>[Ae(e,s.vertex),C.deserialize(Ae(e,s.vertex),s.state)])))}}class we extends Se{constructor(t,s,i=new Map){super(t,i);h(this,"vertexStateChangedEmitter",new F);this.parentState=s}getVertexState(t){return this.vertexStateMap.has(t)?this.vertexStateMap.get(t):this.parentState.getVertexState(t)}setVertexState(t,s){const i=this.getVertexState(t);i.equals(s)||(this.vertexStateMap.set(t,s),this.vertexStateChangedEmitter.emit(t,s,i))}clone(){return new we(this.board,this.parentState,new Map(this.vertexStateMap))}createDelta(){return new we(this.board,this,new Map)}serializeState(t){return Ne(t,this)}}class H{constructor(e,t=C.any){h(this,"vertexStateChangedEmitter",new F);h(this,"vertexStateMap",new Map);this.board=e,e.vertices.forEach(s=>{this.vertexStateMap.set(s,t(s))})}getVertexState(e){return g()&&d(this.vertexStateMap.has(e)),this.vertexStateMap.get(e)}setVertexState(e,t){g()&&d(this.vertexStateMap.has(e));const s=this.vertexStateMap.get(e);s.equals(t)||(this.vertexStateMap.set(e,t),this.vertexStateChangedEmitter.emit(e,t,s))}clone(){return new H(this.board,e=>this.getVertexState(e))}createDelta(){return new we(this.board,this)}serializeState(e){return Ne(e,this)}static deserializeState(e,t){const s=new Map(t.vertices.map(i=>{const a=Ae(e,i.vertex);return[a,C.deserialize(a,i.state)]}));return new H(e,i=>s.get(i)??C.any(i))}}class Ce{constructor(e,t=new Map){this.board=e,this.faceStateMap=t}apply(e){for(const[t,s]of this.faceStateMap)e.setFaceState(t,s)}getUndo(e){const t=new Map;for(const s of this.faceStateMap.keys())t.set(s,e.getFaceState(s));return new Ce(this.board,t)}isEmpty(){return this.faceStateMap.size===0}serializeAction(){return{type:"GeneralFaceAction",faces:Array.from(this.faceStateMap.entries()).map(([e,t])=>({face:Y(e),state:t.serialize()}))}}static deserializeAction(e,t){return new Ce(e,new Map(t.faces.map(s=>[T(e,s.face),w.deserialize(T(e,s.face),s.state)])))}}class Ee extends Ce{constructor(t,s,i=new Map){super(t,i);h(this,"faceStateChangedEmitter",new F);this.parentState=s}getFaceState(t){return this.faceStateMap.has(t)?this.faceStateMap.get(t):this.parentState.getFaceState(t)}setFaceState(t,s){const i=this.getFaceState(t);i.equals(s)||(this.faceStateMap.set(t,s),this.faceStateChangedEmitter.emit(t,s,i))}clone(){return new Ee(this.board,this.parentState,new Map(this.faceStateMap))}createDelta(){return new Ee(this.board,this,new Map)}serializeState(t){return Te(t,this)}}class Z{constructor(e,t){h(this,"faceStateChangedEmitter",new F);h(this,"faceStateMap",new Map);this.board=e,e.faces.forEach(s=>{this.faceStateMap.set(s,t(s))})}getFaceState(e){return g()&&d(this.faceStateMap.has(e)),this.faceStateMap.get(e)}setFaceState(e,t){g()&&d(this.faceStateMap.has(e));const s=this.faceStateMap.get(e);s.equals(t)||(this.faceStateMap.set(e,t),this.faceStateChangedEmitter.emit(e,t,s))}clone(){return new Z(this.board,e=>this.getFaceState(e))}createDelta(){return new Ee(this.board,this)}serializeState(e){return Te(e,this)}static deserializeState(e,t){const s=new Map(t.faces.map(i=>{const a=T(e,i.face);return[a,w.deserialize(a,i.state)]}));return new Z(e,i=>{const a=s.get(i);return g()&&d(a),a})}}class D{constructor(e,t,s,i,a,n,c){h(this,"anyStateChangedEmitter",new F);this.faceValueData=e,this.edgeStateData=t,this.simpleRegionData=s,this.faceColorData=i,this.sectorStateData=a,this.vertexStateData=n,this.faceStateData=c;const o=()=>this.anyStateChangedEmitter.emit();e.faceValueChangedEmitter.addListener(o),t.edgeStateChangedEmitter.addListener(o),s.simpleRegionsChangedEmitter.addListener(o),i.faceColorsChangedEmitter.addListener(o),a.sectorStateChangedEmitter.addListener(o),n.vertexStateChangedEmitter.addListener(o),c.faceStateChangedEmitter.addListener(o)}static fromFacesEdges(e,t,s){const i=new _(e,t);return new D(i,new ee(e,s),new P(e),new B(e),new q(e),new H(e),new Z(e,a=>w.any(a,i.getFaceValue(a))))}static fromFaces(e,t){return D.fromFacesEdges(e,t,()=>E.WHITE)}static fromFaceValueData(e,t){return D.fromFaces(e,s=>t.getFaceValue(s))}static empty(e){return D.fromFaces(e,()=>null)}static faceMapLookup(e){const t=new Map(Array.from(e.entries()).map(([s,i])=>[`${s.x},${s.y}`,i]));return s=>{const i=t.get(`${s.logicalCoordinates.x},${s.logicalCoordinates.y}`);return i!==void 0?i:null}}getFaceValue(e){return this.faceValueData.getFaceValue(e)}setFaceValue(e,t){this.faceValueData.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueData.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateData.getEdgeState(e)}setEdgeState(e,t){this.edgeStateData.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateData.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionData.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionData.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionData.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionData.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionData.getWeirdEdges()}modifyRegions(e,t,s,i){this.simpleRegionData.modifyRegions(e,t,s,i)}get simpleRegionsChangedEmitter(){return this.simpleRegionData.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorData.getFaceColors()}getInsideColor(){return this.faceColorData.getInsideColor()}getOutsideColor(){return this.faceColorData.getOutsideColor()}getFaceColor(e){return this.faceColorData.getFaceColor(e)}getFacesWithColor(e){return this.faceColorData.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorData.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorData.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorData.hasInvalidFaceColors()}modifyFaceColors(e,t,s,i,a){this.faceColorData.modifyFaceColors(e,t,s,i,a)}get faceColorsChangedEmitter(){return this.faceColorData.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateData.getSectorState(e)}setSectorState(e,t){this.sectorStateData.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateData.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateData.getVertexState(e)}setVertexState(e,t){this.vertexStateData.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateData.vertexStateChangedEmitter}getFaceState(e){return this.faceStateData.getFaceState(e)}setFaceState(e,t){this.faceStateData.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateData.faceStateChangedEmitter}clone(){return new D(this.faceValueData.clone(),this.edgeStateData.clone(),this.simpleRegionData.clone(),this.faceColorData.clone(),this.sectorStateData.clone(),this.vertexStateData.clone(),this.faceStateData.clone())}createDelta(){return new ue(this.faceValueData.createDelta(),this.edgeStateData.createDelta(),this.simpleRegionData.createDelta(),this.faceColorData.createDelta(),this.sectorStateData.createDelta(),this.vertexStateData.createDelta(),this.faceStateData.createDelta())}serializeState(e){return Ke(e,this)}static deserializeState(e,t){const s=_.deserializeState(e,t.faceValueData);return new D(s,ee.deserializeState(e,t.edgeStateData),t.simpleRegionData?P.deserializeState(e,t.simpleRegionData):new P(e),t.faceColorData?B.deserializeState(e,t.faceColorData):new B(e),t.sectorStateData?q.deserializeState(e,t.sectorStateData):new q(e),t.vertexStateData?H.deserializeState(e,t.vertexStateData):new H(e),t.faceStateData?Z.deserializeState(e,t.faceStateData):new Z(e,i=>w.any(i,s.getFaceValue(i))))}}class k{constructor(e,t){h(this,"stateProperty");this.board=e,this.stateProperty=new Xe(t)}static fromSolvedPuzzle(e){return new k(e.board,e.cleanState)}static loadDefaultPuzzle(){return k.loadFromSimpleString("10x18 .3.1....1..032....0......3.1....02.3...02....3.1...........2011.01..01.......3...2302..........1102...3.......22..03.0322...........3.2....13...2.30....2.2......1....103..2....1.3.")}static loadFromSimpleString(e){const[t,s]=e.split(" "),[i,a]=t.split("x").map(o=>parseInt(o)),n=new Be(i,a),c=D.fromFaces(n,o=>{const l=o.logicalCoordinates.y*i+o.logicalCoordinates.x,f=s[l];return f==="."?null:parseInt(f)});return new k(n,c)}static loadDeprecatedScalaString(e){if(!e.includes("!"))return k.loadFromSimpleString(e);const t=1,s=2,i=4,a=8,[n,c]=e.split(" "),[o,l]=n.split("x").map(u=>parseInt(u)),f=new Be(o,l),S=u=>3*(u.logicalCoordinates.y*o+u.logicalCoordinates.x)+1,x=(u,p)=>{const y=S(u),v=parseInt(c[y+1]),A=parseInt(c[y+2]);return v&p?E.BLACK:A&p?E.RED:E.WHITE},M=D.fromFacesEdges(f,u=>{const p=c[S(u)];return p==="."?null:parseInt(p)},u=>{if((u.start.logicalCoordinates.x===u.end.logicalCoordinates.x?ye.VERTICAL:ye.HORIZONTAL)===ye.HORIZONTAL){const y=u.start.logicalCoordinates.x<u.end.logicalCoordinates.x?u.forwardFace:u.reversedFace,v=u.start.logicalCoordinates.x<u.end.logicalCoordinates.x?u.reversedFace:u.forwardFace;return y?x(y,s):x(v,a)}else{const y=u.start.logicalCoordinates.y<u.end.logicalCoordinates.y?u.reversedFace:u.forwardFace,v=u.start.logicalCoordinates.y<u.end.logicalCoordinates.y?u.forwardFace:u.reversedFace;return y?x(y,t):x(v,i)}});return new k(f,M)}static loadPointyTopHexagonalString(e){g()&&d(e.startsWith("h")||e.startsWith("H"));const[t,s]=e.slice(1).split(" "),i=parseInt(t),a=new Pe(i,Math.sqrt(3)/2,e.startsWith("h")),n=Pe.enumeratePointyFaceCoordinates(i),c=new Map;for(let l=0;l<s.length;l++){const f=s[l];if(f===".")continue;const S=n[l];c.set(S,parseInt(f))}const o=D.fromFaces(a,D.faceMapLookup(c));return new k(a,o)}}export{k as B,D as C,E,W as F,_ as G,L as S,Ie as U,C as V,ee as a,P as b,oe as c,ce as d,Oe as e,Re as f,Ve as g,_e as h,et as i,Y as j,T as k,w as l,Ye as m,Ae as n,J as o,G as p,re as q,Me as r,ct as s,it as t};
