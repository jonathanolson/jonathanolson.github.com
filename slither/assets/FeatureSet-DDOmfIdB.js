var G=Object.defineProperty;var Q=(w,e,s)=>e in w?G(w,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):w[e]=s;var f=(w,e,s)=>(Q(w,typeof e!="symbol"?e+"":e,s),s);import{a as l,b as h,_ as q}from"./getCoordinateClusteredMap-DCjAm76-.js";import{T as I,e as J,f as X,g as Y,h as _,l as ee,i as se,d as z,I as u,F as b,B as E,R as p,a as x,b as V,c as T,S as v}from"./FaceColorDualFeature-DKZsSiFX.js";import{L as R}from"./logic-solver-O3GFcRDa.js";import{a as $,E as j,d as U}from"./Vector2Property-DCXaH-JP.js";import{q as te}from"./patternBoards-Hmq_9LOt.js";class oe{constructor(e){f(this,"nameMap",new Map);f(this,"termMap",new Map);f(this,"solver",new R.Solver);e&&this.addFormulas(e)}addFormula(e){this.solver.require(e instanceof I?e.name:e.logic),this.addTermsFrom(e)}addFormulas(e){for(const s of e)this.addFormula(s)}addTermsFrom(e){if(e instanceof I)this.nameMap.has(e.name)?l()&&(h(this.nameMap.get(e.name)===e.value),h(this.termMap.get(e.value)===e.name)):(this.nameMap.set(e.name,e.value),l()&&h(!this.termMap.has(e.value)),this.termMap.set(e.value,e.name));else for(const s of e.parameters)this.addTermsFrom(s)}getNextSolution(){let e=null;if(R.disablingAssertions(()=>{e=this.solver.solve()}),e){const s=e.getTrueVars(),t=new Set(s),o=new Set([...this.nameMap.keys()].filter(i=>!t.has(i)));return this.solver.require(R.or(...[...t].map(i=>`-${i}`),...[...o].map(i=>i))),s.map(i=>{const r=this.nameMap.get(i);return l()&&h(r!==void 0),r})}else return null}}class ie{constructor(e){this.vertex=e}isPossibleWith(e){const s=this.vertex.edges.filter(t=>e(t)).length;return s===0||s===2}getPossibleFormula(e){return J(this.vertex.edges.map(s=>e(s)))}}class B{constructor(e){this.possibleLoops=e}isPossibleWith(e){return this.possibleLoops.every(s=>s.some(t=>!e(t)))}getPossibleFormula(e){return this.possibleLoops.length?X(this.possibleLoops.map(s=>Y(s.map(t=>e(t))))):_}static fromBoard(e){return new B(B.findLoops(e.edges,e.vertices).map(s=>[...s]))}static findLoops(e,s){const t=[],o=new Set,i=new Set,r=[],n=(a,d)=>{for(const c of a.edges){if(c.vertices.length<2)continue;const S=c.vertices.find(O=>O!==a);if(l()&&h(S),!i.has(S))if(S===d&&r.length>=2){const O=[...r,c],A=O.map(D=>D.index).sort().join(",");o.has(A)||(o.add(A),t.push(new Set(O)))}else i.add(S),r.push(c),n(S,d),r.pop(),i.delete(S)}};for(const a of s)n(a,a);return t}}const re=w=>[...w.vertices.map(e=>new ie(e)),B.fromBoard(w)];class k{constructor(e){f(this,"solver",new oe);f(this,"getFormula");this.getFormula=s=>new I(s,`e${s.index}`);for(const s of re(e))this.addFeature(s);e.vertices.length===0&&this.solver.addFormula(ee([this.getFormula(e.edges[0]),se(this.getFormula(e.edges[0]))]))}addFeature(e){this.solver.addFormula(e.getPossibleFormula(this.getFormula))}getNextSolution(){return this.solver.getNextSolution()}getRemainingSolutions(){const e=[];for(;;){const s=this.getNextSolution();if(s)e.push(s);else break}return e}static forEachSolution(e,s,t){const o=new k(e);for(const i of s)o.addFeature(i);for(;;){const i=o.getNextSolution();if(i)t(i);else break}}static countSolutions(e,s){let t=0;return k.forEachSolution(e,s,()=>{t++}),t}static getSolutions(e,s){const t=new k(e);for(const o of s)t.addFeature(o);return t.getRemainingSolutions()}static hasSolution(e,s){const t=new k(e);for(const o of s)t.addFeature(o);return t.getNextSolution()!==null}}const ne=(w,e)=>{const s=new Map,t=r=>{const n=r.slice(),a=[];for(;n.length;){const c=n.find(M=>M.isExit);l()&&h(c);const S=M=>{const L=M.vertices.flatMap(Z=>Z.edges).filter(Z=>n.includes(Z));return l()&&h(L.length===1),L[0]};$(n,c);let O=c;for(;O===c||!O.isExit;){const M=S(O);$(n,M),O=M}const A=O,D=Math.min(c.exitVertex.index,A.exitVertex.index),K=Math.max(c.exitVertex.index,A.exitVertex.index);a.push({minVertexIndex:D,maxVertexIndex:K})}const d=q.sortBy(a,c=>c.minVertexIndex);return`${e.map(c=>r.includes(c)?"1":"0")}${d.map(c=>`,c${c.minVertexIndex}-${c.maxVertexIndex}`)}`};for(const r of w){const n=t(r);s.has(n)?s.get(n).push(r):s.set(n,[r])}const o=[],i=[];for(const r of s.values())r.length>1?i.push(r):o.push(r[0]);return{highlanderSolutions:o,excludedSolutionGroups:i}},ae=(w,e)=>{const s=e.filter(o=>o instanceof z),t=new Set(s.map(o=>o.face));return w.edges.filter(o=>o.isExit||o.faces.some(i=>!t.has(i)))},N=class N extends j{};f(N,"INCOMPATIBLE",new N),f(N,"NO_MATCH_NEEDS_FACE_VALUES",new N),f(N,"NO_MATCH_NEEDS_STATE",new N),f(N,"MATCH",new N),f(N,"enumeration",new U(N));let F=N;const H=new WeakMap;class P{constructor(e){f(this,"connectedFacePairs",[]);f(this,"connectedExitFacePairs",[]);f(this,"connectedComponents",[]);this.patternBoard=e;for(const s of e.faces){const t=new Set([s]),o=[new W(s,[])];let i=!0;for(;o.length;){const r=o.shift(),{face:n,edges:a}=r;for(const d of n.edges)if(d.faces.length===2){const c=d.faces[0]===n?d.faces[1]:d.faces[0];if(!t.has(c)){const S=[...a,d];if(t.add(c),o.push(new W(c,S)),s.index<c.index){const O=new ce(s,c,S);this.connectedFacePairs.push(O),n.isExit&&c.isExit&&this.connectedExitFacePairs.push(O)}else i=!1}}}i&&this.connectedComponents.push([...t])}}static get(e){let s=H.get(e);return s||(s=new P(e),H.set(e,s)),s}}class ce{constructor(e,s,t){this.a=e,this.b=s,this.shortestPath=t,l()&&h(e.index<s.index)}containsFace(e){return this.a===e||this.b===e}containsFacePair(e,s){return this.a===e&&this.b===s||this.a===s&&this.b===e}}class W{constructor(e,s){this.face=e,this.edges=s}}const y=class y extends j{};f(y,"INCOMPATIBLE",new y),f(y,"DORMANT",new y),f(y,"MATCH",new y),f(y,"enumeration",new U(y));let g=y;const m=[];class C{constructor(e,s=new Map,t=new Set,o=new Set,i=new Set,r=new Set,n=new Set,a=new Set,d=new Set,c=new Map,S=new Set,O=new Map){f(this,"size");this.patternBoard=e,this.faceValueMap=s,this.blackEdges=t,this.redEdges=o,this.sectorsNotZero=i,this.sectorsNotOne=r,this.sectorsNotTwo=n,this.sectorsOnlyOne=a,this.faceColorDualFeatures=d,this.faceToColorDualMap=c,this.sectors=S,this.edgeToSectorsMap=O,this.size=this.computeSize()}addFaceValue(e,s){const t=this.faceValueMap.get(e);if(t!==void 0){if(t!==s)throw new u(new z(e,s),[new z(e,t)])}else this.faceValueMap.set(e,s),this.size++;l()&&this.verifySize()}addSameColorFaces(e,s){this.addFaceColorDual(b.fromPrimarySecondaryFaces([e,s],[]))}addOppositeColorFaces(e,s){this.addFaceColorDual(b.fromPrimarySecondaryFaces([e],[s]))}addFaceColorDual(e){l()&&h(e);const s=e;for(const t of[...this.faceColorDualFeatures])if(e.overlapsWith(t)){const o=e.union(t);if(o)e=o,this.faceColorDualFeatures.delete(t),this.size-=t.allFaces.size-1;else throw new u(s,[t])}this.faceColorDualFeatures.add(e),this.size+=e.allFaces.size-1;for(const t of e.allFaces)this.faceToColorDualMap.set(t,e);l()&&this.verifySize()}addBlackEdge(e){if(l()&&h(e),this.blackEdges.has(e))return;if(this.redEdges.has(e)){debugger;throw new u(new E(e),[new p(e)])}this.size++,this.blackEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const o=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(o);let i=0;if(this.sectorsNotZero.has(t)&&(this.sectorsNotZero.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.blackEdges.has(o))this.sectorsNotOne.delete(t),this.size--;else{if(this.redEdges.has(o))throw new u(new E(e),[new p(o),new x(t)]);i++}if(this.sectorsNotTwo.has(t))if(this.redEdges.has(o))this.sectorsNotTwo.delete(t),this.size--;else{if(this.blackEdges.has(o))throw new u(new E(e),[new E(o),new V(t)]);i++}if(this.sectorsOnlyOne.has(t))if(this.redEdges.has(o))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.blackEdges.has(o))throw new u(new E(e),[new E(o),new T(t)]);i++}i===0&&this.removeSector(t)}l()&&this.verifySize()}addRedEdge(e){if(l()&&h(e),this.redEdges.has(e))return;if(this.blackEdges.has(e))throw new u(new p(e),[new E(e)]);this.size++,this.redEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const o=e===t.edges[0]?t.edges[1]:t.edges[0];l()&&h(o);let i=0;if(this.sectorsNotTwo.has(t)&&(this.sectorsNotTwo.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.redEdges.has(o))this.sectorsNotOne.delete(t),this.size--;else{if(this.blackEdges.has(o))throw new u(new p(e),[new E(o),new x(t)]);i++}if(this.sectorsNotZero.has(t))if(this.blackEdges.has(o))this.sectorsNotZero.delete(t),this.size--;else{if(this.redEdges.has(o))throw new u(new p(e),[new p(o),new v(t)]);i++}if(this.sectorsOnlyOne.has(t))if(this.blackEdges.has(o))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.redEdges.has(o))throw new u(new p(e),[new p(o),new T(t)]);i++}i===0&&this.removeSector(t)}l()&&this.verifySize()}addSectorNotZero(e){if(l()&&h(e),this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const o=this.redEdges.has(s),i=this.redEdges.has(t);if(o&&i)throw new u(new v(e),[new p(s),new p(t)]);this.blackEdges.has(s)||this.blackEdges.has(t)||(o?this.addBlackEdge(t):i?this.addBlackEdge(s):this.sectorsNotOne.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.size--,this.sectorsNotTwo.delete(e),this.addSectorOnlyOne(e)):(this.size++,this.sectorsNotZero.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotOne(e){if(l()&&h(e),this.sectorsNotOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const o=this.blackEdges.has(s),i=this.blackEdges.has(t),r=this.redEdges.has(s),n=this.redEdges.has(t);if(o&&n)throw new u(new x(e),[new E(s),new p(t)]);if(i&&r)throw new u(new x(e),[new E(t),new p(s)]);if(this.sectorsOnlyOne.has(e))throw new u(new x(e),[new T(e)]);o&&i||r&&n||(o?this.addBlackEdge(t):i?this.addBlackEdge(s):r?this.addRedEdge(t):n?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotOne.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorNotTwo(e){if(l()&&h(e),this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const o=this.blackEdges.has(s),i=this.blackEdges.has(t);if(o&&i)throw new u(new V(e),[new E(s),new E(t)]);this.redEdges.has(s)||this.redEdges.has(t)||(o?this.addRedEdge(t):i?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.size--,this.sectorsNotZero.delete(e),this.addSectorOnlyOne(e)):this.sectorsNotOne.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotTwo.add(e),this.ensureSector(e)),l()&&this.verifySize())}addSectorOnlyOne(e){if(l()&&h(e),this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const o=this.blackEdges.has(s),i=this.blackEdges.has(t),r=this.redEdges.has(s),n=this.redEdges.has(t);if(o&&i)throw new u(new T(e),[new E(s),new E(t)]);if(r&&n)throw new u(new T(e),[new p(s),new p(t)]);if(this.sectorsNotOne.has(e))throw new u(new T(e),[new x(e)]);o&&n||i&&r||(o?this.addRedEdge(t):i?this.addRedEdge(s):r?this.addBlackEdge(t):n?this.addBlackEdge(s):this.sectorsNotZero.has(e)&&(this.size--,this.sectorsNotZero.delete(e)),this.sectorsNotTwo.has(e)&&(this.size--,this.sectorsNotTwo.delete(e)),this.size++,this.sectorsOnlyOne.add(e),this.ensureSector(e),l()&&this.verifySize())}addFeature(e){if(e instanceof z)this.addFaceValue(e.face,e.value);else if(e instanceof b)this.addFaceColorDual(e);else if(e instanceof E)this.addBlackEdge(e.edge);else if(e instanceof p)this.addRedEdge(e.edge);else if(e instanceof v)this.addSectorNotZero(e.sector);else if(e instanceof x)this.addSectorNotOne(e.sector);else if(e instanceof V)this.addSectorNotTwo(e.sector);else if(e instanceof T)this.addSectorOnlyOne(e.sector);else throw new Error(`unimplemented type of feature for FeatureSet: ${e}`);l()&&this.verifySize()}ensureSector(e){if(!this.sectors.has(e)){this.sectors.add(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);let o=this.edgeToSectorsMap.get(s);o?o.add(e):(o=new Set([e]),this.edgeToSectorsMap.set(s,o));let i=this.edgeToSectorsMap.get(t);i?i.add(e):(i=new Set([e]),this.edgeToSectorsMap.set(t,i))}}removeSector(e){if(this.sectors.has(e)){this.sectors.delete(e);const s=e.edges[0],t=e.edges[1];l()&&h(s&&t);const o=this.edgeToSectorsMap.get(s);o&&(o.delete(e),o.size===0&&this.edgeToSectorsMap.delete(s));const i=this.edgeToSectorsMap.get(t);i&&(i.delete(e),i.size===0&&this.edgeToSectorsMap.delete(t))}}computeSize(){let e=this.faceValueMap.size+this.blackEdges.size+this.redEdges.size+this.sectorsNotZero.size+this.sectorsNotOne.size+this.sectorsNotTwo.size+this.sectorsOnlyOne.size;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}verifySize(){l()&&h(this.size===this.computeSize(),"size mismatch")}getInputDifficultyScoreA(){let e=0;e+=this.faceValueMap.size*.5,e+=this.blackEdges.size*1;for(const s of this.redEdges)e+=s.isExit?2.5:1.2;e+=this.sectorsOnlyOne.size*3,e+=this.sectorsNotOne.size*4,e+=this.sectorsNotTwo.size*4.1,e+=this.sectorsNotZero.size*4.2;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}static empty(e){return new C(e)}static emptyWithVertexOrderLimit(e,s){const t=C.empty(e);for(const o of e.vertices)o.isExit&&o.edges.length>s&&t.addRedEdge(o.exitEdge);return t}static fromFeatures(e,s){const t=new C(e);for(const o of s)t.addFeature(o);return t}static fromSolution(e,s){return C.fromFeatures(e,[...e.edges.filter(t=>!s.includes(t)||!t.isExit).map(t=>s.includes(t)?new E(t):new p(t))])}clone(){return new C(this.patternBoard,new Map(this.faceValueMap),new Set(this.blackEdges),new Set(this.redEdges),new Set(this.sectorsNotZero),new Set(this.sectorsNotOne),new Set(this.sectorsNotTwo),new Set(this.sectorsOnlyOne),new Set(this.faceColorDualFeatures),new Map(this.faceToColorDualMap),new Set(this.sectors),new Map(this.edgeToSectorsMap))}getFeaturesArray(){return[...[...this.faceValueMap.entries()].map(([e,s])=>new z(e,s)),...this.faceColorDualFeatures,...[...this.blackEdges].map(e=>new E(e)),...[...this.redEdges].map(e=>new p(e)),...[...this.sectorsNotZero].map(e=>new v(e)),...[...this.sectorsNotOne].map(e=>new x(e)),...[...this.sectorsNotTwo].map(e=>new V(e)),...[...this.sectorsOnlyOne].map(e=>new T(e))]}getHighlanderFeaturesArray(){return this.getFeaturesArray().filter(e=>e instanceof z||e instanceof p&&e.edge.isExit)}getFaceValue(e){return this.faceValueMap.get(e)}getFaceColorDualFromFace(e){return this.faceToColorDualMap.get(e)??null}impliesFaceValue(e,s){const t=this.faceValueMap.get(e);return t!==void 0&&t===s}impliesBlackEdge(e){return this.blackEdges.has(e)}impliesRedEdge(e){return this.redEdges.has(e)}impliesSectorNotZero(e){return this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])||this.blackEdges.has(e.edges[1])}impliesSectorNotOne(e){return this.sectorsNotOne.has(e)||this.blackEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])}impliesSectorNotTwo(e){return this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e)||this.redEdges.has(e.edges[0])||this.redEdges.has(e.edges[1])}impliesSectorOnlyOne(e){return this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])}impliesFaceColorDualFeature(e){for(const s of this.faceColorDualFeatures)if(e.isSubsetOf(s))return!0;return!1}impliesFeature(e){if(e instanceof b)return this.impliesFaceColorDualFeature(e);if(e instanceof E)return this.impliesBlackEdge(e.edge);if(e instanceof p)return this.impliesRedEdge(e.edge);if(e instanceof v)return this.impliesSectorNotZero(e.sector);if(e instanceof x)return this.impliesSectorNotOne(e.sector);if(e instanceof V)return this.impliesSectorNotTwo(e.sector);if(e instanceof T)return this.impliesSectorOnlyOne(e.sector);if(e instanceof z)return this.impliesFaceValue(e.face,e.value);throw new Error(`unimplemented type of feature for FeatureSet: ${e}`)}getAffectedEdges(){return new Set([...this.blackEdges,...this.redEdges,...this.edgeToSectorsMap.keys()])}getAffectedSectors(){return new Set([...this.sectorsNotZero.values(),...this.sectorsNotOne.values(),...this.sectorsNotTwo.values(),...this.sectorsOnlyOne.values()])}getAffectedFaces(){return new Set([...this.faceValueMap.keys()])}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.hasSameShapeAs(e))return!1;const s=te(this.patternBoard,this.patternBoard);for(const t of s)try{const o=this.embedded(this.patternBoard,t);if(o&&o.equals(e))return!0}catch(o){if(!(o instanceof u))throw o}return!1}isCanonicalWith(e){m.length=0;for(const s of e)l()&&h(s.isAutomorphism),s.isIdentityAutomorphism||m.push(s);if(m.length===0)return!0;if(this.faceValueMap.size)for(let s=0;s<this.patternBoard.faces.length&&m.length;s++){const t=this.patternBoard.faces[s],o=this.faceValueMap.get(t),i=o===void 0?-2:o===null?-1:o;for(let r=0;r<m.length;r++){const a=m[r].inverseMapFace(t);l()&&h(a);const d=this.faceValueMap.get(a),c=d===void 0?-2:d===null?-1:d;if(c<i)return!1;c>i&&(m.splice(r,1),r--)}}if(this.blackEdges.size||this.redEdges.size)for(let s=0;s<this.patternBoard.edges.length&&m.length;s++){const t=this.patternBoard.edges[s],o=this.blackEdges.has(t)?1:this.redEdges.has(t)?2:0;for(let i=0;i<m.length;i++){const n=m[i].inverseMapEdge(t);l()&&h(n);const a=this.blackEdges.has(n)?1:this.redEdges.has(n)?2:0;if(a<o)return!1;a>o&&(m.splice(i,1),i--)}}if(this.sectorsNotZero.size||this.sectorsNotOne.size||this.sectorsNotTwo.size||this.sectorsOnlyOne.size)for(let s=0;s<this.patternBoard.sectors.length&&m.length;s++){const t=this.patternBoard.sectors[s],o=(this.sectorsOnlyOne.has(t)?1:0)+(this.sectorsNotOne.has(t)?2:0)+(this.sectorsNotTwo.has(t)?4:0)+(this.sectorsNotZero.has(t)?8:0);for(let i=0;i<m.length;i++){const n=m[i].inverseMapSector(t);l()&&h(n);const a=(this.sectorsOnlyOne.has(n)?1:0)+(this.sectorsNotOne.has(n)?2:0)+(this.sectorsNotTwo.has(n)?4:0)+(this.sectorsNotZero.has(n)?8:0);if(a<o)return!1;a>o&&(m.splice(i,1),i--)}}return!(this.faceColorDualFeatures.size&&!b.areCanonicalWith([...this.faceColorDualFeatures],m))}embedded(e,s){try{return C.fromFeatures(e,this.getFeaturesArray().flatMap(t=>t.embedded(s)))}catch(t){if(t instanceof u)return null;throw t}}hasSameShapeAs(e){return this.faceValueMap.size===e.faceValueMap.size&&this.blackEdges.size===e.blackEdges.size&&this.redEdges.size===e.redEdges.size&&this.sectorsNotZero.size===e.sectorsNotZero.size&&this.sectorsNotOne.size===e.sectorsNotOne.size&&this.sectorsNotTwo.size===e.sectorsNotTwo.size&&this.sectorsOnlyOne.size===e.sectorsOnlyOne.size&&this.faceColorDualFeatures.size===e.faceColorDualFeatures.size}getBoardMatchState(e,s,t=!1){let o=!0;for(const[i,r]of this.faceValueMap)if(e.faceValues[s.mapFace(i).index]!==r)return g.INCOMPATIBLE;for(const i of this.blackEdges){l()&&h(!i.isExit);const r=s.mapNonExitEdge(i).index;if(!e.blackEdgeValues[r]){if(o=!1,e.redEdgeValues[r])return g.INCOMPATIBLE;if(t)return g.DORMANT}}for(const i of this.redEdges)if(i.isExit){const r=s.mapExitEdges(i);for(const n of r){const a=n.index;if(!e.redEdgeValues[a]){if(o=!1,e.blackEdgeValues[a])return g.INCOMPATIBLE;if(t)return g.DORMANT}}}else{const r=s.mapNonExitEdge(i).index;if(!e.redEdgeValues[r]){if(o=!1,e.blackEdgeValues[r])return g.INCOMPATIBLE;if(t)return g.DORMANT}}for(const i of this.sectorsNotZero){const r=s.mapSector(i).index;if(!e.sectorNotZeroValues[r]&&(o=!1,t))return g.DORMANT}for(const i of this.sectorsNotOne){const r=s.mapSector(i).index;if(!e.sectorNotOneValues[r]&&(o=!1,t))return g.DORMANT}for(const i of this.sectorsNotTwo){const r=s.mapSector(i).index;if(!e.sectorNotTwoValues[r]&&(o=!1,t))return g.DORMANT}for(const i of this.sectorsOnlyOne){const r=s.mapSector(i).index;if(!e.sectorOnlyOneValues[r]&&(o=!1,t))return g.DORMANT}for(const i of this.faceColorDualFeatures){const r=i.primaryFaces.map(d=>e.faceColors[s.mapFace(d).index]),n=r[0];l()&&h(n);for(const d of r)if(d!==n&&(o=!1,t))return g.DORMANT;const a=i.secondaryFaces.map(d=>e.faceColors[s.mapFace(d).index]);if(a.length>1){const d=a[0];for(const c of a)if(c!==d&&(o=!1,t))return g.DORMANT}if(a.length){const d=i.secondaryFaces.map(c=>e.oppositeFaceColors[s.mapFace(c).index]);for(const c of d)if(c!==n&&(o=!1,t))return g.DORMANT;if(!o&&!t){for(const c of d)if(a.includes(c))return g.INCOMPATIBLE}}if(!o&&!t){const d=i.primaryFaces.map(c=>e.oppositeFaceColors[s.mapFace(c).index]);for(const c of r)if(a.includes(c))return g.INCOMPATIBLE;for(const c of d)if(r.includes(c))return g.INCOMPATIBLE}}return o?g.MATCH:g.DORMANT}getShapeString(){return`${this.faceValueMap.size} ${this.blackEdges.size} ${this.redEdges.size} ${this.sectorsNotZero.size} ${this.sectorsNotOne.size} ${this.sectorsNotTwo.size} ${this.sectorsOnlyOne.size} ${this.faceColorDualFeatures.size}`}isSubsetOf(e){for(const s of this.blackEdges)if(!e.impliesBlackEdge(s))return!1;for(const s of this.redEdges)if(!e.impliesRedEdge(s))return!1;for(const[s,t]of this.faceValueMap)if(!e.impliesFaceValue(s,t))return!1;for(const s of this.sectorsNotZero)if(!e.impliesSectorNotZero(s))return!1;for(const s of this.sectorsNotOne)if(!e.impliesSectorNotOne(s))return!1;for(const s of this.sectorsNotTwo)if(!e.impliesSectorNotTwo(s))return!1;for(const s of this.sectorsOnlyOne)if(!e.impliesSectorOnlyOne(s))return!1;for(const s of this.faceColorDualFeatures)if(!e.impliesFaceColorDualFeature(s))return!1;return!0}equals(e){if(!this.hasSameShapeAs(e))return!1;for(const[t,o]of this.faceValueMap)if(e.faceValueMap.get(t)!==o)return!1;for(const t of this.blackEdges)if(!e.blackEdges.has(t))return!1;for(const t of this.redEdges)if(!e.redEdges.has(t))return!1;for(const t of this.sectorsNotZero)if(!e.sectorsNotZero.has(t))return!1;for(const t of this.sectorsNotOne)if(!e.sectorsNotOne.has(t))return!1;for(const t of this.sectorsNotTwo)if(!e.sectorsNotTwo.has(t))return!1;for(const t of this.sectorsOnlyOne)if(!e.sectorsOnlyOne.has(t))return!1;const s=new Set;e.faceColorDualFeatures.forEach(t=>s.add(t.toCanonicalString()));for(const t of this.faceColorDualFeatures)if(!s.has(t.toCanonicalString()))return!1;return!0}applyFeaturesFrom(e){e.getFeaturesArray().forEach(s=>this.addFeature(s))}union(e){if(this.size<e.size)return e.union(this);const s=this.clone();try{return s.applyFeaturesFrom(e),s}catch(t){if(t instanceof u)return null;throw t}}isCompatibleWith(e){return this.union(e)!==null}getQuickCompatibilityWith(e){let s=!0;for(const o of this.blackEdges){if(e.impliesRedEdge(o))return F.INCOMPATIBLE;s&&!e.impliesBlackEdge(o)&&(s=!1)}for(const o of this.redEdges){if(e.impliesBlackEdge(o))return F.INCOMPATIBLE;s&&!e.impliesRedEdge(o)&&(s=!1)}for(const o of this.sectorsNotZero)s&&!e.impliesSectorNotZero(o)&&(s=!1);for(const o of this.sectorsNotOne){if(e.impliesSectorOnlyOne(o))return F.INCOMPATIBLE;s&&!e.impliesSectorNotOne(o)&&(s=!1)}for(const o of this.sectorsNotTwo)s&&!e.impliesSectorNotTwo(o)&&(s=!1);for(const o of this.sectorsOnlyOne){if(e.impliesSectorNotOne(o))return F.INCOMPATIBLE;s&&!e.impliesSectorOnlyOne(o)&&(s=!1)}for(const o of this.faceColorDualFeatures)s&&!e.impliesFaceColorDualFeature(o)&&(s=!1);let t=!0;for(const[o,i]of this.faceValueMap){const r=e.getFaceValue(o);if(r===void 0)t=!1;else if(r!==i)return F.INCOMPATIBLE}return t?s?F.MATCH:F.NO_MATCH_NEEDS_STATE:F.NO_MATCH_NEEDS_FACE_VALUES}toCanonicalString(){return`feat:${q.sortBy(this.getFeaturesArray().map(e=>e.toCanonicalString())).join("/")}`}getSolutions(e=!1){const s=this.getFeaturesArray();let t=k.getSolutions(this.patternBoard,s);return t.length&&e&&(t=ne(t,ae(this.patternBoard,s)).highlanderSolutions),t}hasSolution(e=!1){return e?this.getSolutions(e).length>0:k.hasSolution(this.patternBoard,this.getFeaturesArray())}addSolvedEdgeFeatures(e){const s=new Array(this.patternBoard.edges.length).fill(!1),t=new Array(this.patternBoard.edges.length).fill(!1),o=new Set(this.patternBoard.edges),i=new Set(this.patternBoard.vertices.filter(r=>r.isExit));for(const r of e){const n=new Set(o);for(const a of r)s[a.index]=!0,n.delete(a);for(const a of n)t[a.index]=!0;for(const a of[...i])r.has(a.exitEdge)&&i.delete(a),a.edges.filter(d=>r.has(d)).length<2&&i.delete(a)}for(const r of this.patternBoard.edges)if(!r.isExit){const n=s[r.index],a=t[r.index];n&&!a&&this.addBlackEdge(r),!n&&a&&this.addRedEdge(r)}for(const r of i)this.addRedEdge(r.exitEdge)}addSolvedSectorFeatures(e){const s=new Array(this.patternBoard.sectors.length).fill(!1),t=new Array(this.patternBoard.sectors.length).fill(!1),o=new Array(this.patternBoard.sectors.length).fill(!1);for(const i of e)for(const r of this.patternBoard.sectors){const n=(i.has(r.edges[0])?1:0)+(i.has(r.edges[1])?1:0);n===0?s[r.index]=!0:n===1?t[r.index]=!0:n===2&&(o[r.index]=!0)}for(const i of this.patternBoard.sectors){const r=s[i.index],n=t[i.index],a=o[i.index];n&&!r&&!a?this.addSectorOnlyOne(i):r&&n&&!a?this.addSectorNotTwo(i):r&&a&&!n?this.addSectorNotOne(i):!r&&n&&a&&this.addSectorNotZero(i)}}addSolvedFaceColorDualFeatures(e){l()&&h(e.length>0);const s=P.get(this.patternBoard),t=new Set(s.connectedFacePairs.map(o=>new le(o)));for(const o of e)for(const i of[...t]){let r=!0;for(const n of i.pair.shortestPath)o.has(n)&&(r=!r);r?i.isOnlyOpposite=!1:i.isOnlySame=!1,!i.isOnlySame&&!i.isOnlyOpposite&&t.delete(i)}for(const o of t)o.isOnlySame?this.addSameColorFaces(o.pair.a,o.pair.b):o.isOnlyOpposite&&this.addOppositeColorFaces(o.pair.a,o.pair.b)}serialize(){const e={};return this.faceValueMap.size>0&&(e.faceValues=[...this.faceValueMap.entries()].map(([s,t])=>({face:s.index,value:t}))),this.blackEdges.size>0&&(e.blackEdges=[...this.blackEdges].map(s=>s.index)),this.redEdges.size>0&&(e.redEdges=[...this.redEdges].map(s=>s.index)),this.sectorsNotZero.size>0&&(e.sectorsNotZero=[...this.sectorsNotZero].map(s=>s.index)),this.sectorsNotOne.size>0&&(e.sectorsNotOne=[...this.sectorsNotOne].map(s=>s.index)),this.sectorsNotTwo.size>0&&(e.sectorsNotTwo=[...this.sectorsNotTwo].map(s=>s.index)),this.sectorsOnlyOne.size>0&&(e.sectorsOnlyOne=[...this.sectorsOnlyOne].map(s=>s.index)),this.faceColorDualFeatures.size>0&&(e.faceColorDualFeatures=[...this.faceColorDualFeatures].map(s=>s.serialize())),e}static deserialize(e,s){const t=new C(s);for(const o of e.faceValues||[])t.addFaceValue(s.faces[o.face],o.value);for(const o of e.blackEdges||[])t.addBlackEdge(s.edges[o]);for(const o of e.redEdges||[])t.addRedEdge(s.edges[o]);for(const o of e.sectorsNotZero||[])t.addSectorNotZero(s.sectors[o]);for(const o of e.sectorsNotOne||[])t.addSectorNotOne(s.sectors[o]);for(const o of e.sectorsNotTwo||[])t.addSectorNotTwo(s.sectors[o]);for(const o of e.sectorsOnlyOne||[])t.addSectorOnlyOne(s.sectors[o]);for(const o of e.faceColorDualFeatures||[])t.addFaceColorDual(b.deserialize(o,s));return t}}const Ee={solveEdges:!0,solveSectors:!1,solveFaceColors:!1,highlander:!1};class le{constructor(e){f(this,"isOnlySame",!0);f(this,"isOnlyOpposite",!0);this.pair=e}}export{Ee as B,C as F,k as P,P as a,oe as b,re as c,g as d,F as e,ne as f,ae as g};
