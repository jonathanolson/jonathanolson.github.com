import{p as h,o as d,E as z,G as m,I as M,B as w,H as b}from"./patternBoards-CdPs5rJx.js";import{P as I}from"./PatternRule-L1F6UIQ_.js";import{a as u,b as o}from"./getCoordinateClusteredMap-s__X_7ZN.js";import{f as g}from"./FeatureSet-Brj-qr45.js";import{c as f}from"./Vector2Property-DCXaH-JP.js";import{g as P}from"./getSolutionImpliedRules-a_Xnq1eI.js";class p{constructor(t,a,s=[],e=!1){this.patternBoard=t,this.mapping=a,this.rules=s,this.highlander=e,u()&&o(s.every(r=>r.patternBoard===t))}static createImplied(t,a,s,e){u()&&o(t),u()&&o(a);const r=s.flatMap(i=>i.rules),n=f({},e,{prefilterRules:r}),l=P(t,n);return new p(t,a,l,!!(e!=null&&e.highlander))}static createImpliedChained(t,a,s){let e=a.flatMap(n=>n.rules);const r=[];for(let n=0;n<t.length;n++){const l=t[n],i=h.get(l);u()&&o(i);const B=f({},s,{prefilterRules:e}),c=P(l,B);c.length&&r.push(new p(l,i,c,!!(s!=null&&s.highlander))),e=[...e,...c]}return r}serialize(){const t={patternBoard:d(this.patternBoard.descriptor),mapping:z(this.mapping),rules:this.rules.map(a=>({input:a.inputFeatureSet.serialize(),output:a.outputFeatureSet.serialize()}))};return this.highlander&&(t.highlander=!0),t}static deserialize(t){const a=!!t.highlander,s=m(t.patternBoard);let e,r,n=M(s);n?(e=n,r=h.get(e),u()&&o(r)):(e=new w(m(t.patternBoard)),r=b(t.mapping,e),h.set(e,r));const l=t.rules.map(i=>new I(e,g.deserialize(i.input,e),g.deserialize(i.output,e),a));return new p(e,r,l,a)}}export{p as P};
