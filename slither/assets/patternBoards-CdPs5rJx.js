var Pe=Object.defineProperty;var Fe=(t,e,s)=>e in t?Pe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var G=(t,e,s)=>(Fe(t,typeof e!="symbol"?e+"":e,s),s);import{a as f,b as g,_ as T,k as Be,H as Se}from"./getCoordinateClusteredMap-s__X_7ZN.js";import{V as y}from"./Vector2Property-DCXaH-JP.js";import{P as ve,g as Z,t as Ce,f as Ne,r as Ge,s as Te,h as Ae,j as Ie,k as ze,o as $e,w as Oe,y as ke,z as je}from"./getPeriodicTilingGenerator-qmRzQaR8.js";class ge{constructor(e,s,o,i,h,l,c){G(this,"isAutomorphism");G(this,"isIdentityAutomorphism");G(this,"vertexInverseMap");G(this,"edgeInverseMap");G(this,"sectorInverseMap");G(this,"faceInverseMap");this.sourcePatternBoard=e,this.targetPatternBoard=s,this.vertexMap=o,this.nonExitEdgeMap=i,this.exitEdgeMap=h,this.sectorMap=l,this.faceMap=c,this.isAutomorphism=e===s,this.isAutomorphism&&(this.vertexInverseMap=new Map(Array.from(o).map(([r,n])=>[n,r])),this.sectorInverseMap=new Map(Array.from(l).map(([r,n])=>[n,r])),this.faceInverseMap=new Map(Array.from(c).map(([r,n])=>[n,r])),this.edgeInverseMap=new Map([...Array.from(i).map(([r,n])=>[n,r]),...Array.from(h).map(([r,n])=>(f()&&g(n.length===1),[n[0],r]))])),this.isIdentityAutomorphism=this.computeIsIdentityAutomorphism()}static fromMaps(e,s,o,i,h,l,c){return new ge(e,s,o,i,h,l,c)}getVertexMap(){return this.vertexMap}getNonExitEdgeMap(){return this.nonExitEdgeMap}getExitEdgeMap(){return this.exitEdgeMap}getSectorMap(){return this.sectorMap}getFaceMap(){return this.faceMap}mapVertex(e){const s=this.vertexMap.get(e);return f()&&g(s),s}mapNonExitEdge(e){const s=this.nonExitEdgeMap.get(e);return f()&&g(s),s}mapExitEdges(e){const s=this.exitEdgeMap.get(e);return f()&&g(s),s}mapSector(e){const s=this.sectorMap.get(e);return f()&&g(s),s}mapFace(e){const s=this.faceMap.get(e);return f()&&g(s),s}inverseMapVertex(e){const s=this.vertexInverseMap.get(e);return f()&&g(s),s}inverseMapEdge(e){const s=this.edgeInverseMap.get(e);return f()&&g(s),s}inverseMapSector(e){const s=this.sectorInverseMap.get(e);return f()&&g(s),s}inverseMapFace(e){const s=this.faceInverseMap.get(e);return f()&&g(s),s}equals(e){return this.vertexMap.size===e.vertexMap.size&&this.nonExitEdgeMap.size===e.nonExitEdgeMap.size&&this.exitEdgeMap.size===e.exitEdgeMap.size&&this.sectorMap.size===e.sectorMap.size&&this.faceMap.size===e.faceMap.size&&Array.from(this.vertexMap).every(([s,o])=>e.vertexMap.get(s)===o)&&Array.from(this.nonExitEdgeMap).every(([s,o])=>e.nonExitEdgeMap.get(s)===o)&&Array.from(this.exitEdgeMap).every(([s,o])=>e.exitEdgeMap.get(s)===o)&&Array.from(this.sectorMap).every(([s,o])=>e.sectorMap.get(s)===o)&&Array.from(this.faceMap).every(([s,o])=>e.faceMap.get(s)===o)}toString(){return`Embedding(
  vertexMap: ${[...this.vertexMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
  nonExitEdgeMap: ${[...this.nonExitEdgeMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  exitEdgeMap: ${[...this.exitEdgeMap].map(e=>`${e[0].index} => [${e[1].map(s=>s.index).join(", ")}]`).join(", ")}
  sectorMap: ${[...this.sectorMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  faceMap: ${[...this.faceMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
)`}computeIsIdentityAutomorphism(){if(this.sourcePatternBoard!==this.targetPatternBoard)return!1;for(const e of this.vertexMap.keys())if(this.vertexMap.get(e)!==e)return!1;for(const e of this.nonExitEdgeMap.keys())if(this.nonExitEdgeMap.get(e)!==e)return!1;for(const e of this.exitEdgeMap.keys())if(this.exitEdgeMap.get(e).length!==1||this.exitEdgeMap.get(e)[0]!==e)return!1;for(const e of this.sectorMap.keys())if(this.sectorMap.get(e)!==e)return!1;for(const e of this.faceMap.keys())if(this.faceMap.get(e)!==e)return!1;return!0}}const qe=(t,e)=>{if(t.faces.filter(i=>!i.isExit).length>e.faces.filter(i=>!i.isExit).length||t.sectors.length>e.sectors.length||t.edges.filter(i=>!i.isExit).length>e.edges.filter(i=>!i.isExit).length||t.vertices.length>e.vertices.length)return[];const s=[],o=t.faces.filter(i=>!i.isExit);if(o.length){const i=o[0],h=[i],l=[],c=[],r=new Set(o.slice(1)),n=new Set(i.edges),x=new Set(i.vertices);for(;r.size;){const a=T.maxBy([...r],u=>{let d=0;for(const p of u.edges)n.has(p)&&(d+=5);for(const p of u.vertices)x.has(p)&&(d+=1);return d});f()&&g(a),h.push(a),l.push(T.findIndex(a.edges,u=>n.has(u))),c.push(T.findIndex(a.vertices,u=>x.has(u))),r.delete(a);for(const u of a.edges)n.add(u);for(const u of a.vertices)x.add(u)}const v=(a,u,d)=>{if(a.edges.length!==u.edges.length)return!1;for(let p=0;p<a.edges.length;p++){const E=a.edges[p],M=u.edges[d.mapEdgeIndex(p)];f()&&g(E.faces.includes(a)),f()&&g(M.faces.includes(u));const w=E.faces[0]===a?E.faces[1]:E.faces[0];if(!w.isExit){const V=M.faces[0]===u?M.faces[1]:M.faces[0];if(V.isExit||w.edges.length!==V.edges.length)return!1}}return!0};for(const a of e.faces)if(!a.isExit&&a.edges.length===i.edges.length)for(const u of re.allForOrder(a.edges.length)){if(!v(i,a,u))continue;const d=new Map,p=new Map,E=new Map,M=new Map,w=new Map;d.set(i,u),p.set(i,a),E.set(a,i);for(let P=0;P<i.vertices.length;P++){const F=i.vertices[P],B=a.vertices[u.mapVertexIndex(P)];M.set(F,B),w.set(B,F)}const V=(P,F,B,$,C,O)=>{if(f()&&g(C.size===O.size),P===h.length){f()&&g(C.size===t.vertices.length);const m=new Map,K=new Set;for(const[S,A]of B){const N=F.get(S);for(let k=0;k<S.edges.length;k++){const L=S.edges[k],j=A.edges[N.mapEdgeIndex(k)];f()&&m.has(L)&&g(m.get(L)===j),m.set(L,j),K.add(j)}}f()&&g(m.size===t.edges.filter(S=>!S.isExit).length);const ie=new Map;for(const S of t.edges.filter(A=>A.isExit)){const A=S.exitVertex;f()&&g(A);const N=C.get(A);f()&&g(N),ie.set(S,N.edges.filter(k=>!K.has(k)))}for(const S of t.faces.filter(A=>A.isExit)){const A=S.edges[0];f()&&g(A&&S.edges.length===1);const N=m.get(A),k=A.faces[0]===S?A.faces[1]:A.faces[0],L=B.get(k),j=N.faces[0]===L?N.faces[1]:N.faces[0];f()&&g(j),B.set(S,j)}const H=new Map;for(const S of t.sectors){const A=S.face,N=B.get(A);f()&&g(N);const k=S.edges[0],L=S.edges[1],j=m.get(k),Q=m.get(L);f()&&g(j&&Q);const q=N.sectors.find(U=>U.edges.includes(j)&&U.edges.includes(Q));f()&&g(q),H.set(S,q)}s.push(ge.fromMaps(t,e,C,m,ie,H,B))}else{const m=h[P],K=l[P-1],ie=c[P-1];if(K>=0){const H=m.edges[K],S=H.vertices[0],A=H.vertices[1],N=C.get(S),k=C.get(A),L=H.faces[0]===m?H.faces[1]:H.faces[0],j=B.get(L);f()&&g(j);const Q=j.edges.find(ee=>ee.vertices.includes(N)&&ee.vertices.includes(k));f()&&g(Q);const q=Q.faces[0]===j?Q.faces[1]:Q.faces[0];if(q.isExit||$.has(q))return;const U=m.vertices.indexOf(S),Y=m.vertices.indexOf(A),X=q.vertices.indexOf(N),te=q.vertices.indexOf(k),ae=(U+1)%m.vertices.length===Y,de=(X+1)%q.vertices.length===te,b=ae===de?1:-1,_=(X-U*b+m.vertices.length)%m.vertices.length,J=new re(m.vertices.length,_,b);if(f()&&g(J.mapVertexIndex(U)===X),f()&&g(J.mapVertexIndex(Y)===te),!v(m,q,J)||(B.set(m,q),$.set(q,m),B.size!==$.size))return;for(let ee=0;ee<m.vertices.length;ee++){const oe=m.vertices[ee],ce=q.vertices[J.mapVertexIndex(ee)];if(C.has(oe)){if(C.get(oe)!==ce)return}else C.set(oe,ce);if(O.has(ce)){if(O.get(ce)!==oe)return}else O.set(ce,oe);f()&&g(C.size===O.size)}F.set(m,J),V(P+1,F,B,$,C,O)}else{f()&&g(ie>=0,"If this is not satisfied, we have disconnected components OR orderedFaces order is bad");const H=m.vertices[ie],S=C.get(H),A=S.faces.filter(N=>!N.isExit&&!$.has(N));for(const N of A){const k=m.vertices.indexOf(H),L=N.vertices.indexOf(S);f()&&g(k>=0),f()&&g(L>=0);for(const j of[1,-1]){const Q=(L-k*j+m.vertices.length)%m.vertices.length,q=new re(m.vertices.length,Q,j);if(!v(m,N,q))continue;let U=!0;const Y=new Map(C),X=new Map(O);for(let b=0;b<m.vertices.length;b++){const _=m.vertices[b],J=N.vertices[q.mapVertexIndex(b)];if(Y.has(_)){if(Y.get(_)!==J){U=!1;break}}else Y.set(_,J);if(X.has(J)){if(X.get(J)!==_){U=!1;break}}else X.set(J,_);f()&&g(Y.size===X.size)}if(!U)continue;const te=new Map(B),ae=new Map($);if(te.set(m,N),ae.set(N,m),te.size!==ae.size)continue;const de=new Map(F);de.set(m,q),V(P+1,de,te,ae,Y,X)}}}}};V(1,d,p,E,M,w)}}else if(t.vertices.length===1){const i=t.vertices[0];f()&&g(i.edges.length===t.edges.length);const h=i.edges.filter(n=>!n.isExit),l=i.edges.filter(n=>!n.isExit).length,c=i.isExit,r=T.range(0,l).map(n=>{const x=h[n],v=h.slice(0,n+1);return i.sectors.filter(a=>a.edges.includes(x)&&a.edges.every(u=>v.includes(u)))});if(f()&&g(r.flat().length===i.sectors.length),f()&&!i.isExit){g(i.sectors.length===l);for(let n=0;n<l;n++){const x=i.edges[n],v=i.edges[(n+1)%l],a=i.sectors[n],u=i.faces[n];g(a.edges.includes(x)),g(a.edges.includes(v)),g(a.face===u)}}for(const n of e.vertices){if(c){if(n.edges.length<l||n.sectors.length<i.sectors.length)continue}else{if(n.isExit||n.edges.length!==l)continue;f()&&g(n.sectors.length===l)}const x=new Map([[i,n]]),v=(a,u,d,p)=>{if(a===l){f()&&g(u.size===h.length),f()&&g(d.size===t.sectors.length);const E=c?new Map([[i.exitEdge,n.edges.filter(w=>!p.has(w))]]):new Map,M=new Map([...d.keys()].map(w=>[w.face,d.get(w).face]));if(i.sectors.length===0)for(const[w,V]of u){const P=w.faces[0],F=w.faces[1];f()&&g(P.isExit&&F.isExit),M.set(P,V.faces[0]),M.set(F,V.faces[1])}else if(c){for(const w of t.faces.filter(V=>V.isExit))if(w.edges.length===1){const V=w.edges[0];f()&&g(V&&w.edges.length===1);const P=u.get(V);f()&&g(P);const F=V.faces[0]===w?V.faces[1]:V.faces[0],B=M.get(F);f()&&g(B);const $=P.faces[0]===B?P.faces[1]:P.faces[0];f()&&g($),M.set(w,$)}}else for(const w of t.sectors){const V=w.face,F=d.get(w).face;M.set(V,F)}s.push(ge.fromMaps(t,e,x,u,E,d,M))}else{const E=h[a],M=r[a];for(const w of n.edges){if(w.isExit||p.has(w))continue;const V=[];let P=!0;for(const F of M){const B=F.edges[0],$=F.edges[1],C=B===E?w:u.get(B),O=$===E?w:u.get($);f()&&g(C&&O);const m=n.sectors.find(K=>K.edges.includes(C)&&K.edges.includes(O)&&(l>2||!V.includes(K)))??null;if(m)V.push(m);else{P=!1;break}}if(P){const F=new Map(u);F.set(E,w);const B=new Map(d);for(let C=0;C<M.length;C++)B.set(M[C],V[C]);const $=new Set(p);$.add(w),v(a+1,F,B,$)}}}};v(0,new Map,new Map,new Set)}}else if(t.vertices.length===0&&t.edges.length===1){const i=t.edges[0];for(const h of e.edges.filter(l=>!l.isExit))s.push(ge.fromMaps(t,e,new Map,new Map([[i,h]]),new Map,new Map,new Map([[i.faces[0],h.faces[0]],[i.faces[1],h.faces[1]]])))}else throw new Error("pattern search not implemented generally yet");return f()&&t===e&&g(s.filter(i=>i.isIdentityAutomorphism).length===1),s};class re{constructor(e,s,o){this.edgeCount=e,this.offset=s,this.direction=o,f()&&g(o===1||o===-1)}mapVertexIndex(e){return(this.offset+e*this.direction+this.edgeCount)%this.edgeCount}mapEdgeIndex(e){return this.direction===1?(this.offset+e)%this.edgeCount:(this.offset-e-1+2*this.edgeCount)%this.edgeCount}toString(){return`FaceMapping( edgeCount=${this.edgeCount}, offset=${this.offset}, direction=${this.direction} )`}toDetailedString(e,s){return`FaceMapping( vertices: ${T.range(0,this.edgeCount).map(o=>`${e.vertices[o].index} => ${s.vertices[this.mapVertexIndex(o)].index}`).join(", ")}, edges: ${T.range(0,this.edgeCount).map(o=>{const i=e.edges[o],h=s.edges[this.mapEdgeIndex(o)];return`#${i.index} (${i.vertices.map(l=>l.index).join(",")}) => #${h.index} (${h.vertices.map(l=>l.index).join(",")})`}).join(", ")} )`}static allForOrder(e){return[...T.range(0,e).map(s=>new re(e,s,1)),...T.range(0,e).map(s=>new re(e,s,-1))]}}const ue=new WeakMap,pe=(t,e)=>{f()&&g(t),f()&&g(e);let s=ue.get(t)??null;s||(s=new WeakMap,ue.set(t,s));let o=s.get(e)??null;return o||(o=qe(t,e),s.set(e,o)),o},De=(t,e)=>{if(t.numNonExitVertices!==e.numNonExitVertices||t.numExitVertices!==e.numExitVertices||t.type!==e.type)return!1;if(t.type==="faces"&&e.type==="faces"){if(t.vertexLists.length!==e.vertexLists.length)return!1;for(let s=0;s<t.vertexLists.length;s++){if(t.vertexLists[s].length!==e.vertexLists[s].length)return!1;for(let o=0;o<t.vertexLists[s].length;o++)if(t.vertexLists[s][o]!==e.vertexLists[s][o])return!1}}if(t.type==="non-exit-vertex"&&e.type==="non-exit-vertex"&&t.edgeCount!==e.edgeCount)return!1;if(t.type==="exit-vertex"&&e.type==="exit-vertex"){if(t.edgeCount!==e.edgeCount||t.spans.length!==e.spans.length)return!1;for(let s=0;s<t.spans.length;s++)if(t.spans[s]!==e.spans[s])return!1}return!0},Le=t=>{const e=[];e.push(t.numNonExitVertices),e.push(t.numExitVertices),e.push(t.type),t.type==="faces"?e.push(t.vertexLists):(t.type==="non-exit-vertex"||t.type==="exit-vertex")&&(e.push(t.edgeCount),t.type==="exit-vertex"&&e.push(t.spans));const s=JSON.stringify(e);return f()&&g(De(we(s),t)),s},we=t=>{const e=JSON.parse(t),s=e.shift(),o=e.shift(),i=e.shift();return i==="faces"?{numNonExitVertices:s,numExitVertices:o,type:i,vertexLists:e.shift()}:i==="non-exit-vertex"?{numNonExitVertices:s,numExitVertices:o,type:i,edgeCount:e.shift()}:i==="exit-vertex"?{numNonExitVertices:s,numExitVertices:o,type:i,edgeCount:e.shift(),spans:e.shift()}:{numNonExitVertices:s,numExitVertices:o,type:i}};class Ee{constructor(e,s){G(this,"exitEdge",null);G(this,"edges",[]);G(this,"sectors",[]);G(this,"faces",[]);this.index=e,this.isExit=s}}class se{constructor(e,s,o=null){G(this,"vertices");G(this,"sectors",[]);G(this,"faces",[]);this.index=e,this.isExit=s,this.exitVertex=o,this.vertices=o?[o]:[]}}class he{constructor(e,s,o){G(this,"face");this.index=e,this.vertex=s,this.edges=o}}class R{constructor(e,s,o,i,h){this.index=e,this.isExit=s,this.vertices=o,this.edges=i,this.sectors=h}}class z{constructor(e,s){G(this,"name");G(this,"vertices");G(this,"edges");G(this,"sectors");G(this,"faces");this.descriptor=e;const o=[...T.range(0,e.numNonExitVertices).map(c=>new Ee(c,!1)),...T.range(0,e.numExitVertices).map(c=>new Ee(c+e.numNonExitVertices,!0))];let i=[],h=[],l=[];if(e.type==="faces"){for(const c of e.vertexLists){const r=c.map(a=>o[a]),n=r.map((a,u)=>{const d=r[(u+1)%r.length],p=a.edges.find(E=>E.vertices.includes(d));if(p)return p;{const E=new se(i.length,!1),M=a.index<d.index?a:d,w=a.index<d.index?d:a;return E.vertices.push(M),E.vertices.push(w),i.push(E),a.edges.push(E),d.edges.push(E),E}}),x=n.map((a,u)=>{const d=n[(u+1)%n.length],p=a.vertices.find(M=>d.vertices.includes(M));f()&&g(p);const E=new he(h.length,p,[a,d]);return h.push(E),a.sectors.push(E),d.sectors.push(E),p.sectors.push(E),E}),v=new R(l.length,!1,r,n,x);l.push(v),r.forEach(a=>{a.faces.push(v)}),x.forEach(a=>{a.face=v}),n.forEach(a=>{a.faces.push(v)})}i.forEach(c=>{if(c.faces.length<2){f()&&g(c.faces.length===1);const r=new R(l.length,!0,c.vertices,[c],[]);l.push(r),c.faces.push(r),c.vertices.forEach(n=>{n.faces.push(r)})}}),o.forEach(c=>{if(c.isExit){const r=new se(i.length,!0,c);i.push(r),c.edges.push(r),c.exitEdge=r}})}else if(e.type==="edge"){f()&&g(o.length===0);const c=new se(0,!1,null);i.push(c);const r=new R(0,!0,[],[c],[]);l.push(r);const n=new R(1,!0,[],[c],[]);l.push(n),c.faces.push(r),c.faces.push(n)}else if(e.type==="non-exit-vertex"){f()&&g(o.length===1&&!o[0].isExit);const c=o[0];i.push(...T.range(0,e.edgeCount).map(r=>{const n=new se(r,!1);return c.edges.push(n),n.vertices.push(c),n})),h.push(...T.range(0,e.edgeCount).map(r=>{const n=new he(r,c,[i[r],i[(r+1)%e.edgeCount]]);return n.edges.forEach(x=>{x.sectors.push(n)}),c.sectors.push(n),n})),l.push(...T.range(0,e.edgeCount).map(r=>{const n=h[r],x=new R(r,!0,[c],[i[r],i[(r+1)%e.edgeCount]],[n]);return c.faces.push(x),x.edges.forEach(v=>{v.faces.push(x)}),n.face=x,x}))}else if(e.type==="exit-vertex"){f()&&g(o.length===1&&o[0].isExit);const c=o[0];i.push(...T.range(0,e.edgeCount).map(n=>{const x=new se(n,!1);return c.edges.push(x),x.vertices.push(c),x}));const r=new se(i.length,!0,c);if(i.push(r),c.edges.push(r),c.exitEdge=r,e.spans.length){const n=[];let x=0;e.spans.forEach((v,a)=>{const u=x,d=u+v;x=d+1,n.push(T.range(u,d+1).map(p=>i[p]))}),f()&&g(x===e.edgeCount),n.forEach(v=>{for(let a=0;a<v.length-1;a++){const u=v[a],d=v[a+1],p=new he(h.length,c,[u,d]);h.push(p),u.sectors.push(p),d.sectors.push(p),c.sectors.push(p);const E=new R(l.length,!0,[c],[u,d],[p]);l.push(E),c.faces.push(E),u.faces.push(E),d.faces.push(E),p.face=E}}),n.forEach(v=>{const a=v[0],u=v[v.length-1],d=new R(l.length,!0,[c],[a],[]);l.push(d),a.faces.push(d),c.faces.push(d);const p=new R(l.length,!0,[c],[u],[]);l.push(p),u.faces.push(p),c.faces.push(p)})}else{f()&&g(e.edgeCount===2);const n=i[0],x=i[1],v=new R(l.length,!0,[c],[n],[]);l.push(v),n.faces.push(v),c.faces.push(v);const a=new R(l.length,!0,[c],[n],[]);l.push(a),n.faces.push(a),c.faces.push(a);const u=new R(l.length,!0,[c],[x],[]);l.push(u),x.faces.push(u),c.faces.push(u);const d=new R(l.length,!0,[c],[x],[]);l.push(d),x.faces.push(d),c.faces.push(d)}}else throw new Error(`Invalid descriptor: ${e}`);this.vertices=o,this.edges=i,this.sectors=h,this.faces=l,s&&(this.name=s)}serialize(){return Le(this.descriptor)}static deserialize(e){return new z(we(e))}}const Re=new WeakMap,ne=.3,He=t=>(f()&&g(t.vertices.length===0),f()&&g(t.sectors.length===0),f()&&g(t.faces.length===2),f()&&g(t.edges.length===1),{vertexMap:new Map,edgeMap:new Map([[t.edges[0],[new y(0,0),new y(1,0)]]]),sectorMap:new Map,faceMap:new Map([[t.faces[0],[new y(0,0),new y(1,0),new y(.5,ne)]],[t.faces[1],[new y(0,0),new y(.5,-ne),new y(1,0)]]])}),me=t=>{f()&&g(t.vertices.length===1);const e=t.edges.filter(r=>!r.isExit),s=e.length,o=s===2&&t.sectors.length?3:s,i=new Map([[t.vertices[0],y.ZERO]]),h=new Map;t.edges.forEach((r,n)=>{h.set(r,[y.ZERO,y.createPolar(1,2*Math.PI*n/o)])});const l=new Map;t.sectors.forEach(r=>{const n=r.edges[0],x=r.edges[1];(n.index+1)%s!==x.index?l.set(r,[h.get(n)[1],y.ZERO,h.get(x)[1]]):l.set(r,[h.get(x)[1],y.ZERO,h.get(n)[1]])});const c=new Map;return s===2&&t.sectors.length===0?(e[0].faces.forEach((r,n)=>{c.set(r,n===0?[new y(0,0),new y(1,0),new y(.5,ne)]:[new y(0,0),new y(.5,-ne),new y(1,0)])}),e[1].faces.forEach((r,n)=>{c.set(r,n===0?[new y(0,0),new y(-.5,ne),new y(-1,0)]:[new y(0,0),new y(-1,0),new y(-.5,-ne)])})):(t.sectors.forEach((r,n)=>{const x=l.get(r).slice();n===1&&s===2&&(x[1]=x[0].plus(x[2]).negated()),c.set(r.face,x)}),t.faces.forEach(r=>{if(!c.has(r)){f()&&g(r.edges.length===1);const n=r.edges[0],x=h.get(n);f()&&g(n.sectors.length===1);const v=n.sectors[0];{const a=x[1].perpendicular;let u=0;l.get(v).forEach(p=>u+=p.dot(a));const d=x[1].timesScalar(.5);c.set(r,[x[1],y.ZERO,d.plus(a.times(-Math.sign(u)*.5*Math.sin(2*Math.PI/3/s)))])}}})),{vertexMap:i,edgeMap:h,sectorMap:l,faceMap:c}},Dt=t=>{if(f()){const r=n=>{g(n.every(x=>x.index<n.length))};r([...t.vertexMap.keys()]),r([...t.edgeMap.keys()]),r([...t.sectorMap.keys()]),r([...t.faceMap.keys()])}const e=T.sortBy([...t.vertexMap.keys()],r=>r.index),s=T.sortBy([...t.edgeMap.keys()],r=>r.index),o=T.sortBy([...t.sectorMap.keys()],r=>r.index),i=T.sortBy([...t.faceMap.keys()],r=>r.index),h=r=>[r.x,r.y],l=r=>{for(let n=0;n<e.length;n++)if(t.vertexMap.get(e[n]).equals(r))return n;return h(r)},c=JSON.stringify([e.map(r=>h(t.vertexMap.get(r))),s.map(r=>t.edgeMap.get(r).map(l)),o.map(r=>t.sectorMap.get(r).map(h)),i.map(r=>t.faceMap.get(r).map(h))]);if(f()){const r=Je(c,{vertices:e,edges:s,sectors:o,faces:i,descriptor:{}}),n=(x,v)=>{if(x.length!==v.length)return!1;for(let a=0;a<x.length;a++)if(!x[a].equals(v[a]))return!1;return!0};e.forEach(x=>g(t.vertexMap.get(x).equals(r.vertexMap.get(x)))),s.forEach(x=>g(n(t.edgeMap.get(x),r.edgeMap.get(x)))),o.forEach(x=>g(n(t.sectorMap.get(x),r.sectorMap.get(x)))),i.forEach(x=>g(n(t.faceMap.get(x),r.faceMap.get(x))))}return c},Je=(t,e)=>{const s=JSON.parse(t),o=s[0],i=s[1],h=s[2],l=s[3],c=new Map,r=new Map,n=new Map,x=new Map;o.forEach((a,u)=>{c.set(e.vertices[u],new y(a[0],a[1]))});const v=a=>typeof a=="number"?c.get(e.vertices[a]):new y(a[0],a[1]);return i.forEach((a,u)=>{r.set(e.edges[u],[v(a[0]),v(a[1])])}),h.forEach((a,u)=>{n.set(e.sectors[u],[v(a[0]),v(a[1]),v(a[2])])}),l.forEach((a,u)=>{x.set(e.faces[u],a.map(d=>new y(d[0],d[1])))}),{vertexMap:c,edgeMap:r,sectorMap:n,faceMap:x}},Me=(t,e)=>t.vertices.length!==e.vertices.length||t.edges.length!==e.edges.length||t.faces.length!==e.faces.length||t.sectors.length!==e.sectors.length||t.vertices.filter(s=>s.isExit).length!==e.vertices.filter(s=>s.isExit).length||t.edges.filter(s=>s.isExit).length!==e.edges.filter(s=>s.isExit).length||t.faces.filter(s=>s.isExit).length!==e.faces.filter(s=>s.isExit).length?!1:pe(t,e).length>0&&pe(e,t).length>0,Ze=(t,e)=>{if(t.forwardHalf.next.edge===e)return t.forwardHalf;if(t.reversedHalf.next.edge===e)return t.reversedHalf;if(e.forwardHalf.next.edge===t)return e.forwardHalf;if(e.reversedHalf.next.edge===t)return e.reversedHalf;throw new Error("Edges are not connected")};class I extends z{constructor(s,o){const i=new Set,h=new Set;o.forEach(d=>{d.vertices.forEach(p=>{i.add(p)}),d.edges.forEach(p=>{h.add(p)})});const l=Array.from(h),c=[],r=[];for(const d of i)d.faces.every(p=>o.includes(p))?r.push(d):c.push(d);const n=[...r,...c];super({numNonExitVertices:r.length,numExitVertices:c.length,type:"faces",vertexLists:o.map(d=>d.vertices.map(p=>n.indexOf(p)))});G(this,"patternBoard");G(this,"planarPatternMap");this.originalBoard=s,this.originalBoardFaces=o;const x=new Map(n.map((d,p)=>[this.vertices[p],d.viewCoordinates])),v=new Map;this.edges.forEach(d=>{if(!d.isExit){const p=n[d.vertices[0].index],E=n[d.vertices[1].index];v.set(d,[p.viewCoordinates,E.viewCoordinates])}});const a=new Map;this.sectors.forEach(d=>{f()&&g(d.edges.length===2);const p=n[d.edges[0].vertices[0].index],E=n[d.edges[0].vertices[1].index],M=n[d.edges[1].vertices[0].index],w=n[d.edges[1].vertices[1].index],V=l.find(O=>O.vertices.includes(p)&&O.vertices.includes(E)),P=l.find(O=>O.vertices.includes(M)&&O.vertices.includes(w));f()&&g(V&&P);const F=Ze(V,P);f()&&g(F);const B=F.start.viewCoordinates,$=F.end.viewCoordinates,C=F.next.end.viewCoordinates;a.set(d,[B,$,C])});const u=new Map;this.faces.forEach(d=>{if(!d.isExit){const p=d.vertices.map(w=>n[w.index]),E=o.find(w=>w.vertices.every(V=>p.includes(V)));f()&&g(E);const M=E.vertices.map(w=>w.viewCoordinates);u.set(d,M)}}),this.faces.forEach(d=>{if(d.isExit){f()&&g(d.edges.length===1);const p=d.edges[0],E=n[p.vertices[0].index],M=n[p.vertices[1].index];f()&&g(E&&M);const w=l.find(F=>F.vertices.includes(E)&&F.vertices.includes(M));f()&&g(w);const V=o.includes(w.faces[0])?w.faces[1]:w.faces[0];f()&&g(V,"Did we hit null as in --- edge of board? can we expand the search pattern?");const P=[E.viewCoordinates,M.viewCoordinates,E.viewCoordinates.average(M.viewCoordinates).average(V.viewCoordinates)];u.set(d,P)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:x,edgeMap:v,sectorMap:a,faceMap:u}}static getSemiAdjacentFaces(s,o){const i=new Set;return o.vertices.forEach(h=>{h.faces.forEach(l=>{l!==o&&i.add(l)})}),i}static getFirstGeneration(s){const o=T.uniq(s.faces.map(h=>h.vertices.length)),i=s.vertices.map(h=>h.viewCoordinates).reduce((h,l)=>h.plus(l)).timesScalar(1/s.vertices.length);return o.map(h=>{const l=T.minBy(s.faces.filter(c=>c.vertices.length===h),c=>c.viewCoordinates.distanceSquared(i));return f()&&g(l),new I(s,[l])})}static getNextGeneration(s){const o=[];return s.forEach(i=>{const h=new Set;i.originalBoardFaces.forEach(l=>{I.getSemiAdjacentFaces(i.originalBoard,l).forEach(c=>{i.originalBoardFaces.includes(c)||h.add(c)})}),h.forEach(l=>{const c=[...i.originalBoardFaces,l],r=new I(i.originalBoard,c);o.some(n=>Me(n,r))||o.push(r)})}),o}static getFirstNGenerations(s,o){const h=[I.getFirstGeneration(s)];for(let l=0;l<o-1;l++)h.push(I.getNextGeneration(h[h.length-1]));return h}static getUniformTilingGenerations(s,o){const i=s.generate({width:15,height:15}),h=new ve(i,s.scale??1);return I.getFirstNGenerations(h,o)}}const xe=new z({numNonExitVertices:0,numExitVertices:0,type:"edge"},"single-edge"),We=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]},"vertex-2-exit-none"),Ue=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]},"vertex-2-exit-one"),Ke=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]},"vertex-3-exit-two-adjacent"),Qe=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]},"vertex-4-exit-two-opposite"),Xe=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]},"vertex-4-exit-three-adjacent"),Ye=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[2,1]},"vertex-5-exit-two-one"),be=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[4]},"vertex-5-exit-four"),_e=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[1,1,1]},"vertex-6-exit-triple"),et=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[2,2]},"vertex-6-exit-two-two"),tt=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[3,1]},"vertex-6-exit-three-one"),st=new z({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[5]},"vertex-6-exit-five"),nt=new z({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2},"vertex-2"),rt=new z({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3},"vertex-3"),it=new z({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4},"vertex-4"),at=new z({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:5},"vertex-5"),ot=new z({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:6},"vertex-6"),Ve=[We,Ue,Ke,Qe,Xe,Ye,be,_e,et,tt,st],ye=[nt,rt,it,at,ot],Lt=[xe,...Ve,...ye],W=t=>{const e=t.generate({width:20,height:20});return new ve(e,t.scale??1)},le=[],ct=t=>le.find(e=>T.isEqual(e.descriptor,t))??null,gt=t=>{const e=ct(t.descriptor);return e||(le.find(s=>Me(t,s))??null)},Rt=t=>le.find(e=>e.name===t)??null,fe=(t,e)=>{const s=gt(t);return s||(le.push(t),Re.set(t,e),t)},D=(t,e)=>e.map((s,o)=>s.map((i,h)=>(i.name=`${t}-${o}-${h}`,fe(i,i.planarPatternMap))));fe(xe,He(xe));Ve.forEach(t=>fe(t,me(t)));ye.forEach(t=>fe(t,me(t)));const dt=W(Z(Ce)),lt=new Be(20,20),ft=W(Z(Ne)),ht=new Se(10,1,!0),xt=W(Z(Ge)),ut=W(Z(Te)),pt=W(Z(Ae)),Et=W(Z(Ie)),vt=W(Z(ze)),wt=W(Z($e)),mt=W(Z(Oe)),Mt=W(Z(ke)),Vt=W(Z(je)),yt=t=>I.getFirstNGenerations(dt,t),Pt=t=>I.getFirstNGenerations(lt,t),Ft=t=>I.getFirstNGenerations(ft,t),Bt=t=>I.getFirstNGenerations(ht,t),St=t=>I.getFirstNGenerations(xt,t),Ct=t=>I.getFirstNGenerations(ut,t),Nt=t=>I.getFirstNGenerations(pt,t),Gt=t=>I.getFirstNGenerations(Et,t),Tt=t=>I.getFirstNGenerations(vt,t),At=t=>I.getFirstNGenerations(wt,t),It=t=>I.getFirstNGenerations(mt,t),zt=t=>I.getFirstNGenerations(Mt,t),$t=t=>I.getFirstNGenerations(Vt,t),Ht=D("square",Pt(5)),Jt=D("hexagonal",Bt(4)),Zt=D("triangular",yt(4)),Wt=D("cairo",Ft(4)),Ut=D("rhombille",St(4)),Kt=D("snub-square",Ct(3)),Qt=D("trihexagonal",Nt(3)),Xt=D("floret-pentagonal",Gt(3)),Yt=D("deltoidal-trihexagonal",Tt(3)),bt=D("portugal",At(3)),_t=D("rhombitrihexagonal",It(3)),es=D("prismatic-pentagonal",zt(3)),ts=D("elongated-triangular",$t(3));export{Wt as A,z as B,Kt as C,Qt as D,Dt as E,I as F,we as G,Je as H,ct as I,We as J,Ue as K,Ke as L,Qe as M,Xe as N,nt as O,rt as P,it as Q,Xt as R,Yt as S,bt as T,_t as U,es as V,ts as W,Rt as X,ht as a,ft as b,qe as c,dt as d,xt as e,ut as f,pt as g,Et as h,vt as i,wt as j,mt as k,Mt as l,Vt as m,pe as n,Le as o,Re as p,Lt as q,Me as r,lt as s,Ze as t,Ht as u,Zt as v,xe as w,ye as x,Jt as y,Ut as z};
