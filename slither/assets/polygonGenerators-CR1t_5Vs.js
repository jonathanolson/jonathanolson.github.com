var Pt=Object.defineProperty;var vt=(c,t,e)=>t in c?Pt(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var v=(c,t,e)=>(vt(c,typeof t!="symbol"?t+"":t,e),e);import{T as d,P as ue,E as Je,d as Ze,o as Ve,c as ze,D as Et,V as O,h as ie,C as Vt,B as bt,g as ae,R as Ee}from"./Vector2Property-95p6aBvi.js";import{D as Y,B as se,g as H,k as Fe,N,P as X,M as Pe,l as Tt,L as Ge,C as Ae,m as $e,T as Ft,G as kt,R as xt,H as Ke}from"./PhetioControlledVisibilityProperty-DXvpzwXO.js";import{h as Me,k as L,L as ye,_ as J,G as Lt,e as A,f as M,m as Qe}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{e as Nt,f as Ot,g as Ie,J as Rt,h as He,i as At,j as Mt,v as De,k as It,l as Be,w as Ht,m as ee,n as Dt,q as Bt,x as Wt,y as Xt,I as te,G as Yt,E as jt,A as Ut,C as qt,c as G,N as _t,O as Re,u as Jt,s as Zt,r as zt}from"./Theme-BAHTsAQQ.js";import{E as j,F as de,S as F,V as Gt,C as Ne,B as We}from"./BasicPuzzle-BS-Lz1E0.js";import{b as $t,L as Kt,a as Qt,c as eo,P as et}from"./TextPushButton-DPrdGe0P.js";import{Q as tt,R as ot,T as rt,U as st,V as it,W as at,C as we,X as to,K as oo,L as ro,Y as nt,Z as lt,_ as ct,$ as dt,a0 as ht,i as so,a1 as io,F as ao,g as ve,a as no,I as Z,a2 as lo,a3 as co,a4 as ho,a5 as po,a6 as uo,a7 as go,a8 as fo,a9 as wo,aa as mo,ab as So,J as ge,M as pt,s as ut,O as gt,ac as Co}from"./SATSolver-BPZC_vN_.js";import{p as yo,a as Po,b as vo,c as Eo,d as Vo,e as bo,g as B,r as To,f as Fo,s as ko,t as xo,h as Lo,i as No,j as Oo,k as Ro,l as Ao,m as Mo,n as Io,o as Ho,q as Do,u as Bo,v as Wo,w as Xo,x as Yo,y as jo,z as Uo,A as qo,B as _o}from"./getPeriodicTilingGenerator-B19VRuYW.js";const ft=(c,t,e,o)=>(r,s,p)=>{const a=[new tt(r,s),new ot(r,s)];return(c||t||e||o)&&(a.push(new rt(r,s)),(t||e||o)&&(a.push(new st(r,s)),(e||o)&&(a.push(new it(r,s)),o&&a.push(new at(r,s))))),new we(a)},Jo={edgesVisibleProperty:Nt,edgesHaveColorsProperty:Ot,faceColorsVisibleProperty:Ie,faceColorThresholdProperty:Rt,sectorsVisibleProperty:He,sectorsNextToEdgesVisibleProperty:At,sectorsTrivialVisibleProperty:Mt,vertexStateVisibleProperty:De,allVertexStateVisibleProperty:It,faceStateVisibleProperty:Be,whiteLineVisibleProperty:Ht,redLineVisibleProperty:ee,verticesVisibleProperty:Dt,smallVertexProperty:Bt,redXsVisibleProperty:Wt,redXsAlignedProperty:Xt,faceValueStyleProperty:te,redLineStyleProperty:Yt,vertexStyleProperty:jt,joinedLinesJoinProperty:Ut,joinedLinesCapProperty:qt,safeSolverFactoryProperty:new Y([Ie,He,De,Be],(c,t,e,o)=>ft(c,t,e,o)),autoSolverFactoryProperty:to,theme:G},ne=(c,t,e,o,r)=>{const s=ft(c,t,e,o);return{faceColorsVisibleProperty:new se(c),sectorsVisibleProperty:new se(t),vertexStateVisibleProperty:new se(e),faceStateVisibleProperty:new se(o),safeSolverFactoryProperty:new ue(s),autoSolverFactoryProperty:r?new Y([r],p=>(a,h,i)=>new we([s(a,h,i),p(a,h,i)])):new ue(s)}},me=new Y([oo,ro],(c,t)=>(e,o,r)=>new we([new nt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:c,solveAlmostEmptyToRed:!0},r?void 0:[]),new lt(e,o,{solveToRed:!0,solveToBlack:c},r?void 0:[]),...t?[new ct(e,o,{solveToRed:!0,solveToBlack:c,resolveAllRegions:!1},r?void 0:[])]:[]])),wt=new Y([me],c=>(t,e,o)=>new we([c(t,e,o),new dt(t,e,o?void 0:[])])),mt={...ne(!0,!1,!1,!1,me),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Zo={...ne(!0,!1,!1,!1,me),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},zo={...ne(!0,!1,!1,!1,new ue((c,t,e)=>new we([new ht(c,t,{solveToRed:!0,solveToBlack:!0},e?void 0:[])]))),theme:G,edgesVisibleProperty:new d(!1),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Go={...ne(!1,!1,!1,!1,me),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!0),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!0),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("square"),joinedLinesJoinProperty:new d("miter"),joinedLinesCapProperty:new d("square")},$o={...ne(!0,!0,!1,!1,wt),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Ko={...ne(!0,!0,!1,!1,wt),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Qo={...ne(!0,!1,!0,!1,me),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},er={...ne(!0,!1,!1,!0,me),theme:G,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:ee,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:te,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},ke={basicLines:mt,basicFaceColoring:Zo,pureFaceColor:zo,classic:Go,basicSectors:$o,sectorsWithColors:Ko,vertexState:Qo,faceState:er,custom:Jo},Xe=mt,tr=c=>({edgesVisibleProperty:new H(c,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new H(c,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new H(c,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new H(c,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new H(c,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new H(c,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new H(c,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new H(c,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new H(c,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new H(c,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new H(c,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new H(c,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new H(c,{derive:"verticesVisibleProperty"}),smallVertexProperty:new H(c,{derive:"smallVertexProperty"}),redXsVisibleProperty:new H(c,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new H(c,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new H(c,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new H(c,{derive:"redLineStyleProperty"}),vertexStyleProperty:new H(c,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new H(c,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new H(c,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new H(c,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new H(c,{derive:"autoSolverFactoryProperty"}),theme:_t(new Y([c],t=>t.theme))}),or=new $t("puzzleStyle",{serialize:c=>Object.keys(ke).find(t=>ke[t]===c),deserialize:c=>c?ke[c]??Xe:Xe}),ce=tr(or),Xr=new Kt("showPuzzleStyleProperty",!1),D=class D extends Je{constructor(t){super(),this.isEnabledProperty=t}};v(D,"EDGE_STATE",new D(new se(!0))),v(D,"EDGE_STATE_REVERSED",new D(new se(!0))),v(D,"FACE_COLOR_MATCH",new D(ce.faceColorsVisibleProperty)),v(D,"FACE_COLOR_OPPOSITE",new D(ce.faceColorsVisibleProperty)),v(D,"SECTOR_STATE",new D(ce.sectorsVisibleProperty)),v(D,"VERTEX_STATE",new D(ce.vertexStateVisibleProperty)),v(D,"FACE_STATE",new D(ce.faceStateVisibleProperty)),v(D,"FACE_VALUE",new D(new se(!1))),v(D,"DELETE_FACE",new D(new se(!1))),v(D,"enumeration",new Ze(D));let U=D;const le=new Qt("editModeProperty",U.EDGE_STATE);let xe=null;const Ye=c=>{c||(le.value=U.EDGE_STATE)};le.link(c=>{xe&&xe.isEnabledProperty.unlink(Ye),xe=c,c.isEnabledProperty.link(Ye)});const Yr=c=>{c.isEnabledProperty.value&&(le.value=c)},rr=new Y([le],c=>c===U.EDGE_STATE||c===U.EDGE_STATE_REVERSED),St=new Y([le],c=>c===U.FACE_COLOR_MATCH||c===U.FACE_COLOR_OPPOSITE),sr=new Y([le],c=>c===U.SECTOR_STATE),ir=new Y([le],c=>c===U.VERTEX_STATE),ar=new Y([le,St],(c,t)=>t||c===U.FACE_STATE||c===U.FACE_VALUE||c===U.DELETE_FACE),be=(c,t,e,o)=>{const r=new Fe({mouseButton:0,fire:a=>{var h;return e&&e(c,(h=a.domEvent)!=null&&h.shiftKey?2:0)}}),s=new Fe({mouseButton:2,fire:a=>{var h;return e&&e(c,(h=a.domEvent)!=null&&h.shiftKey?0:2)}}),p=new Fe({mouseButton:1,fire:a=>e&&e(c,1)});t.addInputListener(r),t.addInputListener(s),t.addInputListener(p),t.cursor="pointer",r.isHighlightedProperty.lazyLink(a=>{o&&o(c,a)}),t.disposeEmitter.addListener(()=>{r.dispose(),s.dispose(),p.dispose()})};class Te extends N{constructor(t,e,o,r){const s=Ve()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{}},r);super({pickableProperty:St}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,be(null,this,s.facePressListener,s.faceHoverListener);const p=t.map(f=>f.start.viewCoordinates),a=s.useBackgroundOffsetStroke,h=s.backgroundOffsetDistance,n=Me(p)>0?-h:h,l=f=>{const C=new Lt;C.addShape(0,f),C.computeSimplifiedFaces(),C.computeFaceInclusion(V=>V[0]>0);const P=C.createFilledSubGraph(),S=P.facesToShape();return C.dispose(),P.dispose(),S},u=Te.getOffsetBackgroundShape(t,a,h),g=e.map(f=>{const C=f.map(S=>S.start.viewCoordinates),P=L.polygon(C);if(a)return l(P.getOffsetShape(n));{const V=P.getStrokedShape(new ye({lineWidth:2*h})).subpaths.map(m=>new L([m]));return l(J.minBy(V,m=>m.getArea()))}});this.children=[new X(u,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...g.map(f=>new X(f,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const r=t.map(h=>h.start.viewCoordinates),s=L.polygon(r),a=Me(r)>0?-o:o;if(e)return s.getOffsetShape(a).getSimplifiedAreaShape();{const h=s.getStrokedShape(new ye({lineWidth:2*o})),i=h.subpaths.map(n=>new L([n]));try{return h.bounds.width===9.718028227819117?L.bounds(h.bounds):J.maxBy(i,n=>n.getArea()).getSimplifiedAreaShape()}catch{return L.bounds(h.bounds)}}}}class nr extends N{constructor(t,e,o,r){super(),this.vertex=t;const s=new Y([e,r.verticesVisibleProperty],(i,n)=>n&&t.edges.every(l=>i.getEdgeState(l)!==j.BLACK));this.disposeEmitter.addListener(()=>s.dispose());const p=new X(null,{translation:t.viewCoordinates,fill:r.theme.vertexColorProperty,visibleProperty:s});this.addChild(p);const a=Pe.multilink([r.vertexStyleProperty,r.smallVertexProperty],(i,n)=>{const l=n?.03:.05;i==="round"?p.shape=L.circle(l):i==="square"?p.shape=L.rect(-l,-l,2*l,2*l):A()&&M(!1,`unhandled vertex style: ${i}`)});this.disposeEmitter.addListener(()=>a.dispose());const h=i=>{this.visible=!i};o.link(h),this.disposeEmitter.addListener(()=>o.unlink(h))}}class lr extends N{constructor(t,e,o,r){const s=Ve()({textOptions:{font:Re,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{}},r);super({}),this.face=t;const p=L.polygon(t.vertices.map(i=>i.viewCoordinates));this.mouseArea=p,this.touchArea=p,be(t,this,s.facePressListener,s.faceHoverListener);const a=new Tt("",ze({subScale:.7},s==null?void 0:s.textOptions)),h=Pe.multilink([e,o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty],(i,n,l,u,g,f,C)=>{const P=i.getFaceValue(t);this.visible=!C;let S,V,m=!1,k=!1;if(P===null)S="",V=null;else{let w=0,y=0;for(const E of t.edges){const b=i.getEdgeState(E);b===j.BLACK?w++:b===j.WHITE&&y++}if(n==="static"||P===0)S=`${P}`;else if(n==="remaining")S=`${P-w}`,m=w>0;else if(n==="ratio")P-w===0?S="0":(S=`${P-w}<sub style="color: ${f.toCSS()};">/<sub>${y}</sub></sub>`,k=!0),m=w>0;else throw new Error(`unhandled faceValueStyle: ${n}`);w<P?V=l:w===P?V=u:V=g}a.string=S,a.fill=V,a.maxWidth=k?.8:.9,a.maxHeight=k?.8:.9,a.center=t.viewCoordinates,this.children=[a]});this.disposeEmitter.addListener(()=>h.dispose())}}class cr extends N{constructor(t,e,o,r,s){super({}),this.edge=t;const p=new Y([e],w=>w.getEdgeState(t));this.disposeEmitter.addListener(()=>p.dispose());const a=t.start.viewCoordinates,h=t.end.viewCoordinates,i=a.average(h),n=.06,l=new L().moveTo(-n,-n).lineTo(n,n).moveTo(-n,n).lineTo(n,-n),u=new Y([o,r.redXsVisibleProperty],(w,y)=>!w&&y);this.disposeEmitter.addListener(()=>u.dispose());const g=new X(l,{stroke:r.theme.xColorProperty,lineWidth:.02,center:i,visibleProperty:u}),f=w=>{g.rotation=w?h.minus(a).getAngle():0};r.redXsAlignedProperty.link(f),this.disposeEmitter.addListener(()=>r.redXsAlignedProperty.unlink(f));const C=new Y([o,r.whiteLineVisibleProperty],(w,y)=>!w&&y);this.disposeEmitter.addListener(()=>C.dispose());const P=new Ge(a.x,a.y,h.x,h.y,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty,visibleProperty:C}),S=new Y([o,r.redLineVisibleProperty],(w,y)=>y);this.disposeEmitter.addListener(()=>S.dispose());const V=new X(null,{lineWidth:.02,stroke:r.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:S}),m=w=>{w==="middle"?V.shape=new L().moveToPoint(i.blend(a,.35)).lineToPoint(i.blend(h,.35)).makeImmutable():w==="gap"?V.shape=new L().moveToPoint(a).lineToPoint(a.blend(i,.35)).moveToPoint(h.blend(i,.35)).lineToPoint(h).makeImmutable():w==="full"?V.shape=new L().moveToPoint(a).lineToPoint(h).makeImmutable():A()&&M(!1,`Unknown red line style: ${w}`)};r.redLineStyleProperty.link(m),this.disposeEmitter.addListener(()=>r.redLineStyleProperty.unlink(m));const k=s==null?void 0:s.edgePressListener;if(k){const w=new L;if(t.faces.length===2)w.polygon([a,t.faces[0].viewCoordinates,h,t.faces[1].viewCoordinates]);else{A()&&M(t.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const y=t.forwardHalf.face===null?t.forwardHalf:t.reversedHalf;A()&&M(y.previous.face===null),A()&&M(y.next.face===null);const E=y.start.viewCoordinates,b=y.end.viewCoordinates,W=y.previous.start.viewCoordinates,x=y.next.end.viewCoordinates,R=($,I,K)=>{const oe=I.minus($).normalized(),Q=K.minus(I).normalized();let re=oe.minus(Q);return re.getMagnitude()<1e-6?re=oe.getPerpendicular():re=re.normalized(),Et.triangleAreaSigned($,I,I.plus(re))<0&&(re=re.negated()),re},T=R(W,E,b),_=R(E,b,x);w.polygon([E,t.faces[0].viewCoordinates,b,b.plus(_.times(s.backgroundOffsetDistance)),E.plus(T.times(s.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=w,be(t,this,k,s.edgeHoverListener)}p.link(w=>{w===j.WHITE?this.children=[P]:w===j.BLACK?this.children=[]:this.children=[V,g]})}}class dr extends N{constructor(e,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});v(this,"simpleRegionNodeMap",new Map);v(this,"regionIdMap",new Map);v(this,"weirdEdgeNodeMap",new Map);v(this,"regionContainer",new N);v(this,"weirdEdgeContainer",new N);v(this,"adjacentFacesMap",new Map);this.board=e,this.style=r,e.faces.forEach(a=>{this.adjacentFacesMap.set(a,a.edges.map(h=>h.getOtherFace(a)).filter(h=>h!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(a=>this.addRegion(a)),o.value.getWeirdEdges().forEach(a=>this.addWeirdEdge(a)),this.updateHues();const s=(a,h)=>{const i=h.getSimpleRegions(),n=a.getSimpleRegions(),l=h.getWeirdEdges(),u=a.getWeirdEdges(),g=[],f=[];Qe(i,n,g,f,[]);const P=new Set(g);for(const S of f)if(this.regionIdMap.has(S.id)){const V=this.regionIdMap.get(S.id);this.replaceRegion(V,S),P.delete(V)}else this.addRegion(S);for(const S of P)this.removeRegion(S);for(const S of l)u.includes(S)||this.removeWeirdEdge(S);for(const S of u)l.includes(S)||this.addWeirdEdge(S);(f.length||g.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const p=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(p),r.edgesHaveColorsProperty.lazyLink(p),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(p),r.edgesHaveColorsProperty.unlink(p)})}addRegion(e){const o=new pe(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){A()&&M(e.id===o.id);const r=this.simpleRegionNodeMap.get(e);r.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=new Ge(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){const o=this.weirdEdgeNodeMap.get(e);this.weirdEdgeContainer.removeChild(o),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new O(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},s=new Map,p=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of e){const l=new Set;for(const g of n.simpleRegion.edges)for(const f of g.faces)l.add(f);const u=new Set;for(const g of l){u.add(g);for(const f of this.adjacentFacesMap.get(g))u.add(f)}for(const g of u){const f=s.get(g);if(f.length)for(const C of f){let P=!1;for(const S of p)if(S.a===C&&S.b===n){S.weight++,P=!0;break}P||p.push({a:C,b:n,weight:1})}f.push(n)}}const a=new Map;for(const n of e)a.set(n,O.ZERO.copy());const h=(n,l,u)=>{const g=a.get(n),f=a.get(l),C=n.hueVector.dot(l.hueVector),P=o.set(l.hueVector).subtract(n.hueVector);if(P.magnitude>1e-9){P.normalize();const S=.3,V=u*((Math.max(S,C)-S)/(1-S))**3;P.multiplyScalar(V),g.subtract(P),f.add(P)}};let i=1;for(let n=0;n<100;n++){i*=.99;for(const l of e)a.get(l).setXY(0,0);for(const l of p){const u=l.a,g=l.b,f=l.weight;h(u,g,f)}if(e.length<8)for(let l=0;l<e.length;l++){const u=e[l];for(let g=l+1;g<e.length;g++)h(u,e[g],.2)}for(const l of e){const u=a.get(l);u.multiplyScalar(i/l.edgeCount),l.hueVector.add(u),a.get(l).setXY(0,0)}r()}for(const n of e)n.updateHue()}}class pe extends X{constructor(e,o){const r=O.createPolar(1,ie.nextDoubleBetween(0,2*Math.PI));super(pe.toShape(e),{stroke:pe.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});v(this,"hueVector");v(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=r,this.edgeCount=e.edges.length;const s=a=>{this.lineJoin=a};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const p=a=>{this.lineCap=a};o.joinedLinesCapProperty.link(p),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(p))}updateHue(){this.stroke=pe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:O.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=pe.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&M(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(e){const o=new L;let r=!0;for(const s of e.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class hr extends N{constructor(e,o,r){const s=new N;super({pickable:!1,children:[s]});v(this,"faceColorNodeMap",new Map);v(this,"faceColorIdMap",new Map);v(this,"adjacentFacesMap",new Map);v(this,"faceColorNodeContainer");v(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,e.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(n=>n.getOtherFace(i)).filter(n=>n!==null))});{const i=o.value.getFaceColors();for(const n of i)this.addFaceColor(n,o.value.getFacesWithColor(n));this.addDualColorViews(o.value,i)}this.updateHues();let p=o.value.clone();const a=i=>{const n=p;p=i.clone();const l=n.getFaceColors(),u=i.getFaceColors(),g=[],f=[],C=[];Qe(l,u,g,f,C);const P=new Set(g),S=this.removeInvalidDualColorViews(i),V=[...S];for(const m of f)if(S.add(m),this.faceColorIdMap.has(m.id)){const k=this.faceColorIdMap.get(m.id);this.replaceFaceColor(k,m,i.getFacesWithColor(m)),P.delete(k)}else this.addFaceColor(m,i.getFacesWithColor(m));for(const m of C)this.updateFaceColor(m,i.getFacesWithColor(m));for(const m of P)S.delete(m),this.removeFaceColor(m);this.addDualColorViews(i,[...S]),(f.length||g.length||V.length)&&this.updateHues()};o.lazyLink(a),this.disposeEmitter.addListener(()=>o.unlink(a)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const h=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(h),r.theme.faceColorLightHueLUTProperty.lazyLink(h),r.theme.faceColorDarkHueLUTProperty.lazyLink(h),r.theme.faceColorInsideColorProperty.lazyLink(h),r.theme.faceColorOutsideColorProperty.lazyLink(h),r.theme.faceColorDefaultColorProperty.lazyLink(h),r.faceColorThresholdProperty.lazyLink(h),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(h),r.theme.faceColorLightHueLUTProperty.unlink(h),r.theme.faceColorDarkHueLUTProperty.unlink(h),r.theme.faceColorInsideColorProperty.unlink(h),r.theme.faceColorOutsideColorProperty.unlink(h),r.theme.faceColorDefaultColorProperty.unlink(h),r.faceColorThresholdProperty.unlink(h)})}addFaceColor(e,o){const r=new Se(e,o,this.style);this.faceColorNodeMap.set(e,r),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(e,o,r){A()&&M(e.id===o.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const r=this.faceColorNodeMap.get(e);let s=r.faces.length!==o.length;if(!s)for(let p=0;p<o.length;p++){const a=r.faces[p],h=o[p];if(a!==h){s=!0;break}}s&&r.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const p=this.faceColorNodeMap.get(s);A()&&M(p);const a=e.getOppositeFaceColor(s);if(a){A()&&M(r.has(a)),r.delete(a);const h=this.faceColorNodeMap.get(a);A()&&M(h),this.dualColorViews.add(new je([p,h],this.style))}else this.dualColorViews.add(new je([p],this.style))}}removeInvalidDualColorViews(e){const o=new Set,r=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const p of s.colorNodes)o.add(p.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==de.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new O(0,0),r=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(ie.nextDouble()-.5,ie.nextDouble()-.5).normalize()},s=new Map,p=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of e){const l=new Set;for(const g of n.faces)l.add(g);const u=new Set;for(const g of l){u.add(g);for(const f of this.adjacentFacesMap.get(g))u.add(f)}for(const g of u){const f=s.get(g);if(f.length)for(const C of f){let P=!1;for(const S of p)if(S.a===C&&S.b===n){S.weight++,P=!0;break}P||p.push({a:C,b:n,weight:1})}f.push(n)}}const a=new Map;for(const n of e)a.set(n,O.ZERO.copy());const h=(n,l,u)=>{const g=a.get(n),f=a.get(l),C=n.hueVector.dot(l.hueVector),P=o.set(l.hueVector).subtract(n.hueVector).normalize(),S=.2,V=Math.abs(C),m=u*((Math.max(S,V)-S)/(1-S))**3;P.multiplyScalar(m),g.subtract(P),f.add(P)};let i=1;for(let n=0;n<100;n++){i*=.99;for(const l of e)a.get(l).setXY(0,0);for(const l of p){const u=l.a,g=l.b,f=l.weight;h(u,g,f)}if(e.length<8)for(let l=0;l<e.length;l++){const u=e[l];for(let g=l+1;g<e.length;g++)h(u,e[g],.2)}for(const l of e){const u=a.get(l);u.multiplyScalar(i/l.faceCount),l.hueVector.add(u),a.get(l).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const z=class z extends Je{};v(z,"BASIC",new z),v(z,"PRIMARY",new z),v(z,"SECONDARY",new z),v(z,"enumeration",new Ze(z));let q=z;class je{constructor(t,e){v(this,"hueVector");v(this,"faceCount");if(this.colorNodes=t,this.style=e,A()&&M(t.length===1||t.length===2),this.faceCount=J.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=q.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],r=o===t[0]?t[1]:t[0];let s;o.type===q.PRIMARY?s=o:r.type===q.PRIMARY||o.type===q.SECONDARY?s=r:(r.type,q.SECONDARY,s=o);const p=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=q.PRIMARY,p.type=q.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class Se extends X{constructor(e,o,r){const s=O.createPolar(1,ie.nextDoubleBetween(0,2*Math.PI));super(Se.toShape(o));v(this,"hueVector");v(this,"faceCount");v(this,"dualColorView",null);v(this,"type",q.BASIC);this.faceColor=e,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==de.UNDECIDED?this.fill=Se.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:O.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const r=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=Se.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(e,o,r,s){const p=r===q.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===q.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,a=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&M(a>=0&&a<p.length);const h=p[a];if(o===de.UNDECIDED)return h;{const n=(o===de.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,l=n.alpha,u=new Ae(h);return new Ae((1-l)*u.red+l*n.red,(1-l)*u.green+l*n.green,(1-l)*u.blue+l*n.blue).toCSS()}}static toShape(e){const o=new L;for(const r of e)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}const Ue=[.02,.02],pr=new Map([[F.NONE,[]],[F.ONLY_ZERO,[]],[F.ONLY_ONE,[]],[F.ONLY_TWO,[]],[F.NOT_ZERO,Ue],[F.NOT_ONE,[]],[F.NOT_TWO,Ue],[F.ANY,[]]]),Le=.2,qe=.02,Ce=class Ce extends N{constructor(t,e,o,r){super(),this.sector=t;const s=t.start.viewCoordinates,p=t.end.viewCoordinates,a=t.next.end.viewCoordinates,h=s.minus(p),i=a.minus(p),n=h.normalized(),l=i.normalized(),u=h.angle;let g=i.angle;g<u&&(g+=2*Math.PI);const f=l.minus(n).angle+Math.PI/2,C=Ce.getSectorBaseShape(t,r.backgroundOffsetDistance);this.mouseArea=C,this.touchArea=C,be(t,this,r.sectorPressListener,r.sectorHoverListener);const P=(w,y)=>(w.moveToPoint(n.timesScalar(y)),w.arcPoint(O.ZERO,y,u,g,!0),w),S=(w,y,E)=>(w.moveTo(y.x+E,y.y),w.circle(y,E),w),V=w=>{const y=O.createPolar(.2,f);if(w===F.NONE)return new L().moveTo(y.x-.05,y.y-.05).lineTo(y.x+.05,y.y+.05).moveTo(y.x-.05,y.y+.05).lineTo(y.x+.05,y.y-.05).makeImmutable();if(w===F.ONLY_ZERO)return S(new L,y,.05).makeImmutable();if(w===F.ONLY_TWO)return new L().moveToPoint(n.timesScalar(.1).plus(y.timesScalar(.7))).lineToPoint(y.timesScalar(.7)).lineToPoint(l.timesScalar(.1).plus(y.timesScalar(.7))).makeImmutable();if(w===F.ONLY_ONE||w===F.NOT_TWO)return P(new L,Le).makeImmutable();if(w===F.NOT_ZERO||w===F.NOT_ONE)return P(P(new L,Le+qe),Le-qe).makeImmutable();if(w===F.ANY)return S(S(S(new L,y,.05),y,.03),y,.01).makeImmutable();throw new Error("Unhandled sector state")},m=new X(null,{translation:p,lineWidth:.01,lineCap:"butt",visibleProperty:o.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>m.dispose()),this.addChild(m);const k=Pe.multilink([e,o.sectorsNextToEdgesVisibleProperty,o.sectorsTrivialVisibleProperty],(w,y,E)=>{const b=w.getEdgeState(t.edge),W=w.getEdgeState(t.next.edge),x=w.getSectorState(t);let R=null,T=null,_=[],$=.01;if(y||b===j.WHITE&&W===j.WHITE){let I=F.trivialStates.includes(x);if(x===F.NOT_ONE){const K=t.end.edges.filter(Q=>w.getEdgeState(Q)===j.BLACK),oe=t.end.edges.filter(Q=>w.getEdgeState(Q)===j.WHITE);K.length===0&&oe.length===2&&(I=!0)}(E||!I)&&(R=V(x)??null,T=Ce.getStrokeFromStyle(x,o)??null,_=pr.get(x)??[],_.length&&($=.015))}m.shape=R,m.stroke=T,m.lineDash=_,m.lineWidth=$});this.disposeEmitter.addListener(()=>k.dispose())}static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,p=o.minus(r),a=s.minus(r),h=p.normalized(),n=a.normalized().minus(h).angle+Math.PI/2,l=t.face?t.face.viewCoordinates:O.createPolar(e,n).plus(r),u=o.average(r),g=s.average(r);return L.polygon([u,r,g,l]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=t.next.end.viewCoordinates,p=o.minus(r),a=s.minus(r),h=p.normalized(),i=p.angle;let n=a.angle;return n<i&&(n+=2*Math.PI),new L().moveToPoint(r).lineToPoint(h.timesScalar(e).plus(r)).arcPoint(r,e,i,n,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===F.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===F.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===F.NOT_ONE?e.theme.sectorNotOneColorProperty:t===F.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}};v(Ce,"nameMap",new Map([[F.NONE,"Invalid"],[F.ONLY_ZERO,"No Lines"],[F.ONLY_ONE,"Only One Line"],[F.ONLY_TWO,"Both Lines"],[F.NOT_ZERO,"At Least One Line"],[F.NOT_ONE,"Zero or Two Lines"],[F.NOT_TWO,"Less Than Two Lines"],[F.ANY,"Any Lines"]]));let he=Ce;class ur extends N{constructor(t,e,o,r){super({pickable:!1}),this.vertex=t;const s=.12,a=t.edges.map(C=>C.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(C=>C.times(s)),i=L.polygon(Vt.grahamScan([O.ZERO,...a],!1)).getOffsetShape(-.05),n=new X(null,{stroke:r.theme.vertexStateLineProperty,lineWidth:.01}),l=new X(i,{translation:t.viewCoordinates,fill:r.theme.vertexStateBackgroundProperty,stroke:r.theme.vertexStateOutlineProperty,lineWidth:.01,children:[n,...a.map(C=>new $e({radius:.02,translation:C,fill:r.theme.vertexStatePointProperty}))]});let u=null;const g=Pe.multilink([e,r.vertexStateVisibleProperty,r.allVertexStateVisibleProperty],(C,P,S)=>{const V=()=>{this.children=[]};if(!P){V();return}const m=C.getVertexState(t);if(!S){let k=!1,w=!1;const y=new Set;for(const b of t.edges){const W=C.getEdgeState(b);k=k||W===j.BLACK,w=w||W===j.WHITE,W===j.WHITE&&y.add(b)}if(k||!w){V();return}if(Gt.fromLookup(t,(b,W)=>y.has(b)&&y.has(W),!0).equals(m)){V();return}}if(!u||!u.equals(m)){u=m;const k=new L;for(const w of m.getAllowedPairs()){const y=E=>E.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(s);k.moveToPoint(y(w[0])),k.lineToPoint(y(w[1]))}m.allowsEmpty()&&(k.moveTo(.03,0),k.circle(O.ZERO,.03),k.close()),k.makeImmutable(),n.shape=k}this.children=[l]});this.disposeEmitter.addListener(()=>g.dispose());const f=C=>{this.visible=!C};o.link(f),this.disposeEmitter.addListener(()=>o.unlink(f))}}class Ct extends Ft{constructor(t,e){const o=Ve()({font:Jt,fill:G.uiForegroundColorProperty},e);super(t,o)}}class gr extends N{constructor(t,e,o,r){super({translation:t.viewCoordinates}),this.face=t;const s=Pe.multilink([e,r.faceStateVisibleProperty],(a,h)=>{if(this.children=[],h){const i=a.getFaceState(t),n=i.possibilityCount===0||i.possibilityCount>9;let l;const u=i.possibilityCount===1?r.theme.faceValueCompletedColorProperty:r.theme.faceValueColorProperty;if(n)l=new Ct(i.possibilityCount,{font:Re,maxWidth:.4,maxHeight:.4});else{const g=new Set(t.vertices);l=new kt({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(i.possibilityCount)),children:i.getAllowedCombinations().map(f=>{const C=new N,P=new Set(f.map(m=>m.start)),S=new Set(f.map(m=>m.end)),V=m=>m.minus(t.viewCoordinates);if(C.addChild(new X(L.polygon(t.vertices.map(m=>V(m.viewCoordinates))),{stroke:u,lineWidth:.03,opacity:.2})),P.size){const m=new L;if(f.length===t.edges.length)m.polygon(t.vertices.map(k=>V(k.viewCoordinates)));else{const k=new Set(f);for(;k.size;){const w=[...g].find(b=>[...k].filter(W=>W.start===b||W.end===b).length===1);A()&&M(w);let y=w,E=[...k].find(b=>b.start===y||b.end===y)??null;for(m.moveToPoint(V(y.viewCoordinates));E;)k.delete(E),y=E.getOtherVertex(y),m.lineToPoint(V(y.viewCoordinates)),E=[...k].find(b=>b.start===y||b.end===y)??null}}C.addChild(new X(m,{stroke:u,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const m of t.vertices)!P.has(m)&&!S.has(m)&&C.addChild(new $e(.1,{fill:u,translation:V(m.viewCoordinates)}));return C}),maxWidth:.6,maxHeight:.6})}l.center=O.ZERO,this.addChild(l)}});this.disposeEmitter.addListener(()=>s.dispose());const p=a=>{this.visible=!a};o.link(p),this.disposeEmitter.addListener(()=>o.unlink(p))}}const fr=new ye({lineWidth:.2,lineCap:"round",lineJoin:"round"});class wr extends N{constructor(t,e,o){let r;if(Zt.value)if(t.type==="edge-state"){const s=new L().moveToPoint(t.edge.start.viewCoordinates).lineToPoint(t.edge.end.viewCoordinates);r=[new X(s.getStrokedShape(fr),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(t.type==="face-color")if(t.face){const s=L.polygon(t.face.vertices.map(a=>a.viewCoordinates));r=[new X(s.getOffsetShape(-.1),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else if(t.type==="sector"){const s=he.getSectorArcShape(t.sector,.5);r=[new X(s.getOffsetShape(.05),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else r=[];super({children:r}),this.hoverHighlight=t}}class mr extends N{constructor(t,e,o,r){let s=[];try{let p=new L;for(const h of t.faces)p.polygon(h.vertices.map(i=>i.viewCoordinates));if(t.faceColor.colorState===de.OUTSIDE)try{const h=L.polygon(e.outerBoundary.map(l=>l.start.viewCoordinates)),n=Te.getOffsetBackgroundShape(e.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(h);p=p.shapeUnion(n)}catch(h){console.error(h)}const a=new X(p.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(a)}catch(p){console.error(p)}super({children:s}),this.selectedFaceColorHighlight=t}}class Sr extends N{constructor(t,e,o,r){const s=[],p=[],a=t.sector,h=t.currentState,i=he.getSectorArcShape(a,.5),n=new X(i.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(n);const l=[];if(h===F.ANY&&(l.push(F.NOT_ZERO),l.push(F.NOT_ONE),l.push(F.NOT_TWO)),h.one&&h!==F.ONLY_ONE&&l.push(F.ONLY_ONE),l.length){const u=l.map(C=>{const P=he.getStrokeFromStyle(C,o);return new eo({accessibleName:he.nameMap.get(C),content:new xt(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(a,C)},buttonAppearanceStrategy:zt,baseColor:P,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});p.push(...u);const g=new et(new Ke({children:u,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});p.push(g);const f=.1;s.push(g),g.centerBottom=n.centerTop.plusXY(0,-.15),g.top<e.top+f&&(g.centerTop=n.centerBottom.plusXY(0,.15)),g.left<e.left+f&&(g.left=e.left+f),g.right>e.right-f&&(g.right=e.right-f)}super({children:s}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{p.forEach(u=>u.dispose())})}}class _e extends N{constructor(e,o){const r=Ve()({textOptions:{font:Re,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new ue(null),selectedFaceColorHighlightProperty:new ue(null),selectedSectorEditProperty:new ue(null),style:ce},o),s=r.style,p=new N({visibleProperty:s.faceColorsVisibleProperty}),a=new N({pickableProperty:ar}),h=new N({pickableProperty:sr}),i=new N({pickableProperty:rr}),n=new N({pickableProperty:ir}),l=new N,u=new N({pickable:!1}),g=new N({pickable:!1}),f=new N({pickable:!1}),C=new N({pickable:!1}),P=new N({pickable:!1}),S=new N,V=new Y([e.stateProperty],E=>{if(E.getWeirdEdges().length||E.hasInvalidFaceColors())return!1;const b=E.getSimpleRegions();return b.length===1&&b[0].isSolved});p.addChild(new hr(e.board,e.stateProperty,s)),e.board.faces.forEach(E=>{a.addChild(new lr(E,e.stateProperty,s,r)),g.addChild(new gr(E,e.stateProperty,V,s))});const m=new Te(e.board.outerBoundary,e.board.innerBoundaries,s,r);e.board.vertices.forEach(E=>{n.addChild(new nr(E,e.stateProperty,V,s)),u.addChild(new ur(E,e.stateProperty,V,s))}),e.board.edges.forEach(E=>{i.addChild(new cr(E,e.stateProperty,V,s,r))}),e.board.halfEdges.forEach(E=>{h.addChild(new he(E,e.stateProperty,s,r))}),l.addChild(new dr(e.board,e.stateProperty,s));super(ze({children:[m,p,a,h,i,n,l,u,g,f,C,P,S]},r));v(this,"annotationContainer");v(this,"backgroundNode");this.puzzle=e,this.annotationContainer=f;const k=E=>{P.children.forEach(b=>b.dispose()),E&&P.addChild(new wr(E,r.backgroundOffsetDistance,s))};r.hoverHighlightProperty.link(k),this.disposeEmitter.addListener(()=>r.hoverHighlightProperty.unlink(k));const w=E=>{C.children.forEach(b=>b.dispose()),E&&C.addChild(new mr(E,e.board,s,r))};r.selectedFaceColorHighlightProperty.link(w),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(w));const y=E=>{S.children.forEach(b=>b.dispose()),E&&S.addChild(new Sr(E,m,s,r))};r.selectedSectorEditProperty.link(y),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(y)),this.disposeEmitter.addListener(()=>{[p,a,i,n,l,u,g,h].forEach(b=>{b.children.forEach(W=>W.dispose()),b.dispose()}),V.dispose(),m.dispose()}),this.backgroundNode=m}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}const Cr=(c,t)=>{so(io,c,t,!0)};class jr extends N{constructor(t,e,o,r=null){let s;const p=i=>new L().moveToPoint(i.start.viewCoordinates).lineToPoint(i.end.viewCoordinates).getStrokedShape(new ye({lineWidth:.2,lineCap:"round"})).getStrokedShape(new ye({lineWidth:.02})),a=(i,n)=>new X(p(i),{fill:n}),h=[];if(e.type==="ForcedLine")s=[a(e.whiteEdge,"red"),a(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")s=[a(e.whiteEdge,"red"),...e.redEdges.map(i=>a(i,"blue"))];else if(e.type==="JointToRed")s=[...e.whiteEdges.map(i=>a(i,"red")),...e.blackEdges.map(i=>a(i,"blue"))];else if(e.type==="FaceSatisfied")s=[...e.whiteEdges.map(i=>a(i,"red")),...e.blackEdges.map(i=>a(i,"blue"))];else if(e.type==="FaceAntiSatisfied")s=[...e.whiteEdges.map(i=>a(i,"red")),...e.redEdges.map(i=>a(i,"blue"))];else if(e.type==="ForcedSolveLoop")s=[...e.regionEdges.map(i=>a(i,"blue")),...e.pathEdges.map(i=>a(i,"red"))];else if(e.type==="PrematureForcedLoop")s=[...e.regionEdges.map(i=>a(i,"blue")),...e.pathEdges.map(i=>a(i,"red"))];else if(e.type==="CompletingEdgesAfterSolve")s=[...e.whiteEdges.map(i=>a(i,"red"))];else if(e.type==="FaceColoringBlackEdge")s=[a(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")s=[a(e.edge,"red")];else if(e.type==="FaceColorToBlack")s=[a(e.edge,"red")];else if(e.type==="FaceColorToRed")s=[a(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")s=[...e.face.edges.map(i=>a(i,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")s=[...e.balancedPairs.flatMap((i,n)=>{const l=["green","blue","black"][n%3],u=["magenta","orange","yellow"][n%3];return[...i[0].map(g=>a(g,l)),...i[1].map(g=>a(g,u))]})],e.type==="FaceColorMatchToRed"?s.push(...e.matchingEdges.map(i=>a(i,"red"))):e.type==="FaceColorMatchToBlack"?s.push(...e.matchingEdges.map(i=>a(i,"red"))):e.type==="FaceColorBalance"&&(s.push(...e.matchingEdges.map(i=>a(i,"orange"))),s.push(...e.oppositeEdges.map(i=>a(i,"red"))));else if(e.type==="DoubleMinusOneFaces")s=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")s=[e.sector.edge,e.sector.next.edge].map(i=>a(i,"red"));else if(e.type==="ForcedSector"){const i=[...e.toRedEdges,...e.toBlackEdges];s=[e.sector.edge,e.sector.next.edge].map(n=>a(n,i.includes(n)?"red":"blue"))}else if(e.type==="StaticFaceSectors")s=J.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="VertexState")s=e.vertex.edges.map(i=>a(i,"blue"));else if(e.type==="VertexStateToEdge")s=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="VertexStateToSector")s=J.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")s=J.uniq([...e.facesA,...e.facesB].flatMap(i=>i.edges)).map(i=>a(i,"red"));else if(e.type==="FaceState")s=e.face.edges.map(i=>a(i,"red"));else if(e.type==="FaceStateToEdge")s=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="FaceStateToSector")s=J.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const i=new Set([...e.facesA,...e.facesB].flatMap(l=>l.edges)),n=e.face.edges.filter(l=>!i.has(l));s=[...[...i].map(l=>a(l,"red")),...n.map(l=>a(l,"blue"))]}else if(e.type==="FaceStateToVertexState")s=e.face.edges.filter(n=>e.vertices.includes(n.start)||e.vertices.includes(n.end)).map(n=>a(n,"red"));else if(e.type==="Pattern"){const i=new Set(e.affectedEdges);if(e.affectedSectors.forEach(l=>{i.add(l.edge),i.add(l.next.edge)}),e.affectedFaces.forEach(l=>{l.edges.forEach(u=>i.add(u))}),s=[new N({children:[...i].map(l=>a(l,"red"))})],r){const l=bt.NOTHING.copy();[e.input,e.output].forEach(x=>{x.faceValues.forEach(R=>{R.face&&R.face.vertices.forEach(T=>{l.addPoint(T.viewCoordinates)})}),[x.blackEdges,x.redEdges].forEach(R=>{R.forEach(T=>{l.addPoint(T.start.viewCoordinates),l.addPoint(T.end.viewCoordinates)})}),[x.sectorsNotZero,x.sectorsNotOne,x.sectorsNotTwo,x.sectorsOnlyOne].forEach(R=>{R.forEach(T=>{l.addPoint(T.start.viewCoordinates),l.addPoint(T.end.viewCoordinates),l.addPoint(T.next.end.viewCoordinates)})}),x.faceColorDuals.forEach(R=>{[R.primaryFaces,R.secondaryFaces].forEach(T=>{T.forEach(_=>{_&&_.vertices.forEach($=>{l.addPoint($.viewCoordinates)})})})})});const u=Ne.empty(t),g=Ne.empty(t),f=(x,R)=>{R.faceValues.forEach(T=>{T.face&&x.setFaceValue(T.face,T.value)}),R.blackEdges.forEach(T=>{x.setEdgeState(T,j.BLACK)}),R.redEdges.forEach(T=>{x.setEdgeState(T,j.RED)}),R.sectorsNotZero.forEach(T=>{x.setSectorState(T,F.NOT_ZERO)}),R.sectorsNotOne.forEach(T=>{x.setSectorState(T,F.NOT_ONE)}),R.sectorsNotTwo.forEach(T=>{x.setSectorState(T,F.NOT_TWO)}),R.sectorsOnlyOne.forEach(T=>{x.setSectorState(T,F.ONLY_ONE)}),R.faceColorDuals.forEach(T=>{const _=(I,K)=>{const oe=I?x.getFaceColor(I):x.getOutsideColor(),Q=K?x.getFaceColor(K):x.getOutsideColor();new ao(ve(x,oe),ve(x,Q)).apply(x)},$=(I,K)=>{const oe=I?x.getFaceColor(I):x.getOutsideColor(),Q=K?x.getFaceColor(K):x.getOutsideColor();new no(ve(x,oe),ve(x,Q)).apply(x)};for(let I=1;I<T.primaryFaces.length;I++)_(T.primaryFaces[I-1],T.primaryFaces[I]);for(let I=1;I<T.secondaryFaces.length;I++)_(T.secondaryFaces[I-1],T.secondaryFaces[I]);T.secondaryFaces.length&&$(T.primaryFaces[0],T.secondaryFaces[0])}),Cr(t,x)};f(u,e.input),f(g,e.output);const C=new _e(new We(t,u)),P=new _e(new We(t,g));h.push(()=>{C.dispose(),P.dispose()});const S=.2,V=.5,m=.5,k=l.dilated(S),w=L.roundRectangle(k.x,k.y,k.width,k.height,V,V),y=new N({children:[C],clipArea:w,scale:m}),E=new N({children:[P],clipArea:w,scale:m}),b=new et(new Ke({spacing:.2,children:[y,E]}),{cornerRadius:V*(m+.2),xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:ce.theme.patternAnnotationBackgroundColorProperty}),W=S+.05;b.centerBottom=l.centerTop.plusXY(0,-.15),b.top<r.top+W&&(b.centerTop=l.centerBottom.plusXY(0,.15)),b.left<r.left+W&&(b.left=r.left+W),b.right>r.right-W&&(b.right=r.right-W),s.push(b)}}else s=[],console.log(`unknown type: ${e.type}`);super({children:s,pickable:!1}),this.board=t,this.annotation=e,this.style=o,this.disposeEmitter.addListener(()=>h.forEach(i=>i()))}static getHintNode(t){return new Ct(t.type)}}class yr{constructor(t,e,o){v(this,"edgeStateChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(A()&&M(this.board.edges.includes(t)),e!==j.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new Z(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Pr{constructor(t,e,o){v(this,"faceColorsChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){if(s)throw new Z("invalid face color?");const p=new Set([...o.values(),...r.keys(),...o.values()]),a=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())a.set(n,o.get(n));const h=n=>r.has(n)?r.get(n):[...t].includes(n)?this.currentState.getOppositeFaceColor(n):null,i=new Map;for(const n of a.keys()){const l=a.get(n);i.has(l)||i.set(l,new Set([n])),i.get(l).add(n)}for(const n of p){const l=i.get(n);if(!l)continue;const u=[...l];A()&&M(u.length>0);const g=this.solvedState.getFaceColor(u[0]);for(const C of u)if(this.solvedState.getFaceColor(C)!==g)throw new Z("invalid face color");const f=h(n);if(f){let C;if(f.colorState===de.INSIDE?C=this.solvedState.getInsideColor():f.colorState===de.OUTSIDE?C=this.solvedState.getOutsideColor():C=this.solvedState.getFaceColor([...i.get(f)][0]),g===C)throw new Z("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class vr{constructor(t,e,o){v(this,"simpleRegionsChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,r){if([...o].length)throw new Z("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Er{constructor(t,e,o){v(this,"faceValueChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new Z("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Vr{constructor(t,e,o){v(this,"sectorStateChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){A()&&M(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class br{constructor(t,e,o){v(this,"vertexStateChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){A()&&M(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make vertex ${e} when it should be ${o}`);const r=this.currentState.getVertexState(t);if(!e.isSubsetOf(r))throw new Z("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Tr{constructor(t,e,o){v(this,"faceStateChangedEmitter",new ae);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){A()&&M(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new Z(`Attempt to make face ${e} when it should be ${o}`);const r=this.currentState.getFaceState(t);if(!e.isSubsetOf(r))throw new Z("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ur{constructor(t,e,o){v(this,"anyStateChangedEmitter",new ae);v(this,"edgeStateValidator");v(this,"faceValueValidator");v(this,"simpleRegionDataValidator");v(this,"faceColorValidator");v(this,"sectorStateValidator");v(this,"vertexStateValidator");v(this,"faceStateValidator");A()&&M(t),A()&&M(o),this.edgeStateValidator=new yr(t,e,o),this.faceValueValidator=new Er(t,e,o),this.simpleRegionDataValidator=new vr(t,e,o),this.faceColorValidator=new Pr(t,e,o),this.sectorStateValidator=new Vr(t,e,o),this.vertexStateValidator=new br(t,e,o),this.faceStateValidator=new Tr(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,r){this.simpleRegionDataValidator.modifyRegions(t,e,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,r,s){this.faceColorValidator.modifyFaceColors(t,e,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const qr=(c,t,e)=>new we([new tt(c,t),new ot(c,t),new rt(c,t),new nt(c,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new lt(c,t,{solveToRed:!0,solveToBlack:!0}),new ct(c,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new lo(c,t),new st(c,t),new dt(c,t),new co(c,t),new it(c,t),new ho(c,t,{solveToRed:!0,solveToBlack:!0}),new po(c,t),new ht(c,t,{solveToRed:!0,solveToBlack:!0}),new uo(c,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new go(c,t),new at(c,t),new fo(c,t,{solveToRed:!0,solveToBlack:!0}),new wo(c,t),new mo(c,t),new So(c,t)]);let fe=null,Oe=0;const _r=()=>{if(fe&&(Oe++,Oe>5)){const c=fe;fe=null,c(null)}},Fr=async function(c){return new Promise((t,e)=>{fe=t,Oe=0,ge.debugSleep&&console.log("sleep start"),setTimeout(()=>{ge.debugSleep&&console.log("sleep end"),fe===t&&(fe=null,t(null)),ge.debugSleep&&console.log("resolved")},c)})};class kr extends Error{constructor(){super("Interrupted")}}const yt=async function(c,t){if(await Fr(c),ge.debugSleep&&console.log("after sleep before interrupt check"),t.value)throw new kr},Jr=async(c,t,e)=>{let o=0;for(;o++<100;){const r=Ne.fromFaces(c,()=>null),s=ie.shuffle(c.faces);let p=-1,a=[];const h=i=>{try{return a=ut(c,i,{maxIterations:1e4,failOnMultipleSolutions:!0}),a.length}catch(n){if(n instanceof gt)return 2;if(n instanceof Co)return 0;throw n}};for(const i of s){ge.debugSleep&&console.log("going to sleep"),t&&await yt(0,t),ge.debugSleep&&console.log("finished sleep, generating next!");let n=ie.shuffle(J.range(0,i.edges.length));n[0]===0&&(n=ie.shuffle(n));for(const l of n){const u=r.createDelta();if(u.setFaceValue(i,l),p=h(u),p>=1){u.apply(r),e&&e.emit(c.faces.indexOf(i),l);break}}if(p===1)break}if(p===1)return pt(c,r,a[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},Zr=async(c,t=()=>!0,e,o)=>{const r=c.board,s=c.cleanState.clone(),p=ie.shuffle(r.faces),a=h=>{try{return ut(r,h,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(i){if(i instanceof gt)return!0;throw i}};A()&&M(!a(s),"Initial state has multiple solutions"),A()&&M(t(r,s.clone()),"Initial state is not easy enough");for(const h of p){e&&await yt(0,e);const i=s.getFaceValue(h);if(i===null){o&&o.emit(r.faces.indexOf(h),null);continue}const n=s.createDelta();n.setFaceValue(h,null),!a(n)&&t(r,n.clone())?(n.apply(s),o&&o.emit(r.faces.indexOf(h),null)):o&&o.emit(r.faces.indexOf(h),i)}return pt(c.board,s,c.blackEdges)},xr={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new Ee(2,50)},height:{label:"Height",type:"integer",range:new Ee(2,50)}},defaultParameterValues:{width:6,height:10},generate:c=>{const t=c.width,e=c.height;return J.range(0,e).flatMap(o=>J.range(0,t).map(r=>[new O(r,o),new O(r+1,o),new O(r+1,o+1),new O(r,o+1)]))}},Lr={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new Ee(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new Ee(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:c=>{const t=c.radius,e=c.isPointyTop,o=c.holeRadius;let r,s;e?(r=new O(Math.sqrt(3),0),s=new O(Math.sqrt(3)/2,3/2)):(r=new O(3/2,Math.sqrt(3)/2),s=new O(0,Math.sqrt(3)));const p=[new O(1,0),new O(1,-1),new O(0,-1),new O(-1,0),new O(-1,1),new O(0,1)],a=J.range(0,6).map(l=>p[l].plus(p[(l+1)%6])),h=l=>a.map(u=>u.plus(l.timesScalar(3))),i=(l,u)=>(Math.abs(l.x-u.x)+Math.abs(l.x+l.y-u.x-u.y)+Math.abs(l.y-u.y))/2,n=[];for(let l=-t;l<=t;l++)for(let u=Math.max(-t,-l-t);u<=Math.min(t,-l+t);u++){const g=new O(l,u);i(g,new O(0,0))>=o&&n.push(h(g).map(f=>r.timesScalar(f.x).plus(s.timesScalar(f.y)).timesScalar(1/3)))}return n}},Nr={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:c=>{const t={6:yo,10:Po,11:vo,13:Eo,14:Vo,20:bo}[c.radius];A()&&M(t);const e=.01,o=t.thinShape.subpaths.filter(s=>s.segments.length).map(s=>s.points.slice(0,-1).map(p=>p.timesScalar(e)));return[...t.thickShape.subpaths.filter(s=>s.segments.length).map(s=>s.points.slice(0,-1).map(p=>p.timesScalar(e))),...o]}},zr=[xr,B(To,{width:8,height:8}),Lr,B(Fo,{width:8,height:8,squareRegion:!0}),B(ko,{width:5,height:6,squareRegion:!0}),B(xo,{width:6,height:5}),B(Lo,{width:9,height:9}),B(No,{width:9,height:9}),B(Oo,{width:7,height:8}),B(Ro),B(Ao),B(Mo),B(Io,{squareRegion:!0}),B(Ho),B(Do),B(Bo,{width:9,height:9}),B(Wo),B(Xo,{width:9,height:9}),B(Yo),B(jo),B(Uo,{width:6,height:8,squareRegion:!0}),B(qo),B(_o),Nr];export{jr as A,Ur as C,U as E,gr as F,_e as P,Ct as U,ur as V,qr as a,mt as b,ce as c,Zo as d,le as e,zo as f,Go as g,$o as h,Ko as i,er as j,Jo as k,Xr as l,zr as m,Jr as n,Zr as o,or as p,yt as q,Fr as r,Cr as s,Yr as t,Qo as v,_r as w};
