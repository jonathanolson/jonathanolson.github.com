var C=Object.defineProperty;var w=(a,e,t)=>e in a?C(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var F=(a,e,t)=>(w(a,typeof e!="symbol"?e+"":e,t),t);import{e as I,F as o,R as D,B as L,S as V,a as k,b as z,c as R,n as E,P as M,h as y,d as N}from"./FeatureSet-CNv15qKr.js";import{_ as q,e as S,f as l}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{s as H,z as P,n as v,y as U,B as Q,g as W}from"./patternBoards-CAxgrjj1.js";import{E as Z,d as $}from"./Vector2Property-95p6aBvi.js";const h=class h extends Z{};F(h,"INCOMPATIBLE",new h),F(h,"INCONSEQUENTIAL",new h),F(h,"DORMANT",new h),F(h,"ACTIONABLE",new h),F(h,"enumeration",new $(h));let g=h;const j=a=>a.name?a.name:H(a.descriptor),G=a=>{let e=P(a);if(e)return e;const t=v(a);return e=U(t),e||new Q(t)};class J{constructor(e){F(this,"featureArray",[]);F(this,"featureMatchers",[]);this.patternBoard=e;for(const t of e.faces){const r=t.isExit?[null]:[...q.range(0,t.edges.length),null];for(const s of r)this.featureArray.push(new I(t,s)),this.featureMatchers.push((u,i)=>u.faceValues[i.mapFace(t).index]===s?o.MATCH:o.INCOMPATIBLE)}for(const t of e.edges)this.featureArray.push(new D(t)),this.featureMatchers.push((r,s)=>{const u=s.mapNonExitEdge(t).index;return r.redEdgeValues[u]?o.MATCH:r.blackEdgeValues[u]?o.INCOMPATIBLE:o.DORMANT}),t.isExit||(this.featureArray.push(new L(t)),this.featureMatchers.push((r,s)=>{const u=s.mapNonExitEdge(t).index;return r.blackEdgeValues[u]?o.MATCH:r.redEdgeValues[u]?o.INCOMPATIBLE:o.DORMANT}));for(const t of e.sectors)this.featureArray.push(new V(t)),this.featureMatchers.push((r,s)=>r.sectorNotZeroValues[s.mapSector(t).index]?o.MATCH:o.DORMANT),this.featureArray.push(new k(t)),this.featureMatchers.push((r,s)=>r.sectorNotOneValues[s.mapSector(t).index]?o.MATCH:o.DORMANT),this.featureArray.push(new z(t)),this.featureMatchers.push((r,s)=>r.sectorNotTwoValues[s.mapSector(t).index]?o.MATCH:o.DORMANT),this.featureArray.push(new R(t)),this.featureMatchers.push((r,s)=>r.sectorOnlyOneValues[s.mapSector(t).index]?o.MATCH:o.DORMANT);S()&&l(this.featureArray.length<=254,"Our limit for encoding in a byte")}}const b=new WeakMap,x=a=>{let e=b.get(a);return e||(e=new J(a),b.set(a,e)),e};class m{constructor(e,t,r,s=!1){this.patternBoard=e,this.inputFeatureSet=t,this.outputFeatureSet=r,this.highlander=s}getInputDifficultyScoreA(){return this.inputFeatureSet.getInputDifficultyScoreA()+.75*this.patternBoard.vertices.length}embedded(e,t){const r=this.inputFeatureSet.embedded(e,t);if(r===null)return null;const s=this.outputFeatureSet.embedded(e,t);return s===null?null:new m(e,r,s,this.highlander)}getEmbeddedRules(e){return e.map(t=>this.embedded(t.targetPatternBoard,t)).filter(t=>t!==null)}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.inputFeatureSet.hasSameShapeAs(e.inputFeatureSet)||!this.outputFeatureSet.hasSameShapeAs(e.outputFeatureSet))return!1;const t=W(this.patternBoard,this.patternBoard);for(const r of t){const s=this.embedded(this.patternBoard,r);if(s&&s.inputFeatureSet.equals(e.inputFeatureSet)&&s.outputFeatureSet.equals(e.outputFeatureSet))return!0}return!1}isSubsetOf(e){return this.inputFeatureSet.isSubsetOf(e.inputFeatureSet)&&this.outputFeatureSet.isSubsetOf(e.outputFeatureSet)}matches(e){return this.inputFeatureSet.isSubsetOf(e)}getMatchState(e){const t=this.inputFeatureSet.getQuickCompatibilityWith(e);return t===E.INCOMPATIBLE||t===E.NO_MATCH_NEEDS_FACE_VALUES?g.INCOMPATIBLE:this.outputFeatureSet.isSubsetOf(e)?g.INCONSEQUENTIAL:t===E.NO_MATCH_NEEDS_STATE?g.DORMANT:g.ACTIONABLE}isRedundant(e){if(this.isTrivial())return!0;const t=this.outputFeatureSet,r=e.filter(s=>s.outputFeatureSet.isSubsetOf(t));return this.outputFeatureSet.isSubsetOf(m.withRulesApplied(this.patternBoard,this.inputFeatureSet,r))}hasApplication(e){return this.matches(e)&&!this.outputFeatureSet.isSubsetOf(e)}apply(e){S()&&l(this.hasApplication(e)),e.applyFeaturesFrom(this.outputFeatureSet)}isTrivial(){return this.outputFeatureSet.isSubsetOf(this.inputFeatureSet)}isCorrectSlow(){const e=M.countSolutions(this.patternBoard,this.inputFeatureSet.getFeaturesArray()),t=M.countSolutions(this.patternBoard,this.outputFeatureSet.getFeaturesArray());return e===t}toCanonicalString(){return`rule:${this.inputFeatureSet.toCanonicalString()}->${this.outputFeatureSet.toCanonicalString()}`}equals(e){return this.patternBoard===e.patternBoard&&this.inputFeatureSet.equals(e.inputFeatureSet)&&this.outputFeatureSet.equals(e.outputFeatureSet)&&this.highlander===e.highlander}getBinary(e){const t=[],r=e.indexOf(this.patternBoard);S()&&l(r!==-1&&r<256,"pattern board index"),t.push(r);const s=x(this.patternBoard),u=this.inputFeatureSet.getFeaturesArray(),i=this.outputFeatureSet.getFeaturesArray().filter(n=>!u.some(f=>f.equals(n))),d=n=>{const f=n.filter(p=>!(p instanceof N)),A=n.filter(p=>p instanceof N);for(const p of f){const c=s.featureArray.findIndex(O=>O.equals(p));S()&&l(c!==-1,"feature index"),t.push(c)}for(const p of A){t.push(254);for(const c of p.primaryFaces)S()&&l(c.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),t.push(c.index);for(const c of p.secondaryFaces)S()&&l(c.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),t.push(c.index|128)}};if(d(u),t.push(255),d(i),t.push(255),S()){const n=new Uint8Array(t),{rule:f,nextByteIndex:A}=m.fromBinary(e,n,0,this.highlander);l(f.equals(this),"round-trip equality"),l(A===n.length,"round-trip length")}return t}static fromBinary(e,t,r,s){const u=t[r++],i=e[u];S()&&l(i,"pattern board");const d=x(i),n=()=>{const p=y.empty(i);for(;;){const c=t[r++];if(c===255)return p;if(c===254){const O=[],T=[];for(;;){const B=t[r++];if(B===255||B===254){r--;break}B&128?T.push(i.faces[B&127]):O.push(i.faces[B])}p.addFeature(N.fromPrimarySecondaryFaces(O,T))}else p.addFeature(d.featureArray[c])}},f=n(),A=n().union(f);return S()&&l(A),{rule:new m(i,f,A,s),nextByteIndex:r}}serialize(){const e={patternBoard:j(this.patternBoard),input:this.inputFeatureSet.serialize(),output:this.outputFeatureSet.serialize()};return this.highlander&&(e.highlander=!0),e}collectionSerialize(e){return{...this.serialize(),patternBoard:e}}static deserialize(e){const t=G(e.patternBoard);return new m(t,y.deserialize(e.input,t),y.deserialize(e.output,t),e.highlander??!1)}static collectionDeserialize(e,t){const r=e[t.patternBoard];return S()&&l(r,"pattern board"),new m(r,y.deserialize(t.input,r),y.deserialize(t.output,r),t.highlander??!1)}static withRulesApplied(e,t,r){S()&&l(r.every(n=>n.patternBoard===e),"embedding check");let s=r,u=[];const i=t.clone();let d=!0;for(;d;){d=!1;for(const n of s){const f=n.getMatchState(i);f===g.ACTIONABLE?(n.apply(i),d=!0):f===g.DORMANT&&u.push(n)}s=u,u=[]}return i}}export{m as P,G as d,j as s};
