var ft=Object.defineProperty;var gt=(a,e,t)=>e in a?ft(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var P=(a,e,t)=>(gt(a,typeof e!="symbol"?e+"":e,t),t);import{f as c,P as se,E as Xe,d as Ue,o as de,c as _e,D as mt,V as H,g as ge,C as wt,B as Pe,T as G}from"./Vector2Property-DCXaH-JP.js";import{e as B,B as $,D as R,F as ve,N as T,P as M,M as he,l as Ct,L as qe,C as ke,m as Je,T as Ze,G as St,R as yt,H as ze}from"./PhetioControlledVisibilityProperty-sdyDHryr.js";import{E as D,F as te,S as V,V as Pt,B as xe,C as vt}from"./BasicPuzzle-CWyNbg6B.js";import{a as Vt,b as Et,L as bt,R as Ft,P as $e}from"./TextPushButton-F5WNyFmI.js";import{c as Oe,S as F,L as Fe,_ as Te,G as Tt,a as k,b as x,j as Ge,i as Lt}from"./createBoardDescriptor-DQiPBFka.js";import{h as Nt,i as kt,j as Re,M as xt,k as Ae,l as Ot,m as Rt,v as Ie,n as At,q as Be,w as It,x as q,y as Bt,z as Mt,A as Dt,B as Ht,L as J,J as Wt,H as Yt,D as jt,F as Xt,c as j,N as Ut,O as me,u as _t,s as qt,r as Jt}from"./Theme-Bnv1SKXL.js";import{e as Ke,f as Qe,h as et,W as tt,X as ot,Y as rt,C as K,Z as Zt,Q as zt,R as $t,_ as st,$ as it,j as nt,a0 as we,a1 as at,i as Gt,a2 as Kt,F as Qt,c as pe,d as eo,I as X,a3 as to,a4 as oo,a5 as ro,a6 as so,a7 as io,a8 as no,a9 as ao,aa as lo,ab as co,ac as ho}from"./SATSolver-9Ujc5O8c.js";import{A as uo}from"./ShadedSphereNode-CfSdIz5V.js";import{F as po,B as fo,R as go,S as mo,a as wo,b as Co,c as So,d as yo}from"./FaceColorDualFeature-CyAHgR8K.js";import{c as Po}from"./computeEmbeddings-DgNcEsIq.js";import{B as vo}from"./getCoordinateClusteredMap-BFcIYRrL.js";const lt=(a,e,t,o)=>(r,s,u)=>{const i=[new Ke(r,s),new Qe(r,s)];return(a||e||t||o)&&(i.push(new et(r,s)),(e||t||o)&&(i.push(new tt(r,s)),(t||o)&&(i.push(new ot(r,s)),o&&i.push(new rt(r,s))))),new K(i)},Vo={edgesVisibleProperty:Nt,edgesHaveColorsProperty:kt,faceColorsVisibleProperty:Re,faceColorThresholdProperty:xt,sectorsVisibleProperty:Ae,sectorsNextToEdgesVisibleProperty:Ot,sectorsTrivialVisibleProperty:Rt,vertexStateVisibleProperty:Ie,allVertexStateVisibleProperty:At,faceStateVisibleProperty:Be,whiteLineVisibleProperty:It,redLineVisibleProperty:q,verticesVisibleProperty:Bt,smallVertexProperty:Mt,redXsVisibleProperty:Dt,redXsAlignedProperty:Ht,faceValueStyleProperty:J,redLineStyleProperty:Wt,vertexStyleProperty:Yt,joinedLinesJoinProperty:jt,joinedLinesCapProperty:Xt,safeSolverFactoryProperty:new B([Re,Ae,Ie,Be],(a,e,t,o)=>lt(a,e,t,o)),autoSolverFactoryProperty:Zt,theme:j},Q=(a,e,t,o,r)=>{const s=lt(a,e,t,o);return{faceColorsVisibleProperty:new $(a),sectorsVisibleProperty:new $(e),vertexStateVisibleProperty:new $(t),faceStateVisibleProperty:new $(o),safeSolverFactoryProperty:new se(s),autoSolverFactoryProperty:r?new B([r],u=>(i,d,h)=>new K([s(i,d,h),u(i,d,h)])):new se(s)}},ie=new B([zt,$t],(a,e)=>(t,o,r)=>new K([new st(t,o,{solveJointToRed:!0,solveForcedLineToBlack:a,solveAlmostEmptyToRed:!0},r?void 0:[]),new it(t,o,{solveToRed:!0,solveToBlack:a},r?void 0:[]),...e?[new nt(t,o,{solveToRed:!0,solveToBlack:a,resolveAllRegions:!1},r?void 0:[])]:[]])),Eo=new B([ie],a=>(e,t,o)=>new K([a(e,t,o),new we(e,t,{solveToRed:!0,solveToBlack:!0})])),ct=new B([ie],a=>(e,t,o)=>new K([a(e,t,o),new at(e,t,o?void 0:[])])),bo=new B([ct],a=>(e,t,o)=>new K([a(e,t,o),new we(e,t,{solveToRed:!0,solveToBlack:!0})])),dt={...Q(!0,!1,!1,!1,ie),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!0),faceColorThresholdProperty:new c(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},Fo={...Q(!0,!1,!1,!1,Eo),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(2),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},To={...Q(!0,!1,!1,!1,new se((a,e,t)=>new K([new we(a,e,{solveToRed:!0,solveToBlack:!0},t?void 0:[])]))),theme:j,edgesVisibleProperty:new c(!1),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(2),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!1),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},Lo={...Q(!1,!1,!1,!1,ie),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!1),redLineVisibleProperty:q,verticesVisibleProperty:new c(!0),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!0),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("square"),joinedLinesJoinProperty:new c("miter"),joinedLinesCapProperty:new c("square")},No={...Q(!0,!0,!1,!1,ct),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!0),faceColorThresholdProperty:new c(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},ko={...Q(!0,!0,!1,!1,bo),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(2),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},xo={...Q(!0,!1,!0,!1,ie),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(2),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},Oo={...Q(!0,!1,!1,!0,ie),theme:j,edgesVisibleProperty:new c(!0),edgesHaveColorsProperty:new c(!1),faceColorThresholdProperty:new c(2),sectorsNextToEdgesVisibleProperty:new c(!1),sectorsTrivialVisibleProperty:new c(!1),allVertexStateVisibleProperty:new c(!1),whiteLineVisibleProperty:new c(!0),redLineVisibleProperty:q,verticesVisibleProperty:new c(!1),smallVertexProperty:new c(!1),redXsVisibleProperty:new c(!1),redXsAlignedProperty:new c(!1),faceValueStyleProperty:J,redLineStyleProperty:new c("middle"),vertexStyleProperty:new c("round"),joinedLinesJoinProperty:new c("round"),joinedLinesCapProperty:new c("round")},Ve={basicLines:dt,basicFaceColoring:Fo,pureFaceColor:To,classic:Lo,basicSectors:No,sectorsWithColors:ko,vertexState:xo,faceState:Oo,custom:Vo},Me=dt,Ro=a=>({edgesVisibleProperty:new R(a,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new R(a,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new R(a,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new R(a,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new R(a,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new R(a,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new R(a,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new R(a,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new R(a,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new R(a,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new R(a,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new R(a,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new R(a,{derive:"verticesVisibleProperty"}),smallVertexProperty:new R(a,{derive:"smallVertexProperty"}),redXsVisibleProperty:new R(a,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new R(a,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new R(a,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new R(a,{derive:"redLineStyleProperty"}),vertexStyleProperty:new R(a,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new R(a,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new R(a,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new R(a,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new R(a,{derive:"autoSolverFactoryProperty"}),theme:Ut(new B([a],e=>e.theme))}),Ao=new Vt("puzzleStyle",{serialize:a=>Object.keys(Ve).find(e=>Ve[e]===a),deserialize:a=>a?Ve[a]??Me:Me}),_=Ro(Ao),Vr=new Et("showPuzzleStyleProperty",!1),A=class A extends Xe{constructor(e){super(),this.isEnabledProperty=e}};P(A,"EDGE_STATE",new A(new $(!0))),P(A,"EDGE_STATE_REVERSED",new A(new $(!0))),P(A,"FACE_COLOR_MATCH",new A(_.faceColorsVisibleProperty)),P(A,"FACE_COLOR_OPPOSITE",new A(_.faceColorsVisibleProperty)),P(A,"SECTOR_STATE",new A(_.sectorsVisibleProperty)),P(A,"VERTEX_STATE",new A(_.vertexStateVisibleProperty)),P(A,"FACE_STATE",new A(_.faceStateVisibleProperty)),P(A,"FACE_VALUE",new A(new $(!1))),P(A,"DELETE_FACE",new A(new $(!1))),P(A,"enumeration",new Ue(A));let W=A;const ee=new bt("editModeProperty",W.EDGE_STATE);let Ee=null;const De=a=>{a||(ee.value=W.EDGE_STATE)};ee.link(a=>{Ee&&Ee.isEnabledProperty.unlink(De),Ee=a,a.isEnabledProperty.link(De)});const Er=a=>{a.isEnabledProperty.value&&(ee.value=a)},Io=new B([ee],a=>a===W.EDGE_STATE||a===W.EDGE_STATE_REVERSED),ht=new B([ee],a=>a===W.FACE_COLOR_MATCH||a===W.FACE_COLOR_OPPOSITE),Bo=new B([ee],a=>a===W.SECTOR_STATE),Mo=new B([ee],a=>a===W.VERTEX_STATE),Do=new B([ee,ht],(a,e)=>e||a===W.FACE_STATE||a===W.FACE_VALUE||a===W.DELETE_FACE),Ce=(a,e,t,o)=>{const r=new ve({mouseButton:0,fire:i=>{var d;return t&&t(a,(d=i.domEvent)!=null&&d.shiftKey?2:0)}}),s=new ve({mouseButton:2,fire:i=>{var d;return t&&t(a,(d=i.domEvent)!=null&&d.shiftKey?0:2)}}),u=new ve({mouseButton:1,fire:i=>t&&t(a,1)});e.addInputListener(r),e.addInputListener(s),e.addInputListener(u),e.cursor="pointer",r.isHighlightedProperty.lazyLink(i=>{o&&o(a,i)}),e.disposeEmitter.addListener(()=>{r.dispose(),s.dispose(),u.dispose()})};class Se extends T{constructor(e,t,o,r){const s=de()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},r);super({pickableProperty:ht}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!s.noninteractive&&Ce(null,this,s.facePressListener,s.faceHoverListener);const u=e.map(w=>w.start.viewCoordinates),i=s.useBackgroundOffsetStroke,d=s.backgroundOffsetDistance,n=Oe(u)>0?-d:d,l=w=>{const p=new Tt;p.addShape(0,w),p.computeSimplifiedFaces(),p.computeFaceInclusion(v=>v[0]>0);const S=p.createFilledSubGraph(),C=S.facesToShape();return p.dispose(),S.dispose(),C},m=Se.getOffsetBackgroundShape(e,i,d),f=t.map(w=>{const p=w.map(C=>C.start.viewCoordinates),S=F.polygon(p);if(i)return l(S.getOffsetShape(n));{const v=S.getStrokedShape(new Fe({lineWidth:2*d})).subpaths.map(g=>new F([g]));return l(Te.minBy(v,g=>g.getArea()))}});this.children=[new M(m,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...f.map(w=>new M(w,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const r=e.map(d=>d.start.viewCoordinates),s=F.polygon(r),i=Oe(r)>0?-o:o;if(t)return s.getOffsetShape(i).getSimplifiedAreaShape();{const d=s.getStrokedShape(new Fe({lineWidth:2*o})),h=d.subpaths.map(n=>new F([n]));try{return d.bounds.width===9.718028227819117?F.bounds(d.bounds):Te.maxBy(h,n=>n.getArea()).getSimplifiedAreaShape()}catch{return F.bounds(d.bounds)}}}}const ne=.03,ae=.05,Ho=F.circle(ne).makeImmutable(),Wo=F.circle(ae).makeImmutable(),Yo=F.rect(-ne,-ne,2*ne,2*ne).makeImmutable(),jo=F.rect(-ae,-ae,2*ae,2*ae).makeImmutable();class Xo extends T{constructor(e,t,o,r){super(),this.vertex=e;const s=new B([t,r.verticesVisibleProperty],(h,n)=>n&&e.edges.every(l=>h.getEdgeState(l)!==D.BLACK));this.disposeEmitter.addListener(()=>s.dispose());const u=new M(null,{translation:e.viewCoordinates,fill:r.theme.vertexColorProperty,visibleProperty:s});this.addChild(u);const i=he.multilink([r.vertexStyleProperty,r.smallVertexProperty],(h,n)=>{h==="round"?u.shape=n?Ho:Wo:h==="square"?u.shape=n?Yo:jo:k()&&x(!1,`unhandled vertex style: ${h}`)});this.disposeEmitter.addListener(()=>i.dispose());const d=h=>{this.visible=!h};o.link(d),this.disposeEmitter.addListener(()=>o.unlink(d))}}class Uo extends T{constructor(e,t,o,r){const s=de()({textOptions:{font:me,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},r);super({}),this.face=e;const u=F.polygon(e.vertices.map(h=>h.viewCoordinates));this.mouseArea=u,this.touchArea=u,!s.noninteractive&&Ce(e,this,s.facePressListener,s.faceHoverListener);const i=new Ct("",_e({subScale:.7},s==null?void 0:s.textOptions)),d=he.multilink([t,o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty],(h,n,l,m,f,w,p)=>{const S=h.getFaceValue(e);this.visible=!p;let C,v,g=!1,y=!1;if(S===null)C="",v=null;else{let L=0,b=0;for(const O of e.edges){const N=h.getEdgeState(O);N===D.BLACK?L++:N===D.WHITE&&b++}if(n==="static"||S===0)C=`${S}`;else if(n==="remaining")C=`${S-L}`,g=L>0;else if(n==="ratio")S-L===0?C="0":(C=`${S-L}<sub style="color: ${w.toCSS()};">/<sub>${b}</sub></sub>`,y=!0),g=L>0;else throw new Error(`unhandled faceValueStyle: ${n}`);L<S?v=l:L===S?v=m:v=f}i.string=C,i.fill=v,i.maxWidth=y?.8:.9,i.maxHeight=y?.8:.9,i.center=e.viewCoordinates,this.children=[i]});this.disposeEmitter.addListener(()=>d.dispose())}}const z=.07,_o=new F().moveTo(-z,-z).lineTo(z,z).moveTo(-z,z).lineTo(z,-z).makeImmutable();class qo extends T{constructor(e,t,o,r,s){super({}),this.edge=e;const u=new B([t],g=>g.getEdgeState(e));this.disposeEmitter.addListener(()=>u.dispose());const i=e.start.viewCoordinates,d=e.end.viewCoordinates,h=i.average(d),n=new B([o,r.redXsVisibleProperty],(g,y)=>!g&&y);this.disposeEmitter.addListener(()=>n.dispose());const l=new M(_o,{stroke:r.theme.xColorProperty,lineWidth:.025,center:h,visibleProperty:n}),m=g=>{l.rotation=g?d.minus(i).getAngle():0};r.redXsAlignedProperty.link(m),this.disposeEmitter.addListener(()=>r.redXsAlignedProperty.unlink(m));const f=new B([o,r.whiteLineVisibleProperty],(g,y)=>!g&&y);this.disposeEmitter.addListener(()=>f.dispose());const w=new qe(i.x,i.y,d.x,d.y,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty,visibleProperty:f}),p=new B([o,r.redLineVisibleProperty],(g,y)=>y);this.disposeEmitter.addListener(()=>p.dispose());const S=new M(null,{lineWidth:.02,stroke:r.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:p}),C=g=>{g==="middle"?S.shape=new F().moveToPoint(h.blend(i,.35)).lineToPoint(h.blend(d,.35)).makeImmutable():g==="gap"?S.shape=new F().moveToPoint(i).lineToPoint(i.blend(h,.35)).moveToPoint(d.blend(h,.35)).lineToPoint(d).makeImmutable():g==="full"?S.shape=new F().moveToPoint(i).lineToPoint(d).makeImmutable():k()&&x(!1,`Unknown red line style: ${g}`)};r.redLineStyleProperty.link(C),this.disposeEmitter.addListener(()=>r.redLineStyleProperty.unlink(C));const v=s==null?void 0:s.edgePressListener;if(v){const g=new F;if(e.faces.length===2)g.polygon([i,e.faces[0].viewCoordinates,d,e.faces[1].viewCoordinates]);else{k()&&x(e.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const y=e.forwardHalf.face===null?e.forwardHalf:e.reversedHalf;k()&&x(y.previous.face===null),k()&&x(y.next.face===null);const L=y.start.viewCoordinates,b=y.end.viewCoordinates,O=y.previous.start.viewCoordinates,N=y.next.end.viewCoordinates,E=(Le,ue,ut)=>{const Ne=ue.minus(Le).normalized(),pt=ut.minus(ue).normalized();let Z=Ne.minus(pt);return Z.getMagnitude()<1e-6?Z=Ne.getPerpendicular():Z=Z.normalized(),mt.triangleAreaSigned(Le,ue,ue.plus(Z))<0&&(Z=Z.negated()),Z},I=E(O,L,b),ye=E(L,b,N);g.polygon([L,e.faces[0].viewCoordinates,b,b.plus(ye.times(s.backgroundOffsetDistance)),L.plus(I.times(s.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=g,!s.noninteractive&&Ce(e,this,v,s.edgeHoverListener)}u.link(g=>{g===D.WHITE?this.children=[w]:g===D.BLACK?this.children=[]:this.children=[S,l]})}}class Jo extends T{constructor(t,o,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});P(this,"simpleRegionNodeMap",new Map);P(this,"regionIdMap",new Map);P(this,"weirdEdgeNodeMap",new Map);P(this,"regionContainer",new T);P(this,"weirdEdgeContainer",new T);P(this,"adjacentFacesMap",new Map);this.board=t,this.style=r,t.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(d=>d.getOtherFace(i)).filter(d=>d!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(i=>this.addRegion(i)),o.value.getWeirdEdges().forEach(i=>this.addWeirdEdge(i)),this.updateHues();const s=(i,d)=>{const h=d.getSimpleRegions(),n=i.getSimpleRegions(),l=d.getWeirdEdges(),m=i.getWeirdEdges(),f=[],w=[];Ge(h,n,f,w,[]);const S=new Set(f);for(const C of w)if(this.regionIdMap.has(C.id)){const v=this.regionIdMap.get(C.id);this.replaceRegion(v,C),S.delete(v)}else this.addRegion(C);for(const C of S)this.removeRegion(C);for(const C of l)m.includes(C)||this.removeWeirdEdge(C);for(const C of m)l.includes(C)||this.addWeirdEdge(C);(w.length||f.length)&&this.updateHues()};o.lazyLink(s),this.disposeEmitter.addListener(()=>o.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const u=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(u),r.edgesHaveColorsProperty.lazyLink(u),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(u),r.edgesHaveColorsProperty.unlink(u)})}addRegion(t){const o=new re(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){k()&&x(t.id===o.id);const r=this.simpleRegionNodeMap.get(t);r.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=new qe(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(t,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(t){const o=this.weirdEdgeNodeMap.get(t);this.weirdEdgeContainer.removeChild(o),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new H(0,0),r=()=>{for(const n of t)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},s=new Map,u=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of t){const l=new Set;for(const f of n.simpleRegion.edges)for(const w of f.faces)l.add(w);const m=new Set;for(const f of l){m.add(f);for(const w of this.adjacentFacesMap.get(f))m.add(w)}for(const f of m){const w=s.get(f);if(w.length)for(const p of w){let S=!1;for(const C of u)if(C.a===p&&C.b===n){C.weight++,S=!0;break}S||u.push({a:p,b:n,weight:1})}w.push(n)}}const i=new Map;for(const n of t)i.set(n,H.ZERO.copy());const d=(n,l,m)=>{const f=i.get(n),w=i.get(l),p=n.hueVector.dot(l.hueVector),S=o.set(l.hueVector).subtract(n.hueVector);if(S.magnitude>1e-9){S.normalize();const C=.3,v=m*((Math.max(C,p)-C)/(1-C))**3;S.multiplyScalar(v),f.subtract(S),w.add(S)}};let h=1;for(let n=0;n<100;n++){h*=.99;for(const l of t)i.get(l).setXY(0,0);for(const l of u){const m=l.a,f=l.b,w=l.weight;d(m,f,w)}if(t.length<8)for(let l=0;l<t.length;l++){const m=t[l];for(let f=l+1;f<t.length;f++)d(m,t[f],.2)}for(const l of t){const m=i.get(l);m.multiplyScalar(h/l.edgeCount),l.hueVector.add(m),i.get(l).setXY(0,0)}r()}for(const n of t)n.updateHue()}}class re extends M{constructor(t,o){const r=H.createPolar(1,ge.nextDoubleBetween(0,2*Math.PI));super(re.toShape(t),{stroke:re.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});P(this,"hueVector");P(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=r,this.edgeCount=t.edges.length;const s=i=>{this.lineJoin=i};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const u=i=>{this.lineCap=i};o.joinedLinesCapProperty.link(u),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(u))}updateHue(){this.stroke=re.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:H.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=re.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return k()&&x(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(t){const o=new F;let r=!0;for(const s of t.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class Zo extends T{constructor(t,o,r){const s=new T;super({pickable:!1,children:[s]});P(this,"faceColorNodeMap",new Map);P(this,"faceColorIdMap",new Map);P(this,"adjacentFacesMap",new Map);P(this,"faceColorNodeContainer");P(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.style=r,this.faceColorNodeContainer=s,t.faces.forEach(h=>{this.adjacentFacesMap.set(h,h.edges.map(n=>n.getOtherFace(h)).filter(n=>n!==null))});{const h=o.value.getFaceColors();for(const n of h)this.addFaceColor(n,o.value.getFacesWithColor(n));this.addDualColorViews(o.value,h)}this.updateHues();let u=o.value.clone();const i=h=>{const n=u;u=h.clone();const l=n.getFaceColors(),m=h.getFaceColors(),f=[],w=[],p=[];Ge(l,m,f,w,p);const S=new Set(f),C=this.removeInvalidDualColorViews(h),v=[...C];for(const g of w)if(C.add(g),this.faceColorIdMap.has(g.id)){const y=this.faceColorIdMap.get(g.id);this.replaceFaceColor(y,g,h.getFacesWithColor(g)),S.delete(y)}else this.addFaceColor(g,h.getFacesWithColor(g));for(const g of p)this.updateFaceColor(g,h.getFacesWithColor(g));for(const g of S)C.delete(g),this.removeFaceColor(g);this.addDualColorViews(h,[...C]),(w.length||f.length||v.length)&&this.updateHues()};o.lazyLink(i),this.disposeEmitter.addListener(()=>o.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const d=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(d),r.theme.faceColorLightHueLUTProperty.lazyLink(d),r.theme.faceColorDarkHueLUTProperty.lazyLink(d),r.theme.faceColorInsideColorProperty.lazyLink(d),r.theme.faceColorOutsideColorProperty.lazyLink(d),r.theme.faceColorDefaultColorProperty.lazyLink(d),r.faceColorThresholdProperty.lazyLink(d),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(d),r.theme.faceColorLightHueLUTProperty.unlink(d),r.theme.faceColorDarkHueLUTProperty.unlink(d),r.theme.faceColorInsideColorProperty.unlink(d),r.theme.faceColorOutsideColorProperty.unlink(d),r.theme.faceColorDefaultColorProperty.unlink(d),r.faceColorThresholdProperty.unlink(d)})}addFaceColor(t,o){const r=new le(t,o,this.style);this.faceColorNodeMap.set(t,r),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(t,o,r){k()&&x(t.id===o.id);const s=this.faceColorNodeMap.get(t);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const r=this.faceColorNodeMap.get(t);let s=r.faces.length!==o.length;if(!s)for(let u=0;u<o.length;u++){const i=r.faces[u],d=o[u];if(i!==d){s=!0;break}}s&&r.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const u=this.faceColorNodeMap.get(s);k()&&x(u);const i=t.getOppositeFaceColor(s);if(i){k()&&x(r.has(i)),r.delete(i);const d=this.faceColorNodeMap.get(i);k()&&x(d),this.dualColorViews.add(new He([u,d],this.style))}else this.dualColorViews.add(new He([u],this.style))}}removeInvalidDualColorViews(t){const o=new Set,r=new Set(t.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const u of s.colorNodes)o.add(u.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==te.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new H(0,0),r=()=>{for(const n of t)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(ge.nextDouble()-.5,ge.nextDouble()-.5).normalize()},s=new Map,u=[];this.board.faces.forEach(n=>{s.set(n,[])});for(const n of t){const l=new Set;for(const f of n.faces)l.add(f);const m=new Set;for(const f of l){m.add(f);for(const w of this.adjacentFacesMap.get(f))m.add(w)}for(const f of m){const w=s.get(f);if(w){if(w.length)for(const p of w){let S=!1;for(const C of u)if(C.a===p&&C.b===n){C.weight++,S=!0;break}S||u.push({a:p,b:n,weight:1})}w.push(n)}}}const i=new Map;for(const n of t)i.set(n,H.ZERO.copy());const d=(n,l,m)=>{const f=i.get(n),w=i.get(l),p=n.hueVector.dot(l.hueVector),S=o.set(l.hueVector).subtract(n.hueVector).normalize(),C=.2,v=Math.abs(p),g=m*((Math.max(C,v)-C)/(1-C))**3;S.multiplyScalar(g),f.subtract(S),w.add(S)};let h=1;for(let n=0;n<100;n++){h*=.99;for(const l of t)i.get(l).setXY(0,0);for(const l of u){const m=l.a,f=l.b,w=l.weight;d(m,f,w)}if(t.length<8)for(let l=0;l<t.length;l++){const m=t[l];for(let f=l+1;f<t.length;f++)d(m,t[f],.2)}for(const l of t){const m=i.get(l);m.multiplyScalar(h/l.faceCount),l.hueVector.add(m),i.get(l).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const U=class U extends Xe{};P(U,"BASIC",new U),P(U,"PRIMARY",new U),P(U,"SECONDARY",new U),P(U,"enumeration",new Ue(U));let Y=U;class He{constructor(e,t){P(this,"hueVector");P(this,"faceCount");if(this.colorNodes=e,this.style=t,k()&&x(e.length===1||e.length===2),this.faceCount=Te.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=Y.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],r=o===e[0]?e[1]:e[0];let s;o.type===Y.PRIMARY?s=o:r.type===Y.PRIMARY||o.type===Y.SECONDARY?s=r:(r.type,Y.SECONDARY,s=o);const u=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=Y.PRIMARY,u.type=Y.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class le extends M{constructor(t,o,r){const s=H.createPolar(1,ge.nextDoubleBetween(0,2*Math.PI));super(le.toShape(o));P(this,"hueVector");P(this,"faceCount");P(this,"dualColorView",null);P(this,"type",Y.BASIC);this.faceColor=t,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==te.UNDECIDED?this.fill=le.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:H.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const r=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=le.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(t,o,r,s){const u=r===Y.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===Y.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,i=(Math.round(t.getAngle()*180/Math.PI)+360)%360;k()&&x(i>=0&&i<u.length);const d=u[i];if(o===te.UNDECIDED)return d;{const n=(o===te.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,l=n.alpha,m=new ke(d);return new ke((1-l)*m.red+l*n.red,(1-l)*m.green+l*n.green,(1-l)*m.blue+l*n.blue).toCSS()}}static toShape(t){const o=new F;for(const r of t)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}const We=[.02,.02],zo=new Map([[V.NONE,[]],[V.ONLY_ZERO,[]],[V.ONLY_ONE,[]],[V.ONLY_TWO,[]],[V.NOT_ZERO,We],[V.NOT_ONE,[]],[V.NOT_TWO,We],[V.ANY,[]]]),be=.2,Ye=.02,ce=class ce extends T{constructor(e,t,o,r){super(),this.sector=e;const s=ce.getSectorBaseShape(e,r.backgroundOffsetDistance);this.mouseArea=s,this.touchArea=s,!r.noninteractive&&Ce(e,this,r.sectorPressListener,r.sectorHoverListener);const u=h=>{const n=e.start.viewCoordinates,l=e.end.viewCoordinates,m=e.next.end.viewCoordinates,f=n.minus(l),w=m.minus(l),p=f.normalized(),S=w.normalized(),C=S.minus(p).angle+Math.PI/2,v=f.angle;let g=w.angle;g<v&&(g+=2*Math.PI);const y=H.createPolar(.2,C),L=(O,N)=>(O.moveToPoint(p.timesScalar(N)),O.arcPoint(H.ZERO,N,v,g,!0),O),b=(O,N,E)=>(O.moveTo(N.x+E,N.y),O.circle(N,E),O);if(h===V.NONE)return new F().moveTo(y.x-.05,y.y-.05).lineTo(y.x+.05,y.y+.05).moveTo(y.x-.05,y.y+.05).lineTo(y.x+.05,y.y-.05).makeImmutable();if(h===V.ONLY_ZERO)return b(new F,y,.05).makeImmutable();if(h===V.ONLY_TWO)return new F().moveToPoint(p.timesScalar(.1).plus(y.timesScalar(.7))).lineToPoint(y.timesScalar(.7)).lineToPoint(S.timesScalar(.1).plus(y.timesScalar(.7))).makeImmutable();if(h===V.ONLY_ONE||h===V.NOT_TWO)return L(new F,be).makeImmutable();if(h===V.NOT_ZERO||h===V.NOT_ONE)return L(L(new F,be+Ye),be-Ye).makeImmutable();if(h===V.ANY)return b(b(b(new F,y,.05),y,.03),y,.01).makeImmutable();throw new Error("Unhandled sector state")},i=new M(null,{translation:e.end.viewCoordinates,lineWidth:.01,lineCap:"butt",visibleProperty:o.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>i.dispose()),this.addChild(i);const d=he.multilink([t,o.sectorsNextToEdgesVisibleProperty,o.sectorsTrivialVisibleProperty],(h,n,l)=>{const m=h.getEdgeState(e.edge),f=h.getEdgeState(e.next.edge),w=h.getSectorState(e);let p=null,S=null,C=[],v=.01;if(n||m===D.WHITE&&f===D.WHITE){let g=V.trivialStates.includes(w);if(w===V.NOT_ONE){const y=e.end.edges.filter(b=>h.getEdgeState(b)===D.BLACK),L=e.end.edges.filter(b=>h.getEdgeState(b)===D.WHITE);y.length===0&&L.length===2&&(g=!0)}(l||!g)&&(p=u(w)??null,S=ce.getStrokeFromStyle(w,o)??null,C=zo.get(w)??[],C.length&&(v=.015))}i.shape=p,i.stroke=S,i.lineDash=C,i.lineWidth=v});this.disposeEmitter.addListener(()=>d.dispose())}static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,u=o.minus(r),i=s.minus(r),d=u.normalized(),n=i.normalized().minus(d).angle+Math.PI/2,l=e.face?e.face.viewCoordinates:H.createPolar(t,n).plus(r),m=o.average(r),f=s.average(r);return F.polygon([m,r,f,l]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,u=o.minus(r),i=s.minus(r),d=u.normalized(),h=u.angle;let n=i.angle;return n<h&&(n+=2*Math.PI),new F().moveToPoint(r).lineToPoint(d.timesScalar(t).plus(r)).arcPoint(r,t,h,n,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===V.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===V.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===V.NOT_ONE?t.theme.sectorNotOneColorProperty:e===V.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}};P(ce,"nameMap",new Map([[V.NONE,"Invalid"],[V.ONLY_ZERO,"No Lines"],[V.ONLY_ONE,"Only One Line"],[V.ONLY_TWO,"Both Lines"],[V.NOT_ZERO,"At Least One Line"],[V.NOT_ONE,"Zero or Two Lines"],[V.NOT_TWO,"Less Than Two Lines"],[V.ANY,"Any Lines"]]));let oe=ce;class $o extends T{constructor(e,t,o,r){super({pickable:!1}),this.vertex=e;const s=.12,i=e.edges.map(p=>p.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(p=>p.times(s)),h=F.polygon(wt.grahamScan([H.ZERO,...i],!1)).getOffsetShape(-.05),n=new M(null,{stroke:r.theme.vertexStateLineProperty,lineWidth:.01}),l=new M(h,{translation:e.viewCoordinates,fill:r.theme.vertexStateBackgroundProperty,stroke:r.theme.vertexStateOutlineProperty,lineWidth:.01,children:[n,...i.map(p=>new Je({radius:.02,translation:p,fill:r.theme.vertexStatePointProperty}))]});let m=null;const f=he.multilink([t,r.vertexStateVisibleProperty,r.allVertexStateVisibleProperty],(p,S,C)=>{const v=()=>{this.children=[]};if(!S){v();return}const g=p.getVertexState(e);if(!C){let y=!1,L=!1;const b=new Set;for(const N of e.edges){const E=p.getEdgeState(N);y=y||E===D.BLACK,L=L||E===D.WHITE,E===D.WHITE&&b.add(N)}if(y||!L){v();return}if(Pt.fromLookup(e,(N,E)=>b.has(N)&&b.has(E),!0).equals(g)){v();return}}if(!m||!m.equals(g)){m=g;const y=new F;for(const L of g.getAllowedPairs()){const b=O=>O.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(s);y.moveToPoint(b(L[0])),y.lineToPoint(b(L[1]))}g.allowsEmpty()&&(y.moveTo(.03,0),y.circle(H.ZERO,.03),y.close()),y.makeImmutable(),n.shape=y}this.children=[l]});this.disposeEmitter.addListener(()=>f.dispose());const w=p=>{this.visible=!p};o.link(w),this.disposeEmitter.addListener(()=>o.unlink(w))}}class Go extends Ze{constructor(e,t){const o=de()({font:_t,fill:j.uiForegroundColorProperty},t);super(e,o)}}class Ko extends T{constructor(e,t,o,r){super({translation:e.viewCoordinates}),this.face=e;const s=he.multilink([t,r.faceStateVisibleProperty],(i,d)=>{if(this.children=[],d){const h=i.getFaceState(e),n=h.possibilityCount===0||h.possibilityCount>9;let l;const m=h.possibilityCount===1?r.theme.faceValueCompletedColorProperty:r.theme.faceValueColorProperty;if(n)l=new Go(h.possibilityCount,{font:me,maxWidth:.4,maxHeight:.4});else{const f=new Set(e.vertices);l=new St({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(h.possibilityCount)),children:h.getAllowedCombinations().map(w=>{const p=new T,S=new Set(w.map(g=>g.start)),C=new Set(w.map(g=>g.end)),v=g=>g.minus(e.viewCoordinates);if(p.addChild(new M(F.polygon(e.vertices.map(g=>v(g.viewCoordinates))),{stroke:m,lineWidth:.03,opacity:.2})),S.size){const g=new F;if(w.length===e.edges.length)g.polygon(e.vertices.map(y=>v(y.viewCoordinates)));else{const y=new Set(w);for(;y.size;){const L=[...f].find(N=>[...y].filter(E=>E.start===N||E.end===N).length===1);k()&&x(L);let b=L,O=[...y].find(N=>N.start===b||N.end===b)??null;for(g.moveToPoint(v(b.viewCoordinates));O;)y.delete(O),b=O.getOtherVertex(b),g.lineToPoint(v(b.viewCoordinates)),O=[...y].find(N=>N.start===b||N.end===b)??null}}p.addChild(new M(g,{stroke:m,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const g of e.vertices)!S.has(g)&&!C.has(g)&&p.addChild(new Je(.1,{fill:m,translation:v(g.viewCoordinates)}));return p}),maxWidth:.6,maxHeight:.6})}l.center=H.ZERO,this.addChild(l)}});this.disposeEmitter.addListener(()=>s.dispose());const u=i=>{this.visible=!i};o.link(u),this.disposeEmitter.addListener(()=>o.unlink(u))}}const Qo=new Fe({lineWidth:.2,lineCap:"round",lineJoin:"round"});class er extends T{constructor(e,t,o){let r;if(qt.value)if(e.type==="edge-state"){const s=new F().moveToPoint(e.edge.start.viewCoordinates).lineToPoint(e.edge.end.viewCoordinates);r=[new M(s.getStrokedShape(Qo),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(e.type==="face-color")if(e.face){const s=F.polygon(e.face.vertices.map(i=>i.viewCoordinates));r=[new M(s.getOffsetShape(-.1),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else if(e.type==="sector"){const s=oe.getSectorArcShape(e.sector,.5);r=[new M(s.getOffsetShape(.05),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else r=[];super({children:r}),this.hoverHighlight=e}}class tr extends T{constructor(e,t,o,r){let s=[];try{let u=new F;for(const d of e.faces)u.polygon(d.vertices.map(h=>h.viewCoordinates));if(e.faceColor.colorState===te.OUTSIDE)try{const d=F.polygon(t.outerBoundary.map(l=>l.start.viewCoordinates)),n=Se.getOffsetBackgroundShape(t.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(d);u=u.shapeUnion(n)}catch(d){console.error(d)}const i=new M(u.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(i)}catch(u){console.error(u)}super({children:s}),this.selectedFaceColorHighlight=e}}class or extends T{constructor(e,t,o,r){const s=[],u=[],i=e.sector,d=e.currentState,h=oe.getSectorArcShape(i,.5),n=new M(h.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(n);const l=[];if(d===V.ANY&&(l.push(V.NOT_ZERO),l.push(V.NOT_ONE),l.push(V.NOT_TWO)),d.one&&d!==V.ONLY_ONE&&l.push(V.ONLY_ONE),l.length){const m=l.map(p=>{const S=oe.getStrokeFromStyle(p,o);return new Ft({accessibleName:oe.nameMap.get(p),content:new yt(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(i,p)},buttonAppearanceStrategy:Jt,baseColor:S,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});u.push(...m);const f=new $e(new ze({children:m,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});u.push(f);const w=.1;s.push(f),f.centerBottom=n.centerTop.plusXY(0,-.15),f.top<t.top+w&&(f.centerTop=n.centerBottom.plusXY(0,.15)),f.left<t.left+w&&(f.left=t.left+w),f.right>t.right-w&&(f.right=t.right-w)}super({children:s}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{u.forEach(m=>m.dispose())})}}class je extends T{constructor(t,o){const r=de()({textOptions:{font:me,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new se(null),selectedFaceColorHighlightProperty:new se(null),selectedSectorEditProperty:new se(null),style:_,noninteractive:!1},o),s=r.style,u=new T({visibleProperty:s.faceColorsVisibleProperty}),i=new T({pickableProperty:Do}),d=new T({pickableProperty:Bo}),h=new T({pickableProperty:Io}),n=new T({pickableProperty:Mo}),l=new T,m=new T({pickable:!1}),f=new T({pickable:!1}),w=new T({pickable:!1}),p=new T({pickable:!1}),S=new T({pickable:!1}),C=new T,v=new B([t.stateProperty],E=>{if(E.getWeirdEdges().length||E.hasInvalidFaceColors())return!1;const I=E.getSimpleRegions();return I.length===1&&I[0].isSolved});u.addChild(new Zo(t.board,t.stateProperty,s)),t.board.faces.forEach(E=>{i.addChild(new Uo(E,t.stateProperty,s,r)),f.addChild(new Ko(E,t.stateProperty,v,s))});const g=new Se(t.board.outerBoundary,t.board.innerBoundaries,s,r),y=E=>{E?t.board.vertices.forEach(I=>{n.addChild(new Xo(I,t.stateProperty,v,s))}):n.children.forEach(I=>I.dispose())};s.verticesVisibleProperty.link(y);const L=E=>{E?t.board.vertices.forEach(I=>{m.addChild(new $o(I,t.stateProperty,v,s))}):m.children.forEach(I=>I.dispose())};s.vertexStateVisibleProperty.link(L),t.board.edges.forEach(E=>{h.addChild(new qo(E,t.stateProperty,v,s,r))}),t.board.halfEdges.forEach(E=>{d.addChild(new oe(E,t.stateProperty,s,r))}),l.addChild(new Jo(t.board,t.stateProperty,s));super(_e({children:[g,u,i,d,h,n,l,m,f,w,p,S,C]},r));P(this,"annotationContainer");P(this,"backgroundNode");this.puzzle=t,this.annotationContainer=w;const b=E=>{S.children.forEach(I=>I.dispose()),E&&S.addChild(new er(E,r.backgroundOffsetDistance,s))};r.hoverHighlightProperty.link(b),this.disposeEmitter.addListener(()=>r.hoverHighlightProperty.unlink(b));const O=E=>{p.children.forEach(I=>I.dispose()),E&&p.addChild(new tr(E,t.board,s,r))};r.selectedFaceColorHighlightProperty.link(O),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(O));const N=E=>{C.children.forEach(I=>I.dispose()),E&&C.addChild(new or(E,g,s,r))};r.selectedSectorEditProperty.link(N),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(N)),this.disposeEmitter.addListener(()=>{s.verticesVisibleProperty.unlink(y),s.vertexStateVisibleProperty.unlink(L),[u,i,h,n,l,m,f,d].forEach(I=>{I.children.forEach(ye=>ye.dispose()),I.dispose()}),v.dispose(),g.dispose()}),this.backgroundNode=g}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class br extends T{constructor(e,t,o){const r=de()({style:_},o),s=t.getEmbeddedCompleteData(e.inputFeatureSet),u=t.getEmbeddedCompleteData(e.outputFeatureSet),i=new je(new xe(t.smallBoard,s),{noninteractive:!0,style:r.style}),d=new je(new xe(t.smallBoard,u),{noninteractive:!0,style:r.style}),h=e.highlander?new T({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(C=>new Ze("?",{font:me,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?_.theme.faceValueColorProperty:_.theme.faceValueCompletedColorProperty,center:C.viewCoordinates}))}):new T,l=t.tightBounds.dilated(.5),m=.5,f=F.roundRectangle(l.x,l.y,l.width,l.height,m,m),w=new T({children:[i,h],clipArea:f,localBounds:l}),p=new T({children:[d,h],clipArea:f,localBounds:l}),S=new $e(new ze({spacing:.2,children:[w,new uo(0,0,20,0,{fill:j.uiForegroundColorProperty,stroke:j.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),p]}),{cornerRadius:m*1.2,xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:_.theme.patternAnnotationBackgroundColorProperty});r.children=[S],super(r),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{i.dispose(),d.dispose()})}}const rr=(a,e)=>{Gt(Kt,a,e,!0)};class fe{constructor(e,t,o,r,s,u,i,d,h,n){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=u,this.toSmallEdgeMap=i,this.toSmallSectorMap=d,this.tightBounds=h,this.expandedBounds=n}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const r=this.toSmallFaceMap.get(o);return k()&&x(r),r}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return k()&&x(s),s})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),r=this.toSmallSectorMap.get(o);return k()&&x(r),r}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&t.add(r)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=vt.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof po)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof fo)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,D.BLACK));else if(o instanceof go)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,D.RED));else if(o instanceof mo)t.setSectorState(this.mapSector(o.sector),V.NOT_ZERO);else if(o instanceof wo)t.setSectorState(this.mapSector(o.sector),V.NOT_ONE);else if(o instanceof Co)t.setSectorState(this.mapSector(o.sector),V.NOT_TWO);else if(o instanceof So)t.setSectorState(this.mapSector(o.sector),V.ONLY_ONE);else if(o instanceof yo){const r=(u,i)=>{const d=this.mapFace(u),h=this.mapFace(i),n=d?t.getFaceColor(d):t.getOutsideColor(),l=h?t.getFaceColor(h):t.getOutsideColor();new Qt(pe(t,n),pe(t,l)).apply(t)},s=(u,i)=>{const d=this.mapFace(u),h=this.mapFace(i),n=d?t.getFaceColor(d):t.getOutsideColor(),l=h?t.getFaceColor(h):t.getOutsideColor();new eo(pe(t,n),pe(t,l)).apply(t)};for(let u=1;u<o.primaryFaces.length;u++)r(o.primaryFaces[u-1],o.primaryFaces[u]);for(let u=1;u<o.secondaryFaces.length;u++)r(o.secondaryFaces[u-1],o.secondaryFaces[u]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return rr(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o){const r=Pe.NOTHING.copy(),s=i=>{r.addPoint(t.getVertex(o.mapVertex(i)).viewCoordinates)};e.vertices.forEach(s);const u=i=>{const d=t.getFace(o.mapFace(i));d&&d.vertices.forEach(h=>r.addPoint(h.viewCoordinates))};return e.faces.forEach(u),e.edges.forEach(i=>{let d;i.isExit?d=o.mapExitEdges(i).map(h=>t.getEdge(h)):d=[t.getEdge(o.mapNonExitEdge(i))],d.forEach(h=>{r.addPoint(h.start.viewCoordinates),r.addPoint(h.end.viewCoordinates)})}),r}static findBestEmbedding(e,t,o){const r=Po(e,t);if(r.length===0)return null;const s=Pe.NOTHING.copy();o.vertices.forEach(h=>s.addPoint(h.viewCoordinates));const u=s.center;let i=null,d=Number.POSITIVE_INFINITY;for(let h=0;h<r.length;h++){const n=r[h],m=fe.getEmbeddingBounds(e,t,n).center,f=u.distance(m);f<d&&(d=f,i=n)}return i}static getDisplayEmbedding(e,t,o,r){const s=fe.getEmbeddingBounds(e,t,r),u=s.dilated(.5),i=o.faces.filter(p=>{const S=Pe.NOTHING.copy();return p.vertices.forEach(C=>S.addPoint(C.viewCoordinates)),u.intersectsBounds(S)}),d=o.vertices.filter(p=>p.faces.some(S=>i.includes(S))),h=Lt({vertices:d.map(p=>({logicalCoordinates:p.logicalCoordinates,viewCoordinates:p.viewCoordinates})),faces:i.map(p=>({logicalCoordinates:p.logicalCoordinates,vertices:p.vertices.map(S=>({logicalCoordinates:S.logicalCoordinates,viewCoordinates:S.viewCoordinates}))}))}),n=new vo(h),l=1e-6,m=new Map(i.map((p,S)=>{const C=n.faces.find(v=>v.viewCoordinates.equalsEpsilon(p.viewCoordinates,l));return k()&&x(C),[p,C]})),f=new Map(o.edges.map(p=>{const S=n.edges.find(C=>C.start.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,l)&&C.end.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,l)||C.start.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,l)&&C.end.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,l))??null;return S?[p,S]:null}).filter(p=>p!==null)),w=new Map(o.halfEdges.map(p=>{const S=n.halfEdges.find(C=>C.start.viewCoordinates.equalsEpsilon(p.start.viewCoordinates,l)&&C.end.viewCoordinates.equalsEpsilon(p.end.viewCoordinates,l))??null;return S?[p,S]:null}).filter(p=>p!==null));return k()&&x(r),new fe(e,t,o,r,n,m,f,w,s,u)}}class sr{constructor(e,t,o){P(this,"edgeStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(k()&&x(this.board.edges.includes(e)),t!==D.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new X(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class ir{constructor(e,t,o){P(this,"faceColorsChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){if(s)throw new X("invalid face color?");const u=new Set([...o.values(),...r.keys(),...o.values()]),i=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())i.set(n,o.get(n));const d=n=>r.has(n)?r.get(n):[...e].includes(n)?this.currentState.getOppositeFaceColor(n):null,h=new Map;for(const n of i.keys()){const l=i.get(n);h.has(l)||h.set(l,new Set([n])),h.get(l).add(n)}for(const n of u){const l=h.get(n);if(!l)continue;const m=[...l];k()&&x(m.length>0);const f=this.solvedState.getFaceColor(m[0]);for(const p of m)if(this.solvedState.getFaceColor(p)!==f)throw new X("invalid face color");const w=d(n);if(w){let p;if(w.colorState===te.INSIDE?p=this.solvedState.getInsideColor():w.colorState===te.OUTSIDE?p=this.solvedState.getOutsideColor():p=this.solvedState.getFaceColor([...h.get(w)][0]),f===p)throw new X("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class nr{constructor(e,t,o){P(this,"simpleRegionsChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,r){if([...o].length)throw new X("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class ar{constructor(e,t,o){P(this,"faceValueChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new X("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class lr{constructor(e,t,o){P(this,"sectorStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){k()&&x(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class cr{constructor(e,t,o){P(this,"vertexStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){k()&&x(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make vertex ${t} when it should be ${o}`);const r=this.currentState.getVertexState(e);if(!t.isSubsetOf(r))throw new X("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class dr{constructor(e,t,o){P(this,"faceStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){k()&&x(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make face ${t} when it should be ${o}`);const r=this.currentState.getFaceState(e);if(!t.isSubsetOf(r))throw new X("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Fr{constructor(e,t,o){P(this,"anyStateChangedEmitter",new G);P(this,"edgeStateValidator");P(this,"faceValueValidator");P(this,"simpleRegionDataValidator");P(this,"faceColorValidator");P(this,"sectorStateValidator");P(this,"vertexStateValidator");P(this,"faceStateValidator");k()&&x(e),k()&&x(o),this.edgeStateValidator=new sr(e,t,o),this.faceValueValidator=new ar(e,t,o),this.simpleRegionDataValidator=new nr(e,t,o),this.faceColorValidator=new ir(e,t,o),this.sectorStateValidator=new lr(e,t,o),this.vertexStateValidator=new cr(e,t,o),this.faceStateValidator=new dr(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,r){this.simpleRegionDataValidator.modifyRegions(e,t,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){this.faceColorValidator.modifyFaceColors(e,t,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}const Tr=(a,e,t)=>new K([new Ke(a,e),new Qe(a,e),new et(a,e),new st(a,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new it(a,e,{solveToRed:!0,solveToBlack:!0}),new nt(a,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new to(a,e),new tt(a,e),new at(a,e),new oo(a,e),new ot(a,e),new ro(a,e,{solveToRed:!0,solveToBlack:!0}),new so(a,e),new we(a,e,{solveToRed:!0,solveToBlack:!0}),new io(a,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new no(a,e),new rt(a,e),new ao(a,e,{solveToRed:!0,solveToBlack:!0}),new lo(a,e),new co(a,e),new ho(a,e)]);export{Fr as C,fe as D,W as E,Ko as F,je as P,Go as U,$o as V,Tr as a,Vr as b,_ as c,Lo as d,ee as e,Ro as f,dt as g,Ce as h,Do as i,Fo as j,To as k,No as l,ko as m,br as n,Ao as o,Ve as p,Oo as q,Vo as r,rr as s,Er as t,xo as v};
