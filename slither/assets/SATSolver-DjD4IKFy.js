var De=Object.defineProperty;var Ie=(S,e,t)=>e in S?De(S,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[e]=t;var F=(S,e,t)=>(Ie(S,typeof e!="symbol"?e+"":e,t),t);import{g as We,P as Ve,m as Te}from"./Vector2Property-DCXaH-JP.js";import{E as f,c as M,d as D,F as U,S as I,f as He,g as Ne,h as Ke,i as je,j as Ue,k as qe,l as ze,m as $e,n as Ge,V as ae,o as Z,p as Ze,s as ne,q as Je,r as Ye,t as Qe}from"./BasicPuzzle-CWyNbg6B.js";import{L as K}from"./logic-solver-PjryYC9f.js";import{a as b,b as R,_ as Y}from"./createBoardDescriptor-DQiPBFka.js";import{e as Xe}from"./PhetioControlledVisibilityProperty-sdyDHryr.js";import{b as B}from"./TextPushButton-F5WNyFmI.js";const Kt=QueryStringMachine.getAll({p:{type:"string",defaultValue:""},debugScan:{type:"flag"},debugSleep:{type:"flag"},debugColors:{type:"flag"},showPointerAreas:{type:"flag"}});class X{constructor(e){this.solvers=e}get dirty(){return this.solvers.some(e=>e.dirty)}nextAction(){for(const e of this.solvers)if(e.dirty){const t=e.nextAction();if(t)return t}return null}clone(e){return new X(this.solvers.map(t=>t.clone(e)))}dispose(){this.solvers.forEach(e=>e.dispose())}}class P extends Error{constructor(e){super(e)}}class V{constructor(e,t){this.action=e,this.annotation=t}apply(e){this.action.apply(e)}getUndo(e){return new V(this.action.getUndo(e),this.annotation)}isEmpty(){return this.action.isEmpty()}serializeAction(){throw new Error("unimplemented")}static deserializeAction(e,t){throw new Error("unimplemented")}}class ce{constructor(e,t,s,o){F(this,"dirtyEdges",new Set);F(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyEdges=new Set(o):this.dirtyEdges=new Set(e.edges),this.faceColorListener=(r,c,n,l)=>{for(const i of l)for(const a of i.edges)this.dirtyEdges.add(a);for(const i of n){const a=this.state.getFacesWithColor(i);for(const h of a)for(const d of h.edges)this.dirtyEdges.add(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new P("Has invalid face colors");for(;this.dirtyEdges.size>0;){const e=this.dirtyEdges.values().next().value;if(this.state.getEdgeState(e)===f.WHITE){const s=e.forwardFace?this.state.getFaceColor(e.forwardFace):this.state.getOutsideColor(),o=e.reversedFace?this.state.getFaceColor(e.reversedFace):this.state.getOutsideColor(),r=s===o,c=this.state.getOppositeFaceColor(s)===o;if(this.options.solveToBlack&&c)return new V(new M(e,f.BLACK),{type:"FaceColorToBlack",edge:e});if(this.options.solveToRed&&r)return new V(new M(e,f.RED),{type:"FaceColorToRed",edge:e})}this.dirtyEdges.delete(e)}return null}clone(e){return new ce(this.board,e,this.options,this.dirtyEdges)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class le{constructor(e,t,s,o){F(this,"dirtyVertices",[]);F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.edgeListener=(r,c)=>{this.dirtyVertices.push(...r.vertices)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=e.edges;let s=0,o=0;if(t.forEach(r=>{const c=this.state.getEdgeState(r);return c===f.BLACK?s++:c===f.WHITE&&o++,c}),s>2)throw new P("Too many black edges on vertex");if(s===1&&o===0)throw new P("Nowhere for the single edge to go");if(o>0){if(this.options.solveJointToRed&&s===2){const r=t.filter(n=>this.state.getEdgeState(n)===f.WHITE),c=t.filter(n=>this.state.getEdgeState(n)===f.BLACK);return b()&&R(c.length===2),new V(new D(r.map(n=>new M(n,f.RED))),{type:"JointToRed",vertex:e,whiteEdges:r,blackEdges:c})}else if(this.options.solveForcedLineToBlack&&s===1&&o===1){const r=t.find(n=>this.state.getEdgeState(n)===f.WHITE),c=t.find(n=>this.state.getEdgeState(n)===f.BLACK);return b()&&R(r),b()&&R(c),new V(new M(r,f.BLACK),{type:"ForcedLine",vertex:e,blackEdge:c,whiteEdge:r,redEdges:t.filter(n=>this.state.getEdgeState(n)===f.RED)})}else if(this.options.solveAlmostEmptyToRed&&s===0&&o===1){const r=t.find(c=>this.state.getEdgeState(c)===f.WHITE);return b()&&R(r),new V(new M(r,f.RED),{type:"AlmostEmptyToRed",vertex:e,whiteEdge:r,redEdges:t.filter(c=>this.state.getEdgeState(c)===f.RED)})}}}return null}clone(e){return new le(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class de{constructor(e,t,s,o){F(this,"dirtyFaces",[]);F(this,"faceListener");F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces.filter(r=>t.getFaceValue(r)!==null)),this.faceListener=(r,c)=>{this.dirtyFaces.push(r)},this.edgeListener=(r,c)=>{this.dirtyFaces.push(...r.faces)},this.state.faceValueChangedEmitter.addListener(this.faceListener),this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceValue(e);if(t!==null){const s=e.edges;let o=0,r=0,c=0;if(s.forEach(n=>{const l=this.state.getEdgeState(n);return l===f.BLACK?o++:l===f.RED?r++:c++,l}),o>t)throw new P("Too many black edges on face");if(r>e.edges.length-t)throw new P("Too many red edges on face");if(c>0){if(this.options.solveToRed&&o===t){const n=s.filter(i=>this.state.getEdgeState(i)===f.WHITE),l=s.filter(i=>this.state.getEdgeState(i)===f.BLACK);return new V(new D(n.map(i=>new M(i,f.RED))),{type:"FaceSatisfied",face:e,whiteEdges:n,blackEdges:l})}else if(this.options.solveToBlack&&r===e.edges.length-t){const n=s.filter(i=>this.state.getEdgeState(i)===f.WHITE),l=s.filter(i=>this.state.getEdgeState(i)===f.RED);return new V(new D(n.map(i=>new M(i,f.BLACK))),{type:"FaceAntiSatisfied",face:e,whiteEdges:n,redEdges:l})}}}}return null}clone(e){return new de(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class he{constructor(e,t,s,o){F(this,"dirtySimpleRegions");F(this,"hasDirtyWeirdEdges",!1);F(this,"simpleRegionListener");F(this,"edgeListener");this.board=e,this.state=t,this.options=s,o?this.dirtySimpleRegions=new Set(o):this.dirtySimpleRegions=new Set(t.getSimpleRegions()),this.simpleRegionListener=(r,c,n,l)=>{for(const i of c)this.dirtySimpleRegions.delete(i);for(const i of r)this.dirtySimpleRegions.add(i);this.hasDirtyWeirdEdges=t.getWeirdEdges().length>0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener),this.edgeListener=(r,c,n)=>{if(c===f.RED){const l=this.state.getSimpleRegions(),i=a=>{let h=a,d=null,u=0;do{if(u++>1e4)throw new Error("infinite loop detected");const C=h.edges.filter(A=>this.state.getEdgeState(A)===f.BLACK);if(C.length===1){for(const A of l)(A.a===h||A.b===h)&&this.dirtySimpleRegions.add(A);break}if(C.length!==0)break;const E=h.edges.filter(A=>this.state.getEdgeState(A)===f.WHITE);if(E.length!==2)break;const v=E[0].getOtherVertex(h)===d?E[1]:E[0];d=h,h=v.getOtherVertex(h)}while(h!==a)};i(r.start),i(r.end)}},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySimpleRegions.size>0||this.hasDirtyWeirdEdges}nextAction(){if(!this.dirty)return null;if(this.state.getWeirdEdges().length)throw new P("has weird edges");const e=this.options.resolveAllRegions?new Set(this.state.getSimpleRegions()):this.dirtySimpleRegions;for(;e.size>0;){const t=e.values().next().value;if(!t.isSolved){const s=t.a,o=t.b,r=t.halfEdges[0].edge;for(const c of s.edges){if(c===r||this.state.getEdgeState(c)===f.RED)continue;const n=[c];let l=c,i=c.getOtherVertex(s);for(;i!==o;){let a=!1;const h=i.edges.filter(d=>{if(d===l)return!1;const u=this.state.getEdgeState(d);return u===f.BLACK&&(a=!0),u===f.WHITE});if(h.length!==1||a)break;l=h[0],n.push(l),i=l.getOtherVertex(i)}if(i===o){if(this.isSolvedWithAddedEdges(t,n)){if(this.options.solveToBlack)return new V(new D(n.map(a=>new M(a,f.BLACK))),{type:"ForcedSolveLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n})}else if(this.options.solveToRed)return new V(new D(n.map(a=>new M(a,f.RED))),{type:"PrematureForcedLoop",a:s,b:o,regionEdges:t.edges,pathEdges:n})}}}e.delete(t)}return null}isSolvedWithAddedEdges(e,t){const s=new Set(e.edges);for(const o of t)s.add(o);for(const o of this.board.faces){const r=this.state.getFaceValue(o);if(r!==null&&o.edges.filter(n=>s.has(n)).length!==r)return!1}return!0}clone(e){return new he(this.board,e,this.options,this.dirtySimpleRegions)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}const W=(S,e)=>{if(e.colorState===U.OUTSIDE)return{type:"absolute",isOutside:!0};if(e.colorState===U.INSIDE)return{type:"absolute",isOutside:!1};{const t=[...S.getFacesWithColor(e)][0];return b()&&R(t),{type:"face",face:t}}},ee=(S,e)=>e.type==="face"?S.getFaceColor(e.face):e.isOutside?S.getOutsideColor():S.getInsideColor();class q{constructor(e,t){this.a=e,this.b=t,b()&&R(e),b()&&R(t)}apply(e){const t=ee(e,this.a),s=ee(e,this.b);if(t===s)return;const o=e.getOppositeFaceColor(t),r=e.getOppositeFaceColor(s);if(b()){const d=new Set(e.getFaceColors());R(d.has(t)),R(d.has(s)),o&&R(d.has(o)),r&&R(d.has(r))}if(o&&o===s||r&&r===t){e.modifyFaceColors([],[],new Map,new Map,!0);return}const c=[],n=new Map,l=new Map,i=q.combineFaces(t,s,e,c,n),a=o&&r?q.combineFaces(o,r,e,c,n):o||r;i===t&&a===o||i===s&&a===r||(l.set(i,a),a&&l.set(a,i)),e.modifyFaceColors([],c,n,l,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeSameAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorMakeSameAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorMakeSameAction")}static combineFaces(e,t,s,o,r){let c=null;if(e.colorState!==U.UNDECIDED)c=t;else if(t.colorState!==U.UNDECIDED)c=e;else{const l=s.getFacesWithColor(e),i=s.getFacesWithColor(t);c=l.length>i.length?t:e}const n=c===e?t:e;o.push(c);for(const l of s.getFacesWithColor(c))r.set(l,n);return n}}class se{constructor(e,t){this.a=e,this.b=t,b()&&R(e),b()&&R(t)}apply(e){const t=ee(e,this.a),s=ee(e,this.b);if(t===s){e.modifyFaceColors([],[],new Map,new Map,!0);return}const o=e.getOppositeFaceColor(t),r=e.getOppositeFaceColor(s);if(b()){const h=new Set(e.getFaceColors());R(h.has(t)),R(h.has(s)),o&&R(h.has(o)),r&&R(h.has(r))}if(o&&o===s||r&&r===t)return;if(o&&o===r){e.modifyFaceColors([],[],new Map,new Map,!0);return}const c=[],n=new Map,l=new Map,i=r?q.combineFaces(t,r,e,c,n):t,a=o?q.combineFaces(s,o,e,c,n):s;l.set(i,a),l.set(a,i),e.modifyFaceColors([],c,n,l,!1)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorMakeOppositeAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorMakeOppositeAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorMakeOppositeAction")}}class fe{constructor(e,t,s,o){F(this,"dirtyFaces",new Set);F(this,"edgeListener");F(this,"faceColorListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces=new Set(o):this.dirtyFaces=new Set(e.faces),this.faceColorListener=(r,c,n,l)=>{const i=a=>{this.dirtyFaces.add(a);for(const h of a.edges){const d=h.getOtherFace(a);d&&this.dirtyFaces.add(d)}};for(const a of l)i(a);for(const a of[...r,...n]){const h=this.state.getFacesWithColor(a);for(const d of h)i(d)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener),this.edgeListener=(r,c)=>{for(const n of r.faces)this.dirtyFaces.add(n)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;if(this.state.hasInvalidFaceColors())throw new P("Has invalid face colors");for(;this.dirtyFaces.size>0;){const e=this.dirtyFaces.values().next().value,t=o=>{const r=o.getOtherFace(e),c=r?this.state.getFaceColor(r):this.state.getOutsideColor();return new _e(c,o)},s=e.edges.filter(o=>this.state.getEdgeState(o)===f.WHITE).map(t);if(s.length){const o=this.state.getFaceValue(e);if(o===null){const r=s[0].color;if(e.edges.map(t).every(l=>l.color===r)&&this.options.solveToRed){const l=e.edges.map(a=>a.getOtherFace(e)).filter(a=>a!==null);if(this.board.faces.some(a=>a!==e&&this.state.getFaceValue(a)!==null&&!l.includes(a)))return new V(new D(s.map(a=>new M(a.edge,f.RED))),{type:"FaceColorNoTrivialLoop",face:e})}}else{const r=e.edges.filter(l=>this.state.getEdgeState(l)===f.BLACK).length,c=(l,i,a)=>{let h=[];for(const p of i){const T=p.color;let g=!1;for(const m of h)if(m.mainColor===T){m.mainColorSides.add(p),g=!0;break}else if(m.oppositeColor===T){m.oppositeColorSides.add(p),g=!0;break}if(!g){const m=this.state.getOppositeFaceColor(T),x=new et(T,m,0,0);h.push(x),x.mainColorSides.add(p)}}h=Y.sortBy(h,p=>-p.size);const u=Y.sortBy(h.flatMap(p=>{const T=[new Re(p.mainColor,p.mainCount,p.mainColorSides)];return p.oppositeColor&&p.oppositeColorSides.size&&T.push(new Re(p.oppositeColor,p.oppositeCount,p.oppositeColorSides)),T}),p=>-p.size)[0],C=u.size,E=l,v=i.length-E,A=Math.max(E,v),k=C>E,w=C>v,L=C===A;if(k&&w)throw new P("Too many adjacent faces with the same color");const y=()=>{const p=T=>[T[0].map(g=>g.edge),T[1].map(g=>g.edge)];return{face:e,remainingValue:l,availableSideCount:i.length,balancedPairs:a.map(p)}};if(k&&this.options.solveToRed)return new V(new D([...u.sides].map(p=>new M(p.edge,f.RED))),{type:"FaceColorMatchToRed",matchingEdges:[...u.sides].map(p=>p.edge),...y()});if(w&&this.options.solveToBlack)return new V(new D([...u.sides].map(p=>new M(p.edge,f.BLACK))),{type:"FaceColorMatchToBlack",matchingEdges:[...u.sides].map(p=>p.edge),...y()});if(L&&this.options.solveColors){const p=u.color,T=i.filter(m=>m.color!==p),g=Y.uniq(T.map(m=>m.color)).filter(m=>m!==this.state.getOppositeFaceColor(p));if(g.length)return b()&&R(g.every(m=>this.state.getFaceColors().includes(m))),new V(new D(g.map(m=>new se(W(this.state,p),W(this.state,m)))),{type:"FaceColorBalance",matchingEdges:[...u.sides].map(m=>m.edge),oppositeEdges:[...T].map(m=>m.edge),...y()})}if(this.options.allowPartialReduction)for(const p of h){if(p.size<1)continue;const T=[...p.mainColorSides].slice(0,p.size),g=[...p.oppositeColorSides].slice(0,p.size),m=i.filter(x=>!T.includes(x)&&!g.includes(x));if(m.length){const x=c(E-p.size,m,a.concat([[T,g]]));if(x)return x}}return null},n=c(o-r,s,[]);if(n)return n}}this.dirtyFaces.delete(e)}return null}clone(e){return new fe(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener),this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class _e{constructor(e,t){this.color=e,this.edge=t}}class et{constructor(e,t,s,o){F(this,"mainColorSides",new Set);F(this,"oppositeColorSides",new Set);this.mainColor=e,this.oppositeColor=t,this.mainCount=s,this.oppositeCount=o}get size(){return Math.min(this.mainColorSides.size,this.oppositeColorSides.size)}}class Re{constructor(e,t,s){this.color=e,this.count=t,this.sides=s}get size(){return this.sides.size}}const tt=(S,e)=>{let t=0;for(;S.dirty;){if(t++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const s=S.nextAction();s&&s.apply(e)}},st=(S,e)=>{try{tt(S,e)}finally{S.dispose()}},ot=(S,e,t,s,o)=>{const r=S(e,t,o);s(),st(r,t)},it=(S,e,t,s)=>{ot(S,e,t,()=>{},s)},_=S=>{const e=[];for(const t of S.edges){const s=t.getOtherFace(S);s&&e.push(s)}return e},Oe=(S,e)=>S.start===e||S.end===e;class ge{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const c of _(o))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;if(t===s-1)for(const o of e.edges){const r=o.getOtherFace(e);if(r){const c=this.state.getFaceValue(r),n=r.edges.length;if(c===n-1){const l=new Set([..._(e),..._(r)]);if(this.board.faces.some(i=>(this.state.getFaceValue(i)??0)>0&&!l.has(i))){const i=v=>!Oe(v,o.start)&&!Oe(v,o.end),a=e.edges.filter(i),h=r.edges.filter(i),d=v=>!v.faces.some(A=>A===e||A===r),u=[...o.start.edges.filter(d),...o.end.edges.filter(d)],C=[o,...a,...h].filter(v=>this.state.getEdgeState(v)!==f.BLACK),E=u.filter(v=>this.state.getEdgeState(v)!==f.RED);if(C.length||E.length)return new V(new D([...C.map(v=>new M(v,f.BLACK)),...E.map(v=>new M(v,f.RED))]),{type:"DoubleMinusOneFaces",faces:[e,r],toBlackEdges:C,toRedEdges:E})}}}}this.dirtyFaces.delete(e)}return null}clone(e){return new ge(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class ue{constructor(e,t,s){F(this,"dirtySectors");F(this,"edgeListener");F(this,"sectorListener");this.board=e,this.state=t,s?this.dirtySectors=new Set(s):this.dirtySectors=new Set(e.halfEdges),this.edgeListener=(o,r,c)=>{this.dirtySectors.add(o.forwardHalf),this.dirtySectors.add(o.forwardHalf.previous),this.dirtySectors.add(o.reversedHalf),this.dirtySectors.add(o.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(o,r,c)=>{this.dirtySectors.add(o)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getSectorState(e);if(o===I.NONE)throw new P(`invalid sector state: ${o}`);const r=this.state.getEdgeState(t),c=this.state.getEdgeState(s),n=(r===f.WHITE?1:0)+(c===f.WHITE?1:0),l=(r===f.BLACK?1:0)+(c===f.BLACK?1:0),i=(a,h)=>new V(new D([...a.map(d=>new M(d,f.BLACK)),...h.map(d=>new M(d,f.RED))]),{type:"ForcedSector",sector:e,sectorState:o,toRedEdges:h,toBlackEdges:a});if(n===0){if(!o.allows(l))throw new P(`invalid state: ${o} with ${l} black edges with no white`)}else if(n===1){const a=o.allows(l),h=o.allows(l+1);if(!a&&!h)throw new P(`invalid state: ${o} with ${l} black edges and 1 white`);if(a&&!h)return i([],[r===f.WHITE?t:s]);if(h&&!a)return i([r===f.WHITE?t:s],[])}else if(n===2){if(o===I.ONLY_ZERO)return i([],[t,s]);if(o===I.ONLY_TWO)return i([t,s],[])}else throw new P(`invalid white count: ${n}`)}return null}clone(e){return new ue(this.board,e,this.dirtySectors)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener)}}class ${constructor(e,t){this.sector=e,this.state=t}apply(e){e.setSectorState(this.sector,this.state)}getUndo(e){const t=e.getSectorState(this.sector);return new $(this.sector,t)}isEmpty(){return!1}serializeAction(){return{type:"SectorStateSetAction",sector:He(this.sector),state:this.state.serialize()}}static deserializeAction(e,t){return new $(Ne(e,t.sector),I.deserialize(t.state))}}class pe{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces),this.faceListener=(o,r)=>{this.dirtyFaces.add(o);for(const c of _(o))this.dirtyFaces.add(c)},this.state.faceValueChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value,t=this.state.getFaceValue(e),s=e.edges.length;let o=null;if(t===0?o=I.ONLY_ZERO:t===1?o=I.NOT_TWO:t===s-1?o=I.NOT_ZERO:t===s&&(o=I.ONLY_TWO),o){const r=e.halfEdges,c=[],n=[];for(const l of r){const i=this.state.getSectorState(l),a=i.and(o);if(a===I.NONE)throw new P(`invalid sector state: ${i}`);i!==a&&(c.push(new $(l,a)),n.push(l))}if(c.length)return new V(new D(c),{type:"StaticFaceSectors",face:e,sectors:n})}this.dirtyFaces.delete(e)}return null}clone(e){return new pe(this.board,e,this.dirtyFaces)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceListener)}}class we{constructor(e,t,s,o){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyVertices.push(...o):this.dirtyVertices.push(...e.vertices),this.vertexListener=r=>{this.dirtyVertices.push(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new P("Vertex has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const l=[...n][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new V(new D([...s.map(r=>new M(r,f.RED)),...o.map(r=>new M(r,f.BLACK))]),{type:"VertexStateToEdge",vertex:e,toRedEdges:s,toBlackEdges:o})}return null}clone(e){return new we(this.board,e,this.options,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class Se{constructor(e,t,s){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices.pop(),t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new P("Vertex has no possibilities");const s=Ke(e),o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>I.NONE);for(const i of t.getAllowedPairs())for(let a=0;a<s.length;a++){const h=s[a],d=h.edge,u=h.next.edge,C=i[0],E=i[1],v=(d===C||d===E?1:0)+(u===C||u===E?1:0);r[a]=r[a].with(v)}if(t.allowsEmpty())for(let i=0;i<s.length;i++)r[i]=r[i].withZero(!0);for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===I.NONE)throw new P("Sector has no possibilities");const c=[],n=[],l=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(c.push(s[i]),n.push(o[i]),l.push(r[i]));if(c.length)return new V(new D(c.map((i,a)=>new $(i,l[a]))),{type:"VertexStateToSector",vertex:e,sectors:c,beforeStates:n,afterStates:l})}return null}clone(e){return new Se(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class ye{constructor(e,t,s){F(this,"dirtyVertices",[]);F(this,"vertexListener");this.board=e,this.state=t,s?this.dirtyVertices.push(...s):this.dirtyVertices.push(...e.vertices),this.vertexListener=o=>{this.dirtyVertices.push(o)},this.state.vertexStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyVertices.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.length;){const e=this.dirtyVertices[this.dirtyVertices.length-1],t=this.state.getVertexState(e);if(t.possibilityCount===0)throw new P("Vertex has no possibilities");const o=je(e).map(n=>n.face?this.state.getFaceColor(n.face):this.state.getOutsideColor()),r=new Set(o);if(r.size!==1){const n=new Map([...r].map(i=>[i,new Map([...r].map(a=>[a,!1]))])),l=new Map([...r].map(i=>[i,new Map([...r].map(a=>[a,!1]))]));for(const i of t.getAllowedPairs()){const a=e.edges.indexOf(i[0]),h=e.edges.indexOf(i[1]),d=Math.min(a,h),u=Math.max(a,h),C=o.slice(d,u),E=[...o.slice(u),...o.slice(0,d)],v=A=>{for(let k=0;k<A.length;k++)for(let w=k+1;w<A.length;w++)n.get(A[k]).set(A[w],!0),n.get(A[w]).set(A[k],!0)};v(C),v(E);for(const A of C)for(const k of E)A!==k&&(l.get(A).set(k,!0),l.get(k).set(A,!0))}for(const i of r)for(const a of r){if(i===a)continue;const h=t.allowsEmpty()||n.get(i).get(a),d=l.get(i).get(a);if(h&&!d)return new V(new q(W(this.state,i),W(this.state,a)),{type:"VertexStateToSameFaceColor",vertex:e,facesA:e.faces.filter(u=>this.state.getFaceColor(u)===i),facesB:e.faces.filter(u=>this.state.getFaceColor(u)===a)});if(d&&!h&&this.state.getOppositeFaceColor(i)!==a)return new V(new se(W(this.state,i),W(this.state,a)),{type:"VertexStateToOppositeFaceColor",vertex:e,facesA:e.faces.filter(u=>this.state.getFaceColor(u)===i),facesB:e.faces.filter(u=>this.state.getFaceColor(u)===a)})}}const c=this.dirtyVertices.pop();b()&&R(c===e)}return null}clone(e){return new ye(this.board,e,this.dirtyVertices)}dispose(){this.state.vertexStateChangedEmitter.removeListener(this.vertexListener)}}class te{constructor(e,t){this.face=e,this.state=t}apply(e){e.setFaceState(this.face,this.state)}getUndo(e){const t=e.getFaceState(this.face);return new te(this.face,t)}isEmpty(){return!1}serializeAction(){return{type:"FaceStateSetAction",face:Ue(this.face),state:this.state.serialize()}}static deserializeAction(e,t){const s=qe(e,t.face);return new te(s,ze.deserialize(s,t.state))}}class oe{constructor(e,t,s){F(this,"dirtyFaces");F(this,"faceValueListener");F(this,"vertexStateListener");F(this,"faceColorListener");this.board=e,this.state=t,s?this.dirtyFaces=new Set(s):this.dirtyFaces=new Set(e.faces.filter(o=>t.getFaceValue(o)!==null)),this.faceValueListener=(o,r)=>{this.dirtyFaces.add(o)},this.state.faceValueChangedEmitter.addListener(this.faceValueListener),this.vertexStateListener=o=>{for(const r of o.faces)this.dirtyFaces.add(r)},this.state.vertexStateChangedEmitter.addListener(this.vertexStateListener),this.faceColorListener=(o,r,c,n)=>{const l=i=>{this.dirtyFaces.add(i);for(const a of i.edges){const h=a.getOtherFace(i);h&&this.dirtyFaces.add(h)}};for(const i of n)l(i);for(const i of[...o,...c]){const a=this.state.getFacesWithColor(i);for(const h of a)l(h)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyFaces.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.size;){const e=this.dirtyFaces.values().next().value;this.dirtyFaces.delete(e);const t=this.state.getFaceState(e),s=ze.fromVertexAndColorData(e,this.board,this.state).and(t);if(!t.equals(s))return new V(new te(e,s),{type:"FaceState",face:e,beforeState:t,afterState:s})}return null}clone(e){return new oe(this.board,e)}dispose(){this.state.faceValueChangedEmitter.removeListener(this.faceValueListener),this.state.vertexStateChangedEmitter.removeListener(this.vertexStateListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}class Ce{constructor(e,t,s,o){F(this,"dirtyFaces",[]);F(this,"vertexListener");this.board=e,this.state=t,this.options=s,o?this.dirtyFaces.push(...o):this.dirtyFaces.push(...e.faces),this.vertexListener=r=>{this.dirtyFaces.push(r)},this.state.faceStateChangedEmitter.addListener(this.vertexListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new P("Face has no possibilities");const s=[],o=[];for(const r of e.edges)if(this.state.getEdgeState(r)===f.WHITE){const n=t.getFinalStatesOfEdge(r);if(n.size===1){const l=[...n][0];l===f.RED&&this.options.solveToRed&&s.push(r),l===f.BLACK&&this.options.solveToBlack&&o.push(r)}}if(s.length||o.length)return new V(new D([...s.map(r=>new M(r,f.RED)),...o.map(r=>new M(r,f.BLACK))]),{type:"FaceStateToEdge",face:e,toRedEdges:s,toBlackEdges:o})}return null}clone(e){return new Ce(this.board,e,this.options,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.vertexListener)}}class Ee{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new P("Face has no possibilities");const s=e.halfEdges,o=s.map(i=>this.state.getSectorState(i)),r=s.map(i=>I.NONE);for(const i of t.getAllowedCombinations())for(let a=0;a<s.length;a++){const h=s[a],d=h.edge,u=h.next.edge,C=(i.includes(d)?1:0)+(i.includes(u)?1:0);r[a]=r[a].with(C)}for(let i=0;i<s.length;i++)r[i]=r[i].and(o[i]);for(const i of r)if(i===I.NONE)throw new P("Sector has no possibilities");const c=[],n=[],l=[];for(let i=0;i<s.length;i++)o[i]!==r[i]&&(c.push(s[i]),n.push(o[i]),l.push(r[i]));if(c.length)return new V(new D(c.map((i,a)=>new $(i,l[a]))),{type:"FaceStateToSector",face:e,sectors:c,beforeStates:n,afterStates:l})}return null}clone(e){return new Ee(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class me{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces[this.dirtyFaces.length-1],t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new P("Face has no possibilities");const s=new Map(e.edges.map(l=>{const i=l.getOtherFace(e);return[l,i?this.state.getFaceColor(i):this.state.getOutsideColor()]})),o=[e,...e.edges.map(l=>l.getOtherFace(e)).filter(Y.identity)],r=this.state.getFaceColor(e),c=new Set([...s.values(),r]);if(c.size!==1){const l=new Map([...c].map(a=>[a,new Map([...c].map(h=>[h,!1]))])),i=new Map([...c].map(a=>[a,new Map([...c].map(h=>[h,!1]))]));for(const a of t.getAllowedCombinations()){const h=new Set([r]),d=new Set;for(const C of e.edges)a.includes(C)?d.add(s.get(C)):h.add(s.get(C));const u=C=>{for(let E=0;E<C.length;E++)for(let v=E+1;v<C.length;v++)l.get(C[E]).set(C[v],!0),l.get(C[v]).set(C[E],!0)};u([...h]),u([...d]);for(const C of h)for(const E of d)C!==E&&(i.get(C).set(E,!0),i.get(E).set(C,!0))}for(const a of c)for(const h of c){if(a===h)continue;const d=l.get(a).get(h),u=i.get(a).get(h);if(d&&!u)return new V(new q(W(this.state,a),W(this.state,h)),{type:"FaceStateToSameFaceColor",face:e,facesA:o.filter(C=>this.state.getFaceColor(C)===a),facesB:o.filter(C=>this.state.getFaceColor(C)===h)});if(u&&!d&&this.state.getOppositeFaceColor(a)!==h)return new V(new se(W(this.state,a),W(this.state,h)),{type:"FaceStateToOppositeFaceColor",face:e,facesA:o.filter(C=>this.state.getFaceColor(C)===a),facesB:o.filter(C=>this.state.getFaceColor(C)===h)})}}const n=this.dirtyFaces.pop();b()&&R(n===e)}return null}clone(e){return new me(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}class Q{constructor(e,t){this.vertex=e,this.state=t}apply(e){e.setVertexState(this.vertex,this.state)}getUndo(e){const t=e.getVertexState(this.vertex);return new Q(this.vertex,t)}isEmpty(){return!1}serializeAction(){return{type:"VertexStateSetAction",vertex:$e(this.vertex),state:this.state.serialize()}}static deserializeAction(e,t){const s=Ge(e,t.vertex);return new Q(s,ae.deserialize(s,t.state))}}class ve{constructor(e,t,s){F(this,"dirtyFaces",[]);F(this,"faceListener");this.board=e,this.state=t,s?this.dirtyFaces.push(...s):this.dirtyFaces.push(...e.faces),this.faceListener=o=>{this.dirtyFaces.push(o)},this.state.faceStateChangedEmitter.addListener(this.faceListener)}get dirty(){return this.dirtyFaces.length>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyFaces.length;){const e=this.dirtyFaces.pop(),t=this.state.getFaceState(e);if(t.possibilityCount===0)throw new P("Face has no possibilities");const s=e.vertices.map(n=>this.state.getVertexState(n)),o=s.map(n=>{const l=n.vertex.edges.filter(i=>i.faces.includes(e));return b()&&R(l.length===2),{vertex:n.vertex,vertexState:n,edgeA:l[0],edgeB:l[1],...n.getBinaryCombinationsAllowed(l[0],l[1])}}),r=o.map(n=>({vertex:n.vertex,vertexState:n.vertexState,edgeA:n.edgeA,edgeB:n.edgeB,allowsNone:!1,allowsBoth:!1,allowsAOnly:!1,allowsBOnly:!1}));for(const n of t.getAllowedCombinations())for(const l of r){const i=n.includes(l.edgeA),a=n.includes(l.edgeB);i&&a&&(l.allowsBoth=!0),i&&!a&&(l.allowsAOnly=!0),!i&&a&&(l.allowsBOnly=!0),!i&&!a&&(l.allowsNone=!0)}const c=[];for(let n=0;n<r.length;n++){const l=o[n],i=r[n];if(i.allowsBoth&&(i.allowsBoth=l.allowsBoth),i.allowsAOnly&&(i.allowsAOnly=l.allowsAOnly),i.allowsBOnly&&(i.allowsBOnly=l.allowsBOnly),i.allowsNone&&(i.allowsNone=l.allowsNone),i.allowsBoth!==l.allowsBoth||i.allowsAOnly!==l.allowsAOnly||i.allowsBOnly!==l.allowsBOnly||i.allowsNone!==l.allowsNone){const a=l.vertexState,h=ae.fromLookup(l.vertex,(d,u)=>{if(!a.allowsPair(d,u))return!1;const E=d===i.edgeA||u===i.edgeA,v=d===i.edgeB||u===i.edgeB;if(E&&v)return i.allowsBoth;if(E&&!v)return i.allowsAOnly;if(!E&&v)return i.allowsBOnly;if(!E&&!v)return i.allowsNone;throw new Error("Unreachable")},a.allowsEmpty()&&i.allowsNone);b()&&R(h.isSubsetOf(a)),a.equals(h)||c.push(h)}}if(c.length)return new V(new D(c.map(n=>new Q(n.vertex,n))),{type:"FaceStateToVertexState",face:e,vertices:c.map(n=>n.vertex),beforeStates:c.map(n=>s.find(l=>l.vertex===n.vertex)),afterStates:c})}return null}clone(e){return new ve(this.board,e,this.dirtyFaces)}dispose(){this.state.faceStateChangedEmitter.removeListener(this.faceListener)}}const be=()=>We.nextInt(Number.MAX_SAFE_INTEGER);class j{constructor(e,t){F(this,"dirtyEdges",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>{this.dirtyEdges.add(s)}),this.edgeListener=(s,o)=>{this.dirtyEdges.add(s)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0}nextAction(){if(!this.dirty)return null;const e=this.state.getSimpleRegions(),t=this.state.getWeirdEdges(),s=new Set,o=new Set;for(const d of this.dirtyEdges)this.state.getEdgeState(d)===f.BLACK?s.add(d):o.add(d);const r=new Set,c=new Set,n=new Set(e),l=new Set,i=new Set,a=new Set(t);for(const d of o)a.has(d)&&(a.delete(d),i.add(d));for(const d of s)a.has(d)&&s.delete(d),[...n].some(u=>u.halfEdges.some(C=>C.edge===d))&&s.delete(d);for(const d of e)if(d.halfEdges.some(u=>o.has(u.edge))){const u=[];let C=[];for(const E of d.halfEdges)o.has(E.edge)?C.length>0&&(u.push(C),C=[]):C.push(E);if(C.length>0&&u.push(C),c.add(d),n.delete(d),u.length){if(d.isSolved&&u.length>1){const v=u[0][0],A=u[u.length-1][u[u.length-1].length-1];v.start===A.end&&u[0].unshift(...u.pop())}const E=Y.maxBy(u,v=>v.length);for(const v of u){const A=new Z(v===E?d.id:be(),v);r.add(A),n.add(A)}}}const h=d=>{const u=d.start,C=d.end,E=[...n].find(y=>y.a===u||y.b===u)||null,v=[...n].find(y=>y.a===C||y.b===C)||null,A=u.edges.filter(y=>this.state.getEdgeState(y)===f.BLACK).length,k=C.edges.filter(y=>this.state.getEdgeState(y)===f.BLACK).length;if(A>2||k>2)return!1;const w=y=>{n.add(y),r.add(y)},L=y=>{n.delete(y),r.has(y)?r.delete(y):c.add(y)};if(E&&v)if(E===v)if(j.isSolvedWithAddedEdge(this.board,this.state,E,d))L(E),w(new Z(E.id,j.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]),!0));else return!1;else{const y=E.halfEdges.length>=v.halfEdges.length?E:v,p=y===E?v:E,T=new Z(y.id,j.combineHalfEdgeArrays(y.halfEdges,[d.forwardHalf],p.halfEdges));L(y),L(p),w(T)}else if(E){const y=new Z(E.id,j.combineHalfEdgeArrays(E.halfEdges,[d.forwardHalf]));L(E),w(y)}else if(v){const y=new Z(v.id,j.combineHalfEdgeArrays(v.halfEdges,[d.forwardHalf]));L(v),w(y)}else{const y=new Z(be(),[d.forwardHalf]);w(y)}return!0};for(const d of a)h(d)&&(i.add(d),a.delete(d));for(const d of s)h(d)||(l.add(d),a.add(d));return this.dirtyEdges.clear(),r.size||c.size||l.size||i.size?new V(new Ze(this.board,r,c,l,i),{type:"SimpleRegions"}):null}clone(e){return new j(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}static isSolvedWithAddedEdge(e,t,s,o){if(o.start!==s.a&&o.start!==s.b||o.end!==s.a&&o.end!==s.b)return!1;const r=new Set(s.edges);r.add(o);for(const c of e.faces){const n=t.getFaceValue(c);if(n!==null&&c.edges.filter(i=>r.has(i)).length!==n)return!1}return!0}static combineHalfEdgeArrays(...e){if(e.length===0)return[];let t=[...e[0]];for(let s=1;s<e.length;s++){const o=e[s];if(o.length!==0)if(t[0].start===o[0].start)t=[...o.map(r=>r.reversed).reverse(),...t];else if(t[0].start===o[o.length-1].end)t=[...o,...t];else if(t[t.length-1].end===o[0].start)t=[...t,...o];else if(t[t.length-1].end===o[o.length-1].end)t=[...t,...o.map(r=>r.reversed).reverse()];else throw new Error("Cannot combine half edge arrays")}return t}}class Fe{constructor(e,t){F(this,"hasDirtySimpleRegions",!0);F(this,"simpleRegionListener");this.board=e,this.state=t,this.simpleRegionListener=()=>{this.hasDirtySimpleRegions=!0},this.state.simpleRegionsChangedEmitter.addListener(this.simpleRegionListener)}get dirty(){return this.hasDirtySimpleRegions}nextAction(){if(!this.dirty)return null;if(ne(this.state)){const e=this.board.edges.filter(t=>this.state.getEdgeState(t)===f.WHITE);if(e.length)return new V(new D(e.map(t=>new M(t,f.RED))),{type:"CompletingEdgesAfterSolve",whiteEdges:e})}return this.hasDirtySimpleRegions=!1,null}clone(e){return new Fe(this.board,e)}dispose(){this.state.simpleRegionsChangedEmitter.removeListener(this.simpleRegionListener)}}class rt{constructor(){}apply(e){e.modifyFaceColors([],[],new Map,new Map,!0)}getUndo(e){throw new Error("getUndo unimplemented in FaceColorInvalidAction")}isEmpty(){return!1}serializeAction(){throw new Error("serializeAction unimplemented in FaceColorInvalidAction")}static deserializeAction(e,t){throw new Error("deserializeAction unimplemented in FaceColorInvalidAction")}}class Le{constructor(e,t){F(this,"hadEdgeAdjusted",!1);F(this,"dirtyEdges",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.edges.forEach(s=>this.dirtyEdges.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyEdges.add(s),this.hadEdgeAdjusted=this.hadEdgeAdjusted||r!==f.WHITE},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtyEdges.size>0||this.hadEdgeAdjusted}nextAction(){var t;if(!this.dirty)return null;if(this.hadEdgeAdjusted||this.state.hasInvalidFaceColors()){this.hadEdgeAdjusted=!1,this.dirtyEdges.clear();const s=new Map,o=new re(U.OUTSIDE,new Set),r=new re(U.INSIDE,new Set);o.opposite=r,r.opposite=o;const c=new Set([o,r,...this.board.faces.map(w=>{const L=new re(U.UNDECIDED,new Set([w]));return s.set(w,L),L})]);let n=!1;const l=w=>{if(w===null)return o;const L=s.get(w);return b()&&R(L),L},i=(w,L)=>{if(L===o||L===r)return i(L,w);b()&&R(w!==L);for(const y of L.faces)w.faces.add(y),s.set(y,w);return L.faces.clear(),c.delete(L),w},a=(w,L)=>{if(b()&&R(c.has(w)&&c.has(L)),w===L)return;const y=w.opposite,p=L.opposite;if(y&&y===L){n=!0;return}if(p&&p===w){n=!0;return}const T=i(w,L),g=y&&p?i(y,p):y||p;T.opposite=g,g&&(g.opposite=T)},h=(w,L)=>{if(b()&&R(c.has(w)&&c.has(L)),w===L){n=!0;return}if(w.opposite&&w.opposite===L)return;const y=w.opposite,p=L.opposite;if(y&&y===p){n=!0;return}const T=p?i(w,p):w,g=y?i(L,y):L;T.opposite=g,g.opposite=T};for(const w of this.board.edges){if(n)break;const L=this.state.getEdgeState(w);if(L!==f.WHITE){const y=l(w.forwardFace),p=l(w.reversedFace);L===f.BLACK?h(y,p):L===f.RED&&a(y,p)}}if(b()){const w=new Set(this.board.faces);for(const L of c)for(const y of L.faces)w.delete(y);R(w.size===0)}if(n)return new V(new rt,{type:"InvalidFaceColoring"});const d=new Set(this.state.getFaceColors()),u=new Set,C=new Map,E=(w,L)=>{b()&&R(d.has(w)),b()&&R(L.faceColor===null),d.delete(w),L.faceColor=w};E(this.state.getOutsideColor(),o),E(this.state.getInsideColor(),r);for(const w of c){if(!w.faceColor){const y=new Set([...w.faces].map(g=>this.state.getFaceColor(g)));let p=null,T=0;for(const g of y){if(!d.has(g))continue;const m=this.state.getFacesWithColor(g);m.some(x=>!w.faces.has(x))||m.length>T&&(p=g,T=m.length)}if(p)E(p,w);else{const g=new Je(Ye(),U.UNDECIDED);u.add(g),w.faceColor=g}}const L=w.faceColor;b()&&R(L),w.faces.forEach(y=>{this.state.getFaceColor(y)!==L&&C.set(y,L)})}const v=new Set(d),A=new Map;for(const w of c){const L=w.faceColor,y=((t=w.opposite)==null?void 0:t.faceColor)??null;let p=u.has(L);p||(p=this.state.getOppositeFaceColor(L)!==y),p&&A.set(L,y)}return u.size>0||v.size>0||C.size>0||A.size>0||this.state.hasInvalidFaceColors()?new V(new Qe(this.board,u,v,C,A,!1),{type:"GeneralFaceColoring"}):null}else for(;this.dirtyEdges.size;){const s=this.dirtyEdges.values().next().value;this.dirtyEdges.delete(s);const o=this.state.getEdgeState(s);if(o!==f.WHITE){const r=s.forwardFace?this.state.getFaceColor(s.forwardFace):this.state.getOutsideColor(),c=s.reversedFace?this.state.getFaceColor(s.reversedFace):this.state.getOutsideColor();if(o===f.BLACK){if(this.state.getOppositeFaceColor(r)!==c)return new V(new se(W(this.state,r),W(this.state,c)),{type:"FaceColoringBlackEdge",edge:s})}else if(o===f.RED&&r!==c)return new V(new q(W(this.state,r),W(this.state,c)),{type:"FaceColoringRedEdge",edge:s})}}return null}clone(e){return new Le(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class re{constructor(e,t){F(this,"opposite",null);F(this,"faceColor",null);this.colorState=e,this.faces=t}}class xe{constructor(e,t){F(this,"dirtySectors",new Set);F(this,"edgeListener");this.board=e,this.state=t,e.halfEdges.forEach(s=>this.dirtySectors.add(s)),this.edgeListener=(s,o,r)=>{this.dirtySectors.add(s.forwardHalf),this.dirtySectors.add(s.forwardHalf.previous),this.dirtySectors.add(s.reversedHalf),this.dirtySectors.add(s.reversedHalf.previous)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener)}get dirty(){return this.dirtySectors.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtySectors.size;){const e=this.dirtySectors.values().next().value;this.dirtySectors.delete(e);const t=e.edge,s=e.next.edge,o=this.state.getEdgeState(t),r=this.state.getEdgeState(s),c=this.state.getSectorState(e);let n=c;const l=(o===f.WHITE?1:0)+(r===f.WHITE?1:0),i=(o===f.BLACK?1:0)+(r===f.BLACK?1:0),a=(o===f.RED?1:0)+(r===f.RED?1:0);if(l===0?n=I.getOnly(i):l===1&&(i&&n.zero&&(n=n.withDisallowZero()),a&&n.two&&(n=n.withDisallowTwo())),n!==c)return new V(new $(e,n),{type:l===1?"SingleEdgeToSector":"DoubleEdgeToSector",sector:e,beforeState:c,afterState:n})}return null}clone(e){return new xe(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener)}}class Ae{constructor(e,t){F(this,"dirtyVertices",new Set);F(this,"edgeListener");F(this,"sectorListener");F(this,"faceColorListener");this.board=e,this.state=t,e.vertices.forEach(s=>this.dirtyVertices.add(s)),this.edgeListener=(s,o,r)=>{this.dirtyVertices.add(s.start),this.dirtyVertices.add(s.end)},this.state.edgeStateChangedEmitter.addListener(this.edgeListener),this.sectorListener=(s,o,r)=>{this.dirtyVertices.add(s.end)},this.state.sectorStateChangedEmitter.addListener(this.sectorListener),this.faceColorListener=(s,o,r,c)=>{for(const n of c)for(const l of n.vertices)this.dirtyVertices.add(l);for(const n of r){const l=this.state.getFacesWithColor(n);for(const i of l)for(const a of i.vertices)this.dirtyVertices.add(a)}},this.state.faceColorsChangedEmitter.addListener(this.faceColorListener)}get dirty(){return this.dirtyVertices.size>0}nextAction(){if(!this.dirty)return null;for(;this.dirtyVertices.size;){const e=this.dirtyVertices.values().next().value;this.dirtyVertices.delete(e);const t=this.state.getVertexState(e),s=ae.fromEdgeColorSectorData(e,this.state).and(t);if(!t.equals(s))return new V(new Q(e,s),{type:"VertexState",vertex:e,beforeState:t,afterState:s})}return null}clone(e){return new Ae(this.board,e)}dispose(){this.state.edgeStateChangedEmitter.removeListener(this.edgeListener),this.state.sectorStateChangedEmitter.removeListener(this.sectorListener),this.state.faceColorsChangedEmitter.removeListener(this.faceColorListener)}}const Pe=(S,e,t)=>new X([new j(S,e),new Fe(S,e),new Le(S,e),new xe(S,e),new Ae(S,e)]),jt=new B("autoSolveEnabledProperty",!0),Ut=new B("autoSolveToBlackProperty",!1),qt=new B("autoSolveSimpleLoopsProperty",!1),nt=new B("autoSolveSimpleVertexJointToRedProperty",!0),at=new B("autoSolveSimpleVertexForcedLineToBlackProperty",!0),ct=new B("autoSolveSimpleVertexAlmostEmptyToRedProperty",!0),lt=new B("autoSolveSimpleFaceToRedProperty",!0),dt=new B("autoSolveSimpleFaceToBlackProperty",!0),ht=new B("autoSolveSimpleLoopToRedProperty",!0),ft=new B("autoSolveSimpleLoopToBlackProperty",!1),gt=new B("autoSolveDoubleMinusOneFacesProperty",!1),ut=new B("autoSolveStaticFaceSectorProperty",!0),pt=new B("autoSolveSimpleSectorProperty",!1),wt=new B("autoSolveVertexToRedEdgeProperty",!1),St=new B("autoSolveVertexToBlackEdgeProperty",!1),yt=new B("autoSolveVertexToSectorsProperty",!1),Ct=new B("autoSolveVertexToFaceColorProperty",!1),Et=new B("autoSolveFaceColorToRedProperty",!1),mt=new B("autoSolveFaceColorToBlackProperty",!1),vt=new B("autoSolveFaceColorParityToRedProperty",!1),Ft=new B("autoSolveFaceColorParityToBlackProperty",!1),Lt=new B("autoSolveFaceColorParityColorsProperty",!1),xt=new B("autoSolveFaceColorParityPartialReductionProperty",!1),At=new B("autoSolveVertexColorToFaceProperty",!1),Vt=new B("autoSolveFaceToRedProperty",!1),Tt=new B("autoSolveFaceToBlackProperty",!1),Rt=new B("autoSolveFaceToSectorsProperty",!1),Ot=new B("autoSolveFaceToFaceColorsProperty",!1),bt=new B("autoSolveFaceToVertexProperty",!1),Bt=(S,e,t)=>new X([Pe(S,e),new oe(S,e)]),ke=(S,e)=>{it(Bt,S,e,!0)},$t=new Xe([nt,at,ct,lt,dt,ht,ft,gt,ut,pt,wt,St,yt,Ct,Et,mt,vt,Ft,Lt,xt,At,Vt,Tt,Rt,Ot,bt],(S,e,t,s,o,r,c,n,l,i,a,h,d,u,C,E,v,A,k,w,L,y,p,T,g,m)=>(x,O,z)=>new X([...S||e||t?[new le(x,O,{solveJointToRed:S,solveForcedLineToBlack:e,solveAlmostEmptyToRed:t},z?void 0:[])]:[],...s||o?[new de(x,O,{solveToRed:s,solveToBlack:o},z?void 0:[])]:[],...n?[new ge(x,O,z?void 0:[])]:[],Pe(x,O),...l?[new pe(x,O,z?void 0:[])]:[],...i?[new ue(x,O,z?void 0:[])]:[],...r||c?[new he(x,O,{solveToRed:r,solveToBlack:c,resolveAllRegions:!1},z?void 0:[])]:[],...a||h?[new we(x,O,{solveToRed:a,solveToBlack:h},z?void 0:[])]:[],...d?[new Se(x,O,z?void 0:[])]:[],...C||E?[new ce(x,O,{solveToRed:C,solveToBlack:E},z?void 0:[])]:[],...v||A||k?[new fe(x,O,{solveToRed:v,solveToBlack:A,solveColors:k,allowPartialReduction:w},z?void 0:[])]:[],...u?[new ye(x,O,z?void 0:[])]:[],...L?[new oe(x,O,z?void 0:[])]:[],...y||p?[new Ce(x,O,{solveToRed:y,solveToBlack:p},z?void 0:[])]:[],...T?[new Ee(x,O,z?void 0:[])]:[],...g?[new me(x,O,z?void 0:[])]:[],...m?[new ve(x,O,z?void 0:[])]:[]]));class Me extends Error{constructor(e){super("Multiple solutions found"),this.solutionEdges=e}}class zt extends Error{constructor(){super("Too many iterations!")}}const Be=(S,e,t)=>{const s=e.clone();for(const o of t)s.setEdgeState(o,f.BLACK);return ke(S,s),{board:S,cleanState:e,solvedState:s,blackEdges:new Set(t)}},Gt=(S,e)=>{try{if(ne(e))return{board:S,stateProperty:new Ve(e),solution:Be(S,e,[])};const t=Pt(S,e,{maxIterations:1e4,failOnMultipleSolutions:!0});if(t.length!==1)return null;const s=t[0],o=e.clone();for(const r of s)o.setEdgeState(r,f.BLACK);return ke(S,o),b()&&R(ne(o)),{board:S,stateProperty:new Ve(e),solution:Be(S,e,s)}}catch(t){if(t instanceof Me)return null;throw t}},Pt=(S,e,t)=>{const s=S.edges.filter(g=>e.getEdgeState(g)===f.BLACK),o=S.edges.filter(g=>e.getEdgeState(g)===f.WHITE);b()&&R(o.length,"Need to have at least some undefined edges to use solver");const r=new Set(o),c=new Map(o.map((g,m)=>[g,`edge${m+1}`])),n=new Map(o.map((g,m)=>[`edge${m+1}`,g])),l=new K.Solver,i=g=>{const m=c.get(g);return b()&&R(m!==void 0,"Edge not found!"),m},a=g=>`-${i(g)}`,h=g=>{for(const m of g)l.require(K.not(i(m)))},d=g=>{l.require(K.or(...g.map(i)))},u=g=>{l.require(K.or(...g.map(a)))},C=(g,m)=>{m>0&&(d(g),Te.forEachCombination(g,x=>{x.length===g.length-m+1&&l.require(K.not(K.and(...x.map(a))))}))},E=(g,m)=>{Te.forEachCombination(g,x=>{x.length===m+1&&l.require(K.or(...x.map(a)))})},v=g=>{l.require(K.not(K.exactlyOne(...g.map(i))))},A=g=>{E(g,2),v(g)},k=(g,m)=>{m===0?h(g):(C(g,m),E(g,m))};d(o);for(const g of S.vertices){let m=0,x=0,O=[];for(const z of g.edges){const H=e.getEdgeState(z);H===f.BLACK?m++:H===f.WHITE&&(x++,O.push(z))}x!==0&&(m===0?A(O):m===1?k(O,1):h(O))}let w=!1;for(const g of S.faces){const m=e.getFaceValue(g);if(m===null)continue;w=!0;let x=0,O=0,z=[];for(const G of g.edges){const N=e.getEdgeState(G);N===f.BLACK?x++:N===f.WHITE&&(O++,z.push(G))}if(O===0)continue;const H=Math.max(m-x,0);k(z,H)}b()&&R(w,"No faces with values!");const L=()=>{let g=null;return K.disablingAssertions(()=>{g=l.solve()}),g?g.getTrueVars().map(x=>n.get(x)):null};let y=0;const p=()=>{const g=L();if(g===null)return{touchingValueLoops:[],nonTouchingValueLoops:[]};const m=new Set([...g,...s]),x=[],O=[];for(;m.size;){const z=m.values().next().value,H=[];let G=z.end,N=z,ie=!1;for(;N;)m.delete(N),H.push(N),ie=ie||N.faces.some(J=>e.getFaceValue(J)!==null),N=G.edges.find(J=>m.has(J))??null,N&&(G=N.getOtherVertex(G));b()&&R(H[0].vertices.some(J=>H[H.length-1].vertices.includes(J)),"Loop is not a loop!"),(ie?x:O).push(H)}return{touchingValueLoops:x,nonTouchingValueLoops:O}},T=[];for(;;){const g=p();if(!g.touchingValueLoops.length)break;if(g.touchingValueLoops.length===1&&(T.push(g.touchingValueLoops[0]),T.length>1&&t.failOnMultipleSolutions))throw new Me(T);const m=[...g.touchingValueLoops,...g.nonTouchingValueLoops];for(const x of m)u(x.filter(O=>r.has(O)));if(y++,y>t.maxIterations)throw new zt}return T};export{de as $,V as A,Ct as B,X as C,Et as D,mt as E,q as F,vt as G,Ft as H,P as I,Lt as J,xt as K,At as L,Vt as M,Tt as N,Rt as O,Ot as P,Ut as Q,qt as R,Kt as S,Me as T,ke as U,zt as V,xe as W,Ae as X,oe as Y,$t as Z,le as _,Gt as a,pe as a0,ce as a1,Pe as a2,ge as a3,ue as a4,we as a5,Se as a6,fe as a7,ye as a8,Ce as a9,Ee as aa,me as ab,ve as ac,$ as b,W as c,se as d,j as e,Fe as f,Be as g,Le as h,it as i,he as j,jt as k,nt as l,at as m,ct as n,lt as o,dt as p,ht as q,ft as r,Pt as s,gt as t,ut as u,pt as v,ot as w,wt as x,St as y,yt as z};
