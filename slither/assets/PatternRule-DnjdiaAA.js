var A=Object.defineProperty;var g=(u,t,e)=>t in u?A(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var n=(u,t,e)=>(g(u,typeof t!="symbol"?t+"":t,e),e);import{n as c,P as B,h as l}from"./FeatureSet-1wxomgJY.js";import{e as f,f as F}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{s as E,z as O,n as b,y as C,B as N,g as T}from"./patternBoards-DgFI8dKG.js";import{E as I,d as w}from"./Vector2Property-95p6aBvi.js";const s=class s extends I{};n(s,"INCOMPATIBLE",new s),n(s,"INCONSEQUENTIAL",new s),n(s,"DORMANT",new s),n(s,"ACTIONABLE",new s),n(s,"enumeration",new w(s));let a=s;const y=u=>u.name?u.name:E(u.descriptor),z=u=>{let t=O(u);if(t)return t;const e=b(u);return t=C(e),t||new N(e)};class p{constructor(t,e,r,i=!1){this.patternBoard=t,this.inputFeatureSet=e,this.outputFeatureSet=r,this.highlander=i}getInputDifficultyScoreA(){return this.inputFeatureSet.getInputDifficultyScoreA()+.75*this.patternBoard.vertices.length}embedded(t,e){const r=this.inputFeatureSet.embedded(t,e);if(r===null)return null;const i=this.outputFeatureSet.embedded(t,e);return i===null?null:new p(t,r,i,this.highlander)}getEmbeddedRules(t){return t.map(e=>this.embedded(e.targetPatternBoard,e)).filter(e=>e!==null)}isIsomorphicTo(t){if(this.patternBoard!==t.patternBoard||!this.inputFeatureSet.hasSameShapeAs(t.inputFeatureSet)||!this.outputFeatureSet.hasSameShapeAs(t.outputFeatureSet))return!1;const e=T(this.patternBoard,this.patternBoard);for(const r of e){const i=this.embedded(this.patternBoard,r);if(i&&i.inputFeatureSet.equals(t.inputFeatureSet)&&i.outputFeatureSet.equals(t.outputFeatureSet))return!0}return!1}isSubsetOf(t){return this.inputFeatureSet.isSubsetOf(t.inputFeatureSet)&&this.outputFeatureSet.isSubsetOf(t.outputFeatureSet)}matches(t){return this.inputFeatureSet.isSubsetOf(t)}getMatchState(t){const e=this.inputFeatureSet.getQuickCompatibilityWith(t);return e===c.INCOMPATIBLE||e===c.NO_MATCH_NEEDS_FACE_VALUES?a.INCOMPATIBLE:this.outputFeatureSet.isSubsetOf(t)?a.INCONSEQUENTIAL:e===c.NO_MATCH_NEEDS_STATE?a.DORMANT:a.ACTIONABLE}isRedundant(t){if(this.isTrivial())return!0;const e=this.outputFeatureSet,r=t.filter(i=>i.outputFeatureSet.isSubsetOf(e));return this.outputFeatureSet.isSubsetOf(p.withRulesApplied(this.patternBoard,this.inputFeatureSet,r))}hasApplication(t){return this.matches(t)&&!this.outputFeatureSet.isSubsetOf(t)}apply(t){f()&&F(this.hasApplication(t)),t.applyFeaturesFrom(this.outputFeatureSet)}isTrivial(){return this.outputFeatureSet.isSubsetOf(this.inputFeatureSet)}isCorrectSlow(){const t=B.countSolutions(this.patternBoard,this.inputFeatureSet.getFeaturesArray()),e=B.countSolutions(this.patternBoard,this.outputFeatureSet.getFeaturesArray());return t===e}toCanonicalString(){return`rule:${this.inputFeatureSet.toCanonicalString()}->${this.outputFeatureSet.toCanonicalString()}`}serialize(){const t={patternBoard:y(this.patternBoard),input:this.inputFeatureSet.serialize(),output:this.outputFeatureSet.serialize()};return this.highlander&&(t.highlander=!0),t}collectionSerialize(t){return{...this.serialize(),patternBoard:t}}static deserialize(t){const e=z(t.patternBoard);return new p(e,l.deserialize(t.input,e),l.deserialize(t.output,e),t.highlander??!1)}static collectionDeserialize(t,e){const r=t[e.patternBoard];return f()&&F(r,"pattern board"),new p(r,l.deserialize(e.input,r),l.deserialize(e.output,r),e.highlander??!1)}static withRulesApplied(t,e,r){f()&&F(r.every(o=>o.patternBoard===t),"embedding check");let i=r,d=[];const h=e.clone();let S=!0;for(;S;){S=!1;for(const o of i){const m=o.getMatchState(h);m===a.ACTIONABLE?(o.apply(h),S=!0):m===a.DORMANT&&d.push(o)}i=d,d=[]}return h}}export{p as P,z as d,y as s};
