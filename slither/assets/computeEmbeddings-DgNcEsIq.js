var se=Object.defineProperty;var ne=(g,e,t)=>e in g?se(g,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):g[e]=t;var Q=(g,e,t)=>(ne(g,typeof e!="symbol"?e+"":e,t),t);import{a as r,b as n,_ as H}from"./createBoardDescriptor-DQiPBFka.js";class ee{constructor(e,t,d,s,v,l,O){Q(this,"isAutomorphism");Q(this,"isIdentityAutomorphism");Q(this,"vertexInverseMap");Q(this,"edgeInverseMap");Q(this,"sectorInverseMap");Q(this,"faceInverseMap");this.sourcePatternBoard=e,this.targetPatternBoard=t,this.vertexMap=d,this.nonExitEdgeMap=s,this.exitEdgeMap=v,this.sectorMap=l,this.faceMap=O,this.isAutomorphism=e===t,this.isAutomorphism&&(this.vertexInverseMap=new Map(Array.from(d).map(([F,i])=>[i,F])),this.sectorInverseMap=new Map(Array.from(l).map(([F,i])=>[i,F])),this.faceInverseMap=new Map(Array.from(O).map(([F,i])=>[i,F])),this.edgeInverseMap=new Map([...Array.from(s).map(([F,i])=>[i,F]),...Array.from(v).map(([F,i])=>(r()&&n(i.length===1),[i[0],F]))])),this.isIdentityAutomorphism=this.computeIsIdentityAutomorphism()}static fromMaps(e,t,d,s,v,l,O){return new ee(e,t,d,s,v,l,O)}getVertexMap(){return this.vertexMap}getNonExitEdgeMap(){return this.nonExitEdgeMap}getExitEdgeMap(){return this.exitEdgeMap}getSectorMap(){return this.sectorMap}getFaceMap(){return this.faceMap}mapVertex(e){const t=this.vertexMap.get(e);return r()&&n(t),t}mapNonExitEdge(e){const t=this.nonExitEdgeMap.get(e);return r()&&n(t),t}mapExitEdges(e){const t=this.exitEdgeMap.get(e);return r()&&n(t),t}mapSector(e){const t=this.sectorMap.get(e);return r()&&n(t),t}mapFace(e){const t=this.faceMap.get(e);return r()&&n(t),t}inverseMapVertex(e){const t=this.vertexInverseMap.get(e);return r()&&n(t),t}inverseMapEdge(e){const t=this.edgeInverseMap.get(e);return r()&&n(t),t}inverseMapSector(e){const t=this.sectorInverseMap.get(e);return r()&&n(t),t}inverseMapFace(e){const t=this.faceInverseMap.get(e);return r()&&n(t),t}equals(e){return this.vertexMap.size===e.vertexMap.size&&this.nonExitEdgeMap.size===e.nonExitEdgeMap.size&&this.exitEdgeMap.size===e.exitEdgeMap.size&&this.sectorMap.size===e.sectorMap.size&&this.faceMap.size===e.faceMap.size&&Array.from(this.vertexMap).every(([t,d])=>e.vertexMap.get(t)===d)&&Array.from(this.nonExitEdgeMap).every(([t,d])=>e.nonExitEdgeMap.get(t)===d)&&Array.from(this.exitEdgeMap).every(([t,d])=>e.exitEdgeMap.get(t)===d)&&Array.from(this.sectorMap).every(([t,d])=>e.sectorMap.get(t)===d)&&Array.from(this.faceMap).every(([t,d])=>e.faceMap.get(t)===d)}toString(){return`Embedding(
  vertexMap: ${[...this.vertexMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
  nonExitEdgeMap: ${[...this.nonExitEdgeMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  exitEdgeMap: ${[...this.exitEdgeMap].map(e=>`${e[0].index} => [${e[1].map(t=>t.index).join(", ")}]`).join(", ")}
  sectorMap: ${[...this.sectorMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  faceMap: ${[...this.faceMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
)`}computeIsIdentityAutomorphism(){if(this.sourcePatternBoard!==this.targetPatternBoard)return!1;for(const e of this.vertexMap.keys())if(this.vertexMap.get(e)!==e)return!1;for(const e of this.nonExitEdgeMap.keys())if(this.nonExitEdgeMap.get(e)!==e)return!1;for(const e of this.exitEdgeMap.keys())if(this.exitEdgeMap.get(e).length!==1||this.exitEdgeMap.get(e)[0]!==e)return!1;for(const e of this.sectorMap.keys())if(this.sectorMap.get(e)!==e)return!1;for(const e of this.faceMap.keys())if(this.faceMap.get(e)!==e)return!1;return!0}}const ce=(g,e)=>{if(g.faces.filter(s=>!s.isExit).length>e.faces.filter(s=>!s.isExit).length||g.sectors.length>e.sectors.length||g.edges.filter(s=>!s.isExit).length>e.edges.filter(s=>!s.isExit).length||g.vertices.length>e.vertices.length)return[];const t=[],d=g.faces.filter(s=>!s.isExit);if(d.length){const s=d[0],v=[s],l=[],O=[],F=new Set(d.slice(1)),i=new Set(s.edges),q=new Set(s.vertices);for(;F.size;){const o=H.maxBy([...F],a=>{let A=0;for(const z of a.edges)i.has(z)&&(A+=5);for(const z of a.vertices)q.has(z)&&(A+=1);return A});r()&&n(o),v.push(o),l.push(H.findIndex(o.edges,a=>i.has(a))),O.push(H.findIndex(o.vertices,a=>q.has(a))),F.delete(o);for(const a of o.edges)i.add(a);for(const a of o.vertices)q.add(a)}const C=(o,a,A)=>{if(o.edges.length!==a.edges.length)return!1;for(let z=0;z<o.edges.length;z++){const j=o.edges[z],V=a.edges[A.mapEdgeIndex(z)];r()&&n(j.faces.includes(o)),r()&&n(V.faces.includes(a));const f=j.faces[0]===o?j.faces[1]:j.faces[0];if(!f.isExit){const p=V.faces[0]===a?V.faces[1]:V.faces[0];if(p.isExit||f.edges.length!==p.edges.length)return!1}}return!0};for(const o of e.faces)if(!o.isExit&&o.edges.length===s.edges.length)for(const a of X.allForOrder(o.edges.length)){if(!C(s,o,a))continue;const A=new Map,z=new Map,j=new Map,V=new Map,f=new Map;A.set(s,a),z.set(s,o),j.set(o,s);for(let x=0;x<s.vertices.length;x++){const w=s.vertices[x],E=o.vertices[a.mapVertexIndex(x)];V.set(w,E),f.set(E,w)}const p=(x,w,E,S,M,P)=>{if(r()&&n(M.size===P.size),x===v.length){r()&&n(M.size===g.vertices.length);const c=new Map,D=new Set;for(const[h,m]of E){const u=w.get(h);for(let y=0;y<h.edges.length;y++){const B=h.edges[y],I=m.edges[u.mapEdgeIndex(y)];r()&&c.has(B)&&n(c.get(B)===I),c.set(B,I),D.add(I)}}r()&&n(c.size===g.edges.filter(h=>!h.isExit).length);const Y=new Map;for(const h of g.edges.filter(m=>m.isExit)){const m=h.exitVertex;r()&&n(m);const u=M.get(m);r()&&n(u),Y.set(h,u.edges.filter(y=>!D.has(y)))}for(const h of g.faces.filter(m=>m.isExit)){const m=h.edges[0];r()&&n(m&&h.edges.length===1);const u=c.get(m),y=m.faces[0]===h?m.faces[1]:m.faces[0],B=E.get(y),I=u.faces[0]===B?u.faces[1]:u.faces[0];r()&&n(I),E.set(h,I)}const k=new Map;for(const h of g.sectors){const m=h.face,u=E.get(m);r()&&n(u);const y=h.edges[0],B=h.edges[1],I=c.get(y),R=c.get(B);r()&&n(I&&R);const $=u.sectors.find(N=>N.edges.includes(I)&&N.edges.includes(R));r()&&n($),k.set(h,$)}t.push(ee.fromMaps(g,e,M,c,Y,k,E))}else{const c=v[x],D=l[x-1],Y=O[x-1];if(D>=0){const k=c.edges[D],h=k.vertices[0],m=k.vertices[1],u=M.get(h),y=M.get(m),B=k.faces[0]===c?k.faces[1]:k.faces[0],I=E.get(B);r()&&n(I);const R=I.edges.find(L=>L.vertices.includes(u)&&L.vertices.includes(y));r()&&n(R);const $=R.faces[0]===I?R.faces[1]:R.faces[0];if($.isExit||S.has($))return;const N=c.vertices.indexOf(h),G=c.vertices.indexOf(m),U=$.vertices.indexOf(u),W=$.vertices.indexOf(y),Z=(N+1)%c.vertices.length===G,te=(U+1)%$.vertices.length===W,J=Z===te?1:-1,K=(U-N*J+c.vertices.length)%c.vertices.length,T=new X(c.vertices.length,K,J);if(r()&&n(T.mapVertexIndex(N)===U),r()&&n(T.mapVertexIndex(G)===W),!C(c,$,T)||(E.set(c,$),S.set($,c),E.size!==S.size))return;for(let L=0;L<c.vertices.length;L++){const _=c.vertices[L],b=$.vertices[T.mapVertexIndex(L)];if(M.has(_)){if(M.get(_)!==b)return}else M.set(_,b);if(P.has(b)){if(P.get(b)!==_)return}else P.set(b,_);r()&&n(M.size===P.size)}w.set(c,T),p(x+1,w,E,S,M,P)}else{r()&&n(Y>=0,"If this is not satisfied, we have disconnected components OR orderedFaces order is bad");const k=c.vertices[Y],h=M.get(k),m=h.faces.filter(u=>!u.isExit&&!S.has(u));for(const u of m){const y=c.vertices.indexOf(k),B=u.vertices.indexOf(h);r()&&n(y>=0),r()&&n(B>=0);for(const I of[1,-1]){const R=(B-y*I+c.vertices.length)%c.vertices.length,$=new X(c.vertices.length,R,I);if(!C(c,u,$))continue;let N=!0;const G=new Map(M),U=new Map(P);for(let J=0;J<c.vertices.length;J++){const K=c.vertices[J],T=u.vertices[$.mapVertexIndex(J)];if(G.has(K)){if(G.get(K)!==T){N=!1;break}}else G.set(K,T);if(U.has(T)){if(U.get(T)!==K){N=!1;break}}else U.set(T,K);r()&&n(G.size===U.size)}if(!N)continue;const W=new Map(E),Z=new Map(S);if(W.set(c,u),Z.set(u,c),W.size!==Z.size)continue;const te=new Map(w);te.set(c,$),p(x+1,te,W,Z,G,U)}}}}};p(1,A,z,j,V,f)}}else if(g.vertices.length===1){const s=g.vertices[0];r()&&n(s.edges.length===g.edges.length);const v=s.edges.filter(i=>!i.isExit),l=s.edges.filter(i=>!i.isExit).length,O=s.isExit,F=H.range(0,l).map(i=>{const q=v[i],C=v.slice(0,i+1);return s.sectors.filter(o=>o.edges.includes(q)&&o.edges.every(a=>C.includes(a)))});if(r()&&n(F.flat().length===s.sectors.length),r()&&!s.isExit){n(s.sectors.length===l);for(let i=0;i<l;i++){const q=s.edges[i],C=s.edges[(i+1)%l],o=s.sectors[i],a=s.faces[i];n(o.edges.includes(q)),n(o.edges.includes(C)),n(o.face===a)}}for(const i of e.vertices){if(O){if(i.edges.length<l||i.sectors.length<s.sectors.length)continue}else{if(i.isExit||i.edges.length!==l)continue;r()&&n(i.sectors.length===l)}const q=new Map([[s,i]]),C=(o,a,A,z)=>{if(o===l){r()&&n(a.size===v.length),r()&&n(A.size===g.sectors.length);const j=O?new Map([[s.exitEdge,i.edges.filter(f=>!z.has(f))]]):new Map,V=new Map([...A.keys()].map(f=>[f.face,A.get(f).face]));if(s.sectors.length===0)for(const[f,p]of a){const x=f.faces[0],w=f.faces[1];r()&&n(x.isExit&&w.isExit),V.set(x,p.faces[0]),V.set(w,p.faces[1])}else if(O){for(const f of g.faces.filter(p=>p.isExit))if(f.edges.length===1){const p=f.edges[0];r()&&n(p&&f.edges.length===1);const x=a.get(p);r()&&n(x);const w=p.faces[0]===f?p.faces[1]:p.faces[0],E=V.get(w);r()&&n(E);const S=x.faces[0]===E?x.faces[1]:x.faces[0];r()&&n(S),V.set(f,S)}}else for(const f of g.sectors){const p=f.face,w=A.get(f).face;V.set(p,w)}t.push(ee.fromMaps(g,e,q,a,j,A,V))}else{const j=v[o],V=F[o];for(const f of i.edges){if(f.isExit||z.has(f))continue;const p=[];let x=!0;for(const w of V){const E=w.edges[0],S=w.edges[1],M=E===j?f:a.get(E),P=S===j?f:a.get(S);r()&&n(M&&P);const c=i.sectors.find(D=>D.edges.includes(M)&&D.edges.includes(P)&&(l>2||!p.includes(D)))??null;if(c)p.push(c);else{x=!1;break}}if(x){const w=new Map(a);w.set(j,f);const E=new Map(A);for(let M=0;M<V.length;M++)E.set(V[M],p[M]);const S=new Set(z);S.add(f),C(o+1,w,E,S)}}}};C(0,new Map,new Map,new Set)}}else if(g.vertices.length===0&&g.edges.length===1){const s=g.edges[0];for(const v of e.edges.filter(l=>!l.isExit))t.push(ee.fromMaps(g,e,new Map,new Map([[s,v]]),new Map,new Map,new Map([[s.faces[0],v.faces[0]],[s.faces[1],v.faces[1]]])))}else throw new Error("pattern search not implemented generally yet");return r()&&g===e&&n(t.filter(s=>s.isIdentityAutomorphism).length===1),t};class X{constructor(e,t,d){this.edgeCount=e,this.offset=t,this.direction=d,r()&&n(d===1||d===-1)}mapVertexIndex(e){return(this.offset+e*this.direction+this.edgeCount)%this.edgeCount}mapEdgeIndex(e){return this.direction===1?(this.offset+e)%this.edgeCount:(this.offset-e-1+2*this.edgeCount)%this.edgeCount}toString(){return`FaceMapping( edgeCount=${this.edgeCount}, offset=${this.offset}, direction=${this.direction} )`}toDetailedString(e,t){return`FaceMapping( vertices: ${H.range(0,this.edgeCount).map(d=>`${e.vertices[d].index} => ${t.vertices[this.mapVertexIndex(d)].index}`).join(", ")}, edges: ${H.range(0,this.edgeCount).map(d=>{const s=e.edges[d],v=t.edges[this.mapEdgeIndex(d)];return`#${s.index} (${s.vertices.map(l=>l.index).join(",")}) => #${v.index} (${v.vertices.map(l=>l.index).join(",")})`}).join(", ")} )`}static allForOrder(e){return[...H.range(0,e).map(t=>new X(e,t,1)),...H.range(0,e).map(t=>new X(e,t,-1))]}}export{ce as c};
