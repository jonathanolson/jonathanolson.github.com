var is=Object.defineProperty;var rs=(u,t,e)=>t in u?is(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var K=(u,t,e)=>(rs(u,typeof t!="symbol"?t+"":t,e),e);import{z as Q,ab as as,a as qt,O as Ft,N as ls,D as O,t as Pe,ai as D,M as Ne,S as os,V as E,aj as Kt,ak as Ht,T as Me,o as Se,B as ot,b as Bt,E as hs,d as us,a6 as We,c as Le,g as cs,a8 as Xt}from"./Vector2Property-DCXaH-JP.js";function ds(u,t,e,s,i){assert&&assert(Array.isArray(u)&&_.uniq(u).length===u.length,"a is not an array of unique items"),assert&&assert(Array.isArray(t)&&_.uniq(t).length===t.length,"b is not an array of unique items"),e=e||[],s=s||[],i=i||[],assert&&assert(Array.isArray(e)&&e.length===0),assert&&assert(Array.isArray(s)&&s.length===0),assert&&assert(Array.isArray(i)&&i.length===0),Array.prototype.push.apply(e,u),Array.prototype.push.apply(s,t);t:for(let r=0;r<e.length;r++){const a=e[r];for(let l=0;l<s.length;l++){const o=s[l];if(a===o){if(i.push(a),e.splice(r,1),s.splice(l,1),l=0,r===e.length)break t;r-=1}}}return e}Q.register("arrayDifference",ds);const gs=(u,t)=>{assert&&u&&t.forEach(e=>{assert&&assert(Object.getOwnPropertyDescriptor(u,e)||_.some(as(u.constructor).map(s=>Object.getOwnPropertyDescriptor(s.prototype,e))),`property not defined: ${e}`)})};Q.register("assertHasProperties",gs);class fs{constructor(){this.pendingLocks=[],this.loadComplete=!1,this.listeners=[]}reset(){this.loadComplete=!1}addListener(t){this.listeners.push(t)}proceedIfReady(){this.pendingLocks.length===0&&(assert&&assert(!this.loadComplete,"cannot complete load twice"),this.loadComplete=!0,this.listeners.forEach(t=>t()))}createLock(t){return assert&&assert(!this.loadComplete,"Cannot create more locks after load-step has completed"),this.pendingLocks.push(t),()=>{assert&&assert(this.pendingLocks.includes(t),"invalid lock"),qt(this.pendingLocks,t),this.proceedIfReady()}}}const Qe=new fs;Q.register("asyncLoader",Qe);function _t(u){if(assert&&assert(!u||Array.isArray(u),"cleanArray either takes an Array"),u){for(;u.length;)u.pop();return u}else return[]}Q.register("cleanArray",_t);function ps(u){const t=[];return u(e=>{t.push(e)}),t}Q.register("collect",ps);function Ee(u){if(Array.isArray(u))return u.map(Ee);if(typeof u!="object"||u===null)return u;const t={};return Object.keys(u).sort().forEach(e=>{const s=u[e];t[e]=Ee(s)}),t}Q.register("copyWithSortedKeys",Ee);function ms(u,t){if(u[t]!==void 0)return t;if(t=t.charAt(0).toUpperCase()+t.slice(1),u[`moz${t}`]!==void 0)return`moz${t}`;if(u[`Moz${t}`]!==void 0)return`Moz${t}`;if(u[`webkit${t}`]!==void 0)return`webkit${t}`;if(u[`ms${t}`]!==void 0)return`ms${t}`;if(u[`o${t}`]!==void 0)return`o${t}`}Q.register("detectPrefix",ms);function _s(u,t){if(u[`on${t}`]!==void 0)return t;if(u[`onmoz${t}`]!==void 0)return`moz${t}`;if(u[`onMoz${t}`]!==void 0)return`Moz${t}`;if(u[`onwebkit${t}`]!==void 0)return`webkit${t}`;if(u[`onms${t}`]!==void 0)return`ms${t}`;if(u[`ono${t}`]!==void 0)return`o${t}`}Q.register("detectPrefixEvent",_s);function vs(u,t,e){const s=[];function i(r,a){return a.forEach((l,o)=>{s.push(o),r===1?e(l,...s):i(r-1,l),s.pop()})}return i(u,t)}Q.register("dimensionForEach",vs);function As(u,t,e){const s=[];function i(r,a){return a.map((l,o)=>{s.push(o);const h=r===1?e(l,...s):i(r-1,l);return s.pop(),h})}return i(u,t)}Q.register("dimensionMap",As);class _e{constructor(t,e){this._map=new Map,this._enumeration=t,this._values=t.enumeration.values,this._values.forEach(s=>{assert&&assert(!this._map.has(s),"Enumeration key override problem"),this._map.set(s,e(s))})}get(t){return assert&&assert(this._values.includes(t)),assert&&assert(this._map.has(t)),this._map.get(t)}set(t,e){assert&&assert(this._values.includes(t)),this._map.set(t,e)}map(t){return new _e(this._enumeration,e=>t(this.get(e),e))}forEach(t){this._values.forEach(e=>t(this.get(e),e))}values(){return this._values.map(t=>this.get(t))}}Q.register("EnumerationMap",_e);function bs(u){return u.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;")}Q.register("escapeHTML",bs);const ee=class ee{constructor(t,e){this.eventModel=t,this.eventCallback=e,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period}step(t){for(;t>=this.timeBeforeNextEvent;)t-=this.timeBeforeNextEvent,this.period=this.eventModel.getPeriodBeforeNextEvent(),this.timeBeforeNextEvent=this.period,this.eventCallback(t);this.timeBeforeNextEvent-=t}getRatio(){return(this.period-this.timeBeforeNextEvent)/this.period}};ee.ConstantEventModel=class{constructor(e){this.rate=e,assert&&assert(e>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){return 1/this.rate}},ee.UniformEventModel=class{constructor(e,s){this.rate=e,this.pseudoRandomNumberSource=s,assert&&assert(e>0,"We need to have a strictly positive rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const e=this.pseudoRandomNumberSource();return assert&&assert(e>=0&&e<1,`Our uniform random number is outside of its expected range with a value of ${e}`),e*2/this.rate}},ee.PoissonEventModel=class{constructor(e,s){this.rate=e,this.pseudoRandomNumberSource=s,assert&&assert(e>0,"We need to have a strictly positive poisson rate in order to prevent infinite loops.")}getPeriodBeforeNextEvent(){const e=this.pseudoRandomNumberSource();return assert&&assert(e>=0&&e<1,`Our uniform random number is outside of its expected range with a value of ${e}`),-Math.log(e)/this.rate}};let Te=ee;Q.register("EventTimer",Te);function ws(u,...t){return _.each(t,e=>{if(e)for(const s in e){const i=Object.getOwnPropertyDescriptor(e,s);i&&(typeof i.get=="function"||e[s]!==void 0)&&Object.defineProperty(u,s,i)}}),u}Q.register("extendDefined",ws);const Ge=u=>{assert&&assert(u.trim()===u,"path must be trimmed");const t=_.get(window,u);return t!==void 0?t:null};Q.register("getGlobal",Ge);const xs=u=>{assert&&assert(u.split(".").length>1,"path must have multiple parts"),assert&&assert(u.trim()===u,"path must be trimmed");const t=u.split("."),e=t.pop(),s=_.get(window,t);return s?s[e].bind(s):null};Q.register("gracefulBind",xs);function ys(u){return u}Q.register("identity",ys);function Ps(u,t){assert&&assert(Array.isArray(u));const e=[],s=u.length*2-1;for(let i=0;i<s;i++)i%2===0?e.push(u[i/2]):e.push(t((i-1)/2));return e}Q.register("interleave",Ps);function Ss(u){const t=typeof u=="string"?{src:u}:u,e=t.src,s=t.callback,i=t.async===void 0?!0:t.async,r=t.cacheBust===void 0?!1:t.cacheBust;let a=!1;const l=document.createElement("script");l.type="text/javascript",l.async=i,l.onload=l.onreadystatechange=function(){const h=this.readyState;h&&h!=="complete"&&h!=="loaded"||a||(a=!0,s&&s())},l.src=e+(r?`?random=${Math.random().toFixed(10)}`:"");const o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(l,o)}Q.register("loadScript",Ss);function Es(u){phet.log&&phet.log(`${u}: ${JSON.stringify(Ge(u),null,2)}`)}Q.register("logGlobal",Es);function Ts(u){const t=new Map;return e=>{if(t.has(e))return t.get(e);{const s=u(e);return t.set(e,s),s}}}Q.register("memoize",Ts);class Is{constructor(t,e,s){this.width=t,this.height=e,this.url=s,this.img=new Image;const i=Qe.createLock(this.img);this.img.onload=i,this.img.src=this.url,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height;const r=this.canvas.getContext("2d");this.updateCanvas=()=>{this.img.complete&&(typeof this.img.naturalWidth>"u"||this.img.naturalWidth>0)&&(r.drawImage(this.img,0,0),delete this.updateCanvas)}}}Q.register("MipmapElement",Is);function Cs(u,t,e){assert&&assert(u),assert&&assert(Array.isArray(t)),e&&(assert&&assert(Object.getPrototypeOf(e)===Object.prototype,"Extra prototype on options object is a code smell"),_.each(t,s=>{assert&&assert(!e.hasOwnProperty(s)||e[s]!==void 0,`Undefined not allowed for key: ${s}`),e[s]!==void 0&&(u[s]=e[s])}))}Q.register("mutate",Cs);class te extends _e{constructor(t,e){super(Ft,s=>s===Ft.HORIZONTAL?t:e)}get horizontal(){return this.get(Ft.HORIZONTAL)}set horizontal(t){this.set(Ft.HORIZONTAL,t)}get vertical(){return this.get(Ft.VERTICAL)}set vertical(t){this.set(Ft.VERTICAL,t)}with(t,e){return new te(t===Ft.HORIZONTAL?e:this.horizontal,t===Ft.VERTICAL?e:this.vertical)}static create(t){return new te(t(Ft.HORIZONTAL),t(Ft.VERTICAL))}map(t){return new te(t(this.horizontal,Ft.HORIZONTAL),t(this.vertical,Ft.VERTICAL))}}Q.register("OrientationPair",te);function Ms(u){const t=[],e=u.length;if(e>1)for(let s=0;s<e-1;s++){const i=u[s];for(let r=s+1;r<e;r++)t.push([i,u[r]])}return t}Q.register("pairs",Ms);function Fs(u,t){assert&&assert(Array.isArray(u));const e=[],s=[],i=u.length;for(let r=0;r<i;r++)t(u[r])?e.push(u[r]):s.push(u[r]);return[e,s]}Q.register("partition",Fs);const Rs={GRAVITATIONAL_CONSTANT:66743e-15,GRAVITY_ON_EARTH:9.81};Q.register("PhysicalConstants",Rs);const W=navigator.userAgent;function be(u){return Ze()===u}function Oe(){return!!(window.phet&&phet.chipper&&phet.chipper.queryParameters&&phet.chipper.queryParameters["phet-app"]||(W.match(/(iPod|iPhone|iPad)/)||navigator.platform==="MacIntel"&&navigator.maxTouchPoints>=2)&&W.match(/AppleWebKit/))}function Ze(){let u=-1,t=null;return navigator.appName==="Microsoft Internet Explorer"?(t=new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})"),t.exec(W)!==null&&(u=parseFloat(RegExp.$1))):navigator.appName==="Netscape"&&(t=new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"),t.exec(W)!==null&&(u=parseFloat(RegExp.$1))),u}const Vs={firefox:W.toLowerCase().includes("firefox"),mobileSafari:Oe(),safari5:!!(W.match(/Version\/5\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari6:!!(W.match(/Version\/6\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari7:!!(W.match(/Version\/7\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari10:!!(W.match(/Version\/10\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari11:!!(W.match(/Version\/11\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari9:!!(W.match(/Version\/9\./)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),safari:Oe()||!!(W.match(/Version\//)&&W.match(/Safari\//)&&W.match(/AppleWebKit/)),ie:Ze()!==-1,ie9:be(9),ie10:be(10),ie11:be(11),android:W.indexOf("Android")>0,edge:!!W.match(/Edge\//),chromium:/chrom(e|ium)/.test(W.toLowerCase())&&!W.match(/Edge\//),chromeOS:W.indexOf("CrOS")>0,mac:navigator.platform.includes("Mac")};Q.register("platform",Vs);function $s(u){return assert&&assert(u!==void 0,"Required field is undefined."),u}Q.register("required",$s);function Bs(u){return u.replace(/\u202a|\u202b|\u202c/g,"")}Q.register("stripEmbeddingMarks",Bs);const we={};function Ns(u,t,e){const s=we;let i=s,r=s;return u.hasOwnProperty(t)&&(i=u[t]),u.hasOwnProperty(e)&&(r=u[e]),i!==we?u[e]=i:delete u[e],r!==we?u[t]=r:delete u[t],u}Q.register("swapObjectKeys",Ns);const Y=new ls("kite"),Ls=O.lineLineIntersection,Os={lineWidth:1,lineCap:"butt",lineJoin:"miter",lineDash:[],lineDashOffset:0,miterLimit:10};class ve{constructor(t){const e=Pe({},Os,t);this.lineWidth=e.lineWidth,this.lineCap=e.lineCap,this.lineJoin=e.lineJoin,this.lineDash=e.lineDash,this.lineDashOffset=e.lineDashOffset,this.miterLimit=e.miterLimit,assert&&assert(typeof this.lineWidth=="number",`lineWidth should be a number: ${this.lineWidth}`),assert&&assert(isFinite(this.lineWidth),`lineWidth should be a finite number: ${this.lineWidth}`),assert&&assert(this.lineWidth>=0,`lineWidth should be non-negative: ${this.lineWidth}`),assert&&assert(this.lineCap==="butt"||this.lineCap==="round"||this.lineCap==="square",`Invalid lineCap: ${this.lineCap}`),assert&&assert(this.lineJoin==="miter"||this.lineJoin==="round"||this.lineJoin==="bevel",`Invalid lineJoin: ${this.lineJoin}`),assert&&assert(Array.isArray(this.lineDash),`lineDash should be an array: ${this.lineDash}`),assert&&assert(_.every(this.lineDash,s=>typeof s=="number"&&isFinite(s)&&s>=0),`Every lineDash should be a non-negative finite number: ${this.lineDash}`),assert&&assert(typeof this.lineDashOffset=="number",`lineDashOffset should be a number: ${this.lineDashOffset}`),assert&&assert(isFinite(this.lineDashOffset),`lineDashOffset should be a finite number: ${this.lineDashOffset}`),assert&&assert(typeof this.miterLimit=="number",`miterLimit should be a number: ${this.miterLimit}`),assert&&assert(isFinite(this.miterLimit),`miterLimit should be a finite number: ${this.miterLimit}`)}equals(t){if(!(this.lineWidth===t.lineWidth&&this.lineCap===t.lineCap&&this.lineJoin===t.lineJoin&&this.miterLimit===t.miterLimit&&this.lineDashOffset===t.lineDashOffset))return!1;if(this.lineDash.length===t.lineDash.length){for(let s=0;s<this.lineDash.length;s++)if(this.lineDash[s]!==t.lineDash[s])return!1}else return!1;return!0}copy(){return new ve({lineWidth:this.lineWidth,lineCap:this.lineCap,lineJoin:this.lineJoin,lineDash:this.lineDash,lineDashOffset:this.lineDashOffset,miterLimit:this.miterLimit})}leftJoin(t,e,s){e=e.normalized(),s=s.normalized();const i=t.plus(e.perpendicular.negated().times(this.lineWidth/2)),r=t.plus(s.perpendicular.negated().times(this.lineWidth/2)),a=i.equals(r)?[]:[new F(i,r)];let l,o,h;if(e.perpendicular.dot(s)>1e-12)switch(this.lineJoin){case"round":return l=e.angle+Math.PI/2,o=s.angle+Math.PI/2,[new H(t,this.lineWidth/2,l,o,!0)];case"miter":if(h=e.angleBetween(s.negated()),1/Math.sin(h/2)<=this.miterLimit&&h<Math.PI-1e-5){const g=Ls(i,i.plus(e),r,r.plus(s));return g?[new F(i,g),new F(g,r)]:[new F(i,r)]}else return a;case"bevel":return a;default:throw new Error(`invalid lineJoin: ${this.lineJoin}`)}else return a}rightJoin(t,e,s){return this.leftJoin(t,s.negated(),e.negated())}cap(t,e){e=e.normalized();const s=t.plus(e.perpendicular.times(-this.lineWidth/2)),i=t.plus(e.perpendicular.times(this.lineWidth/2));let r,a,l,o,h,g;switch(this.lineCap){case"butt":return[new F(s,i)];case"round":return r=e.angle,[new H(t,this.lineWidth/2,r+Math.PI/2,r-Math.PI/2,!0)];case"square":return a=e.perpendicular.negated().times(this.lineWidth/2),l=e.perpendicular.times(this.lineWidth/2),o=e.times(this.lineWidth/2),h=t.plus(a).plus(o),g=t.plus(l).plus(o),[new F(s,h),new F(h,g),new F(g,i)];default:throw new Error(`invalid lineCap: ${this.lineCap}`)}}}Y.register("LineStyles",ve);class Qt{constructor(t,e){assert&&assert(isFinite(t)&&t!==0,"a should be a finite non-zero number"),assert&&assert(isFinite(e),"b should be a finite number"),this.a=t,this.b=e;let s=0,i=1,r=this.apply(s),a=this.apply(i);r>1&&(r=1,s=this.applyInverse(r)),r<0&&(r=0,s=this.applyInverse(r)),a>1&&(a=1,i=this.applyInverse(a)),a<0&&(a=0,i=this.applyInverse(a)),this.t0=s,this.t1=i,t>0?(this.qt0=r,this.qt1=a):(this.qt0=a,this.qt1=r),this.t0<0&&this.t0>-1e-8&&(this.t0=0),this.t0>1&&this.t0<1+1e-8&&(this.t0=1),this.t1<0&&this.t1>-1e-8&&(this.t1=0),this.t1>1&&this.t1<1+1e-8&&(this.t1=1),this.qt0<0&&this.qt0>-1e-8&&(this.qt0=0),this.qt0>1&&this.qt0<1+1e-8&&(this.qt0=1),this.qt1<0&&this.qt1>-1e-8&&(this.qt1=0),this.qt1>1&&this.qt1<1+1e-8&&(this.qt1=1),assert&&assert(this.t0>=0&&this.t0<=1,`t0 out of range: ${this.t0}`),assert&&assert(this.t1>=0&&this.t1<=1,`t1 out of range: ${this.t1}`),assert&&assert(this.qt0>=0&&this.qt0<=1,`qt0 out of range: ${this.qt0}`),assert&&assert(this.qt1>=0&&this.qt1<=1,`qt1 out of range: ${this.qt1}`)}apply(t){return this.a*t+this.b}applyInverse(t){return(t-this.b)/this.a}static createLinear(t,e,s,i){const r=(i-e)/(s-t);return new Qt(r,e-t*r)}}Y.register("Overlap",Qt);class zt{constructor(t,e,s,i,r){assert&&assert(isFinite(t)&&t>=0,"invalid distance"),assert&&assert(Math.abs(s.magnitude-1)<1e-7,"invalid normal"),assert&&assert(r>=-1e-10&&r<=1+1e-10,`t out of range: ${r}`),this.point=e,this.normal=s,this.distance=t,this.wind=i,this.t=O.clamp(r,0,1)}}Y.register("RayIntersection",zt);class vt{constructor(t,e,s){assert&&assert(e>=-1e-10&&e<=1+1e-10,"aT out of range"),assert&&assert(s>=-1e-10&&s<=1+1e-10,"bT out of range"),this.point=t,this.aT=O.clamp(e,0,1),this.bT=O.clamp(s,0,1)}getSwapped(){return new vt(this.point,this.bT,this.aT)}}Y.register("SegmentIntersection",vt);const L=u=>u.toFixed(20);Y.register("svgNumber",L);const kt=(u,t,e,s)=>u.times(s).minus(t.times(e)),ks=u=>{const t=u[0],e=u[1],s=u[2],i=u[3],r=u[4],a=u[5],l=u[6],o=u[7],h=u[8];return t.times(r).times(h).plus(e.times(a).times(l)).plus(s.times(i).times(o)).minus(s.times(r).times(l)).minus(e.times(i).times(h)).minus(t.times(a).times(o))},qs=u=>{const t=u[0],e=u[1],s=u[2],i=u[3],r=u[4],a=u[5],l=u[6],o=u[7],h=u[8];return[kt(r,a,o,h),kt(e,s,o,h).negate(),kt(e,s,r,a),kt(i,a,l,h).negate(),kt(t,s,l,h),kt(t,s,i,a).negate(),kt(i,r,l,o),kt(t,e,l,o).negate(),kt(t,e,i,r)]},Hs=u=>[u[0],u[3],u[6],u[1],u[4],u[7],u[2],u[5],u[8]],Fe=(u,t=!1)=>_.sortBy([u.slice(0,3),u.slice(3,6),u.slice(6,9)],e=>-(e[0].magnitude+e[1].magnitude+(t?e[2].magnitude:0)))[0],Ds=(u,t=!1)=>Fe(Hs(u),t),zs=u=>{const t=qs(u),e=Fe(t);return[D.ZERO,e[2],e[1].negated(),e[2].negated(),D.ZERO,e[0],e[1],e[0].negated(),D.ZERO]},Xs=(u,t)=>{const e=u[0],s=u[1],i=u[3],r=u[4],a=t[0],l=t[1],o=t[3],h=t[4],g=l.times(o).minus(a.times(h)),p=h.negated().times(e).plus(o.times(s)).plus(l.times(i)).minus(a.times(r)),A=s.times(i).minus(e.times(r)),b=D.solveQuadraticRoots(g,p,A);return b===null?null:b[0]},Ys=u=>{const t=zs(u),e=Xs(u,t);return e===null?u:[u[0].plus(e.times(t[0])),u[1].plus(e.times(t[1])),u[2].plus(e.times(t[2])),u[3].plus(e.times(t[3])),u[4].plus(e.times(t[4])),u[5].plus(e.times(t[5])),u[6].plus(e.times(t[6])),u[7].plus(e.times(t[7])),u[8].plus(e.times(t[8]))]},Ws=u=>{const t=[],e=u[0],s=u[1].times(D.real(2)),i=u[4],r=u[2].times(D.real(2)),a=u[5].times(D.real(2)),l=u[8];let o=[];const h=new D(-2.51653525696959,1.5292850284402),g=i,p=s.times(h).plus(a),A=e.times(h).times(h).plus(r.times(h)).plus(l),b=D.solveQuadraticRoots(g,p,A);if(b&&b.length>=2)o=[[h,b[0]],[h,b[1]]];else{const S=e,y=s.times(h).plus(r),P=i.times(h).times(h).plus(a.times(h)).plus(l),x=D.solveQuadraticRoots(S,y,P);if(x&&x.length>=2)o=[[x[0],h],[x[1],h]];else if(b&&b.length===1)o=[[h,b[0]]];else if(x&&x.length===1)o=[[x[0],h]];else throw new Error("Implement more advanced initialization to find two solutions")}return o.forEach(S=>{const y=S[0].real,P=S[1].real,x=S[0].imaginary,v=S[1].imaginary,T=e.real,M=s.real,V=i.real,$=r.real,B=a.real,X=e.imaginary,k=s.imaginary,q=i.imaginary,N=r.imaginary,j=a.imaginary,Pt=new Kt(-2*X*x-k*v+$+2*T*y+M*P,-k*x-2*q*v+B+M*y+2*V*P,-N-2*x*T-v*M-2*X*y-k*P,-j-x*M-2*v*V-k*y-2*q*P),G=new Kt(N+2*x*T+v*M+2*X*y+k*P,j+x*M+2*v*V+k*y+2*q*P,-2*X*x-k*v+$+2*T*y+M*P,-k*x-2*q*v+B+M*y+2*V*P),it=new Kt(6.1951068548253,-1.159268950386,.1602918829294,3.205818692048202),At=new Kt(-5.420628549296924,-15.2069583028685,.159590602048868,5.10688288040682),at=(dt,pt)=>pt.timesScalar(dt.dot(pt)/pt.dot(pt)),ft=Pt,et=G.minus(at(G,ft)),tt=it.minus(at(it,ft)).minus(at(it,et)),Z=At.minus(at(At,ft)).minus(at(At,et)).minus(at(At,tt)),Ct=new Ne(2,2,[tt.z,Z.z,tt.w,Z.w]),z=new os(Ct).getSingularValues();let ct=null;if(Math.abs(x)<1e-10&&Math.abs(v)<1e-10)ct=new E(y,P);else{if(Math.abs(z[1])>1e-10){const dt=Ct.solve(new Ne(2,1,[-x,-v])).extractVector2(0);ct=new E(y+dt.x*tt.z+dt.y*Z.z,P+dt.x*tt.w+dt.y*Z.w)}else if(Math.abs(z[0])>1e-10){const dt=Math.abs(tt.z)+Math.abs(tt.w)>Math.abs(Z.z)+Math.abs(Z.w)?tt:Z,pt=new E(dt.z,dt.w),St=new E(x,v).dot(pt)/pt.dot(pt),Tt=new Kt(y,P,x,v).minus(dt.timesScalar(St));Math.abs(Tt.z)<1e-8&&Math.abs(Tt.w)<1e-8&&(ct=new E(Tt.x,Tt.y))}else ct=null;if(ct){if(Math.abs(z[1])>1e-10)t.push(ct);else if(Math.abs(z[0])>1e-10){const dt=Math.abs(tt.z)+Math.abs(tt.w)>Math.abs(Z.z)+Math.abs(Z.w),pt=dt?Z:tt,St=dt?tt:Z,Et=Math.abs(St.z)>Math.abs(St.w)?pt.z/St.z:pt.w/St.w,Nt=St.timesScalar(Et).minus(pt);t.push(new Ht(ct,new E(Nt.x,Nt.y).normalized()))}}}}),t},Qs=u=>{const t=Ys(u);return[Fe(t),Ds(t)]},jt=(u,t)=>{const e=u[0],s=u[1],i=u[2],r=t[0],a=t[1],l=t[2],o=r.times(s).minus(e.times(a));if(o.equalsEpsilon(D.ZERO,1e-8))return null;{const h=a.times(i).minus(s.times(l)).dividedBy(o);let g;if(!s.equalsEpsilon(D.ZERO,1e-8))g=e.negated().times(h).minus(i).dividedBy(s);else if(!a.equalsEpsilon(D.ZERO,1e-8))g=r.negated().times(h).minus(l).dividedBy(a);else return null;return Math.abs(h.imaginary)<1e-8&&Math.abs(g.imaginary)<1e-8?new E(h.real,g.real):null}},Gs=(u,t)=>{const e=u.m00(),s=u.m01(),i=u.m02(),r=u.m10(),a=u.m11(),l=u.m12(),o=u.m20(),h=u.m21(),g=u.m22(),p=t.m00(),A=t.m01(),b=t.m02(),S=t.m10(),y=t.m11(),P=t.m12(),x=t.m20(),v=t.m21(),T=t.m22(),M=-i*a*o+s*l*o+i*r*h-e*l*h-s*r*g+e*a*g,V=-r*g*A+r*h*b+i*h*S-s*g*S-i*o*y+e*g*y+s*o*P-e*h*P+i*r*v+l*(-h*p+o*A+s*x-e*v)-s*r*T+a*(g*p-o*b-i*x+e*T),$=-g*A*S+h*b*S+g*p*y-o*b*y-h*p*P+o*A*P+l*A*x-a*b*x-i*y*x+s*P*x-l*p*v+r*b*v+i*S*v-e*P*v+a*p*T-r*A*T-s*S*T+e*y*T,B=-b*y*x+A*P*x+b*S*v-p*P*v-A*S*T+p*y*T,X=D.solveCubicRoots(D.real(M),D.real(V),D.real($),D.real(B));if(!X||X.length===0)return{degenerateConicMatrices:[],intersectionCollections:[],points:[],lines:[]};const q=_.uniqWith(X,(G,it)=>G.equals(it)).map(G=>[D.real(e).multiply(G).add(D.real(p)),D.real(s).multiply(G).add(D.real(A)),D.real(i).multiply(G).add(D.real(b)),D.real(r).multiply(G).add(D.real(S)),D.real(a).multiply(G).add(D.real(y)),D.real(l).multiply(G).add(D.real(P)),D.real(o).multiply(G).add(D.real(x)),D.real(h).multiply(G).add(D.real(v)),D.real(g).multiply(G).add(D.real(T))]);console.log("determinant magnitudes",q.map(G=>ks(G).magnitude));const N=[],j=q.map(Qs);console.log(j);const Pt=q.map(Ws);console.log(Pt);for(let G=0;G<j.length;G++){const it=j[G],At=jt(it[0],it[1]);At&&N.push(At);for(let at=G+1;at<j.length;at++){const ft=j[at],et=[jt(it[0],ft[0]),jt(it[0],ft[1]),jt(it[1],ft[0]),jt(it[1],ft[1])];for(let tt=0;tt<4;tt++){const Z=et[tt];Z&&N.push(Z)}}}return{points:N,degenerateConicMatrices:q,lines:_.flatten(j),intersectionCollections:Pt}};Y.register("intersectConicMatrices",Gs);function Ue(u){return'"'+u.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}const Re={parse:function(u,t){const e={svgPath:l,movetoDrawtoCommandGroups:o,movetoDrawtoCommandGroup:h,drawtoCommands:g,drawtoCommand:p,moveto:A,movetoArgumentSequence:b,closepath:S,lineto:y,linetoArgumentSequence:P,horizontalLineto:x,horizontalLinetoArgumentSequence:v,verticalLineto:T,verticalLinetoArgumentSequence:M,curveto:V,curvetoArgumentSequence:$,curvetoArgument:B,smoothCurveto:X,smoothCurvetoArgumentSequence:k,smoothCurvetoArgument:q,quadraticBezierCurveto:N,quadraticBezierCurvetoArgumentSequence:j,quadraticBezierCurvetoArgument:Pt,smoothQuadraticBezierCurveto:G,smoothQuadraticBezierCurvetoArgumentSequence:it,ellipticalArc:At,ellipticalArcArgumentSequence:at,ellipticalArcArgument:ft,coordinatePair:et,nonnegativeNumber:tt,number:Z,flag:Ct,commaWsp:z,comma:ct,floatingPointConstant:dt,fractionalConstant:pt,exponent:St,sign:Tt,digitSequence:Et,digit:Nt,wsp:R};if(t!==void 0){if(e[t]===void 0)throw new Error("Invalid rule name: "+Ue(t)+".")}else t="svgPath";let s=0,i=0,r=[];function a(n){s<i||(s>i&&(i=s,r=[]),r.push(n))}function l(){let n,c,d,f,m,C;for(m=s,C=s,n=[],c=R();c!==null;)n.push(c),c=R();if(n!==null)if(c=o(),c=c!==null?c:"",c!==null){for(d=[],f=R();f!==null;)d.push(f),f=R();d!==null?n=[n,c,d]:(n=null,s=C)}else n=null,s=C;else n=null,s=C;return n!==null&&(n=function(w,I){return I||[]}(m,n[1])),n===null&&(s=m),n}function o(){let n,c,d,f,m;if(f=s,m=s,n=h(),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=o(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;return n!==null&&(n=function(C,w,I){return w.concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=h(),n!==null&&(n=function(C,w){return w}(f,n)),n===null&&(s=f)),n}function h(){let n,c,d,f,m;if(f=s,m=s,n=A(),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=g(),d=d!==null?d:"",d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;return n!==null&&(n=function(C,w,I){return I.length?w.concat(I):w}(f,n[0],n[2])),n===null&&(s=f),n}function g(){let n,c,d,f,m;if(f=s,m=s,n=p(),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=g(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;return n!==null&&(n=function(C,w,I){return w.concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=p(),n!==null&&(n=function(C,w){return w}(f,n)),n===null&&(s=f)),n}function p(){let n;return n=S(),n===null&&(n=y(),n===null&&(n=x(),n===null&&(n=T(),n===null&&(n=V(),n===null&&(n=X(),n===null&&(n=N(),n===null&&(n=G(),n===null&&(n=At())))))))),n}function A(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===77?(n="M",s++):(n=null,a('"M"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=b(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return Rt(w,!1)}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===109?(n="m",s++):(n=null,a('"m"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=b(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return Rt(w,!0)}(f,n[2])),n===null&&(s=f)}return n}function b(){let n,c,d,f,m;return f=s,m=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=P(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=et(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function S(){let n,c;return c=s,u.charCodeAt(s)===90?(n="Z",s++):(n=null,a('"Z"')),n===null&&(u.charCodeAt(s)===122?(n="z",s++):(n=null,a('"z"'))),n!==null&&(n=function(d,f){return{cmd:"close"}}()),n===null&&(s=c),n}function y(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===76?(n="L",s++):(n=null,a('"L"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=P(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"lineTo",args:[I.x,I.y]}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===108?(n="l",s++):(n=null,a('"l"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=P(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"lineToRelative",args:[I.x,I.y]}))}(f,n[2])),n===null&&(s=f)}return n}function P(){let n,c,d,f,m;return f=s,m=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=P(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=et(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function x(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===72?(n="H",s++):(n=null,a('"H"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=v(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"horizontalLineTo",args:[I]}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===104?(n="h",s++):(n=null,a('"h"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=v(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"horizontalLineToRelative",args:[I]}))}(f,n[2])),n===null&&(s=f)}return n}function v(){let n,c,d,f,m;return f=s,m=s,n=Z(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=v(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=Z(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function T(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===86?(n="V",s++):(n=null,a('"V"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=M(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"verticalLineTo",args:[I]}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===118?(n="v",s++):(n=null,a('"v"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=M(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"verticalLineToRelative",args:[I]}))}(f,n[2])),n===null&&(s=f)}return n}function M(){let n,c,d,f,m;return f=s,m=s,n=Z(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=M(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=Z(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function V(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===67?(n="C",s++):(n=null,a('"C"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=$(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"cubicCurveTo",args:I}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===99?(n="c",s++):(n=null,a('"c"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=$(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"cubicCurveToRelative",args:I}))}(f,n[2])),n===null&&(s=f)}return n}function $(){let n,c,d,f,m;return f=s,m=s,n=B(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=$(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=B(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function B(){let n,c,d,f,m,C,w;return C=s,w=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=et(),d!==null?(f=z(),f=f!==null?f:"",f!==null?(m=et(),m!==null?n=[n,c,d,f,m]:(n=null,s=w)):(n=null,s=w)):(n=null,s=w)):(n=null,s=w)):(n=null,s=w),n!==null&&(n=function(I,Dt,Ot,Gt){return[Dt.x,Dt.y,Ot.x,Ot.y,Gt.x,Gt.y]}(C,n[0],n[2],n[4])),n===null&&(s=C),n}function X(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===83?(n="S",s++):(n=null,a('"S"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=k(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"smoothCubicCurveTo",args:I}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===115?(n="s",s++):(n=null,a('"s"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=k(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"smoothCubicCurveToRelative",args:I}))}(f,n[2])),n===null&&(s=f)}return n}function k(){let n,c,d,f,m;return f=s,m=s,n=q(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=k(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=q(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function q(){let n,c,d,f,m;return f=s,m=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=et(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w.x,w.y,I.x,I.y]}(f,n[0],n[2])),n===null&&(s=f),n}function N(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===81?(n="Q",s++):(n=null,a('"Q"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=j(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"quadraticCurveTo",args:I}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===113?(n="q",s++):(n=null,a('"q"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=j(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"quadraticCurveToRelative",args:I}))}(f,n[2])),n===null&&(s=f)}return n}function j(){let n,c,d,f,m;return f=s,m=s,n=Pt(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=j(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=Pt(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function Pt(){let n,c,d,f,m;return f=s,m=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=et(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w.x,w.y,I.x,I.y]}(f,n[0],n[2])),n===null&&(s=f),n}function G(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===84?(n="T",s++):(n=null,a('"T"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=it(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>({cmd:"smoothQuadraticCurveTo",args:[I.x,I.y]}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===116?(n="t",s++):(n=null,a('"t"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=it(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>({cmd:"smoothQuadraticCurveToRelative",args:[I.x,I.y]}))}(f,n[2])),n===null&&(s=f)}return n}function it(){let n,c,d,f,m;return f=s,m=s,n=et(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=it(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=et(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function At(){let n,c,d,f,m;if(f=s,m=s,u.charCodeAt(s)===65?(n="A",s++):(n=null,a('"A"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=at(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;if(n!==null&&(n=function(C,w){return w.map(I=>(I[2]*=Math.PI/180,{cmd:"ellipticalArcTo",args:I}))}(f,n[2])),n===null&&(s=f),n===null){if(f=s,m=s,u.charCodeAt(s)===97?(n="a",s++):(n=null,a('"a"')),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?(d=at(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)}else n=null,s=m;n!==null&&(n=function(C,w){return w.map(I=>(I[2]*=Math.PI/180,{cmd:"ellipticalArcToRelative",args:I}))}(f,n[2])),n===null&&(s=f)}return n}function at(){let n,c,d,f,m;return f=s,m=s,n=ft(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=at(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return[w].concat(I)}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,n=ft(),n!==null&&(n=function(C,w){return[w]}(f,n)),n===null&&(s=f)),n}function ft(){let n,c,d,f,m,C,w,I,Dt,Ot,Gt,Ae,Mt;return Ae=s,Mt=s,n=tt(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=tt(),d!==null?(f=z(),f=f!==null?f:"",f!==null?(m=Z(),m!==null?(C=z(),C!==null?(w=Ct(),w!==null?(I=z(),I=I!==null?I:"",I!==null?(Dt=Ct(),Dt!==null?(Ot=z(),Ot=Ot!==null?Ot:"",Ot!==null?(Gt=et(),Gt!==null?n=[n,c,d,f,m,C,w,I,Dt,Ot,Gt]:(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt)):(n=null,s=Mt),n!==null&&(n=function(Pn,je,ts,es,ss,ns,Be){return[je,ts,es,ss,ns,Be.x,Be.y]}(Ae,n[0],n[2],n[4],n[6],n[8],n[10])),n===null&&(s=Ae),n}function et(){let n,c,d,f,m;return f=s,m=s,n=Z(),n!==null?(c=z(),c=c!==null?c:"",c!==null?(d=Z(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return{x:w,y:I}}(f,n[0],n[2])),n===null&&(s=f),n}function tt(){let n,c;return c=s,n=dt(),n!==null&&(n=function(d,f){return parseFloat(f)}(c,n)),n===null&&(s=c),n===null&&(c=s,n=Et(),n!==null&&(n=function(d,f){return Number(f)}(c,n)),n===null&&(s=c)),n}function Z(){let n,c,d,f;return d=s,f=s,n=Tt(),n=n!==null?n:"",n!==null?(c=dt(),c!==null?n=[n,c]:(n=null,s=f)):(n=null,s=f),n!==null&&(n=function(m,C,w){return parseFloat(C+w)}(d,n[0],n[1])),n===null&&(s=d),n===null&&(d=s,f=s,n=Tt(),n=n!==null?n:"",n!==null?(c=Et(),c!==null?n=[n,c]:(n=null,s=f)):(n=null,s=f),n!==null&&(n=function(m,C,w){return Number(C+w)}(d,n[0],n[1])),n===null&&(s=d)),n}function Ct(){let n,c;return c=s,u.charCodeAt(s)===48?(n="0",s++):(n=null,a('"0"')),n!==null&&(n=function(d){return!1}()),n===null&&(s=c),n===null&&(c=s,u.charCodeAt(s)===49?(n="1",s++):(n=null,a('"1"')),n!==null&&(n=function(d){return!0}()),n===null&&(s=c)),n}function z(){let n,c,d,f,m;if(m=s,c=R(),c!==null)for(n=[];c!==null;)n.push(c),c=R();else n=null;if(n!==null)if(c=ct(),c=c!==null?c:"",c!==null){for(d=[],f=R();f!==null;)d.push(f),f=R();d!==null?n=[n,c,d]:(n=null,s=m)}else n=null,s=m;else n=null,s=m;if(n===null)if(m=s,n=ct(),n!==null){for(c=[],d=R();d!==null;)c.push(d),d=R();c!==null?n=[n,c]:(n=null,s=m)}else n=null,s=m;return n}function ct(){let n;return u.charCodeAt(s)===44?(n=",",s++):(n=null,a('","')),n}function dt(){let n,c,d,f;return d=s,f=s,n=pt(),n!==null?(c=St(),c=c!==null?c:"",c!==null?n=[n,c]:(n=null,s=f)):(n=null,s=f),n!==null&&(n=function(m,C,w){return C+w}(d,n[0],n[1])),n===null&&(s=d),n===null&&(d=s,f=s,n=Et(),n!==null?(c=St(),c!==null?n=[n,c]:(n=null,s=f)):(n=null,s=f),n!==null&&(n=function(m,C,w){return C+w}(d,n[0],n[1])),n===null&&(s=d)),n}function pt(){let n,c,d,f,m;return f=s,m=s,n=Et(),n=n!==null?n:"",n!==null?(u.charCodeAt(s)===46?(c=".",s++):(c=null,a('"."')),c!==null?(d=Et(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I){return w+"."+I}(f,n[0],n[2])),n===null&&(s=f),n===null&&(f=s,m=s,n=Et(),n!==null?(u.charCodeAt(s)===46?(c=".",s++):(c=null,a('"."')),c!==null?n=[n,c]:(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w){return w}(f,n[0])),n===null&&(s=f)),n}function St(){let n,c,d,f,m;return f=s,m=s,u.charCodeAt(s)===101?(n="e",s++):(n=null,a('"e"')),n===null&&(u.charCodeAt(s)===69?(n="E",s++):(n=null,a('"E"'))),n!==null?(c=Tt(),c=c!==null?c:"",c!==null?(d=Et(),d!==null?n=[n,c,d]:(n=null,s=m)):(n=null,s=m)):(n=null,s=m),n!==null&&(n=function(C,w,I,Dt){return w+I+Dt}(f,n[0],n[1],n[2])),n===null&&(s=f),n}function Tt(){let n;return u.charCodeAt(s)===43?(n="+",s++):(n=null,a('"+"')),n===null&&(u.charCodeAt(s)===45?(n="-",s++):(n=null,a('"-"'))),n}function Et(){let n,c,d,f;return d=s,f=s,n=Nt(),n!==null?(c=Et(),c!==null?n=[n,c]:(n=null,s=f)):(n=null,s=f),n!==null&&(n=function(m,C,w){return C+w}(d,n[0],n[1])),n===null&&(s=d),n===null&&(n=Nt()),n}function Nt(){let n;return/^[0-9]/.test(u.charAt(s))?(n=u.charAt(s),s++):(n=null,a("[0-9]")),n}function R(){let n;return u.charCodeAt(s)===32?(n=" ",s++):(n=null,a('" "')),n===null&&(u.charCodeAt(s)===9?(n="	",s++):(n=null,a('"\\t"')),n===null&&(u.charCodeAt(s)===13?(n="\r",s++):(n=null,a('"\\r"')),n===null&&(u.charCodeAt(s)===10?(n=`
`,s++):(n=null,a('"\\n"'))))),n}function ue(n){n.sort();let c=null;const d=[];for(let f=0;f<n.length;f++)n[f]!==c&&(d.push(n[f]),c=n[f]);return d}function Lt(){let n=1,c=1,d=!1;for(let f=0;f<Math.max(s,i);f++){const m=u.charAt(f);m===`
`?(d||n++,c=1,d=!1):m==="\r"||m==="\u2028"||m==="\u2029"?(n++,c=1,d=!0):(c++,d=!1)}return{line:n,column:c}}function Rt(n,c){const d=[{cmd:c?"moveToRelative":"moveTo",args:[n[0].x,n[0].y]}];if(n.length>1)for(let f=1;f<n.length;f++)d.push({cmd:c?"lineToRelative":"lineTo",args:[n[f].x,n[f].y]});return d}const $e=e[t]();if($e===null||s!==u.length){const n=Math.max(s,i),c=n<u.length?u.charAt(n):null,d=Lt();throw new this.SyntaxError(ue(r),c,n,d.line,d.column)}return $e},toSource:function(){return this._source}};Re.SyntaxError=function(u,t,e,s,i){function r(a,l){let o,h;switch(a.length){case 0:o="end of input";break;case 1:o=a[0];break;default:o=a.slice(0,a.length-1).join(", ")+" or "+a[a.length-1]}return h=l?Ue(l):"end of input","Expected "+o+" but "+h+" found."}this.name="SyntaxError",this.expected=u,this.found=t,this.message=r(u,t),this.offset=e,this.line=s,this.column=i};Re.SyntaxError.prototype=Error.prototype;Y.register("svgPath",Re);const Zs=Y.svgPath;class nt{constructor(){this.invalidationEmitter=new Me}areStrokedBoundsDilated(){return Math.abs(this.startTangent.x*this.startTangent.y)<1e-7&&Math.abs(this.endTangent.x*this.endTangent.y)<1e-7}getBoundsWithTransform(t){return this.transformed(t).getBounds()}slice(t,e){assert&&assert(t>=0&&t<=1&&e>=0&&e<=1,"Parametric value out of range"),assert&&assert(t<e);let s=this;return e<1&&(s=s.subdivided(e)[0]),t>0&&(s=s.subdivided(O.linear(0,e,0,1,t))[1]),s}subdivisions(t){let e=this;const s=[];for(let i=0;i<t.length;i++){const r=t[i],a=e.subdivided(r);assert&&assert(a.length===2),s.push(a[0]),e=a[1];for(let l=i+1;l<t.length;l++)t[l]=O.linear(r,1,0,1,t[l])}return s.push(e),s}subdividedIntoMonotone(){return this.subdivisions(this.getInteriorExtremaTs())}isSufficientlyFlat(t,e){const s=this.start,i=this.positionAt(.5),r=this.end;return nt.isSufficientlyFlat(t,e,s,i,r)}getArcLength(t,e,s){if(t=t===void 0?1e-10:t,e=e===void 0?1e-8:e,s=s===void 0?15:s,s<=0||this.isSufficientlyFlat(t,e))return this.start.distance(this.end);{const i=this.subdivided(.5);return i[0].getArcLength(t,e,s-1)+i[1].getArcLength(t,e,s-1)}}getDashValues(t,e,s,i){assert&&assert(t.length>0,"Do not call with an empty dash array");const r=this,a=[];let l=0;const o=_.sum(t);e=e%o,e<0&&(e+=o);let h=0,g=0,p=!0;function A(){h=(h+1)%t.length,p=!p}for(;e>0;)e>=t[h]?(e-=t[h],A()):(g=e,e=0);const b=p;return function S(y,P,x,v,T){const M=(y+P)/2,V=r.positionAt(M);if(T>14||nt.isSufficientlyFlat(s,i,x,V,v)){const $=x.distance(V)+V.distance(v);l+=$;let B=$;for(;g+B>=t[h];){const X=O.linear(0,$,y,P,$-B+t[h]-g);a.push(X),B-=t[h]-g,g=0,A()}g=g+B}else S(y,M,x,V,T+1),S(M,P,V,v,T+1)}(0,1,this.start,this.end,0),{values:a,arcLength:l,initiallyInside:b}}toPiecewiseLinearSegments(t,e,s,i,r,a){e=e===void 0?t.minLevels:e,s=s===void 0?t.maxLevels:s,i=i||[];const l=t.pointMap||_.identity;r=r||l(this.start),a=a||l(this.end);const o=l(this.positionAt(.5));assert&&assert(e<=s),assert&&assert(t.distanceEpsilon===null||typeof t.distanceEpsilon=="number"),assert&&assert(t.curveEpsilon===null||typeof t.curveEpsilon=="number"),assert&&assert(!l||typeof l=="function");let h=s===0;if(!h&&e<=0&&(h=this.isSufficientlyFlat(t.distanceEpsilon===null||t.distanceEpsilon===void 0?Number.POSITIVE_INFINITY:t.distanceEpsilon,t.curveEpsilon===null||t.curveEpsilon===void 0?Number.POSITIVE_INFINITY:t.curveEpsilon)),h)i.push(new F(r,a));else{const g=this.subdivided(.5);g[0].toPiecewiseLinearSegments(t,e-1,s-1,i,r,o),g[1].toPiecewiseLinearSegments(t,e-1,s-1,i,o,a)}return i}toPiecewiseLinearOrArcSegments(t){const e=Se()({minLevels:2,maxLevels:7,curvatureThreshold:.02,errorThreshold:10,errorPoints:[.25,.75]},t),s=[];return this.toPiecewiseLinearOrArcRecursion(e,e.minLevels,e.maxLevels,s,0,1,this.positionAt(0),this.positionAt(1),this.curvatureAt(0),this.curvatureAt(1)),s}toPiecewiseLinearOrArcRecursion(t,e,s,i,r,a,l,o,h,g){const p=(r+a)/2,A=this.positionAt(p),b=this.curvatureAt(p);if(s<=0||e<=0&&Math.abs(h-b)+Math.abs(b-g)<t.curvatureThreshold*2){const S=H.createFromPoints(l,A,o);let y=!1;if(S instanceof H){const P=S.radius*S.radius;for(let x=0;x<t.errorPoints.length;x++){const v=t.errorPoints[x],T=this.positionAt(r*(1-v)+a*v);if(Math.abs(T.distanceSquared(S.center)-P)>t.errorThreshold){y=!0;break}}}if(!y){i.push(S);return}}this.toPiecewiseLinearOrArcRecursion(t,e-1,s-1,i,r,p,l,A,h,b),this.toPiecewiseLinearOrArcRecursion(t,e-1,s-1,i,p,a,A,o,b,g)}toShape(){return new an([new yt([this])])}getClosestPoints(t){return nt.closestToPoint([this],t,1e-7)}static closestToPoint(t,e,s){const i=s*s;let r=[],a=[],l=Number.POSITIVE_INFINITY,o=!1;for(_.each(t,h=>{if(h instanceof F){const g=h.explicitClosestToPoint(e);_.each(g,p=>{p.distanceSquared<l?(a=[p],l=p.distanceSquared):p.distanceSquared===l&&a.push(p)})}else{const g=[0].concat(h.getInteriorExtremaTs()).concat([1]);for(let p=0;p<g.length-1;p++){const A=g[p],b=g[p+1],S=h.positionAt(A),y=h.positionAt(b),P=ot.point(S).addPoint(y),x=P.minimumDistanceToPointSquared(e);if(x<=l){const v=P.maximumDistanceToPointSquared(e);v<l&&(l=v,a=[]),r.push({ta:A,tb:b,pa:S,pb:y,segment:h,bounds:P,min:x,max:v})}}}});r.length&&!o;){const h=r;r=[],o=!0;for(const g of h){if(g.min>l)continue;o&&g.pa.distanceSquared(g.pb)>i&&(o=!1);const p=(g.ta+g.tb)/2,A=g.segment.positionAt(p),b=ot.point(g.pa).addPoint(A),S=ot.point(g.pb).addPoint(A),y=b.minimumDistanceToPointSquared(e),P=S.minimumDistanceToPointSquared(e);if(y<=l){const x=b.maximumDistanceToPointSquared(e);x<l&&(l=x,a=[]),r.push({ta:g.ta,tb:p,pa:g.pa,pb:A,segment:g.segment,bounds:b,min:y,max:x})}if(P<=l){const x=S.maximumDistanceToPointSquared(e);x<l&&(l=x,a=[]),r.push({ta:p,tb:g.tb,pa:A,pb:g.pb,segment:g.segment,bounds:S,min:P,max:x})}}}return _.each(r,h=>{const g=(h.ta+h.tb)/2,p=h.segment.positionAt(g);a.push({segment:h.segment,t:g,closestPoint:p,distanceSquared:e.distanceSquared(p)})}),a}static polynomialGetOverlapCubic(t,e,s,i,r,a,l,o){if(o===0)return nt.polynomialGetOverlapQuadratic(t,e,s,r,a,l);const h=Math.sign(i/o)*Math.pow(Math.abs(i/o),1/3);if(h===0)return null;const g=(s-h*h*l)/(3*h*h*o);return{a:h,b:g}}static polynomialGetOverlapQuadratic(t,e,s,i,r,a){if(a===0)return nt.polynomialGetOverlapLinear(t,e,i,r);if(s/a<0)return null;const o=Math.sqrt(s/a);if(o===0)return null;const h=(e-o*r)/(2*o*a);return{a:o,b:h}}static polynomialGetOverlapLinear(t,e,s,i){if(i===0)return t===s?!0:null;const r=e/i;if(r===0)return null;const a=(t-s)/i;return{a:r,b:a}}static intersect(t,e){if(F&&t instanceof F&&e instanceof F)return F.intersect(t,e);if(F&&t instanceof F)return F.intersectOther(t,e);if(F&&e instanceof F)return F.intersectOther(e,t).map(Us);if(H&&t instanceof H&&e instanceof H)return H.intersect(t,e);if(rt&&t instanceof rt&&e instanceof rt)return rt.intersect(t,e);if(st&&lt&&(t instanceof st||t instanceof lt)&&(e instanceof st||e instanceof lt)){const s=t instanceof lt?t:t.degreeElevated(),i=e instanceof lt?e:e.degreeElevated(),r=new paper.Curve(s.start.x,s.start.y,s.control1.x,s.control1.y,s.control2.x,s.control2.y,s.end.x,s.end.y),a=new paper.Curve(i.start.x,i.start.y,i.control1.x,i.control1.y,i.control2.x,i.control2.y,i.end.x,i.end.y);return r.getIntersections(a).map(o=>{const h=new E(o.point.x,o.point.y);return new vt(h,o.time,o.intersection.time)})}else return Jt.intersect(t,e)}static deserialize(t){return assert&&assert(t.type&&Y[t.type]&&Y[t.type].deserialize),Y[t.type].deserialize(t)}static isSufficientlyFlat(t,e,s,i,r){return!(O.distToSegmentSquared(i,s,r)/s.distanceSquared(r)>e||O.distToSegmentSquared(i,s,r)>t)}static filterClosestToPointResult(t){if(t.length===0)return[];const e=_.minBy(t,s=>s.distanceSquared).distanceSquared;return _.uniqWith(t.filter(s=>Math.abs(s.distanceSquared-e)<1e-11),(s,i)=>s.closestPoint.distanceSquared(i.closestPoint)<1e-11)}}Y.register("Segment",nt);function Us(u){return u.getSwapped()}const ke=new E(0,0);class F extends nt{constructor(t,e){super(),this._start=t,this._end=e,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Line start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setEnd(t){return assert&&assert(t.isFinite(),`Line end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this._start.plus(this._end.minus(this._start).times(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.getStartTangent()}curvatureAt(t){return assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),0}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.positionAt(t);return[new F(this._start,e),new F(e,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Line start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Line start should be finite: ${this._start.toString()}`),assert&&assert(this._end instanceof E,`Line end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Line end should be finite: ${this._end.toString()}`),this._tangent=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){return this._tangent===null&&(this._tangent=this._end.minus(this._start).normalized()),this._tangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this.getStartTangent()}get endTangent(){return this.getEndTangent()}getBounds(){return this._bounds===null&&(this._bounds=ot.NOTHING.copy().addPoint(this._start).addPoint(this._end)),this._bounds}get bounds(){return this.getBounds()}getBoundsWithTransform(t){const e=ot.NOTHING.copy();return e.addPoint(t.multiplyVector2(ke.set(this._start))),e.addPoint(t.multiplyVector2(ke.set(this._end))),e}getNondegenerateSegments(){return this._start.equals(this._end)?[]:[this]}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`L ${L(this._end.x)} ${L(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){const e=this.getEndTangent().perpendicular.negated().times(t/2);return[new F(this._start.plus(e),this._end.plus(e))]}strokeRight(t){const e=this.getStartTangent().perpendicular.times(t/2);return[new F(this._end.plus(e),this._start.plus(e))]}getInteriorExtremaTs(){return[]}intersection(t){const e=[],s=this._start,r=this._end.minus(s);if(r.magnitudeSquared===0)return e;const a=t.direction.y*r.x-t.direction.x*r.y;if(a===0)return e;const l=(t.direction.x*(s.y-t.position.y)-t.direction.y*(s.x-t.position.x))/a;if(l<0||l>=1)return e;const o=(r.x*(s.y-t.position.y)-r.y*(s.x-t.position.x))/a;if(o<1e-8)return e;const h=r.perpendicular,g=s.plus(r.times(l)),p=(h.dot(t.direction)>0?h.negated():h).normalized(),A=t.direction.perpendicular.dot(r)<0?1:-1;return e.push(new zt(o,g,p,A,l)),e}windingIntersection(t){const e=this.intersection(t);return e.length?e[0].wind:0}writeToContext(t){t.lineTo(this._end.x,this._end.y)}transformed(t){return new F(t.timesVector2(this._start),t.timesVector2(this._end))}explicitClosestToPoint(t){const e=this._end.minus(this._start);let s=t.minus(this._start).dot(e)/e.magnitudeSquared;s=O.clamp(s,0,1);const i=this.positionAt(s);return[{segment:this,t:s,closestPoint:i,distanceSquared:t.distanceSquared(i)}]}getSignedAreaFragment(){return 1/2*(this._start.x*this._end.y-this._start.y*this._end.x)}reparameterized(t,e){return new F(this.positionAt(e),this.positionAt(t+e))}reversed(){return new F(this._end,this._start)}polarToCartesian(t){return this._start.x===this._end.x?[new F(E.createPolar(this._start.y,this._start.x),E.createPolar(this._end.y,this._end.x))]:this._start.y===this._end.y?[new H(E.ZERO,this._start.y,this._start.x,this._end.x,this._start.x>this._end.x)]:this.toPiecewiseLinearSegments(t)}getArcLength(){return this.start.distance(this.end)}toPiecewiseLinearOrArcSegments(){return[this]}serialize(){return{type:"Line",startX:this._start.x,startY:this._start.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof F?F.getOverlaps(this,t):null}getClosestPoints(t){const e=this._end.minus(this._start),s=e.normalized(),i=t.minus(this._start).dot(s),r=O.clamp(i/e.magnitude,0,1),a=this.positionAt(r);return[{segment:this,t:r,closestPoint:a,distanceSquared:a.distanceSquared(t)}]}static deserialize(t){return assert&&assert(t.type==="Line"),new F(new E(t.startX,t.startY),new E(t.endX,t.endY))}static getOverlaps(t,e,s=1e-6){const i=[],r=t._start.x,a=-1*t._start.x+t._end.x,l=t._start.y,o=-1*t._start.y+t._end.y,h=e._start.x,g=-1*e._start.x+e._end.x,p=e._start.y,A=-1*e._start.y+e._end.y,b=Math.abs(Math.max(t._start.x,t._end.x,e._start.x,e._end.x)-Math.min(t._start.x,t._end.x,e._start.x,e._end.x)),S=Math.abs(Math.max(t._start.y,t._end.y,e._start.y,e._end.y)-Math.min(t._start.y,t._end.y,e._start.y,e._end.y)),y=nt.polynomialGetOverlapLinear(r,a,h,g),P=nt.polynomialGetOverlapLinear(l,o,p,A);let x;if(b>S?x=y===null||y===!0?P:y:x=P===null||P===!0?y:P,x===null||x===!0)return i;const v=x.a,T=x.b,M=h+T*g-r,V=v*g-a,$=p+T*A-l,B=v*A-o;if(Math.abs(M)>s||Math.abs(V+M)>s||Math.abs($)>s||Math.abs(B+$)>s)return i;const X=T,k=v+T;return X>1&&k>1||X<0&&k<0?i:[new Qt(v,T)]}static intersect(t,e){const s=O.lineSegmentIntersection(t.start.x,t.start.y,t.end.x,t.end.y,e.start.x,e.start.y,e.end.x,e.end.y);if(s!==null){const i=t.explicitClosestToPoint(s)[0].t,r=e.explicitClosestToPoint(s)[0].t;return[new vt(s,i,r)]}else return[]}static intersectOther(t,e){const s=t.end.minus(t.start),i=s.magnitude,r=new Ht(t.start,s.normalize()),a=e.intersection(r),l=[];for(let o=0;o<a.length;o++){const h=a[o],g=h.distance/i;g>1e-8&&g<1-1e-8&&l.push(new vt(h.point,g,h.t))}return l}}Y.register("Line",F);const Js=O.solveQuadraticRootsReal,Ks=O.arePointsCollinear;function qe(u){return u>=0&&u<=1}class st extends nt{constructor(t,e,s){super(),this._start=t,this._control=e,this._end=s,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Quadratic start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setControl(t){return assert&&assert(t.isFinite(),`Quadratic control should be finite: ${t.toString()}`),this._control.equals(t)||(this._control=t,this.invalidate()),this}set control(t){this.setControl(t)}get control(){return this.getControl()}getControl(){return this._control}setEnd(t){return assert&&assert(t.isFinite(),`Quadratic end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1");const e=1-t;return this._start.times(e*e).plus(this._control.times(2*e*t)).plus(this._end.times(t*t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this._control.minus(this._start).times(2*(1-t)).plus(this._end.minus(this._control).times(2*t))}curvatureAt(t){if(assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),Math.abs(t-.5)>.5-1e-7){const s=t<.5,i=s?this._start:this._end,r=this._control,a=s?this._end:this._start,l=r.minus(i),o=l.magnitude;return(s?-1:1)*l.perpendicular.normalized().dot(a.minus(r))*(this.degree-1)/(this.degree*o*o)}else return this.subdivided(t)[0].curvatureAt(1)}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this._start.blend(this._control,t),s=this._control.blend(this._end,t),i=e.blend(s,t);return[new st(this._start,e,i),new st(i,s,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Quadratic start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Quadratic start should be finite: ${this._start.toString()}`),assert&&assert(this._control instanceof E,`Quadratic control should be a Vector2: ${this._control}`),assert&&assert(this._control.isFinite(),`Quadratic control should be finite: ${this._control.toString()}`),assert&&assert(this._end instanceof E,`Quadratic end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Quadratic end should be finite: ${this._end.toString()}`),this._startTangent=null,this._endTangent=null,this._tCriticalX=null,this._tCriticalY=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){if(this._startTangent===null){const t=this._start.equals(this._control);this._startTangent=t?this._end.minus(this._start).normalized():this._control.minus(this._start).normalized()}return this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){if(this._endTangent===null){const t=this._end.equals(this._control);this._endTangent=t?this._end.minus(this._start).normalized():this._end.minus(this._control).normalized()}return this._endTangent}get endTangent(){return this.getEndTangent()}getTCriticalX(){return this._tCriticalX===null&&(this._tCriticalX=st.extremaT(this._start.x,this._control.x,this._end.x)),this._tCriticalX}get tCriticalX(){return this.getTCriticalX()}getTCriticalY(){return this._tCriticalY===null&&(this._tCriticalY=st.extremaT(this._start.y,this._control.y,this._end.y)),this._tCriticalY}get tCriticalY(){return this.getTCriticalY()}getNondegenerateSegments(){const t=this._start,e=this._control,s=this._end,i=t.equals(s),r=t.equals(e),a=t.equals(e);if(i&&r)return[];if(i){const l=this.positionAt(.5);return[new F(t,l),new F(l,s)]}else if(Ks(t,e,s)){if(r||a)return[new F(t,s)];const l=s.minus(t),o=e.minus(t).dot(l.normalized())/l.magnitude,h=st.extremaT(0,o,1);if(!isNaN(h)&&h>0&&h<1){const g=this.positionAt(h);return _.flatten([new F(t,g).getNondegenerateSegments(),new F(g,s).getNondegenerateSegments()])}else return[new F(t,s)]}else return[this]}getBounds(){if(this._bounds===null){this._bounds=new ot(Math.min(this._start.x,this._end.x),Math.min(this._start.y,this._end.y),Math.max(this._start.x,this._end.x),Math.max(this._start.y,this._end.y));const t=this.getTCriticalX(),e=this.getTCriticalY();!isNaN(t)&&t>0&&t<1&&(this._bounds=this._bounds.withPoint(this.positionAt(t))),!isNaN(e)&&e>0&&e<1&&(this._bounds=this._bounds.withPoint(this.positionAt(e)))}return this._bounds}get bounds(){return this.getBounds()}offsetTo(t,e){let s=[this];const i=5;for(let a=0;a<i;a++)s=_.flatten(_.map(s,l=>l.subdivided(.5)));let r=_.map(s,a=>a.approximateOffset(t));return e&&(r.reverse(),r=_.map(r,a=>a.reversed())),r}degreeElevated(){return new lt(this._start,this._start.plus(this._control.timesScalar(2)).dividedScalar(3),this._end.plus(this._control.timesScalar(2)).dividedScalar(3),this._end)}approximateOffset(t){return new st(this._start.plus((this._start.equals(this._control)?this._end.minus(this._start):this._control.minus(this._start)).perpendicular.normalized().times(t)),this._control.plus(this._end.minus(this._start).perpendicular.normalized().times(t)),this._end.plus((this._end.equals(this._control)?this._end.minus(this._start):this._end.minus(this._control)).perpendicular.normalized().times(t)))}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`Q ${L(this._control.x)} ${L(this._control.y)} ${L(this._end.x)} ${L(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=[],s=this.getTCriticalX(),i=this.getTCriticalY();return!isNaN(s)&&s>1e-10&&s<1-1e-10&&t.push(this.tCriticalX),!isNaN(i)&&i>1e-10&&i<1-1e-10&&t.push(this.tCriticalY),t.sort()}intersection(t){const e=[],s=Bt.rotation2(-t.direction.angle).timesMatrix(Bt.translation(-t.position.x,-t.position.y)),i=s.timesVector2(this._start),r=s.timesVector2(this._control),a=s.timesVector2(this._end),l=i.y-2*r.y+a.y,o=-2*i.y+2*r.y,h=i.y,g=Js(l,o,h);return _.each(g,p=>{if(p>=0&&p<=1){const A=this.positionAt(p),b=this.tangentAt(p).normalized(),S=b.perpendicular,y=A.minus(t.position);if(y.dot(t.direction)>0){const P=S.dot(t.direction)>0?S.negated():S,x=t.direction.perpendicular.dot(b)<0?1:-1;e.push(new zt(y.magnitude,A,P,x,p))}}}),e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,i=>{e+=i.wind}),e}writeToContext(t){t.quadraticCurveTo(this._control.x,this._control.y,this._end.x,this._end.y)}transformed(t){return new st(t.timesVector2(this._start),t.timesVector2(this._control),t.timesVector2(this._end))}getSignedAreaFragment(){return 1/6*(this._start.x*(2*this._control.y+this._end.y)+this._control.x*(-2*this._start.y+2*this._end.y)+this._end.x*(-this._start.y-2*this._control.y))}reparameterized(t,e){const s=this._start.plus(this._end.plus(this._control.timesScalar(-2))),i=this._control.minus(this._start).timesScalar(2),r=this._start,a=s.timesScalar(t*t),l=s.timesScalar(t*e).timesScalar(2).plus(i.timesScalar(t)),o=s.timesScalar(e*e).plus(i.timesScalar(e)).plus(r);return new st(o,l.timesScalar(.5).plus(o),a.plus(l).plus(o))}reversed(){return new st(this._end,this._control,this._start)}serialize(){return{type:"Quadratic",startX:this._start.x,startY:this._start.y,controlX:this._control.x,controlY:this._control.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof st?st.getOverlaps(this,t):null}static deserialize(t){return assert&&assert(t.type==="Quadratic"),new st(new E(t.startX,t.startY),new E(t.controlX,t.controlY),new E(t.endX,t.endY))}static extremaT(t,e,s){const i=2*(s-2*e+t);return i!==0?-2*(e-t)/i:NaN}static getOverlaps(t,e,s=1e-6){const i=[],r=t._start.x,a=-2*t._start.x+2*t._control.x,l=t._start.x-2*t._control.x+t._end.x,o=t._start.y,h=-2*t._start.y+2*t._control.y,g=t._start.y-2*t._control.y+t._end.y,p=e._start.x,A=-2*e._start.x+2*e._control.x,b=e._start.x-2*e._control.x+e._end.x,S=e._start.y,y=-2*e._start.y+2*e._control.y,P=e._start.y-2*e._control.y+e._end.y,x=Math.abs(Math.max(t._start.x,t._control.x,t._end.x,e._start.x,e._control.x,e._end.x)-Math.min(t._start.x,t._control.x,t._end.x,e._start.x,e._control.x,e._end.x)),v=Math.abs(Math.max(t._start.y,t._control.y,t._end.y,e._start.y,e._control.y,e._end.y)-Math.min(t._start.y,t._control.y,t._end.y,e._start.y,e._control.y,e._end.y)),T=nt.polynomialGetOverlapQuadratic(r,a,l,p,A,b),M=nt.polynomialGetOverlapQuadratic(o,h,g,S,y,P);let V;if(x>v?V=T===null||T===!0?M:T:V=M===null||M===!0?T:M,V===null||V===!0)return i;const $=V.a,B=V.b,X=$*$,k=B*B,q=2*$*B,N=p+B*A+k*b-r,j=$*A+q*b-a,Pt=X*b-l,G=S+B*y+k*P-o,it=$*y+q*P-h,At=X*P-g,at=O.solveLinearRootsReal(2*Pt,j),ft=O.solveLinearRootsReal(2*At,it),et=_.uniq([0,1].concat(at?at.filter(qe):[])),tt=_.uniq([0,1].concat(ft?ft.filter(qe):[]));for(let z=0;z<et.length;z++){const ct=et[z];if(Math.abs((Pt*ct+j)*ct+N)>s)return i}for(let z=0;z<tt.length;z++){const ct=tt[z];if(Math.abs((At*ct+it)*ct+G)>s)return i}const Z=B,Ct=$+B;return Z>1&&Ct>1||Z<0&&Ct<0?i:[new Qt($,B)]}}st.prototype.degree=2;Y.register("Quadratic",st);const js=O.solveQuadraticRootsReal,tn=O.solveCubicRootsReal,He=O.arePointsCollinear,ce=new E(0,0),en=new E(0,0),sn=new E(0,0);function xe(u){return u>=0&&u<=1}class lt extends nt{constructor(t,e,s,i){super(),this._start=t,this._control1=e,this._control2=s,this._end=i,this.invalidate()}setStart(t){return assert&&assert(t.isFinite(),`Cubic start should be finite: ${t.toString()}`),this._start.equals(t)||(this._start=t,this.invalidate()),this}set start(t){this.setStart(t)}get start(){return this.getStart()}getStart(){return this._start}setControl1(t){return assert&&assert(t.isFinite(),`Cubic control1 should be finite: ${t.toString()}`),this._control1.equals(t)||(this._control1=t,this.invalidate()),this}set control1(t){this.setControl1(t)}get control1(){return this.getControl1()}getControl1(){return this._control1}setControl2(t){return assert&&assert(t.isFinite(),`Cubic control2 should be finite: ${t.toString()}`),this._control2.equals(t)||(this._control2=t,this.invalidate()),this}set control2(t){this.setControl2(t)}get control2(){return this.getControl2()}getControl2(){return this._control2}setEnd(t){return assert&&assert(t.isFinite(),`Cubic end should be finite: ${t.toString()}`),this._end.equals(t)||(this._end=t,this.invalidate()),this}set end(t){this.setEnd(t)}get end(){return this.getEnd()}getEnd(){return this._end}positionAt(t){assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1");const e=1-t,s=e*e*e,i=3*e*e*t,r=3*e*t*t,a=t*t*t;return new E(this._start.x*s+this._control1.x*i+this._control2.x*r+this._end.x*a,this._start.y*s+this._control1.y*i+this._control2.y*r+this._end.y*a)}tangentAt(t){assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1");const e=1-t;return new E(0,0).set(this._start).multiplyScalar(-3*e*e).add(ce.set(this._control1).multiplyScalar(3*e*e-6*e*t)).add(ce.set(this._control2).multiplyScalar(6*e*t-3*t*t)).add(ce.set(this._end).multiplyScalar(3*t*t))}curvatureAt(t){if(assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),Math.abs(t-.5)>.5-1e-7){const s=t<.5,i=s?this._start:this._end,r=s?this._control1:this._control2,a=s?this._control2:this._control1,l=r.minus(i),o=l.magnitude;return(s?-1:1)*l.perpendicular.normalized().dot(a.minus(r))*(this.degree-1)/(this.degree*o*o)}else return this.subdivided(t)[0].curvatureAt(1)}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this._start.blend(this._control1,t),s=this._control2.blend(this._end,t),i=this._control1.blend(this._control2,t),r=e.blend(i,t),a=i.blend(s,t),l=r.blend(a,t);return[new lt(this._start,e,r,l),new lt(l,a,s,this._end)]}invalidate(){assert&&assert(this._start instanceof E,`Cubic start should be a Vector2: ${this._start}`),assert&&assert(this._start.isFinite(),`Cubic start should be finite: ${this._start.toString()}`),assert&&assert(this._control1 instanceof E,`Cubic control1 should be a Vector2: ${this._control1}`),assert&&assert(this._control1.isFinite(),`Cubic control1 should be finite: ${this._control1.toString()}`),assert&&assert(this._control2 instanceof E,`Cubic control2 should be a Vector2: ${this._control2}`),assert&&assert(this._control2.isFinite(),`Cubic control2 should be finite: ${this._control2.toString()}`),assert&&assert(this._end instanceof E,`Cubic end should be a Vector2: ${this._end}`),assert&&assert(this._end.isFinite(),`Cubic end should be finite: ${this._end.toString()}`),this._startTangent=null,this._endTangent=null,this._r=null,this._s=null,this._tCusp=null,this._tDeterminant=null,this._tInflection1=null,this._tInflection2=null,this._quadratics=null,this._xExtremaT=null,this._yExtremaT=null,this._bounds=null,this._svgPathFragment=null,this.invalidationEmitter.emit()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAt(0).normalized()),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAt(1).normalized()),this._endTangent}get endTangent(){return this.getEndTangent()}getR(){return this._r===null&&(this._r=this._control1.minus(this._start).normalized()),this._r}get r(){return this.getR()}getS(){return this._s===null&&(this._s=this.getR().perpendicular),this._s}get s(){return this.getS()}getTCusp(){return this._tCusp===null&&this.computeCuspInfo(),assert&&assert(this._tCusp!==null),this._tCusp}get tCusp(){return this.getTCusp()}getTDeterminant(){return this._tDeterminant===null&&this.computeCuspInfo(),assert&&assert(this._tDeterminant!==null),this._tDeterminant}get tDeterminant(){return this.getTDeterminant()}getTInflection1(){return this._tInflection1===null&&this.computeCuspInfo(),assert&&assert(this._tInflection1!==null),this._tInflection1}get tInflection1(){return this.getTInflection1()}getTInflection2(){return this._tInflection2===null&&this.computeCuspInfo(),assert&&assert(this._tInflection2!==null),this._tInflection2}get tInflection2(){return this.getTInflection2()}getQuadratics(){return this._quadratics===null&&this.computeCuspSegments(),assert&&assert(this._quadratics!==null),this._quadratics}getXExtremaT(){return this._xExtremaT===null&&(this._xExtremaT=lt.extremaT(this._start.x,this._control1.x,this._control2.x,this._end.x)),this._xExtremaT}get xExtremaT(){return this.getXExtremaT()}getYExtremaT(){return this._yExtremaT===null&&(this._yExtremaT=lt.extremaT(this._start.y,this._control1.y,this._control2.y,this._end.y)),this._yExtremaT}get yExtremaT(){return this.getYExtremaT()}getBounds(){return this._bounds===null&&(this._bounds=ot.NOTHING,this._bounds=this._bounds.withPoint(this._start),this._bounds=this._bounds.withPoint(this._end),_.each(this.getXExtremaT(),t=>{t>=0&&t<=1&&(this._bounds=this._bounds.withPoint(this.positionAt(t)))}),_.each(this.getYExtremaT(),t=>{t>=0&&t<=1&&(this._bounds=this._bounds.withPoint(this.positionAt(t)))}),this.hasCusp()&&(this._bounds=this._bounds.withPoint(this.positionAt(this.getTCusp())))),this._bounds}get bounds(){return this.getBounds()}computeCuspInfo(){const t=this._start.times(-1).plus(this._control1.times(3)).plus(this._control2.times(-3)).plus(this._end),e=this._start.times(3).plus(this._control1.times(-6)).plus(this._control2.times(3)),s=this._start.times(-3).plus(this._control1.times(3)),i=t.perpendicular,r=e.perpendicular,a=i.dot(e);if(this._tCusp=-.5*(i.dot(s)/a),this._tDeterminant=this._tCusp*this._tCusp-1/3*(r.dot(s)/a),this._tDeterminant>=0){const l=Math.sqrt(this._tDeterminant);this._tInflection1=this._tCusp-l,this._tInflection2=this._tCusp+l}else this._tInflection1=NaN,this._tInflection2=NaN}computeCuspSegments(){if(this.hasCusp()){this._quadratics=[];const t=this.getTCusp();if(t===0)this._quadratics.push(new st(this.start,this.control2,this.end));else if(t===1)this._quadratics.push(new st(this.start,this.control1,this.end));else{const e=this.subdivided(t);this._quadratics.push(new st(e[0].start,e[0].control1,e[0].end)),this._quadratics.push(new st(e[1].start,e[1].control2,e[1].end))}}else this._quadratics=null}getNondegenerateSegments(){const t=this._start,e=this._control1,s=this._control2,i=this._end,r=this.degreeReduced(1e-9);if(t.equals(i)&&t.equals(e)&&t.equals(s))return[];if(this.hasCusp())return _.flatten(this.getQuadratics().map(a=>a.getNondegenerateSegments()));if(r)return r.getNondegenerateSegments();if(He(t,e,i)&&He(t,s,i)&&!t.equalsEpsilon(i,1e-7)){const a=this.getXExtremaT().concat(this.getYExtremaT()).sort().map(h=>this.positionAt(h)),l=[];let o=t;a.length&&(l.push(new F(t,a[0])),o=a[0]);for(let h=1;h<a.length;h++)l.push(new F(a[h-1],a[h])),o=a[h];return l.push(new F(o,i)),_.flatten(l.map(h=>h.getNondegenerateSegments()))}else return[this]}hasCusp(){const t=this.getTCusp();return t>=0&&t<=1&&this.tangentAt(t).magnitude<1e-7}toRS(t){const e=t.minus(this._start);return new E(e.dot(this.getR()),e.dot(this.getS()))}offsetTo(t,e){const i=[],r=[];for(let a=0;a<32;a++){let l=a/31;e&&(l=1-l),i.push(this.positionAt(l).plus(this.tangentAt(l).perpendicular.normalized().times(t))),a>0&&r.push(new F(i[a-1],i[a]))}return r}getSVGPathFragment(){let t;return assert&&(t=this._svgPathFragment,this._svgPathFragment=null),this._svgPathFragment||(this._svgPathFragment=`C ${L(this._control1.x)} ${L(this._control1.y)} ${L(this._control2.x)} ${L(this._control2.y)} ${L(this._end.x)} ${L(this._end.y)}`),assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=this.getXExtremaT().concat(this.getYExtremaT()),e=[];return _.each(t,s=>{s>1e-10&&s<1-1e-10&&_.every(e,r=>Math.abs(s-r)>1e-10)&&e.push(s)}),e.sort()}intersection(t){const e=[],s=Bt.rotation2(-t.direction.angle).timesMatrix(Bt.translation(-t.position.x,-t.position.y)),i=s.timesVector2(this._start),r=s.timesVector2(this._control1),a=s.timesVector2(this._control2),l=s.timesVector2(this._end),o=-i.y+3*r.y-3*a.y+l.y,h=3*i.y-6*r.y+3*a.y,g=-3*i.y+3*r.y,p=i.y,A=tn(o,h,g,p);return _.each(A,b=>{if(b>=0&&b<=1){const S=this.positionAt(b),y=this.tangentAt(b).normalized(),P=y.perpendicular,x=S.minus(t.position);if(x.dot(t.direction)>0){const v=P.dot(t.direction)>0?P.negated():P,T=t.direction.perpendicular.dot(y)<0?1:-1;e.push(new zt(x.magnitude,S,v,T,b))}}}),e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,i=>{e+=i.wind}),e}writeToContext(t){t.bezierCurveTo(this._control1.x,this._control1.y,this._control2.x,this._control2.y,this._end.x,this._end.y)}transformed(t){return new lt(t.timesVector2(this._start),t.timesVector2(this._control1),t.timesVector2(this._control2),t.timesVector2(this._end))}degreeReduced(t){t=t||0;const e=ce.set(this._control1).multiplyScalar(3).subtract(this._start).divideScalar(2),s=en.set(this._control2).multiplyScalar(3).subtract(this._end).divideScalar(2);return sn.set(e).subtract(s).magnitude<=t?new st(this._start,e.average(s),this._end):null}getSignedAreaFragment(){return 1/20*(this._start.x*(6*this._control1.y+3*this._control2.y+this._end.y)+this._control1.x*(-6*this._start.y+3*this._control2.y+3*this._end.y)+this._control2.x*(-3*this._start.y-3*this._control1.y+6*this._end.y)+this._end.x*(-this._start.y-3*this._control1.y-6*this._control2.y))}reversed(){return new lt(this._end,this._control2,this._control1,this._start)}getSelfIntersection(){const t=this.getInteriorExtremaTs(),e=[0].concat(t).concat([1]),s=this.subdivisions(t);if(s.length<3)return null;for(let i=0;i<s.length;i++){const r=s[i];for(let a=i+1;a<s.length;a++){const l=s[a],o=Jt.intersect(r,l);if(assert&&assert(o.length<2),o.length){const h=o[0];if(h.aT>1e-7&&h.aT<1-1e-7&&h.bT>1e-7&&h.bT<1-1e-7){const g=e[i]+h.aT*(e[i+1]-e[i]),p=e[a]+h.bT*(e[a+1]-e[a]);return new vt(h.point,g,p)}}}}return null}serialize(){return{type:"Cubic",startX:this._start.x,startY:this._start.y,control1X:this._control1.x,control1Y:this._control1.y,control2X:this._control2.x,control2Y:this._control2.y,endX:this._end.x,endY:this._end.y}}getOverlaps(t,e=1e-6){return t instanceof lt?lt.getOverlaps(this,t):null}static deserialize(t){return assert&&assert(t.type==="Cubic"),new lt(new E(t.startX,t.startY),new E(t.control1X,t.control1Y),new E(t.control2X,t.control2Y),new E(t.endX,t.endY))}static extremaT(t,e,s,i){if(t===e&&t===s&&t===i)return[];const r=-3*t+9*e-9*s+3*i,a=6*t-12*e+6*s,l=-3*t+3*e;return _.filter(js(r,a,l),xe)}static getOverlaps(t,e,s=1e-6){const i=[],r=t._start.x,a=-3*t._start.x+3*t._control1.x,l=3*t._start.x-6*t._control1.x+3*t._control2.x,o=-1*t._start.x+3*t._control1.x-3*t._control2.x+t._end.x,h=t._start.y,g=-3*t._start.y+3*t._control1.y,p=3*t._start.y-6*t._control1.y+3*t._control2.y,A=-1*t._start.y+3*t._control1.y-3*t._control2.y+t._end.y,b=e._start.x,S=-3*e._start.x+3*e._control1.x,y=3*e._start.x-6*e._control1.x+3*e._control2.x,P=-1*e._start.x+3*e._control1.x-3*e._control2.x+e._end.x,x=e._start.y,v=-3*e._start.y+3*e._control1.y,T=3*e._start.y-6*e._control1.y+3*e._control2.y,M=-1*e._start.y+3*e._control1.y-3*e._control2.y+e._end.y,V=Math.abs(Math.max(t._start.x,t._control1.x,t._control2.x,t._end.x,t._start.x,t._control1.x,t._control2.x,t._end.x)-Math.min(t._start.x,t._control1.x,t._control2.x,t._end.x,t._start.x,t._control1.x,t._control2.x,t._end.x)),$=Math.abs(Math.max(t._start.y,t._control1.y,t._control2.y,t._end.y,t._start.y,t._control1.y,t._control2.y,t._end.y)-Math.min(t._start.y,t._control1.y,t._control2.y,t._end.y,t._start.y,t._control1.y,t._control2.y,t._end.y)),B=nt.polynomialGetOverlapCubic(r,a,l,o,b,S,y,P),X=nt.polynomialGetOverlapCubic(h,g,p,A,x,v,T,M);let k;if(V>$?k=B===null||B===!0?X:B:k=X===null||X===!0?B:X,k===null||k===!0)return i;const q=k.a,N=k.b,j=q*q,Pt=q*q*q,G=N*N,it=N*N*N,At=2*q*N,at=3*q*G,ft=3*j*N,et=b+N*S+G*y+it*P-r,tt=q*S+At*y+at*P-a,Z=j*y+ft*P-l,Ct=Pt*P-o,z=x+N*v+G*T+it*M-h,ct=q*v+At*T+at*M-g,dt=j*T+ft*M-p,pt=Pt*M-A,St=O.solveQuadraticRootsReal(3*Ct,2*Z,tt),Tt=O.solveQuadraticRootsReal(3*pt,2*dt,ct),Et=_.uniq([0,1].concat(St!==null?St.filter(xe):[])),Nt=_.uniq([0,1].concat(Tt!==null?Tt.filter(xe):[]));for(let Lt=0;Lt<Et.length;Lt++){const Rt=Et[Lt];if(Math.abs(((Ct*Rt+Z)*Rt+tt)*Rt+et)>s)return i}for(let Lt=0;Lt<Nt.length;Lt++){const Rt=Nt[Lt];if(Math.abs(((pt*Rt+dt)*Rt+ct)*Rt+z)>s)return i}const R=N,ue=q+N;return R>1&&ue>1||R<0&&ue<0?i:[new Qt(q,N)]}}lt.prototype.degree=3;Y.register("Cubic",lt);const Vt=Math.PI*2;class H extends nt{constructor(t,e,s,i,r){super(),this._center=t,this._radius=e,this._startAngle=s,this._endAngle=i,this._anticlockwise=r,this.invalidate()}setCenter(t){return assert&&assert(t.isFinite(),`Arc center should be finite: ${t.toString()}`),this._center.equals(t)||(this._center=t,this.invalidate()),this}set center(t){this.setCenter(t)}get center(){return this.getCenter()}getCenter(){return this._center}setRadius(t){return assert&&assert(isFinite(t),`Arc radius should be a finite number: ${t}`),this._radius!==t&&(this._radius=t,this.invalidate()),this}set radius(t){this.setRadius(t)}get radius(){return this.getRadius()}getRadius(){return this._radius}setStartAngle(t){return assert&&assert(isFinite(t),`Arc startAngle should be a finite number: ${t}`),this._startAngle!==t&&(this._startAngle=t,this.invalidate()),this}set startAngle(t){this.setStartAngle(t)}get startAngle(){return this.getStartAngle()}getStartAngle(){return this._startAngle}setEndAngle(t){return assert&&assert(isFinite(t),`Arc endAngle should be a finite number: ${t}`),this._endAngle!==t&&(this._endAngle=t,this.invalidate()),this}set endAngle(t){this.setEndAngle(t)}get endAngle(){return this.getEndAngle()}getEndAngle(){return this._endAngle}setAnticlockwise(t){return this._anticlockwise!==t&&(this._anticlockwise=t,this.invalidate()),this}set anticlockwise(t){this.setAnticlockwise(t)}get anticlockwise(){return this.getAnticlockwise()}getAnticlockwise(){return this._anticlockwise}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this.positionAtAngle(this.angleAt(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.tangentAtAngle(this.angleAt(t))}curvatureAt(t){return assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1"),(this._anticlockwise?-1:1)/this._radius}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.angleAt(0),s=this.angleAt(t),i=this.angleAt(1);return[new H(this._center,this._radius,e,s,this._anticlockwise),new H(this._center,this._radius,s,i,this._anticlockwise)]}invalidate(){this._start=null,this._end=null,this._startTangent=null,this._endTangent=null,this._actualEndAngle=null,this._isFullPerimeter=null,this._angleDifference=null,this._bounds=null,this._svgPathFragment=null,assert&&assert(this._center instanceof E,"Arc center should be a Vector2"),assert&&assert(this._center.isFinite(),"Arc center should be finite (not NaN or infinite)"),assert&&assert(typeof this._radius=="number",`Arc radius should be a number: ${this._radius}`),assert&&assert(isFinite(this._radius),`Arc radius should be a finite number: ${this._radius}`),assert&&assert(typeof this._startAngle=="number",`Arc startAngle should be a number: ${this._startAngle}`),assert&&assert(isFinite(this._startAngle),`Arc startAngle should be a finite number: ${this._startAngle}`),assert&&assert(typeof this._endAngle=="number",`Arc endAngle should be a number: ${this._endAngle}`),assert&&assert(isFinite(this._endAngle),`Arc endAngle should be a finite number: ${this._endAngle}`),assert&&assert(typeof this._anticlockwise=="boolean",`Arc anticlockwise should be a boolean: ${this._anticlockwise}`),this._radius<0&&(this._radius=-this._radius,this._startAngle+=Math.PI,this._endAngle+=Math.PI),assert&&assert(!(!this.anticlockwise&&this._endAngle-this._startAngle<=-Math.PI*2||this.anticlockwise&&this._startAngle-this._endAngle<=-Math.PI*2),"Not handling arcs with start/end angles that show differences in-between browser handling"),assert&&assert(!(!this.anticlockwise&&this._endAngle-this._startAngle>Math.PI*2||this.anticlockwise&&this._startAngle-this._endAngle>Math.PI*2),"Not handling arcs with start/end angles that show differences in-between browser handling"),this.invalidationEmitter.emit()}getStart(){return this._start===null&&(this._start=this.positionAtAngle(this._startAngle)),this._start}get start(){return this.getStart()}getEnd(){return this._end===null&&(this._end=this.positionAtAngle(this._endAngle)),this._end}get end(){return this.getEnd()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAtAngle(this._startAngle)),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAtAngle(this._endAngle)),this._endTangent}get endTangent(){return this.getEndTangent()}getActualEndAngle(){return this._actualEndAngle===null&&(this._actualEndAngle=H.computeActualEndAngle(this._startAngle,this._endAngle,this._anticlockwise)),this._actualEndAngle}get actualEndAngle(){return this.getActualEndAngle()}getIsFullPerimeter(){return this._isFullPerimeter===null&&(this._isFullPerimeter=!this._anticlockwise&&this._endAngle-this._startAngle>=Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>=Math.PI*2),this._isFullPerimeter}get isFullPerimeter(){return this.getIsFullPerimeter()}getAngleDifference(){return this._angleDifference===null&&(this._angleDifference=this._anticlockwise?this._startAngle-this._endAngle:this._endAngle-this._startAngle,this._angleDifference<0&&(this._angleDifference+=Math.PI*2),assert&&assert(this._angleDifference>=0)),this._angleDifference}get angleDifference(){return this.getAngleDifference()}getBounds(){return this._bounds===null&&(this._bounds=ot.NOTHING.copy().withPoint(this.getStart()).withPoint(this.getEnd()),this._startAngle!==this._endAngle&&(this.includeBoundsAtAngle(0),this.includeBoundsAtAngle(Math.PI/2),this.includeBoundsAtAngle(Math.PI),this.includeBoundsAtAngle(3*Math.PI/2))),this._bounds}get bounds(){return this.getBounds()}getNondegenerateSegments(){return this._radius<=0||this._startAngle===this._endAngle?[]:[this]}includeBoundsAtAngle(t){this.containsAngle(t)&&(this._bounds=this._bounds.withPoint(this._center.plus(E.createPolar(this._radius,t))))}mapAngle(t){return Math.abs(O.moduloBetweenDown(t-this._startAngle,-Math.PI,Math.PI))<1e-8?this._startAngle:Math.abs(O.moduloBetweenDown(t-this.getActualEndAngle(),-Math.PI,Math.PI))<1e-8?this.getActualEndAngle():this._startAngle>this.getActualEndAngle()?O.moduloBetweenUp(t,this._startAngle-2*Math.PI,this._startAngle):O.moduloBetweenDown(t,this._startAngle,this._startAngle+2*Math.PI)}tAtAngle(t){const e=(this.mapAngle(t)-this._startAngle)/(this.getActualEndAngle()-this._startAngle);return assert&&assert(e>=0&&e<=1,`tAtAngle out of range: ${e}`),e}angleAt(t){return this._startAngle+(this.getActualEndAngle()-this._startAngle)*t}positionAtAngle(t){return this._center.plus(E.createPolar(this._radius,t))}tangentAtAngle(t){const e=E.createPolar(1,t);return this._anticlockwise?e.perpendicular:e.perpendicular.negated()}containsAngle(t){const e=this._anticlockwise?t-this._endAngle:t-this._startAngle;return O.moduloBetweenDown(e,0,Math.PI*2)<=this.angleDifference}getSVGPathFragment(){let t;if(assert&&(t=this._svgPathFragment,this._svgPathFragment=null),!this._svgPathFragment){const s=this._anticlockwise?"0":"1";let i;if(this.angleDifference<Math.PI*2-.01)i=this.angleDifference<Math.PI?"0":"1",this._svgPathFragment=`A ${L(this._radius)} ${L(this._radius)} 0 ${i} ${s} ${L(this.end.x)} ${L(this.end.y)}`;else{const r=(this._startAngle+this._endAngle)/2,a=this._center.plus(E.createPolar(this._radius,r));i="0";const l=`A ${L(this._radius)} ${L(this._radius)} 0 ${i} ${s} ${L(a.x)} ${L(a.y)}`,o=`A ${L(this._radius)} ${L(this._radius)} 0 ${i} ${s} ${L(this.end.x)} ${L(this.end.y)}`;this._svgPathFragment=`${l} ${o}`}}return assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return[new H(this._center,this._radius+(this._anticlockwise?1:-1)*t/2,this._startAngle,this._endAngle,this._anticlockwise)]}strokeRight(t){return[new H(this._center,this._radius+(this._anticlockwise?-1:1)*t/2,this._endAngle,this._startAngle,!this._anticlockwise)]}getInteriorExtremaTs(){const t=[];return _.each([0,Math.PI/2,Math.PI,3*Math.PI/2],e=>{if(this.containsAngle(e)){const s=this.tAtAngle(e),i=1e-10;s>i&&s<1-i&&t.push(s)}}),t.sort()}intersection(t){const e=[],i=t.position.minus(this._center),r=t.direction.dot(i),a=i.magnitudeSquared,l=4*r*r-4*(a-this._radius*this._radius);if(l<0)return e;const o=t.direction.dot(this._center)-t.direction.dot(t.position),h=Math.sqrt(l)/2,g=o-h,p=o+h;if(p<0)return e;const A=t.pointAtDistance(p),b=A.minus(this._center).normalized(),S=b.angle;if(g<0)this.containsAngle(S)&&e.push(new zt(p,A,b.negated(),this._anticlockwise?-1:1,this.tAtAngle(S)));else{const y=t.pointAtDistance(g),P=y.minus(this._center).normalized(),x=P.angle;this.containsAngle(x)&&e.push(new zt(g,y,P,this._anticlockwise?1:-1,this.tAtAngle(x))),this.containsAngle(S)&&e.push(new zt(p,A,b.negated(),this._anticlockwise?-1:1,this.tAtAngle(S)))}return e}windingIntersection(t){let e=0;const s=this.intersection(t);return _.each(s,i=>{e+=i.wind}),e}writeToContext(t){t.arc(this._center.x,this._center.y,this._radius,this._startAngle,this._endAngle,this._anticlockwise)}transformed(t){const e=t.timesVector2(E.createPolar(1,this._startAngle)).minus(t.timesVector2(E.ZERO)).angle;let s=t.timesVector2(E.createPolar(1,this._endAngle)).minus(t.timesVector2(E.ZERO)).angle;const i=t.getDeterminant()>=0?this._anticlockwise:!this._anticlockwise;Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(s=i?e-Math.PI*2:e+Math.PI*2);const r=t.getScaleVector();if(r.x!==r.y){const a=r.x*this._radius,l=r.y*this._radius;return new rt(t.timesVector2(this._center),a,l,0,e,s,i)}else{const a=r.x*this._radius;return new H(t.timesVector2(this._center),a,e,s,i)}}getSignedAreaFragment(){const t=this._startAngle,e=this.getActualEndAngle();return .5*this._radius*(this._radius*(e-t)+this._center.x*(Math.sin(e)-Math.sin(t))-this._center.y*(Math.cos(e)-Math.cos(t)))}reversed(){return new H(this._center,this._radius,this._endAngle,this._startAngle,!this._anticlockwise)}getArcLength(){return this.getAngleDifference()*this._radius}toPiecewiseLinearOrArcSegments(){return[this]}serialize(){return{type:"Arc",centerX:this._center.x,centerY:this._center.y,radius:this._radius,startAngle:this._startAngle,endAngle:this._endAngle,anticlockwise:this._anticlockwise}}getOverlaps(t,e=1e-6){return t instanceof H?H.getOverlaps(this,t):null}getConicMatrix(){const t=this.center.x,e=this.center.y,s=1,i=0,r=1,a=-2*t,l=-2*e,o=t*t+e*e-this.radius*this.radius;return Bt.rowMajor(s,i/2,a/2,i/2,r,l/2,a/2,l/2,o)}static deserialize(t){return assert&&assert(t.type==="Arc"),new H(new E(t.centerX,t.centerY),t.radius,t.startAngle,t.endAngle,t.anticlockwise)}static computeActualEndAngle(t,e,s){return s?t>e?e:t<e?e-2*Math.PI:t:t<e?e:t>e?e+Math.PI*2:t}static getPartialOverlap(t,e,s,i,r){assert&&assert(t>0&&t<=Vt+1e-10),assert&&assert(e>=0&&e<Vt+1e-10),assert&&assert(s>=0&&s<=Vt+1e-10),assert&&assert(i>=0&&i<=1),assert&&assert(r>=0&&r<=1);const a=s<e,l=a?s:e,o=a?e:s,h=l,g=Math.min(t,o);return g<h+1e-8?[]:[Qt.createLinear(O.clamp(O.linear(0,t,0,1,h),0,1),O.clamp(O.linear(e,s,i,r,h),0,1),O.clamp(O.linear(0,t,0,1,g),0,1),O.clamp(O.linear(e,s,i,r,g),0,1))]}static getAngularOverlaps(t,e,s,i){assert&&assert(isFinite(t)),assert&&assert(isFinite(e)),assert&&assert(isFinite(s)),assert&&assert(isFinite(i));let r=e-t;const a=r<0?-1:1;r*=a;const l=O.moduloBetweenDown(a*(s-t),0,Vt),o=a*(i-s)+l;let h;return o<-1e-10?(h=-l/(o-l),H.getPartialOverlap(r,l,0,0,h).concat(H.getPartialOverlap(r,Vt,o+Vt,h,1))):o>Vt+1e-10?(h=(Vt-l)/(o-l),H.getPartialOverlap(r,l,Vt,0,h).concat(H.getPartialOverlap(r,0,o-Vt,h,1))):H.getPartialOverlap(r,l,o,0,1)}static getOverlaps(t,e){return t._center.distance(e._center)>1e-4||Math.abs(t._radius-e._radius)>1e-4?[]:H.getAngularOverlaps(t._startAngle,t.getActualEndAngle(),e._startAngle,e.getActualEndAngle())}static getCircleIntersectionPoint(t,e,s,i){assert&&assert(isFinite(e)&&e>=0),assert&&assert(isFinite(i)&&i>=0);const r=s.minus(t),a=r.magnitude;let l=[];if(!(a<1e-10||a>e+i+1e-10))if(a>e+i-1e-10)l=[t.blend(s,e/a)];else{const o=.5*(a*a-i*i+e*e)/a,h=a*a-i*i+e*e,g=4*a*a*e*e-h*h,p=t.blend(s,o/a);if(g>=1e-10){const A=Math.sqrt(g)/a/2,b=r.perpendicular.setMagnitude(A);l=[p.plus(b),p.minus(b)]}else g>-1e-10&&(l=[p])}return assert&&l.forEach(o=>{assert(Math.abs(o.distance(t)-e)<1e-8),assert(Math.abs(o.distance(s)-i)<1e-8)}),l}static intersect(t,e){const i=[];if(t._center.equalsEpsilon(e._center,1e-7)&&Math.abs(t._radius-e._radius)<1e-7){const r=t.positionAt(0),a=t.positionAt(1),l=e.positionAt(0),o=e.positionAt(1);r.equalsEpsilon(l,1e-7)&&i.push(new vt(r.average(l),0,0)),r.equalsEpsilon(o,1e-7)&&i.push(new vt(r.average(o),0,1)),a.equalsEpsilon(l,1e-7)&&i.push(new vt(a.average(l),1,0)),a.equalsEpsilon(o,1e-7)&&i.push(new vt(a.average(o),1,1))}else{const r=H.getCircleIntersectionPoint(t._center,t._radius,e._center,e._radius);for(let a=0;a<r.length;a++){const l=r[a],o=l.minus(t._center).angle,h=l.minus(e._center).angle;t.containsAngle(o)&&e.containsAngle(h)&&i.push(new vt(l,t.tAtAngle(o),e.tAtAngle(h)))}}return i}static createFromPoints(t,e,s){const i=O.circleCenterFromPoints(t,e,s);if(i===null)return new F(t,s);{const r=t.minus(i),a=e.minus(i),l=s.minus(i),o=r.angle,h=a.angle,g=l.angle,p=(r.magnitude+a.magnitude+l.magnitude)/3,A=new H(i,p,o,g,!1);return A.containsAngle(h)?A:new H(i,p,o,g,!0)}}}Y.register("Arc",H);const nn=O.toDegrees,rn=Bt.rowMajor(1,0,0,0,1,0,0,0,-1);class rt extends nt{constructor(t,e,s,i,r,a,l){super(),this._center=t,this._radiusX=e,this._radiusY=s,this._rotation=i,this._startAngle=r,this._endAngle=a,this._anticlockwise=l,this.invalidate()}setCenter(t){return assert&&assert(t.isFinite(),`EllipticalArc center should be finite: ${t.toString()}`),this._center.equals(t)||(this._center=t,this.invalidate()),this}set center(t){this.setCenter(t)}get center(){return this.getCenter()}getCenter(){return this._center}setRadiusX(t){return assert&&assert(isFinite(t),`EllipticalArc radiusX should be a finite number: ${t}`),this._radiusX!==t&&(this._radiusX=t,this.invalidate()),this}set radiusX(t){this.setRadiusX(t)}get radiusX(){return this.getRadiusX()}getRadiusX(){return this._radiusX}setRadiusY(t){return assert&&assert(isFinite(t),`EllipticalArc radiusY should be a finite number: ${t}`),this._radiusY!==t&&(this._radiusY=t,this.invalidate()),this}set radiusY(t){this.setRadiusY(t)}get radiusY(){return this.getRadiusY()}getRadiusY(){return this._radiusY}setRotation(t){return assert&&assert(isFinite(t),`EllipticalArc rotation should be a finite number: ${t}`),this._rotation!==t&&(this._rotation=t,this.invalidate()),this}set rotation(t){this.setRotation(t)}get rotation(){return this.getRotation()}getRotation(){return this._rotation}setStartAngle(t){return assert&&assert(isFinite(t),`EllipticalArc startAngle should be a finite number: ${t}`),this._startAngle!==t&&(this._startAngle=t,this.invalidate()),this}set startAngle(t){this.setStartAngle(t)}get startAngle(){return this.getStartAngle()}getStartAngle(){return this._startAngle}setEndAngle(t){return assert&&assert(isFinite(t),`EllipticalArc endAngle should be a finite number: ${t}`),this._endAngle!==t&&(this._endAngle=t,this.invalidate()),this}set endAngle(t){this.setEndAngle(t)}get endAngle(){return this.getEndAngle()}getEndAngle(){return this._endAngle}setAnticlockwise(t){return this._anticlockwise!==t&&(this._anticlockwise=t,this.invalidate()),this}set anticlockwise(t){this.setAnticlockwise(t)}get anticlockwise(){return this.getAnticlockwise()}getAnticlockwise(){return this._anticlockwise}positionAt(t){return assert&&assert(t>=0,"positionAt t should be non-negative"),assert&&assert(t<=1,"positionAt t should be no greater than 1"),this.positionAtAngle(this.angleAt(t))}tangentAt(t){return assert&&assert(t>=0,"tangentAt t should be non-negative"),assert&&assert(t<=1,"tangentAt t should be no greater than 1"),this.tangentAtAngle(this.angleAt(t))}curvatureAt(t){assert&&assert(t>=0,"curvatureAt t should be non-negative"),assert&&assert(t<=1,"curvatureAt t should be no greater than 1");const e=this.angleAt(t),s=this._radiusX*Math.sin(e),i=this._radiusY*Math.cos(e),r=Math.pow(i*i+s*s,3/2);return(this._anticlockwise?-1:1)*this._radiusX*this._radiusY/r}subdivided(t){if(assert&&assert(t>=0,"subdivided t should be non-negative"),assert&&assert(t<=1,"subdivided t should be no greater than 1"),t===0||t===1)return[this];const e=this.angleAt(0),s=this.angleAt(t),i=this.angleAt(1);return[new rt(this._center,this._radiusX,this._radiusY,this._rotation,e,s,this._anticlockwise),new rt(this._center,this._radiusX,this._radiusY,this._rotation,s,i,this._anticlockwise)]}invalidate(){if(assert&&assert(this._center instanceof E,"Arc center should be a Vector2"),assert&&assert(this._center.isFinite(),"Arc center should be finite (not NaN or infinite)"),assert&&assert(typeof this._radiusX=="number",`Arc radiusX should be a number: ${this._radiusX}`),assert&&assert(isFinite(this._radiusX),`Arc radiusX should be a finite number: ${this._radiusX}`),assert&&assert(typeof this._radiusY=="number",`Arc radiusY should be a number: ${this._radiusY}`),assert&&assert(isFinite(this._radiusY),`Arc radiusY should be a finite number: ${this._radiusY}`),assert&&assert(typeof this._rotation=="number",`Arc rotation should be a number: ${this._rotation}`),assert&&assert(isFinite(this._rotation),`Arc rotation should be a finite number: ${this._rotation}`),assert&&assert(typeof this._startAngle=="number",`Arc startAngle should be a number: ${this._startAngle}`),assert&&assert(isFinite(this._startAngle),`Arc startAngle should be a finite number: ${this._startAngle}`),assert&&assert(typeof this._endAngle=="number",`Arc endAngle should be a number: ${this._endAngle}`),assert&&assert(isFinite(this._endAngle),`Arc endAngle should be a finite number: ${this._endAngle}`),assert&&assert(typeof this._anticlockwise=="boolean",`Arc anticlockwise should be a boolean: ${this._anticlockwise}`),this._unitTransform=null,this._start=null,this._end=null,this._startTangent=null,this._endTangent=null,this._actualEndAngle=null,this._isFullPerimeter=null,this._angleDifference=null,this._unitArcSegment=null,this._bounds=null,this._svgPathFragment=null,this._radiusX<0&&(this._radiusX=-this._radiusX,this._startAngle=Math.PI-this._startAngle,this._endAngle=Math.PI-this._endAngle,this._anticlockwise=!this._anticlockwise),this._radiusY<0&&(this._radiusY=-this._radiusY,this._startAngle=-this._startAngle,this._endAngle=-this._endAngle,this._anticlockwise=!this._anticlockwise),this._radiusX<this._radiusY){this._rotation+=Math.PI/2,this._startAngle-=Math.PI/2,this._endAngle-=Math.PI/2;const t=this._radiusX;this._radiusX=this._radiusY,this._radiusY=t}if(this._radiusX<this._radiusY)throw new Error("Not verified to work if radiusX < radiusY");assert&&assert(!(!this._anticlockwise&&this._endAngle-this._startAngle<=-Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle<=-Math.PI*2),"Not handling elliptical arcs with start/end angles that show differences in-between browser handling"),assert&&assert(!(!this._anticlockwise&&this._endAngle-this._startAngle>Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>Math.PI*2),"Not handling elliptical arcs with start/end angles that show differences in-between browser handling"),this.invalidationEmitter.emit()}getUnitTransform(){return this._unitTransform===null&&(this._unitTransform=rt.computeUnitTransform(this._center,this._radiusX,this._radiusY,this._rotation)),this._unitTransform}get unitTransform(){return this.getUnitTransform()}getStart(){return this._start===null&&(this._start=this.positionAtAngle(this._startAngle)),this._start}get start(){return this.getStart()}getEnd(){return this._end===null&&(this._end=this.positionAtAngle(this._endAngle)),this._end}get end(){return this.getEnd()}getStartTangent(){return this._startTangent===null&&(this._startTangent=this.tangentAtAngle(this._startAngle)),this._startTangent}get startTangent(){return this.getStartTangent()}getEndTangent(){return this._endTangent===null&&(this._endTangent=this.tangentAtAngle(this._endAngle)),this._endTangent}get endTangent(){return this.getEndTangent()}getActualEndAngle(){return this._actualEndAngle===null&&(this._actualEndAngle=H.computeActualEndAngle(this._startAngle,this._endAngle,this._anticlockwise)),this._actualEndAngle}get actualEndAngle(){return this.getActualEndAngle()}getIsFullPerimeter(){return this._isFullPerimeter===null&&(this._isFullPerimeter=!this._anticlockwise&&this._endAngle-this._startAngle>=Math.PI*2||this._anticlockwise&&this._startAngle-this._endAngle>=Math.PI*2),this._isFullPerimeter}get isFullPerimeter(){return this.getIsFullPerimeter()}getAngleDifference(){return this._angleDifference===null&&(this._angleDifference=this._anticlockwise?this._startAngle-this._endAngle:this._endAngle-this._startAngle,this._angleDifference<0&&(this._angleDifference+=Math.PI*2),assert&&assert(this._angleDifference>=0)),this._angleDifference}get angleDifference(){return this.getAngleDifference()}getUnitArcSegment(){return this._unitArcSegment===null&&(this._unitArcSegment=new H(E.ZERO,1,this._startAngle,this._endAngle,this._anticlockwise)),this._unitArcSegment}get unitArcSegment(){return this.getUnitArcSegment()}getBounds(){if(this._bounds===null&&(this._bounds=ot.NOTHING.withPoint(this.getStart()).withPoint(this.getEnd()),this._startAngle!==this._endAngle)){const t=Math.atan(-(this._radiusY/this._radiusX)*Math.tan(this._rotation)),e=Math.atan(this._radiusY/this._radiusX/Math.tan(this._rotation));this.possibleExtremaAngles=[t,t+Math.PI,e,e+Math.PI],_.each(this.possibleExtremaAngles,this.includeBoundsAtAngle.bind(this))}return this._bounds}get bounds(){return this.getBounds()}getNondegenerateSegments(){if(this._radiusX<=0||this._radiusY<=0||this._startAngle===this._endAngle)return[];if(this._radiusX===this._radiusY){const t=this._startAngle+this._rotation;let e=this._endAngle+this._rotation;return Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(e=this._anticlockwise?t-Math.PI*2:t+Math.PI*2),[new H(this._center,this._radiusX,t,e,this._anticlockwise)]}else return[this]}includeBoundsAtAngle(t){this.unitArcSegment.containsAngle(t)&&(this._bounds=this._bounds.withPoint(this.positionAtAngle(t)))}mapAngle(t){return Math.abs(O.moduloBetweenDown(t-this._startAngle,-Math.PI,Math.PI))<1e-8?this._startAngle:Math.abs(O.moduloBetweenDown(t-this.getActualEndAngle(),-Math.PI,Math.PI))<1e-8?this.getActualEndAngle():this._startAngle>this.getActualEndAngle()?O.moduloBetweenUp(t,this._startAngle-2*Math.PI,this._startAngle):O.moduloBetweenDown(t,this._startAngle,this._startAngle+2*Math.PI)}tAtAngle(t){return(this.mapAngle(t)-this._startAngle)/(this.getActualEndAngle()-this._startAngle)}angleAt(t){return this._startAngle+(this.getActualEndAngle()-this._startAngle)*t}positionAtAngle(t){return this.getUnitTransform().transformPosition2(E.createPolar(1,t))}tangentAtAngle(t){const e=this.getUnitTransform().transformNormal2(E.createPolar(1,t));return this._anticlockwise?e.perpendicular:e.perpendicular.negated()}offsetTo(t,e){const i=[],r=[];for(let a=0;a<32;a++){let l=a/31;e&&(l=1-l);const o=this.angleAt(l);i.push(this.positionAtAngle(o).plus(this.tangentAtAngle(o).perpendicular.normalized().times(t))),a>0&&r.push(new F(i[a-1],i[a]))}return r}getSVGPathFragment(){let t;if(assert&&(t=this._svgPathFragment,this._svgPathFragment=null),!this._svgPathFragment){const s=this._anticlockwise?"0":"1";let i;const r=nn(this._rotation);if(this.getAngleDifference()<Math.PI*2-.01)i=this.getAngleDifference()<Math.PI?"0":"1",this._svgPathFragment=`A ${L(this._radiusX)} ${L(this._radiusY)} ${r} ${i} ${s} ${L(this.getEnd().x)} ${L(this.getEnd().y)}`;else{const a=(this._startAngle+this._endAngle)/2,l=this.positionAtAngle(a);i="0";const o=`A ${L(this._radiusX)} ${L(this._radiusY)} ${r} ${i} ${s} ${L(l.x)} ${L(l.y)}`,h=`A ${L(this._radiusX)} ${L(this._radiusY)} ${r} ${i} ${s} ${L(this.getEnd().x)} ${L(this.getEnd().y)}`;this._svgPathFragment=`${o} ${h}`}}return assert&&t&&assert(t===this._svgPathFragment,"Quadratic line segment changed without invalidate()"),this._svgPathFragment}strokeLeft(t){return this.offsetTo(-t/2,!1)}strokeRight(t){return this.offsetTo(t/2,!0)}getInteriorExtremaTs(){const t=[];return _.each(this.possibleExtremaAngles,e=>{if(this.unitArcSegment.containsAngle(e)){const s=this.tAtAngle(e),i=1e-10;s>i&&s<1-i&&t.push(s)}}),t.sort()}intersection(t){const e=this.getUnitTransform(),s=e.inverseRay2(t),i=this.getUnitArcSegment().intersection(s);return _.map(i,r=>{const a=e.transformPosition2(r.point),l=t.position.distance(a),o=e.inverseNormal2(r.normal);return new zt(l,a,o,r.wind,r.t)})}windingIntersection(t){const e=this.getUnitTransform().inverseRay2(t);return this.getUnitArcSegment().windingIntersection(e)}writeToContext(t){t.ellipse?t.ellipse(this._center.x,this._center.y,this._radiusX,this._radiusY,this._rotation,this._startAngle,this._endAngle,this._anticlockwise):(this.getUnitTransform().getMatrix().canvasAppendTransform(t),t.arc(0,0,1,this._startAngle,this._endAngle,this._anticlockwise),this.getUnitTransform().getInverse().canvasAppendTransform(t))}transformed(t){const e=t.timesVector2(E.createPolar(this._radiusX,this._rotation)).minus(t.timesVector2(E.ZERO)),s=t.timesVector2(E.createPolar(this._radiusY,this._rotation+Math.PI/2)).minus(t.timesVector2(E.ZERO)),i=e.angle,r=e.magnitude,a=s.magnitude,l=t.getDeterminant()<0,o=l?!this._anticlockwise:this._anticlockwise,h=l?-this._startAngle:this._startAngle;let g=l?-this._endAngle:this._endAngle;return Math.abs(this._endAngle-this._startAngle)===Math.PI*2&&(g=o?h-Math.PI*2:h+Math.PI*2),new rt(t.timesVector2(this._center),r,a,i,h,g,o)}getSignedAreaFragment(){const t=this._startAngle,e=this.getActualEndAngle(),s=Math.sin(t),i=Math.sin(e),r=Math.cos(t),a=Math.cos(e);return .5*(this._radiusX*this._radiusY*(e-t)+Math.cos(this._rotation)*(this._radiusX*this._center.y*(r-a)+this._radiusY*this._center.x*(i-s))+Math.sin(this._rotation)*(this._radiusX*this._center.x*(a-r)+this._radiusY*this._center.y*(i-s)))}reversed(){return new rt(this._center,this._radiusX,this._radiusY,this._rotation,this._endAngle,this._startAngle,!this._anticlockwise)}serialize(){return{type:"EllipticalArc",centerX:this._center.x,centerY:this._center.y,radiusX:this._radiusX,radiusY:this._radiusY,rotation:this._rotation,startAngle:this._startAngle,endAngle:this._endAngle,anticlockwise:this._anticlockwise}}getOverlaps(t,e=1e-6){return t instanceof rt?rt.getOverlaps(this,t):null}getConicMatrix(){const e=rt.computeUnitMatrix(this._center,this._radiusX,this._radiusY,this._rotation).inverted();return e.transposed().multiplyMatrix(rn).multiplyMatrix(e)}static deserialize(t){return assert&&assert(t.type==="EllipticalArc"),new rt(new E(t.centerX,t.centerY),t.radiusX,t.radiusY,t.rotation,t.startAngle,t.endAngle,t.anticlockwise)}static getOverlapType(t,e,s=1e-4){if(t._center.distance(e._center)<s){const i=Math.abs(t._radiusX-e._radiusX)<s&&Math.abs(t._radiusY-e._radiusY)<s,r=Math.abs(t._radiusX-e._radiusY)<s&&Math.abs(t._radiusY-e._radiusX)<s;if(i&&Math.abs(O.moduloBetweenDown(t._rotation-e._rotation+Math.PI/2,0,Math.PI)-Math.PI/2)<s)return Yt.MATCHING_OVERLAP;if(r&&Math.abs(O.moduloBetweenDown(t._rotation-e._rotation,0,Math.PI)-Math.PI/2)<s)return Yt.OPPOSITE_OVERLAP}return Yt.NONE}static getOverlaps(t,e){return rt.getOverlapType(t,e)===Yt.NONE?[]:H.getAngularOverlaps(t._startAngle+t._rotation,t.getActualEndAngle()+t._rotation,e._startAngle+e._rotation,e.getActualEndAngle()+e._rotation)}static intersect(t,e,s=1e-10){if(rt.getOverlapType(t,e,s)===Yt.NONE)return Jt.intersect(t,e);{const r=[],a=t.positionAt(0),l=t.positionAt(1),o=e.positionAt(0),h=e.positionAt(1);return a.equalsEpsilon(o,s)&&r.push(new vt(a.average(o),0,0)),a.equalsEpsilon(h,s)&&r.push(new vt(a.average(h),0,1)),l.equalsEpsilon(o,s)&&r.push(new vt(l.average(o),1,0)),l.equalsEpsilon(h,s)&&r.push(new vt(l.average(h),1,1)),r}}static computeUnitMatrix(t,e,s,i){return Bt.translationFromVector(t).timesMatrix(Bt.rotation2(i)).timesMatrix(Bt.scaling(e,s))}static computeUnitTransform(t,e,s,i){return new We(rt.computeUnitMatrix(t,e,s,i))}}const $t=class $t extends hs{};$t.MATCHING_OVERLAP=new $t,$t.OPPOSITE_OVERLAP=new $t,$t.NONE=new $t,$t.enumeration=new us($t);let Yt=$t;Y.register("EllipticalArc",rt);class bt{constructor(t,e,s){if(this.segments=[],this.invalidatedEmitter=new Me,this._bounds=null,this._strokedSubpaths=null,this._strokedSubpathsComputed=!1,this._strokedStyles=null,this._invalidatingPoints=!1,this.points=e||(t&&t.length?_.map(t,i=>i.start).concat(t[t.length-1].end):[]),this.closed=!!s,this._invalidateListener=this.invalidate.bind(this),t)for(let i=0;i<t.length;i++)_.each(t[i].getNondegenerateSegments(),r=>{this.addSegmentDirectly(r)})}getBounds(){if(this._bounds===null){const t=ot.NOTHING.copy();_.each(this.segments,e=>{t.includeBounds(e.getBounds())}),this._bounds=t}return this._bounds}get bounds(){return this.getBounds()}getArcLength(t,e,s){let i=0;for(let r=0;r<this.segments.length;r++)i+=this.segments[r].getArcLength(t,e,s);return i}copy(){return new bt(this.segments.slice(0),this.points.slice(0),this.closed)}invalidatePoints(){this._invalidatingPoints=!0;const t=this.segments.length;for(let e=0;e<t;e++)this.segments[e].invalidate();this._invalidatingPoints=!1,this.invalidate()}invalidate(){this._invalidatingPoints||(this._bounds=null,this._strokedSubpathsComputed=!1,this.invalidatedEmitter.emit())}addPoint(t){return this.points.push(t),this}addSegmentDirectly(t){return assert&&assert(t.start.isFinite(),"Segment start is infinite"),assert&&assert(t.end.isFinite(),"Segment end is infinite"),assert&&assert(t.startTangent.isFinite(),"Segment startTangent is infinite"),assert&&assert(t.endTangent.isFinite(),"Segment endTangent is infinite"),assert&&assert(t.bounds.isEmpty()||t.bounds.isFinite(),"Segment bounds is infinite and non-empty"),this.segments.push(t),t.invalidationEmitter.addListener(this._invalidateListener),this}addSegment(t){const s=t.getNondegenerateSegments().length;for(let i=0;i<s;i++)this.addSegmentDirectly(t);return this.invalidate(),this}addClosingSegment(){if(this.hasClosingSegment()){const t=this.getClosingSegment();this.addSegmentDirectly(t),this.invalidate(),this.addPoint(this.getFirstPoint()),this.closed=!0}}close(){this.closed=!0,this.addClosingSegment()}getLength(){return this.points.length}getFirstPoint(){return assert&&assert(this.points.length),_.first(this.points)}getLastPoint(){return assert&&assert(this.points.length),_.last(this.points)}getFirstSegment(){return assert&&assert(this.segments.length),_.first(this.segments)}getLastSegment(){return assert&&assert(this.segments.length),_.last(this.segments)}getFillSegments(){const t=this.segments.slice();return this.hasClosingSegment()&&t.push(this.getClosingSegment()),t}isDrawable(){return this.segments.length>0}isClosed(){return this.closed}hasClosingSegment(){return!this.getFirstPoint().equalsEpsilon(this.getLastPoint(),1e-9)}getClosingSegment(){return assert&&assert(this.hasClosingSegment(),"Implicit closing segment unnecessary on a fully closed path"),new F(this.getLastPoint(),this.getFirstPoint())}getClosestPoints(t){return nt.filterClosestToPointResult(_.flatten(this.segments.map(e=>e.getClosestPoints(t))))}writeToContext(t){if(this.isDrawable()){const e=this.getFirstSegment().start;t.moveTo(e.x,e.y);let s=this.segments.length;this.closed&&s>=2&&this.segments[s-1]instanceof F&&s--;for(let i=0;i<s;i++)this.segments[i].writeToContext(t);this.closed&&t.closePath()}}toPiecewiseLinear(t){return assert&&assert(!t.pointMap,"For use with pointMap, please use nonlinearTransformed"),new bt(_.flatten(_.map(this.segments,e=>e.toPiecewiseLinearSegments(t))),void 0,this.closed)}transformed(t){return new bt(_.map(this.segments,e=>e.transformed(t)),_.map(this.points,e=>t.timesVector2(e)),this.closed)}nonlinearTransformed(t){return new bt(_.flatten(_.map(this.segments,e=>t.methodName&&e[t.methodName]?e[t.methodName](t):e.toPiecewiseLinearSegments(t))),void 0,this.closed)}getBoundsWithTransform(t){const e=ot.NOTHING.copy(),s=this.segments.length;for(let i=0;i<s;i++)e.includeBounds(this.segments[i].getBoundsWithTransform(t));return e}offset(t){if(!this.isDrawable())return new bt([],void 0,this.closed);if(t===0)return new bt(this.segments.slice(),void 0,this.closed);let e;const s=this.segments.slice(),i=[];for(e=0;e<s.length;e++)i.push(s[e].strokeLeft(2*t));let r=[];for(e=0;e<s.length;e++){if(this.closed||e>0){const a=(e>0?e:s.length)-1,l=s[e].start,o=s[a].endTangent,h=s[e].startTangent,g=o.perpendicular.negated().times(t).angle,p=h.perpendicular.negated().times(t).angle,A=o.perpendicular.dot(h)>0;r.push(new H(l,Math.abs(t),g,p,A))}r=r.concat(i[e])}return new bt(r,void 0,this.closed)}stroked(t){if(!this.isDrawable())return[];if(t===void 0&&(t=new ve),assert&&assert(!this._strokedSubpathsComputed||this._strokedStyles&&this._strokedSubpaths),this._strokedSubpathsComputed&&this._strokedStyles.equals(t))return this._strokedSubpaths;const e=t.lineWidth;let s,i=[],r=[];const a=this.getFirstSegment(),l=this.getLastSegment(),o=b=>{i=i.concat(b)},h=b=>{r=r.concat(b)},g=l.end.equals(a.start),p=g?null:new F(this.segments[this.segments.length-1].end,this.segments[0].start);for(s=0;s<this.segments.length;s++)s>0&&o(t.leftJoin(this.segments[s].start,this.segments[s-1].endTangent,this.segments[s].startTangent)),o(this.segments[s].strokeLeft(e));for(s=this.segments.length-1;s>=0;s--)s<this.segments.length-1&&h(t.rightJoin(this.segments[s].end,this.segments[s].endTangent,this.segments[s+1].startTangent)),h(this.segments[s].strokeRight(e));let A;return this.closed?(g?(o(t.leftJoin(l.end,l.endTangent,a.startTangent)),h(t.rightJoin(l.end,l.endTangent,a.startTangent))):(o(t.leftJoin(p.start,l.endTangent,p.startTangent)),o(p.strokeLeft(e)),o(t.leftJoin(p.end,p.endTangent,a.startTangent)),h(t.rightJoin(p.end,p.endTangent,a.startTangent)),h(p.strokeRight(e)),h(t.rightJoin(p.start,l.endTangent,p.startTangent))),A=[new bt(i,void 0,!0),new bt(r,void 0,!0)]):A=[new bt(i.concat(t.cap(l.end,l.endTangent)).concat(r).concat(t.cap(a.start,a.startTangent.negated())),void 0,!0)],this._strokedSubpaths=A,this._strokedSubpathsComputed=!0,this._strokedStyles=t.copy(),A}dashed(t,e,s,i){const r=(o,h)=>{const g=o[o.length-1].concat(h[0]),p=o.slice(0,o.length-1).concat([g]).concat(h.slice(1));return assert&&assert(p.length===o.length+h.length-1),p},a=(o,h)=>{if(!o.hasRightFilled||!h.hasLeftFilled)return!1;const g=_.last(_.last(o.segmentArrays)),p=h.segmentArrays[0][0];return g.end.distance(p.start)<1e-5},l=[];for(let o=0;o<this.segments.length;o++){const h=this.segments[o],g=h.getDashValues(t,e,s,i);l.push(g),e+=g.arcLength;const p=[0].concat(g.values).concat([1]),A=g.initiallyInside;g.hasLeftFilled=A,g.hasRightFilled=p.length%2===0?A:!A,g.segmentArrays=[];for(let b=A?0:1;b<p.length-1;b+=2)p[b]!==p[b+1]&&g.segmentArrays.push([h.slice(p[b],p[b+1])])}for(let o=l.length-1;o>=1;o--){const h=l[o-1],g=l[o];a(h,g)&&l.splice(o-1,2,{segmentArrays:r(h.segmentArrays,g.segmentArrays),hasLeftFilled:h.hasLeftFilled,hasRightFilled:g.hasRightFilled})}if(l.length>1&&a(l[l.length-1],l[0])){const o=l.pop(),h=l.shift();l.push({segmentArrays:r(o.segmentArrays,h.segmentArrays),hasLeftFilled:o.hasLeftFilled,hasRightFilled:h.hasRightFilled})}return this.closed&&l.length===1&&l[0].segmentArrays.length===1&&l[0].hasLeftFilled&&l[0].hasRightFilled?[new bt(l[0].segmentArrays[0],void 0,!0)]:_.flatten(l.map(o=>o.segmentArrays)).map(o=>new bt(o))}serialize(){return{type:"Subpath",segments:this.segments.map(t=>t.serialize()),points:this.points.map(t=>({x:t.x,y:t.y})),closed:this.closed}}static deserialize(t){return assert&&assert(t.type==="Subpath"),new bt(t.segments.map(nt.deserialize),t.points.map(e=>new E(e.x,e.y)),t.closed)}}Y.register("Subpath",bt);const yt=bt,de=Math.random,U=(u,t)=>new E(u,t),De=(u,t,e,s)=>e.copy().subtract(u).multiplyScalar((1-s)/6).add(t),J=class J{constructor(t,e){if(this.subpaths=[],this._invalidatingPoints=!1,this._immutable=!1,this.invalidatedEmitter=new Me,this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=null,this._bounds=e?e.copy():null,this.resetControlPoints(),this._invalidateListener=this.invalidate.bind(this),typeof t=="object")for(let s=0;s<t.length;s++)this.addSubpath(t[s]);t&&typeof t!="object"&&_.each(Zs.parse(t),s=>{assert&&assert(J.prototype[s.cmd]!==void 0,`method ${s.cmd} from parsed SVG does not exist`),this[s.cmd].apply(this,s.args)}),this.invalidate()}resetControlPoints(){this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=null}setQuadraticControlPoint(t){this.lastQuadraticControlPoint=t,this.lastCubicControlPoint=null}setCubicControlPoint(t){this.lastQuadraticControlPoint=null,this.lastCubicControlPoint=t}moveTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.moveToPoint(U(t,e))}moveToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.moveToPointRelative(U(t,e))}moveToPointRelative(t){return this.moveToPoint(this.getRelativePoint().plus(t))}moveToPoint(t){return this.addSubpath(new yt().addPoint(t)),this.resetControlPoints(),this}lineTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.lineToPoint(U(t,e))}lineToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.lineToPointRelative(U(t,e))}lineToPointRelative(t){return this.lineToPoint(this.getRelativePoint().plus(t))}lineToPoint(t){if(this.hasSubpaths()){const e=this.getLastSubpath().getLastPoint(),s=t,i=new F(e,s);this.getLastSubpath().addPoint(s),this.addSegmentAndBounds(i)}else this.ensure(t);return this.resetControlPoints(),this}horizontalLineTo(t){return this.lineTo(t,this.getRelativePoint().y)}horizontalLineToRelative(t){return this.lineToRelative(t,0)}verticalLineTo(t){return this.lineTo(this.getRelativePoint().x,t)}verticalLineToRelative(t){return this.lineToRelative(0,t)}zigZagTo(t,e,s,i,r){return this.zigZagToPoint(new E(t,e),s,i,r)}zigZagToPoint(t,e,s,i){assert&&assert(Number.isInteger(s),`numberZigZags must be an integer: ${s}`),this.ensure(t);const r=this.getLastPoint(),a=t.minus(r),l=a.normalized(),o=l.perpendicular.times(e);let h;i?h=a.magnitude/(s+.5):h=a.magnitude/s;for(let g=0;g<s;g++){const p=l.times(g*h).plus(r),A=p.plus(l.times(h/4)).plus(o),b=p.plus(l.times(3*h/4)).minus(o);this.lineToPoint(A),this.lineToPoint(b)}if(i){const p=l.times(s*h).plus(r).plus(l.times(h/4)).plus(o);this.lineToPoint(p)}return this.lineToPoint(t)}quadraticCurveTo(t,e,s,i){return assert&&assert(isFinite(t),`cpx must be a finite number: ${t}`),assert&&assert(isFinite(e),`cpy must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(i),`y must be a finite number: ${i}`),this.quadraticCurveToPoint(U(t,e),U(s,i))}quadraticCurveToRelative(t,e,s,i){return assert&&assert(isFinite(t),`cpx must be a finite number: ${t}`),assert&&assert(isFinite(e),`cpy must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(i),`y must be a finite number: ${i}`),this.quadraticCurveToPointRelative(U(t,e),U(s,i))}quadraticCurveToPointRelative(t,e){const s=this.getRelativePoint();return this.quadraticCurveToPoint(s.plus(t),s.plus(e))}smoothQuadraticCurveTo(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.quadraticCurveToPoint(this.getSmoothQuadraticControlPoint(),U(t,e))}smoothQuadraticCurveToRelative(t,e){return assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),this.quadraticCurveToPoint(this.getSmoothQuadraticControlPoint(),U(t,e).plus(this.getRelativePoint()))}quadraticCurveToPoint(t,e){this.ensure(t);const s=this.getLastSubpath().getLastPoint(),i=new st(s,t,e);this.getLastSubpath().addPoint(e);const r=i.getNondegenerateSegments();return _.each(r,a=>{this.addSegmentAndBounds(a)}),this.setQuadraticControlPoint(t),this}cubicCurveTo(t,e,s,i,r,a){return assert&&assert(isFinite(t),`cp1x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp1y must be a finite number: ${e}`),assert&&assert(isFinite(s),`cp2x must be a finite number: ${s}`),assert&&assert(isFinite(i),`cp2y must be a finite number: ${i}`),assert&&assert(isFinite(r),`x must be a finite number: ${r}`),assert&&assert(isFinite(a),`y must be a finite number: ${a}`),this.cubicCurveToPoint(U(t,e),U(s,i),U(r,a))}cubicCurveToRelative(t,e,s,i,r,a){return assert&&assert(isFinite(t),`cp1x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp1y must be a finite number: ${e}`),assert&&assert(isFinite(s),`cp2x must be a finite number: ${s}`),assert&&assert(isFinite(i),`cp2y must be a finite number: ${i}`),assert&&assert(isFinite(r),`x must be a finite number: ${r}`),assert&&assert(isFinite(a),`y must be a finite number: ${a}`),this.cubicCurveToPointRelative(U(t,e),U(s,i),U(r,a))}cubicCurveToPointRelative(t,e,s){const i=this.getRelativePoint();return this.cubicCurveToPoint(i.plus(t),i.plus(e),i.plus(s))}smoothCubicCurveTo(t,e,s,i){return assert&&assert(isFinite(t),`cp2x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp2y must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(i),`y must be a finite number: ${i}`),this.cubicCurveToPoint(this.getSmoothCubicControlPoint(),U(t,e),U(s,i))}smoothCubicCurveToRelative(t,e,s,i){return assert&&assert(isFinite(t),`cp2x must be a finite number: ${t}`),assert&&assert(isFinite(e),`cp2y must be a finite number: ${e}`),assert&&assert(isFinite(s),`x must be a finite number: ${s}`),assert&&assert(isFinite(i),`y must be a finite number: ${i}`),this.cubicCurveToPoint(this.getSmoothCubicControlPoint(),U(t,e).plus(this.getRelativePoint()),U(s,i).plus(this.getRelativePoint()))}cubicCurveToPoint(t,e,s){this.ensure(t);const i=this.getLastSubpath().getLastPoint(),a=new lt(i,t,e,s).getNondegenerateSegments();return _.each(a,l=>{this.addSegmentAndBounds(l)}),this.getLastSubpath().addPoint(s),this.setCubicControlPoint(e),this}arc(t,e,s,i,r,a){return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.arcPoint(U(t,e),s,i,r,a)}arcPoint(t,e,s,i,r){r===void 0&&(r=!1);const a=new H(t,e,s,i,r),l=a.getStart(),o=a.getEnd();return this.hasSubpaths()&&this.getLastSubpath().getLength()>0&&!l.equals(this.getLastSubpath().getLastPoint())&&this.addSegmentAndBounds(new F(this.getLastSubpath().getLastPoint(),l)),this.hasSubpaths()||this.addSubpath(new yt),this.getLastSubpath().addPoint(l),this.getLastSubpath().addPoint(o),this.addSegmentAndBounds(a),this.resetControlPoints(),this}ellipticalArc(t,e,s,i,r,a,l,o){return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.ellipticalArcPoint(U(t,e),s,i,r,a,l,o)}ellipticalArcPoint(t,e,s,i,r,a,l){l===void 0&&(l=!1);const o=new rt(t,e,s,i,r,a,l),h=o.start,g=o.end;return this.hasSubpaths()&&this.getLastSubpath().getLength()>0&&!h.equals(this.getLastSubpath().getLastPoint())&&this.addSegmentAndBounds(new F(this.getLastSubpath().getLastPoint(),h)),this.hasSubpaths()||this.addSubpath(new yt),this.getLastSubpath().addPoint(h),this.getLastSubpath().addPoint(g),this.addSegmentAndBounds(o),this.resetControlPoints(),this}close(){if(this.hasSubpaths()){const t=this.getLastSubpath(),e=new yt;t.close(),this.addSubpath(e),e.addPoint(t.getFirstPoint())}return this.resetControlPoints(),this}newSubpath(){return this.addSubpath(new yt),this.resetControlPoints(),this}makeImmutable(){return this._immutable=!0,this.notifyInvalidationListeners(),this}isImmutable(){return this._immutable}ellipticalArcToRelative(t,e,s,i,r,a,l){const o=this.getRelativePoint();return this.ellipticalArcTo(t,e,s,i,r,a+o.x,l+o.y)}ellipticalArcTo(t,e,s,i,r,a,l){const o=new E(a,l);this.ensure(o);const h=this.getLastSubpath().getLastPoint();this.getLastSubpath().addPoint(o),t<0&&(t*=-1),e<0&&(e*=-1);let g=t*t,p=e*e;const A=h.minus(o).dividedScalar(2).rotated(-s),b=A.x*A.x,S=A.y*A.y;let y=new E(t*A.y/e,-e*A.x/t);const P=b/g+S/p;P>1&&(t*=Math.sqrt(P),e*=Math.sqrt(P),g=t*t,p=e*e,y=new E(t*A.y/e,-e*A.x/t)),y.multiplyScalar(Math.sqrt(Math.max(0,(g*p-g*S-p*b)/(g*S+p*b)))),i===r&&y.multiplyScalar(-1);const x=h.blend(o,.5).plus(y.rotated(s)),v=(k,q)=>(k.x*q.y-k.y*q.x>0?1:-1)*k.angleBetween(q),T=new E((A.x-y.x)/t,(A.y-y.y)/e),M=new E((-A.x-y.x)/t,(-A.y-y.y)/e),V=v(E.X_UNIT,T);let $=v(T,M)%(Math.PI*2);!r&&$>0&&($-=Math.PI*2),r&&$<0&&($+=Math.PI*2);const X=new rt(x,t,e,s,V,V+$,!r).getNondegenerateSegments();return _.each(X,k=>{this.addSegmentAndBounds(k)}),this}circle(t,e,s){if(typeof t=="object"){const i=t;return s=e,this.arcPoint(i,s,0,Math.PI*2,!1).close()}else return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.arcPoint(U(t,e),s,0,Math.PI*2,!1).close()}ellipse(t,e,s,i,r){if(typeof t=="object"){const a=t;return r=i,i=s,s=e,this.ellipticalArcPoint(a,s,i,r||0,0,Math.PI*2,!1).close()}else return assert&&assert(isFinite(t),`centerX must be a finite number: ${t}`),assert&&assert(isFinite(e),`centerY must be a finite number: ${e}`),this.ellipticalArcPoint(U(t,e),s,i,r||0,0,Math.PI*2,!1).close()}rect(t,e,s,i){assert&&assert(isFinite(t),`x must be a finite number: ${t}`),assert&&assert(isFinite(e),`y must be a finite number: ${e}`),assert&&assert(isFinite(s),`width must be a finite number: ${s}`),assert&&assert(isFinite(i),`height must be a finite number: ${i}`);const r=new yt;return this.addSubpath(r),r.addPoint(U(t,e)),r.addPoint(U(t+s,e)),r.addPoint(U(t+s,e+i)),r.addPoint(U(t,e+i)),this.addSegmentAndBounds(new F(r.points[0],r.points[1])),this.addSegmentAndBounds(new F(r.points[1],r.points[2])),this.addSegmentAndBounds(new F(r.points[2],r.points[3])),r.close(),this.addSubpath(new yt),this.getLastSubpath().addPoint(U(t,e)),assert&&assert(!isNaN(this.bounds.getX())),this.resetControlPoints(),this}roundRect(t,e,s,i,r,a){const l=t+r,o=t+s-r,h=e+a,g=e+i-a;return r===a?this.arc(o,h,r,-Math.PI/2,0,!1).arc(o,g,r,0,Math.PI/2,!1).arc(l,g,r,Math.PI/2,Math.PI,!1).arc(l,h,r,Math.PI,Math.PI*3/2,!1).close():this.ellipticalArc(o,h,r,a,0,-Math.PI/2,0,!1).ellipticalArc(o,g,r,a,0,0,Math.PI/2,!1).ellipticalArc(l,g,r,a,0,Math.PI/2,Math.PI,!1).ellipticalArc(l,h,r,a,0,Math.PI,Math.PI*3/2,!1).close(),this}polygon(t){const e=t.length;if(e>0){this.moveToPoint(t[0]);for(let s=1;s<e;s++)this.lineToPoint(t[s])}return this.close()}cardinalSpline(t,e){const s=Se()({tension:0,isClosedLineSegments:!1},e);assert&&assert(s.tension<1&&s.tension>-1," the tension goes from -1 to 1 ");const i=t.length,r=s.isClosedLineSegments?i:i-1;for(let a=0;a<r;a++){let l;a===0&&!s.isClosedLineSegments?l=[t[0],t[0],t[1],t[2]]:a===r-1&&!s.isClosedLineSegments?l=[t[a-1],t[a],t[a+1],t[a+1]]:l=[t[(a-1+i)%i],t[a%i],t[(a+1)%i],t[(a+2)%i]];const o=[l[1],De(l[0],l[1],l[2],s.tension),De(l[3],l[2],l[1],s.tension),l[2]];a===0&&(this.ensure(o[0]),this.getLastSubpath().addPoint(o[0])),this.cubicCurveToPoint(o[1],o[2],o[3])}return this}copy(){return new J(_.map(this.subpaths,t=>t.copy()),this.bounds)}writeToContext(t){const e=this.subpaths.length;for(let s=0;s<e;s++)this.subpaths[s].writeToContext(t)}getSVGPath(){let t="";const e=this.subpaths.length;for(let s=0;s<e;s++){const i=this.subpaths[s];if(i.isDrawable()){const r=i.segments[0].start;t+=`M ${L(r.x)} ${L(r.y)} `;for(let a=0;a<i.segments.length;a++)t+=`${i.segments[a].getSVGPathFragment()} `;i.isClosed()&&(t+="Z ")}}return t}getSVGPathWithSafariWorkaround(){let t="";const e=this.subpaths.length;for(let s=0;s<e;s++){const i=this.subpaths[s];if(i.isDrawable()){const r=i.segments[0].start;t+=`M ${L(r.x)} ${L(r.y)} `;for(let a=0;a<i.segments.length;a++){const l=i.segments[a];if(l instanceof st){const o=l.start,h=l.control,g=l.end,p=(o.x+h.x)/2,A=(o.y+h.y)/2,b=(h.x+g.x)/2,S=(h.y+g.y)/2,y=(p+b)/2,P=(A+S)/2;t+=`Q ${L(p)} ${L(A)} ${L(y)} ${L(P)} `,t+=`Q ${L(b)} ${L(S)} ${L(g.x)} ${L(g.y)} `}else t+=`${i.segments[a].getSVGPathFragment()} `}i.isClosed()&&(t+="Z ")}}return t}transformed(t){const e=_.map(this.subpaths,i=>i.transformed(t)),s=_.reduce(e,(i,r)=>i.union(r.bounds),ot.NOTHING);return new J(e,s)}nonlinearTransformed(t){const e=Le({minLevels:0,maxLevels:7,distanceEpsilon:.16,curveEpsilon:t&&t.includeCurvature?.002:null},t),s=_.map(this.subpaths,r=>r.nonlinearTransformed(e)),i=_.reduce(s,(r,a)=>r.union(a.bounds),ot.NOTHING);return new J(s,i)}polarToCartesian(t){return this.nonlinearTransformed(Le({pointMap:e=>E.createPolar(e.y,e.x),methodName:"polarToCartesian"},t))}toPiecewiseLinear(t){return assert&&assert(!t||!t.pointMap,"No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments"),assert&&assert(!t||!t.methodName,"No methodName for toPiecewiseLinear allowed, since it could create non-linear segments"),this.nonlinearTransformed(t)}containsPoint(t){const e=E.X_UNIT.copy();let s=0;for(;s<5&&(s++,_.some(this.subpaths,r=>_.some(r.segments,a=>{const l=a.start.minus(t),o=l.magnitude;return o!==0?(l.divideScalar(o),l.subtract(e),l.magnitudeSquared<1e-9):!1})));)e.rotate(cs.nextDouble());return this.windingIntersection(new Ht(t,e))!==0}intersection(t){let e=[];const s=this.subpaths.length;for(let i=0;i<s;i++){const r=this.subpaths[i];if(r.isDrawable()){const a=r.segments.length;for(let l=0;l<a;l++){const o=r.segments[l];e=e.concat(o.intersection(t))}r.hasClosingSegment()&&(e=e.concat(r.getClosingSegment().intersection(t)))}}return _.sortBy(e,i=>i.distance)}interiorIntersectsLineSegment(t,e){const s=t.blend(e,.5);if(this.containsPoint(s))return!0;const i=e.minus(t),r=i.magnitude;if(r===0)return!1;i.normalize();const a=this.intersection(new Ht(t,i));for(let l=0;l<a.length;l++)if(a[l].distance<=r)return!0;return!1}windingIntersection(t){let e=0;const s=this.subpaths.length;for(let i=0;i<s;i++){const r=this.subpaths[i];if(r.isDrawable()){const a=r.segments.length;for(let l=0;l<a;l++)e+=r.segments[l].windingIntersection(t);r.hasClosingSegment()&&(e+=r.getClosingSegment().windingIntersection(t))}}return e}intersectsBounds(t){if(this.bounds.intersection(t).equals(this.bounds))return!0;const e=new Ht(new E(t.minX,t.minY),new E(1,0)),s=new Ht(new E(t.minX,t.minY),new E(0,1)),i=new Ht(new E(t.maxX,t.maxY),new E(-1,0)),r=new Ht(new E(t.maxX,t.maxY),new E(0,-1));let a,l;const o=this.intersection(e).concat(this.intersection(i));for(l=0;l<o.length;l++)if(a=o[l].point,a.x>=t.minX&&a.x<=t.maxX)return!0;const h=this.intersection(s).concat(this.intersection(r));for(l=0;l<h.length;l++)if(a=h[l].point,a.y>=t.minY&&a.y<=t.maxY)return!0;return!1}getStrokedShape(t){let e=[];const s=ot.NOTHING.copy();let i=this.subpaths.length;for(let r=0;r<i;r++){const l=this.subpaths[r].stroked(t);e=e.concat(l)}i=e.length;for(let r=0;r<i;r++)s.includeBounds(e[r].bounds);return new J(e,s)}getOffsetShape(t){const e=[],s=ot.NOTHING.copy();let i=this.subpaths.length;for(let r=0;r<i;r++)e.push(this.subpaths[r].offset(t));i=e.length;for(let r=0;r<i;r++)s.includeBounds(e[r].bounds);return new J(e,s)}getDashedShape(t,e,s){const i=Se()({distanceEpsilon:1e-10,curveEpsilon:1e-8},s);return new J(_.flatten(this.subpaths.map(r=>r.dashed(t,e,i.distanceEpsilon,i.curveEpsilon))))}getBounds(){if(this._bounds===null){const t=ot.NOTHING.copy();_.each(this.subpaths,e=>{t.includeBounds(e.getBounds())}),this._bounds=t}return this._bounds}get bounds(){return this.getBounds()}getStrokedBounds(t){let e=!0;for(let s=0;s<this.subpaths.length;s++){const i=this.subpaths[s];if(i.isDrawable()&&!i.isClosed()){e=!1;break}for(let r=0;r<i.segments.length;r++)if(!i.segments[r].areStrokedBoundsDilated()){e=!1;break}}if(e)return this.bounds.dilated(t.lineWidth/2);{const s=this.bounds.copy();for(let i=0;i<this.subpaths.length;i++){const r=this.subpaths[i].stroked(t);for(let a=0;a<r.length;a++)s.includeBounds(r[a].bounds)}return s}}getSimplifiedAreaShape(){return It.simplifyNonZero(this)}getBoundsWithTransform(t,e){const s=ot.NOTHING.copy(),i=this.subpaths.length;for(let r=0;r<i;r++){const a=this.subpaths[r];s.includeBounds(a.getBoundsWithTransform(t))}return e&&s.includeBounds(this.getStrokedShape(e).getBoundsWithTransform(t)),s}getApproximateArea(t){const e=this.bounds.minX,s=this.bounds.minY,i=this.bounds.width,r=this.bounds.height,a=i*r;let l=0;const o=new E(0,0);for(let h=0;h<t;h++)o.x=e+de()*i,o.y=s+de()*r,this.containsPoint(o)&&l++;return a*l/t}getNonoverlappingArea(){return Math.abs(_.sum(this.subpaths.map(t=>_.sum(t.getFillSegments().map(e=>e.getSignedAreaFragment())))))}getArea(){return this.getSimplifiedAreaShape().getNonoverlappingArea()}getApproximateCentroid(t){const e=this.bounds.minX,s=this.bounds.minY,i=this.bounds.width,r=this.bounds.height;let a=0;const l=new E(0,0),o=new E(0,0);for(let h=0;h<t;h++)o.x=e+de()*i,o.y=s+de()*r,this.containsPoint(o)&&(l.add(o),a++);return l.dividedScalar(a)}getClosestPoints(t){return nt.filterClosestToPointResult(_.flatten(this.subpaths.map(e=>e.getClosestPoints(t))))}getClosestPoint(t){return this.getClosestPoints(t)[0].closestPoint}invalidatePoints(){this._invalidatingPoints=!0;const t=this.subpaths.length;for(let e=0;e<t;e++)this.subpaths[e].invalidatePoints();this._invalidatingPoints=!1,this.invalidate()}toString(){return`new phet.kite.Shape( '${this.getSVGPath()}' )`}invalidate(){assert&&assert(!this._immutable,"Attempt to modify an immutable Shape"),this._invalidatingPoints||(this._bounds=null,this.notifyInvalidationListeners())}notifyInvalidationListeners(){this.invalidatedEmitter.emit()}addSegmentAndBounds(t){this.getLastSubpath().addSegment(t),this.invalidate()}ensure(t){this.hasSubpaths()||(this.addSubpath(new yt),this.getLastSubpath().addPoint(t))}addSubpath(t){return this.subpaths.push(t),t.invalidatedEmitter.addListener(this._invalidateListener),this.invalidate(),this}hasSubpaths(){return this.subpaths.length>0}getLastSubpath(){return assert&&assert(this.hasSubpaths(),"We should have a subpath if this is called"),_.last(this.subpaths)}getLastPoint(){return assert&&assert(this.hasSubpaths(),"We should have a subpath if this is called"),assert&&assert(this.getLastSubpath().getLastPoint(),"We should have a last point"),this.getLastSubpath().getLastPoint()}getLastSegment(){if(!this.hasSubpaths())return null;const t=this.getLastSubpath();return t.isDrawable()?t.getLastSegment():null}getSmoothQuadraticControlPoint(){const t=this.getLastPoint();return this.lastQuadraticControlPoint?t.plus(t.minus(this.lastQuadraticControlPoint)):t}getSmoothCubicControlPoint(){const t=this.getLastPoint();return this.lastCubicControlPoint?t.plus(t.minus(this.lastCubicControlPoint)):t}getRelativePoint(){let t=E.ZERO;if(this.hasSubpaths()){const e=this.getLastSubpath();e.points.length&&(t=e.getLastPoint())}return t}shapeUnion(t){return It.binaryResult(this,t,It.BINARY_NONZERO_UNION)}shapeIntersection(t){return It.binaryResult(this,t,It.BINARY_NONZERO_INTERSECTION)}shapeDifference(t){return It.binaryResult(this,t,It.BINARY_NONZERO_DIFFERENCE)}shapeXor(t){return It.binaryResult(this,t,It.BINARY_NONZERO_XOR)}shapeClip(t,e){return It.clipShape(t,this,e)}getArcLength(t,e,s){let i=0;for(let r=0;r<this.subpaths.length;r++)i+=this.subpaths[r].getArcLength(t,e,s);return i}serialize(){return{type:"Shape",subpaths:this.subpaths.map(t=>t.serialize())}}static deserialize(t){return assert&&assert(t.type==="Shape"),new J(t.subpaths.map(yt.deserialize))}static rectangle(t,e,s,i){return new J().rect(t,e,s,i)}static roundRect(t,e,s,i,r,a){return new J().roundRect(t,e,s,i,r,a)}static roundedRectangleWithRadii(t,e,s,i,r){let a=r&&r.topLeft||0,l=r&&r.topRight||0,o=r&&r.bottomLeft||0,h=r&&r.bottomRight||0;assert&&assert(isFinite(t),"Non-finite x"),assert&&assert(isFinite(e),"Non-finite y"),assert&&assert(s>=0&&isFinite(s),"Negative or non-finite width"),assert&&assert(i>=0&&isFinite(i),"Negative or non-finite height"),assert&&assert(a>=0&&isFinite(a),"Invalid topLeft"),assert&&assert(l>=0&&isFinite(l),"Invalid topRight"),assert&&assert(o>=0&&isFinite(o),"Invalid bottomLeft"),assert&&assert(h>=0&&isFinite(h),"Invalid bottomRight");const g=a+l;g>s&&g>0&&(a=a/g*s,l=l/g*s);const p=o+h;p>s&&p>0&&(o=o/p*s,h=h/p*s);const A=a+o;A>i&&A>0&&(a=a/A*i,o=o/A*i);const b=l+h;b>i&&b>0&&(l=l/b*i,h=h/b*i),assert&&assert(a+l<=s,"Corner overlap on top edge"),assert&&assert(o+h<=s,"Corner overlap on bottom edge"),assert&&assert(a+o<=i,"Corner overlap on left edge"),assert&&assert(l+h<=i,"Corner overlap on right edge");const S=new J,y=t+s,P=e+i;return h>0?S.arc(y-h,P-h,h,0,Math.PI/2,!1):S.moveTo(y,P),o>0?S.arc(t+o,P-o,o,Math.PI/2,Math.PI,!1):S.lineTo(t,P),a>0?S.arc(t+a,e+a,a,Math.PI,3*Math.PI/2,!1):S.lineTo(t,e),l>0?S.arc(y-l,e+l,l,3*Math.PI/2,2*Math.PI,!1):S.lineTo(y,e),S.close(),S}static boundsOffsetWithRadii(t,e,s){const i=t.withOffsets(e.left,e.top,e.right,e.bottom);return J.roundedRectangleWithRadii(i.minX,i.minY,i.width,i.height,s)}static polygon(t){return new J().polygon(t)}static bounds(t){return new J().rect(t.minX,t.minY,t.maxX-t.minX,t.maxY-t.minY)}static lineSegment(t,e,s,i){return typeof t=="number"?new J().moveTo(t,e).lineTo(s,i):new J().moveToPoint(t).lineToPoint(e)}static regularPolygon(t,e){const s=new J;return _.each(_.range(t),i=>{const r=E.createPolar(e,2*Math.PI*i/t);i===0?s.moveToPoint(r):s.lineToPoint(r)}),s.close()}static circle(t,e,s){return e===void 0?new J().circle(0,0,t):new J().circle(t,e,s)}static ellipse(t,e,s,i,r){return i===void 0?new J().ellipse(0,0,t,e,s):new J().ellipse(t,e,s,i,r)}static arc(t,e,s,i,r,a){return new J().arc(t,e,s,i,r,a)}static union(t){return It.unionNonZero(t)}static intersection(t){return It.intersectionNonZero(t)}static xor(t){return It.xorNonZero(t)}static segments(t,e){if(assert)for(let s=1;s<t.length;s++)assert(t[s-1].end.equalsEpsilon(t[s].start,1e-6),"Mismatched start/end");return new J([new yt(t,void 0,!!e)])}};J.rect=J.rectangle,J.roundRectangle=J.roundRect;let fe=J;Y.register("Shape",fe);const an=fe;let ln=0;const se=class se{constructor(t,e){this.id=++ln,this.initialize(t,e)}initialize(t,e){return assert&&assert(t instanceof Y.Edge),assert&&assert(typeof e=="boolean"),this.edge=t,this.face=null,this.isReversed=e,this.signedAreaFragment=t.signedAreaFragment*(e?-1:1),this.startVertex=null,this.endVertex=null,this.sortVector=this.sortVector||new E(0,0),this.data=null,this.updateReferences(),this}serialize(){return{type:"HalfEdge",id:this.id,edge:this.edge.id,face:this.face===null?null:this.face.id,isReversed:this.isReversed,signedAreaFragment:this.signedAreaFragment,startVertex:this.startVertex===null?null:this.startVertex.id,endVertex:this.endVertex===null?null:this.endVertex.id,sortVector:E.Vector2IO.toStateObject(this.sortVector),data:this.data}}dispose(){this.edge=null,this.face=null,this.startVertex=null,this.endVertex=null,this.data=null,this.freeToPool()}getNext(t){for(let e=1;;e++){let s=this.endVertex.incidentHalfEdges.indexOf(this)-e;s<0&&(s+=this.endVertex.incidentHalfEdges.length);const i=this.endVertex.incidentHalfEdges[s].getReversed();if(!(t&&!t(i.edge)))return assert&&assert(this.endVertex===i.startVertex),i}}updateReferences(){this.startVertex=this.isReversed?this.edge.endVertex:this.edge.startVertex,this.endVertex=this.isReversed?this.edge.startVertex:this.edge.endVertex,assert&&assert(this.startVertex),assert&&assert(this.endVertex)}getEndTangent(){return this.isReversed?this.edge.segment.startTangent:this.edge.segment.endTangent.negated()}getEndCurvature(){return this.isReversed?-this.edge.segment.curvatureAt(0):this.edge.segment.curvatureAt(1)}getReversed(){return this.isReversed?this.edge.forwardHalf:this.edge.reversedHalf}getDirectionalSegment(){return this.isReversed?this.edge.segment.reversed():this.edge.segment}freeToPool(){se.pool.freeToPool(this)}};K(se,"pool",new Xt(se));let le=se;Y.register("HalfEdge",le);let on=0;const Zt=class Zt{constructor(t){this.id=++on,this.initialize(t)}initialize(t){return assert&&assert(t instanceof E),this.point=t,this.incidentHalfEdges=_t(this.incidentHalfEdges),this.visited=!1,this.visitIndex=0,this.lowIndex=0,this.data=null,this.internalData={},this}serialize(){return{type:"Vertex",id:this.id,point:E.Vector2IO.toStateObject(this.point),incidentHalfEdges:this.incidentHalfEdges.map(t=>t.id),visited:this.visited,visitIndex:this.visitIndex,lowIndex:this.lowIndex}}dispose(){this.point=E.ZERO,_t(this.incidentHalfEdges),this.freeToPool()}sortEdges(){const t=[];for(let i=0;i<this.incidentHalfEdges.length;i++){const r=this.incidentHalfEdges[i];t.push(r.sortVector.setXY(r.getEndTangent().angle,r.getEndCurvature()))}const e=-Math.PI+1e-4;let s=!1;for(;!s;){s=!0;for(let i=0;i<t.length;i++)t[i].x<e&&(s=!1);if(!s)for(let i=0;i<t.length;i++){const r=t[i];r.x-=1.62594024516,r.x<-Math.PI-1e-4&&(r.x+=Math.PI*2)}}this.incidentHalfEdges.sort(Zt.edgeComparison)}static edgeComparison(t,e){const s=t.sortVector.x,i=e.sortVector.x;if(Math.abs(s-i)>1e-5||s!==i&&t.edge.segment instanceof F&&e.edge.segment instanceof F)return s<i?-1:1;{const r=t.sortVector.y,a=e.sortVector.y;if(Math.abs(r-a)>1e-5)return r<a?1:-1;{const o=t.getDirectionalSegment().subdivided(.999)[1].curvatureAt(0),h=e.getDirectionalSegment().subdivided(.999)[1].curvatureAt(0);return o<h?1:-1}}}freeToPool(){Zt.pool.freeToPool(this)}};K(Zt,"pool",new Xt(Zt));let xt=Zt;Y.register("Vertex",xt);let hn=0;const ne=class ne{constructor(t,e,s){this.id=++hn,this.initialize(t,e,s)}initialize(t,e,s){return assert&&assert(t instanceof nt),assert&&assert(e instanceof xt),assert&&assert(s instanceof xt),assert&&assert(t.start.distance(e.point)<.001),assert&&assert(t.end.distance(s.point)<.001),this.segment=t,this.startVertex=e,this.endVertex=s,this.signedAreaFragment=t.getSignedAreaFragment(),this.forwardHalf=le.pool.create(this,!1),this.reversedHalf=le.pool.create(this,!0),this.visited=!1,this.data=null,this.internalData={},this}serialize(){return{type:"Edge",id:this.id,segment:this.segment.serialize(),startVertex:this.startVertex===null?null:this.startVertex.id,endVertex:this.endVertex===null?null:this.endVertex.id,signedAreaFragment:this.signedAreaFragment,forwardHalf:this.forwardHalf.serialize(),reversedHalf:this.reversedHalf.serialize(),visited:this.visited,data:this.data}}dispose(){this.segment=null,this.startVertex=null,this.endVertex=null,this.forwardHalf.dispose(),this.reversedHalf.dispose(),this.forwardHalf=null,this.reversedHalf=null,this.data=null,this.freeToPool()}getOtherVertex(t){return assert&&assert(t===this.startVertex||t===this.endVertex),this.startVertex===t?this.endVertex:this.startVertex}updateReferences(){this.forwardHalf.updateReferences(),this.reversedHalf.updateReferences(),assert&&assert(!(this.segment instanceof F)||this.startVertex!==this.endVertex,"No line segments for same vertices")}freeToPool(){ne.pool.freeToPool(this)}};K(ne,"pool",new Xt(ne));let gt=ne;Y.register("Edge",gt);let un=0;const ie=class ie{constructor(t){this.id=++un,this.initialize(t)}initialize(t){return assert&&assert(t===null||t.isInner()),this.boundary=t,this.holes=_t(this.holes),this.windingMap=null,this.filled=null,t&&this.addBoundaryFaceReferences(t),this}serialize(){return{type:"Face",id:this.id,boundary:this.boundary===null?null:this.boundary.id,holes:this.holes.map(t=>t.id),windingMap:this.windingMap,filled:this.filled}}dispose(){this.boundary=null,_t(this.holes),this.windingMap=null,this.filled=null,this.freeToPool()}addBoundaryFaceReferences(t){for(let e=0;e<t.halfEdges.length;e++)assert&&assert(t.halfEdges[e].face===null),t.halfEdges[e].face=this}recursivelyAddHoles(t){assert&&assert(!t.isInner()),this.holes.push(t),this.addBoundaryFaceReferences(t);for(let e=0;e<t.childBoundaries.length;e++)this.recursivelyAddHoles(t.childBoundaries[e])}freeToPool(){ie.pool.freeToPool(this)}};K(ie,"pool",new Xt(ie));let Ut=ie;Y.register("Face",Ut);let cn=0;const re=class re{constructor(t,e){this.id=++cn,this.initialize(t,e)}initialize(t,e){return assert&&assert(typeof t=="number"),assert&&assert(typeof e=="boolean"),this.shapeId=t,this.closed=e,this.halfEdges=_t(this.halfEdges),this}serialize(){return{type:"Loop",id:this.id,shapeId:this.shapeId,closed:this.closed,halfEdges:this.halfEdges.map(t=>t.id)}}toSubpath(){const t=[];for(let e=0;e<this.halfEdges.length;e++)t.push(this.halfEdges[e].getDirectionalSegment());return new yt(t,void 0,this.closed)}dispose(){_t(this.halfEdges),this.freeToPool()}freeToPool(){re.pool.freeToPool(this)}};K(re,"pool",new Xt(re));let oe=re;Y.register("Loop",oe);let dn=0;const ae=class ae{constructor(t){this.id=++dn,this.initialize(t)}initialize(t){return this.halfEdges=t,this.signedArea=this.computeSignedArea(),this.bounds=this.computeBounds(),this.childBoundaries=_t(this.childBoundaries),this}serialize(){return{type:"Boundary",id:this.id,halfEdges:this.halfEdges.map(t=>t.id),signedArea:this.signedArea,bounds:ot.Bounds2IO.toStateObject(this.bounds),childBoundaries:this.childBoundaries.map(t=>t.id)}}dispose(){this.halfEdges=[],_t(this.childBoundaries),this.freeToPool()}isInner(){return this.signedArea>0}computeSignedArea(){let t=0;for(let e=0;e<this.halfEdges.length;e++)t+=this.halfEdges[e].signedAreaFragment;return t}computeBounds(){const t=ot.NOTHING.copy();for(let e=0;e<this.halfEdges.length;e++)t.includeBounds(this.halfEdges[e].edge.segment.getBounds());return t}computeExtremePoint(t){assert&&assert(this.halfEdges.length>0,"There is no extreme point if we have no edges");const e=[];for(let i=0;i<this.halfEdges.length;i++)e.push(this.halfEdges[i].edge.segment.transformed(t.getMatrix()));const s=ot.NOTHING.copy();for(let i=0;i<e.length;i++)s.includeBounds(e[i].getBounds());for(let i=0;i<e.length;i++){const r=e[i];if(r.getBounds().top===s.top){let a=new E(0,Number.POSITIVE_INFINITY);const l=[0,1].concat(r.getInteriorExtremaTs());for(let o=0;o<l.length;o++){const h=r.positionAt(l[o]);h.y<a.y&&(a=h)}return t.inversePosition2(a)}}throw new Error("Should not reach here if we have segments")}computeExtremeRay(t){const e=this.computeExtremePoint(t),s=t.inverseDelta2(new E(0,-1)).normalized();return new Ht(e.plus(s.timesScalar(1e-4)),s)}hasHalfEdge(t){for(let e=0;e<this.halfEdges.length;e++)if(this.halfEdges[e]===t)return!0;return!1}toSubpath(){const t=[];for(let e=0;e<this.halfEdges.length;e++)t.push(this.halfEdges[e].getDirectionalSegment());return new yt(t,null,!0)}freeToPool(){ae.pool.freeToPool(this)}};K(ae,"pool",new Xt(ae));let he=ae;Y.register("Boundary",he);const mt=class mt{constructor(t,e,s,i,r,a,l,o,h,g){this.initialize(t,e,s,i,r,a,l,o,h,g)}initialize(t,e,s,i,r,a,l,o,h,g){return this.a=t,this.b=e,this.atMin=s,this.atMax=i,this.btMin=r,this.btMax=a,this.aMin=l,this.aMax=o,this.bMin=h,this.bMax=g,this}pushSubdivisions(t){const e=this,s=(e.atMax+e.atMin)/2,i=(e.btMax+e.btMin)/2;if(s===this.atMin||s===this.atMax||i===this.btMin||i===this.btMax){t.push(this);return}const r=e.a.positionAt(s),a=e.b.positionAt(i);mt.boxIntersects(e.aMin,r,e.bMin,a)&&t.push(mt.pool.create(e.a,e.b,e.atMin,s,e.btMin,i,e.aMin,r,e.bMin,a)),mt.boxIntersects(r,e.aMax,e.bMin,a)&&t.push(mt.pool.create(e.a,e.b,s,e.atMax,e.btMin,i,r,e.aMax,e.bMin,a)),mt.boxIntersects(e.aMin,r,a,e.bMax)&&t.push(mt.pool.create(e.a,e.b,e.atMin,s,i,e.btMax,e.aMin,r,a,e.bMax)),mt.boxIntersects(r,e.aMax,a,e.bMax)&&t.push(mt.pool.create(e.a,e.b,s,e.atMax,i,e.btMax,r,e.aMax,a,e.bMax)),this.freeToPool()}distance(t){const e=this.atMin-t.atMin,s=this.atMax-t.atMax,i=this.btMin-t.btMin,r=this.btMax-t.btMax;return e*e+s*s+i*i+r*r}clean(){this.a=null,this.b=null,this.aMin=null,this.aMax=null,this.bMin=null,this.bMax=null}static intersect(t,e){if(!t.bounds.intersectsBounds(e.bounds))return[];const s=mt.getIntersectionRanges(t,e),i=[];for(let a=0;a<s.length;a++){const l=s[a];let o=!1;t:for(let h=0;h<i.length;h++){const g=i[h];for(let p=0;p<g.length;p++){const A=g[p];if(l.distance(A)<1e-13){g.push(l),o=!0;break t}}}o||i.push([l])}const r=[];for(let a=0;a<i.length;a++){const l=i[a];let o=0,h=0;for(let A=0;A<l.length;A++)o+=l[A].atMin+l[A].atMax,h+=l[A].btMin+l[A].btMax;o/=2*l.length,h/=2*l.length;const g=t.positionAt(o),p=e.positionAt(h);assert&&assert(g.distance(p)<1e-10),r.push(new vt(g.average(p),o,h))}for(let a=0;a<s.length;a++)s[a].freeToPool();return mt.cleanPool(),r}static getIntersectionRanges(t,e){const s=t.getInteriorExtremaTs(),i=e.getInteriorExtremaTs(),r=_.zip([0].concat(s),s.concat([1])),a=_.zip([0].concat(i),i.concat([1]));let l=[];for(let o=0;o<r.length;o++)for(let h=0;h<a.length;h++){const g=r[o][0],p=r[o][1],A=a[h][0],b=a[h][1],S=t.positionAt(g),y=t.positionAt(p),P=e.positionAt(A),x=e.positionAt(b);mt.boxIntersects(S,y,P,x)&&l.push(mt.pool.create(t,e,g,p,A,b,S,y,P,x))}for(let o=0;o<50;o++){const h=[];for(let g=l.length-1;g>=0;g--)l[g].pushSubdivisions(h);l=h}return l}static boxIntersects(t,e,s,i){const r=Math.max(Math.min(t.x,e.x),Math.min(s.x,i.x)),a=Math.max(Math.min(t.y,e.y),Math.min(s.y,i.y)),l=Math.min(Math.max(t.x,e.x),Math.max(s.x,i.x)),o=Math.min(Math.max(t.y,e.y),Math.max(s.y,i.y));return l-r>=0&&o-a>=0}static cleanPool(){mt.pool.forEach(t=>t.clean())}freeToPool(){mt.pool.freeToPool(this)}};mt.pool=new Xt(mt);let Jt=mt;Y.register("BoundsIntersection",Jt);let gn=1;const ze=[];class Ve{constructor(t=1e-6){this.rootNode=Ie.pool.create(this,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),this.rootNode.isBlack=!0,this.epsilon=t,this.items=new Set}query(t,e){const s=gn++;return this.rootNode?this.rootNode.query(t,this.getMinX(t,this.epsilon),this.getMaxX(t,this.epsilon),s,e):!1}addItem(t){const e=this.getMinX(t,this.epsilon),s=this.getMaxX(t,this.epsilon);this.rootNode.split(e,this),this.rootNode.split(s,this),this.rootNode.addItem(t,e,s),this.items.add(t)}removeItem(t){this.rootNode.removeItem(t,this.getMinX(t,this.epsilon),this.getMaxX(t,this.epsilon)),this.items.delete(t)}audit(){this.rootNode.audit(this.epsilon,this.items,[])}toString(){let t=0,e="";return function s(i){e+=`${_.repeat("  ",t)}${i.toString()}
`,t++,i.hasChildren()&&(s(i.left),s(i.right)),t--}(this.rootNode),e}}const Wt=class Wt{constructor(t,e,s){this.items=[],this.initialize(t,e,s)}initialize(t,e,s){return this.min=e,this.max=s,this.splitValue=null,this.left=null,this.right=null,this.parent=null,this.tree=t,this.isBlack=!1,_t(this.items),this}contains(t){return t>=this.min&&t<=this.max}hasChildren(){return this.splitValue!==null}query(t,e,s,i,r){var l,o;let a=!1;if(this.min<=s&&this.max>=e){for(let h=0;h<this.items.length;h++){const g=this.items[h];if((!((l=g.internalData)!=null&&l.segmentId)||((o=g.internalData)==null?void 0:o.segmentId)<i)&&(g.internalData.segmentId=i,a=r(g),a))return!0}this.hasChildren()&&(a||(a=this.left.query(t,e,s,i,r)),a||(a=this.right.query(t,e,s,i,r)))}return a}swapChild(t,e){assert&&assert(this.left===t||this.right===t),this.left===t?this.left=e:this.right=e}hasChild(t){return this.left===t||this.right===t}otherChild(t){return assert&&assert(this.hasChild(t)),this.left===t?this.right:this.left}leftRotate(t){if(assert&&assert(this.hasChildren()&&this.right.hasChildren()),this.right.hasChildren()){const e=this.right,s=this.left,i=e.left,r=e.right;e.parent=this.parent,this.parent?this.parent.swapChild(this,e):t.rootNode=e,this.parent=e,i.parent=this,e.left=this,this.left=s,this.right=i,this.max=i.max,this.splitValue=s.max,e.min=this.min,e.splitValue=this.max;const a=_t(ze);a.push(...this.items),_t(this.items);for(let l=s.items.length-1;l>=0;l--){const o=s.items[l],h=i.items.indexOf(o);h>=0&&(s.items.splice(l,1),i.items.splice(h,1),this.items.push(o))}i.items.push(...e.items),r.items.push(...e.items),_t(e.items),e.items.push(...a)}}rightRotate(t){assert&&assert(this.hasChildren()&&this.left.hasChildren());const e=this.left,s=this.right,i=e.left,r=e.right;e.parent=this.parent,this.parent?this.parent.swapChild(this,e):t.rootNode=e,this.parent=e,r.parent=this,e.right=this,this.left=r,this.right=s,this.min=r.min,this.splitValue=s.min,e.max=this.max,e.splitValue=this.min;const a=_t(ze);a.push(...this.items),_t(this.items);for(let l=s.items.length-1;l>=0;l--){const o=s.items[l],h=r.items.indexOf(o);h>=0&&(s.items.splice(l,1),r.items.splice(h,1),this.items.push(o))}i.items.push(...e.items),r.items.push(...e.items),_t(e.items),e.items.push(...a)}fixRedBlack(t){if(assert&&assert(!this.isBlack),!this.parent)this.isBlack=!0;else{const e=this.parent;if(!e.isBlack){const s=e.parent,i=s.otherChild(e);i.isBlack?e===s.left?this===e.right?(e.leftRotate(t),e.parent.isBlack=!0,e.parent.parent.isBlack=!1,e.parent.parent.rightRotate(t)):(e.isBlack=!0,s.isBlack=!1,s.rightRotate(t)):this===e.left?(e.rightRotate(t),e.parent.isBlack=!0,e.parent.parent.isBlack=!1,e.parent.parent.leftRotate(t)):(e.isBlack=!0,s.isBlack=!1,s.leftRotate(t)):(e.isBlack=!0,i.isBlack=!0,s.isBlack=!1,s.fixRedBlack(t))}}}split(t,e){if(assert&&assert(this.contains(t)),!(t===this.min||t===this.max))if(this.hasChildren())this.splitValue!==t&&(t>this.splitValue?this.right:this.left).split(t,e);else{this.splitValue=t;const s=Wt.pool.create(this.tree,this.min,t);s.parent=this,this.left=s;const i=Wt.pool.create(this.tree,t,this.max);if(i.parent=this,this.right=i,!this.isBlack&&this.parent){const r=this.parent,a=r.otherChild(this);a.isBlack?(this===r.left?(r.rightRotate(e),s.isBlack=!0):(r.leftRotate(e),i.isBlack=!0),this.fixRedBlack(e)):(this.isBlack=!0,a.isBlack=!0,r.isBlack=!1,r.fixRedBlack(e))}}}addItem(t,e,s){this.min>s||this.max<e||(this.min>=e&&this.max<=s?this.items.push(t):this.hasChildren()&&(this.left.addItem(t,e,s),this.right.addItem(t,e,s)))}removeItem(t,e,s){this.min>s||this.max<e||(this.min>=e&&this.max<=s?(assert&&assert(this.items.includes(t)),qt(this.items,t)):this.hasChildren()&&(this.left.removeItem(t,e,s),this.right.removeItem(t,e,s)))}audit(t,e,s=[]){if(assert){for(const i of s)assert(!this.items.includes(i));for(const i of this.items)assert(this.tree.getMinX(i,t)<=this.min),assert(this.tree.getMaxX(i,t)>=this.max);for(const i of s)this.tree.getMinX(i,t)<=this.min&&this.tree.getMaxX(i,t)>=this.max&&assert(e.has(i)||this.items.includes(i));if(assert(this.hasChildren()===(this.left!==null)),assert(this.hasChildren()===(this.right!==null)),assert(this.hasChildren()===(this.splitValue!==null)),assert(this.min<this.max),this.parent&&(assert(this.parent.hasChild(this)),assert(this.isBlack||this.parent.isBlack)),this.hasChildren()){assert(this.left.parent===this),assert(this.right.parent===this),assert(this.min===this.left.min),assert(this.max===this.right.max),assert(this.splitValue===this.left.max),assert(this.splitValue===this.right.min);for(const r of this.left.items)assert(!this.right.items.includes(r),"We shouldn't have two children with the same item");const i=[...s,...this.items];this.left.audit(t,e,i),this.right.audit(t,e,i)}}}toString(){return`[${this.min} ${this.max}] split:${this.splitValue} ${this.isBlack?"black":"red"} ${this.items}`}freeToPool(){Wt.pool.freeToPool(this)}};Wt.pool=new Xt(Wt);let Ie=Wt;Y.register("SegmentTree",Ve);class Ce extends Ve{getMinX(t,e){return t.segment.bounds.left-e}getMaxX(t,e){return t.segment.bounds.right+e}}Y.register("EdgeSegmentTree",Ce);class Je extends Ve{getMinX(t,e){return t.point.x-e}getMaxX(t,e){return t.point.x+e}}Y.register("VertexSegmentTree",Je);let fn=0,ye=0;const pe=1e-5,Xe=.1*pe,Ye=.01*pe,ge=1e-6;class wt{constructor(){this.vertices=[],this.edges=[],this.innerBoundaries=[],this.outerBoundaries=[],this.boundaries=[],this.shapeIds=[],this.loops=[],this.unboundedFace=Ut.pool.create(null),this.faces=[this.unboundedFace]}serialize(){return{type:"Graph",vertices:this.vertices.map(t=>t.serialize()),edges:this.edges.map(t=>t.serialize()),boundaries:this.boundaries.map(t=>t.serialize()),innerBoundaries:this.innerBoundaries.map(t=>t.id),outerBoundaries:this.outerBoundaries.map(t=>t.id),shapeIds:this.shapeIds,loops:this.loops.map(t=>t.serialize()),unboundedFace:this.unboundedFace.id,faces:this.faces.map(t=>t.serialize())}}static deserialize(t){const e=new wt,s={},i={},r={},a={},l={},o={};return e.vertices=t.vertices.map(h=>{const g=new xt(E.Vector2IO.fromStateObject(h.point));return s[h.id]=g,g.visited=h.visited,g.visitIndex=h.visitIndex,g.lowIndex=h.lowIndex,g}),e.edges=t.edges.map(h=>{const g=new gt(nt.deserialize(h.segment),s[h.startVertex],s[h.endVertex]);i[h.id]=g,g.signedAreaFragment=h.signedAreaFragment;const p=(A,b)=>{r[b.id]=A,A.isReversed=b.isReversed,A.signedAreaFragment=b.signedAreaFragment,A.startVertex=s[b.startVertex.id],A.endVertex=s[b.endVertex.id],A.sortVector=E.Vector2IO.fromStateObject(b.sortVector),A.data=b.data};return p(g.forwardHalf,h.forwardHalf),p(g.reversedHalf,h.reversedHalf),g.visited=h.visited,g.data=h.data,g}),t.vertices.forEach((h,g)=>{const p=e.vertices[g];p.incidentHalfEdges=h.incidentHalfEdges.map(A=>r[A])}),e.boundaries=t.boundaries.map(h=>{const g=he.pool.create(h.halfEdges.map(p=>r[p]));return a[h.id]=g,g.signedArea=h.signedArea,g.bounds=ot.Bounds2IO.fromStateObject(h.bounds),g}),t.boundaries.forEach((h,g)=>{const p=e.boundaries[g];p.childBoundaries=h.childBoundaries.map(A=>a[A])}),e.innerBoundaries=t.innerBoundaries.map(h=>a[h]),e.outerBoundaries=t.outerBoundaries.map(h=>a[h]),e.shapeIds=t.shapeIds,e.loops=t.loops.map(h=>{const g=new oe(h.shapeId,h.closed);return l[h.id]=g,g.halfEdges=h.halfEdges.map(p=>r[p]),g}),e.faces=t.faces.map((h,g)=>{const p=g===0?e.unboundedFace:new Ut(a[h.boundary]);return o[h.id]=p,p.holes=h.holes.map(A=>a[A]),p.windingMap=h.windingMap,p.filled=h.filled,p}),t.edges.forEach((h,g)=>{const p=e.edges[g];p.forwardHalf.face=h.forwardHalf.face===null?null:o[h.forwardHalf.face],p.reversedHalf.face=h.reversedHalf.face===null?null:o[h.reversedHalf.face]}),e}addShape(t,e,s){for(let i=0;i<e.subpaths.length;i++)this.addSubpath(t,e.subpaths[i],s)}addSubpath(t,e,s){if(assert&&assert(typeof t=="number"),assert&&assert(e instanceof yt),s=Pe({ensureClosed:!0},s),this.shapeIds.indexOf(t)<0&&this.shapeIds.push(t),e.segments.length===0)return;const i=e.closed||s.ensureClosed,r=s.ensureClosed?e.getFillSegments():e.segments;let a;const l=[];for(a=0;a<r.length;a++){let h=a-1;h<0&&(h=r.length-1);let g=r[h].end;const p=r[a].start;!i&&a===0&&(g=p),p.equals(g)?l.push(xt.pool.create(p)):(assert&&assert(p.distance(g)<1e-5,"Inaccurate start/end points"),l.push(xt.pool.create(p.average(g))))}i||l.push(xt.pool.create(r[r.length-1].end));const o=oe.pool.create(t,i);for(a=0;a<r.length;a++){let h=a+1;i&&h===r.length&&(h=0);const g=gt.pool.create(r[a],l[a],l[h]);o.halfEdges.push(g.forwardHalf),this.addEdge(g)}this.loops.push(o),this.vertices.push(...l)}computeSimplifiedFaces(){this.eliminateOverlap(),this.eliminateSelfIntersection(),this.eliminateIntersection(),this.collapseVertices(),this.removeBridges(),this.removeLowOrderVertices(),this.orderVertexEdges(),this.extractFaces(),this.computeBoundaryTree(),this.computeWindingMap()}computeFaceInclusion(t){for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.filled=t(s.windingMap)}}createFilledSubGraph(){const t=new wt,e={};for(let s=0;s<this.edges.length;s++){const i=this.edges[s];if(i.forwardHalf.face.filled!==i.reversedHalf.face.filled){if(!e[i.startVertex.id]){const l=xt.pool.create(i.startVertex.point);t.vertices.push(l),e[i.startVertex.id]=l}if(!e[i.endVertex.id]){const l=xt.pool.create(i.endVertex.point);t.vertices.push(l),e[i.endVertex.id]=l}const r=e[i.startVertex.id],a=e[i.endVertex.id];t.addEdge(gt.pool.create(i.segment,r,a))}}return t.collapseAdjacentEdges(),t.orderVertexEdges(),t.extractFaces(),t.computeBoundaryTree(),t.fillAlternatingFaces(),t}facesToShape(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];if(s.filled){t.push(s.boundary.toSubpath());for(let i=0;i<s.holes.length;i++)t.push(s.holes[i].toSubpath())}}return new Y.Shape(t)}dispose(){for(;this.boundaries.length;)this.boundaries.pop().dispose();for(_t(this.innerBoundaries),_t(this.outerBoundaries);this.loops.length;)this.loops.pop().dispose();for(;this.faces.length;)this.faces.pop().dispose();for(;this.vertices.length;)this.vertices.pop().dispose();for(;this.edges.length;)this.edges.pop().dispose()}addEdge(t){assert&&assert(t instanceof gt),assert&&assert(!_.includes(t.startVertex.incidentHalfEdges,t.reversedHalf),"Should not already be connected"),assert&&assert(!_.includes(t.endVertex.incidentHalfEdges,t.forwardHalf),"Should not already be connected"),this.edges.push(t),t.startVertex.incidentHalfEdges.push(t.reversedHalf),t.endVertex.incidentHalfEdges.push(t.forwardHalf)}removeEdge(t){assert&&assert(t instanceof gt),qt(this.edges,t),qt(t.startVertex.incidentHalfEdges,t.reversedHalf),qt(t.endVertex.incidentHalfEdges,t.forwardHalf)}replaceEdgeInLoops(t,e){const s=[];for(let i=0;i<e.length;i++)s.push(e[e.length-1-i].getReversed());for(let i=0;i<this.loops.length;i++){const r=this.loops[i];for(let a=r.halfEdges.length-1;a>=0;a--){const l=r.halfEdges[a];if(l.edge===t){const o=l===t.forwardHalf?e:s;Array.prototype.splice.apply(r.halfEdges,[a,1].concat(o))}}}}collapseAdjacentEdges(){let t=!0;for(;t;){t=!1;for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];if(s.incidentHalfEdges.length===2){const i=s.incidentHalfEdges[0].edge,r=s.incidentHalfEdges[1].edge;let a=i.segment,l=r.segment;const o=i.getOtherVertex(s),h=r.getOtherVertex(s);if(assert&&assert(this.loops.length===0),i.startVertex===s&&(a=a.reversed()),r.endVertex===s&&(l=l.reversed()),a instanceof F&&l instanceof F&&a.tangentAt(0).normalized().distance(l.tangentAt(0).normalized())<1e-6){this.removeEdge(i),this.removeEdge(r),i.dispose(),r.dispose(),qt(this.vertices,s),s.dispose();const g=new F(o.point,h.point);this.addEdge(new gt(g,o,h)),t=!0;break}}}}}eliminateOverlap(){const e=new window.FlatQueue,s=new Ce(1e-4),i=ye++,r=o=>{const h=o.segment.bounds;e.push({start:!0,edge:o},h.minY-1e-4),e.push({start:!1,edge:o},h.maxY+1e-4)},a=o=>{o.internalData.removedId=i};for(let o=0;o<this.edges.length;o++)r(this.edges[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.edge;if(h.internalData.removedId!==i)if(o.start){let g=!1,p,A;if(s.query(h,b=>{const S=h.segment.getOverlaps(b.segment);if(S!==null&&S.length)for(let y=0;y<S.length;y++){const P=S[y];if(Math.abs(P.t1-P.t0)>1e-5&&Math.abs(P.qt1-P.qt0)>1e-5)return A=this.splitOverlap(h,b,P),g=!0,p=b,!0}return!1}),g){s.removeItem(p),a(p),a(h);for(let b=0;b<A.length;b++)r(A[b]);l.push(h),l.push(p)}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose()}splitOverlap(t,e,s){const i=[],r=t.segment,a=e.segment;this.removeEdge(t),this.removeEdge(e);let l=s.t0,o=s.t1,h=s.qt0,g=s.qt1;l<1e-5&&(l=0),o>1-1e-5&&(o=1),h<1e-5&&(h=0),g>1-1e-5&&(g=1);const p=l>0?r.subdivided(l)[0]:null,A=h>0?a.subdivided(h)[0]:null,b=o<1?r.subdivided(o)[1]:null,S=g<1?a.subdivided(g)[1]:null;let y=r;l>0&&(y=y.subdivided(l)[1]),o<1&&(y=y.subdivided(O.linear(l,1,0,1,o))[0]);let P;p&&A?(P=xt.pool.create(y.start),this.vertices.push(P)):p?P=s.a>0?e.startVertex:e.endVertex:P=t.startVertex;let x;b&&S?(x=xt.pool.create(y.end),this.vertices.push(x)):b?x=s.a>0?e.endVertex:e.startVertex:x=t.endVertex;const v=gt.pool.create(y,P,x);i.push(v);let T,M,V,$;p&&(T=gt.pool.create(p,t.startVertex,P),i.push(T)),b&&(M=gt.pool.create(b,x,t.endVertex),i.push(M)),A&&(V=gt.pool.create(A,e.startVertex,s.a>0?P:x),i.push(V)),S&&($=gt.pool.create(S,s.a>0?x:P,e.endVertex),i.push($));for(let N=0;N<i.length;N++)this.addEdge(i[N]);const B=(p?[T]:[]).concat([v]).concat(b?[M]:[]),X=(A?[V]:[]).concat([v]).concat(S?[$]:[]),k=[],q=[];for(let N=0;N<B.length;N++)k.push(B[N].forwardHalf);for(let N=0;N<X.length;N++){const j=X[N]!==v||s.a>0;q.push(j?X[N].forwardHalf:X[N].reversedHalf)}return this.replaceEdgeInLoops(t,k),this.replaceEdgeInLoops(e,q),i}eliminateSelfIntersection(){assert&&assert(this.boundaries.length===0,"Only handles simpler level primitive splitting right now");for(let t=this.edges.length-1;t>=0;t--){const e=this.edges[t],s=e.segment;if(s instanceof lt){const i=s.getSelfIntersection();if(i){assert&&assert(i.aT<i.bT);const r=s.subdivisions([i.aT,i.bT]),a=xt.pool.create(i.point);this.vertices.push(a);const l=gt.pool.create(r[0],e.startVertex,a),o=gt.pool.create(r[1],a,a),h=gt.pool.create(r[2],a,e.endVertex);this.removeEdge(e),this.addEdge(l),this.addEdge(o),this.addEdge(h),this.replaceEdgeInLoops(e,[l.forwardHalf,o.forwardHalf,h.forwardHalf]),e.dispose()}}}}eliminateIntersection(){const e=new window.FlatQueue,s=new Ce(1e-4),i=ye++,r=o=>{const h=o.segment.bounds;e.push({start:!0,edge:o},h.minY-1e-4),e.push({start:!1,edge:o},h.maxY+1e-4)},a=o=>{o.internalData.removedId=i};for(let o=0;o<this.edges.length;o++)r(this.edges[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.edge;if(h.internalData.removedId!==i)if(o.start){let g=!1,p,A,b;if(s.query(h,S=>{const y=h.segment,P=S.segment;let x=nt.intersect(y,P);if(x=x.filter(v=>{const T=v.point;return wt.isInternal(T,v.aT,y,Xe,ge)||wt.isInternal(T,v.bT,P,Xe,ge)}),x.length){const v=x[0],T=this.simpleSplit(h,S,v.aT,v.bT,v.point);if(T)return g=!0,p=S,A=T.addedEdges,b=T.removedEdges,!0}return!1}),g){b.includes(h)?(a(h),l.push(h)):s.addItem(h),b.includes(p)&&(s.removeItem(p),a(p),l.push(p));for(let S=0;S<A.length;S++)r(A[S])}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose()}simpleSplit(t,e,s,i,r){const a=wt.isInternal(r,s,t.segment,Ye,ge),l=wt.isInternal(r,i,e.segment,Ye,ge);let o=null;a?l?(o=xt.pool.create(r),this.vertices.push(o)):o=i<.5?e.startVertex:e.endVertex:o=s<.5?t.startVertex:t.endVertex;let h=!1;const g=[],p=[];return a&&o!==t.startVertex&&o!==t.endVertex&&(g.push(...this.splitEdge(t,s,o)),p.push(t),h=!0),l&&o!==e.startVertex&&o!==e.endVertex&&(g.push(...this.splitEdge(e,i,o)),p.push(e),h=!0),h?{addedEdges:g,removedEdges:p}:null}splitEdge(t,e,s){assert&&assert(this.boundaries.length===0,"Only handles simpler level primitive splitting right now"),assert&&assert(t.startVertex!==s),assert&&assert(t.endVertex!==s);const i=t.segment.subdivided(e);assert&&assert(i.length===2);const r=gt.pool.create(i[0],t.startVertex,s),a=gt.pool.create(i[1],s,t.endVertex);return this.removeEdge(t),this.addEdge(r),this.addEdge(a),this.replaceEdgeInLoops(t,[r.forwardHalf,a.forwardHalf]),[r,a]}collapseVertices(){assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.startVertex))),assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.endVertex)));const t=10*pe,e=new window.FlatQueue,s=new Je(t),i=ye++,r=o=>{e.push({start:!0,vertex:o},o.point.y-t),e.push({start:!1,vertex:o},o.point.y+t)},a=o=>{o.internalData.removedId=i};for(let o=0;o<this.vertices.length;o++)r(this.vertices[o]);const l=[];for(;e.length;){const o=e.pop(),h=o.vertex;if(h.internalData.removedId!==i)if(o.start){let g=!1,p,A;if(s.query(h,b=>{const S=h.point.distance(b.point);if(S<pe){const y=xt.pool.create(S===0?h.point:h.point.average(b.point));this.vertices.push(y),qt(this.vertices,h),qt(this.vertices,b);for(let P=this.edges.length-1;P>=0;P--){const x=this.edges[P],v=x.startVertex===h||x.startVertex===b,T=x.endVertex===h||x.endVertex===b;if(v&&T){if((x.segment.bounds.width>1e-5||x.segment.bounds.height>1e-5)&&(x.segment instanceof lt||x.segment instanceof H||x.segment instanceof rt)){const M=gt.pool.create(x.segment,y,y);this.addEdge(M),this.replaceEdgeInLoops(x,[M.forwardHalf])}else this.replaceEdgeInLoops(x,[]);this.removeEdge(x),x.dispose()}else v?(x.startVertex=y,y.incidentHalfEdges.push(x.reversedHalf),x.updateReferences()):T&&(x.endVertex=y,y.incidentHalfEdges.push(x.forwardHalf),x.updateReferences())}return A=[y],g=!0,p=b,!0}return!1}),g){s.removeItem(p),a(p),a(h);for(let b=0;b<A.length;b++)r(A[b]);l.push(h),l.push(p)}else s.addItem(h)}else s.removeItem(h)}for(let o=0;o<l.length;o++)l[o].dispose();assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.startVertex))),assert&&assert(_.every(this.edges,o=>_.includes(this.vertices,o.endVertex)))}markBridges(t,e){e.visited=!0,e.visitIndex=e.lowIndex=fn++;for(let s=0;s<e.incidentHalfEdges.length;s++){const i=e.incidentHalfEdges[s].edge,r=e.incidentHalfEdges[s].startVertex;r.visited?i.visited||(e.lowIndex=Math.min(e.lowIndex,r.visitIndex)):(i.visited=!0,r.parent=e,this.markBridges(t,r),e.lowIndex=Math.min(e.lowIndex,r.lowIndex),r.lowIndex>e.visitIndex&&t.push(i))}}removeBridges(){const t=[];for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];s.visited||this.markBridges(t,s)}for(let e=0;e<t.length;e++){const s=t[e];this.removeEdge(s),this.replaceEdgeInLoops(s,[]),s.dispose()}}removeLowOrderVertices(){assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.startVertex))),assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.endVertex)));let t=!0;for(;t;){t=!1;for(let e=this.vertices.length-1;e>=0;e--){const s=this.vertices[e];if(s.incidentHalfEdges.length<2){for(let i=0;i<s.incidentHalfEdges.length;i++){const r=s.incidentHalfEdges[i].edge;this.removeEdge(r),this.replaceEdgeInLoops(r,[]),r.dispose()}this.vertices.splice(e,1),s.dispose(),t=!0;break}}}assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.startVertex))),assert&&assert(_.every(this.edges,e=>_.includes(this.vertices,e.endVertex)))}orderVertexEdges(){for(let t=0;t<this.vertices.length;t++)this.vertices[t].sortEdges()}extractFaces(){const t=[];for(let e=0;e<this.edges.length;e++)t.push(this.edges[e].forwardHalf),t.push(this.edges[e].reversedHalf);for(;t.length;){const e=[];let s=t[0];const i=s;for(;s&&(qt(t,s),e.push(s),s=s.getNext(),s!==i););const r=he.pool.create(e);(r.signedArea>0?this.innerBoundaries:this.outerBoundaries).push(r),this.boundaries.push(r)}for(let e=0;e<this.innerBoundaries.length;e++)this.faces.push(Ut.pool.create(this.innerBoundaries[e]))}computeBoundaryTree(){const t=[],e=new We(Bt.rotation2(1.5729657));for(let s=0;s<this.outerBoundaries.length;s++){const i=this.outerBoundaries[s],r=i.computeExtremeRay(e);let a=null,l=Number.POSITIVE_INFINITY,o=!1;for(let h=0;h<this.edges.length;h++){const g=this.edges[h],p=g.segment.intersection(r);for(let A=0;A<p.length;A++){const b=p[A];b.distance<l&&(a=g,l=b.distance,o=b.wind)}}if(a===null)t.push(i);else{const g=o<0?a.reversedHalf:a.forwardHalf;this.getBoundaryOfHalfEdge(g).childBoundaries.push(i)}}t.forEach(this.unboundedFace.recursivelyAddHoles.bind(this.unboundedFace));for(let s=0;s<this.faces.length;s++){const i=this.faces[s];i.boundary!==null&&i.boundary.childBoundaries.forEach(i.recursivelyAddHoles.bind(i))}}computeWindingMap(){const t=this.edges.slice(),e={};for(let s=0;s<this.shapeIds.length;s++)e[this.shapeIds[s]]=0;for(this.unboundedFace.windingMap=e;t.length;)for(let s=t.length-1;s>=0;s--){const i=t[s],r=i.forwardHalf,a=i.reversedHalf,l=r.face,o=a.face;assert&&assert(l!==o);const h=l.windingMap!==null,g=o.windingMap!==null;if(h&&g){if(t.splice(s,1),assert)for(let p=0;p<this.shapeIds.length;p++){const A=this.shapeIds[p];assert(l.windingMap[A]-o.windingMap[A]===this.computeDifferential(i,A))}}else{if(!h&&!g)continue;{const p=h?l:o,A=h?o:l,b={};for(let S=0;S<this.shapeIds.length;S++){const y=this.shapeIds[S],P=this.computeDifferential(i,y);b[y]=p.windingMap[y]+P*(h?-1:1)}A.windingMap=b}}}}computeDifferential(t,e){let s=0;for(let i=0;i<this.loops.length;i++){const r=this.loops[i];if(assert&&assert(r.closed,"This is only defined to work for closed loops"),r.shapeId===e)for(let a=0;a<r.halfEdges.length;a++){const l=r.halfEdges[a];l===t.forwardHalf?s++:l===t.reversedHalf&&s--}}return s}fillAlternatingFaces(){let t=0;for(let e=0;e<this.faces.length;e++)this.faces[e].filled=null,t++;for(this.unboundedFace.filled=!1,t--;t;)for(let e=0;e<this.edges.length;e++){const s=this.edges[e],i=s.forwardHalf.face,r=s.reversedHalf.face,a=i.filled===null,l=r.filled===null;a&&!l?(i.filled=!r.filled,t--):!a&&l&&(r.filled=!i.filled,t--)}}getBoundaryOfHalfEdge(t){for(let e=0;e<this.boundaries.length;e++){const s=this.boundaries[e];if(s.hasHalfEdge(t))return s}throw new Error("Could not find boundary")}static isInternal(t,e,s,i,r){return e>r&&e<1-r&&t.distance(s.start)>i&&t.distance(s.end)>i}static BINARY_NONZERO_UNION(t){return t[0]!==0||t[1]!==0}static BINARY_NONZERO_INTERSECTION(t){return t[0]!==0&&t[1]!==0}static BINARY_NONZERO_DIFFERENCE(t){return t[0]!==0&&t[1]===0}static BINARY_NONZERO_XOR(t){return(t[0]!==0^t[1]!==0)===1}static binaryResult(t,e,s){const i=new wt;i.addShape(0,t),i.addShape(1,e),i.computeSimplifiedFaces(),i.computeFaceInclusion(s);const r=i.createFilledSubGraph(),a=r.facesToShape();return i.dispose(),r.dispose(),a}static unionNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{for(let a=0;a<t.length;a++)if(r[a]!==0)return!0;return!1});const s=e.createFilledSubGraph(),i=s.facesToShape();return e.dispose(),s.dispose(),i}static intersectionNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{for(let a=0;a<t.length;a++)if(r[a]===0)return!1;return!0});const s=e.createFilledSubGraph(),i=s.facesToShape();return e.dispose(),s.dispose(),i}static xorNonZero(t){const e=new wt;for(let r=0;r<t.length;r++)e.addShape(r,t[r]);e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>{let a=!1;for(let l=0;l<t.length;l++)r[l]!==0&&(a=!a);return a});const s=e.createFilledSubGraph(),i=s.facesToShape();return e.dispose(),s.dispose(),i}static simplifyNonZero(t){const e=new wt;e.addShape(0,t),e.computeSimplifiedFaces(),e.computeFaceInclusion(r=>r[0]!==0);const s=e.createFilledSubGraph(),i=s.facesToShape();return e.dispose(),s.dispose(),i}static clipShape(t,e,s){let i,r,a;s=Pe({includeExterior:!1,includeBoundary:!0,includeInterior:!0},s);const h=wt.simplifyNonZero(t),g=new wt;for(g.addShape(0,e,{ensureClosed:!1}),g.addShape(1,h),g.eliminateOverlap(),g.eliminateSelfIntersection(),g.eliminateIntersection(),g.collapseVertices(),i=0;i<g.loops.length;i++)if(a=g.loops[i],a.shapeId===1)for(r=0;r<a.halfEdges.length;r++)a.halfEdges[r].edge.data=!0;const p=[];for(i=0;i<g.loops.length;i++)if(a=g.loops[i],a.shapeId===0){let A=[];for(r=0;r<a.halfEdges.length;r++){const b=a.halfEdges[r];(b.edge.data?s.includeBoundary:h.containsPoint(b.edge.segment.positionAt(.5))?s.includeInterior:s.includeExterior)?A.push(b.getDirectionalSegment()):A.length&&(p.push(new yt(A,void 0,a.closed)),A=[])}A.length&&p.push(new yt(A,void 0,a.closed))}return g.dispose(),new Y.Shape(p)}}Y.register("Graph",wt);const It=wt,pn=window._,ht=(u,...t)=>window.assert(u,...t),ut=()=>!!window.assert;class mn{constructor(t,e){K(this,"incomingHalfEdges");K(this,"outgoingHalfEdges");K(this,"edges");K(this,"faces");this.logicalCoordinates=t,this.viewCoordinates=e,ut()&&ht(t),ut()&&ht(e)}getHalfEdgeTo(t){const e=this.outgoingHalfEdges.find(s=>s.end===t);return ut()&&ht(e),e}getHalfEdgeFrom(t){const e=this.incomingHalfEdges.find(s=>s.start===t);return ut()&&ht(e),e}getEdgeTo(t){const e=this.edges.find(s=>s.start===t||s.end===t);return ut()&&ht(e),e}}class _n{constructor(t,e){K(this,"halfEdges");K(this,"edges");K(this,"vertices");this.logicalCoordinates=t,this.viewCoordinates=e,ut()&&ht(t),ut()&&ht(e)}}class vn{constructor(t,e){K(this,"forwardHalf");K(this,"reversedHalf");K(this,"forwardFace");K(this,"reversedFace");K(this,"vertices");K(this,"faces");this.start=t,this.end=e,ut()&&ht(t),ut()&&ht(e)}getOtherVertex(t){return ut()&&ht(t===this.start||t===this.end,"vertex must be one of the two vertices of this edge"),t===this.start?this.end:this.start}getOtherFace(t){return ut()&&ht(t===this.forwardFace||t===this.reversedFace,"face must be one of the two faces of this edge"),t===this.forwardFace?this.reversedFace:this.forwardFace}}class An{constructor(t,e,s){K(this,"edge");K(this,"reversed");K(this,"next");K(this,"previous");K(this,"face",null);this.start=t,this.end=e,this.isReversed=s,ut()&&ht(t),ut()&&ht(e)}}const me=u=>{let t=0;for(let e=0;e<u.length;e++){const s=u[e],i=u[(e+1)%u.length];t+=(i.x+s.x)*(i.y-s.y)}return .5*t},bn=u=>Math.abs(me(u)),wn=u=>{const t=me(u);if(t===0)return u.reduce((i,r)=>i.plus(r),new E(0,0)).timesScalar(1/u.length);let e=0,s=0;for(let i=0;i<u.length;i++){const r=u[i],a=u[(i+1)%u.length],l=r.x*(2*r.y+a.y)+a.x*(r.y+2*a.y);e+=(r.x-a.x)*l,s+=(a.y-r.y)*l}return new E(e,s).timesScalar(1/(6*t))},Mn=(u,t)=>{let e=0;for(let s=0;s<u.length;s++){const i=u[s],r=u[(s+1)%u.length],a=t[s],l=t[(s+1)%u.length];e+=(r.x+i.x)*(l.y-a.y)+(l.x-a.x)*(r.y-i.y)}return .5*e},Ke=(u,t)=>{const e=u.faces.map(a=>bn(a.vertices.map(l=>l.viewCoordinates))),s=t(e),i=u.vertices.map(a=>({logicalCoordinates:a.logicalCoordinates,viewCoordinates:a.viewCoordinates.timesScalar(s)})),r=new Map(i.map((a,l)=>[u.vertices[l],a]));return{vertices:i,faces:u.faces.map(a=>({logicalCoordinates:a.logicalCoordinates,vertices:a.vertices.map(l=>r.get(l))}))}},Fn=(u,t)=>Ke(u,e=>Math.sqrt(t/(pn.sum(e)/e.length))),Rn=(u,t)=>Ke(u,e=>Math.sqrt(t/Math.min(...e)));class xn{constructor(t,e){this.start=t,this.end=e}isCanonicalHalfEdge(){return this.start.x<this.end.x||this.start.x===this.end.x&&this.start.y<this.end.y}}class yn{constructor(){K(this,"identifiers",[]);K(this,"canonicalIdentifiers",[]);K(this,"map",new Map)}add(t,e){if(ut()&&ht(t.x!==e.x||t.y!==e.y),this.lookupAttempt(t,e)!==null)return;const s=(i,r)=>{let a;this.map.has(i)?a=this.map.get(i):(a=new Map,this.map.set(i,a));const l=new xn(i,r);a.set(r,l),this.identifiers.push(l),l.isCanonicalHalfEdge()&&this.canonicalIdentifiers.push(l)};s(t,e),s(e,t)}getAdjacentLocations(t){const e=this.map.get(t);return e?Array.from(e.keys()):[]}lookupAttempt(t,e){const s=this.map.get(t);return s?s.get(e)??null:null}lookup(t,e){const s=this.lookupAttempt(t,e);return ut()&&ht(s),s}lookupCanonical(t,e){const s=this.lookup(t,e);return s.isCanonicalHalfEdge()?s:this.lookup(e,t)}}const Vn=u=>{const t=u.vertices;let e=u.faces;e=e.map(v=>me(v.vertices.map(T=>T.viewCoordinates))>0?v:{logicalCoordinates:v.logicalCoordinates,vertices:v.vertices.slice().reverse()});const s=new yn;e.forEach(v=>{for(let T=0;T<v.vertices.length;T++){const M=v.vertices[T].logicalCoordinates,V=v.vertices[(T+1)%v.vertices.length].logicalCoordinates;s.add(M,V)}});const i=new Map,r=new Map,a=new Map,l=new Map,o=v=>i.get(v)??null,h=v=>r.get(v)??null,g=(v,T)=>{const M=s.lookup(v,T);return l.get(M)??null},p=t.map(v=>new mn(v.logicalCoordinates,v.viewCoordinates));p.forEach(v=>i.set(v.logicalCoordinates,v));const A=e.map(v=>new _n(v.logicalCoordinates,wn(v.vertices.map(T=>T.viewCoordinates))));A.forEach(v=>r.set(v.logicalCoordinates,v));const b=s.canonicalIdentifiers.map(v=>new vn(o(v.start),o(v.end)));b.forEach(v=>a.set(s.lookupCanonical(v.start.logicalCoordinates,v.end.logicalCoordinates),v));const S=s.identifiers.map(v=>new An(o(v.start),o(v.end),!v.isCanonicalHalfEdge()));S.forEach(v=>l.set(s.lookup(v.start.logicalCoordinates,v.end.logicalCoordinates),v)),b.forEach(v=>{const T=g(v.start.logicalCoordinates,v.end.logicalCoordinates),M=g(v.end.logicalCoordinates,v.start.logicalCoordinates);ut()&&ht(T),ut()&&ht(M),T.edge=v,M.edge=v,T.reversed=M,M.reversed=T,v.forwardHalf=T,v.reversedHalf=M,v.vertices=[v.start,v.end]}),e.forEach(v=>{const T=h(v.logicalCoordinates),M=v.vertices.map(B=>o(B.logicalCoordinates)),V=[],$=[];for(let B=0;B<M.length;B++){const X=v.vertices[B].logicalCoordinates,k=v.vertices[(B+1)%M.length].logicalCoordinates,q=v.vertices[(B+2)%M.length].logicalCoordinates,N=g(X,k);N.face=T;const j=g(k,q);N.next=j,j.previous=N,$.push(N),V.push(N.edge)}T.halfEdges=$,T.edges=V,T.vertices=M}),S.forEach(v=>{v.face===void 0&&(v.face=null)}),b.forEach(v=>{v.forwardFace=v.forwardHalf.face,v.reversedFace=v.reversedHalf.face,v.faces=[v.forwardFace,v.reversedFace].filter(T=>T!==null)});const y=new Set(S.filter(v=>v.face===null)),P=[],x=[];for(;y.size;){const v=y.values().next().value;y.delete(v);const T=$=>{ut()&&ht($.face===null);const B=$.end.logicalCoordinates,q=s.getAdjacentLocations(B).filter(N=>N!==$.start.logicalCoordinates).map(N=>g(B,N)).filter(N=>N.face===null);return ut()&&ht(q.length===1),q[0]},M=[v];let V=T(v);for(v.next=V,V.previous=v;V!==v;){M.push(V),y.delete(V);const $=V;V=T(V),$.next=V,V.previous=$}me(M.map($=>$.start.viewCoordinates))<0?P.push(M):x.push(M)}return ut()&&ht(P.length===1),p.forEach(v=>{const T=s.getAdjacentLocations(v.logicalCoordinates),M=g(T[0],v.logicalCoordinates);let V=M;const $=[M];for(;V.reversed.previous!==M;)ut()&&ht(V.reversed.previous),V=V.reversed.previous,$.push(V);v.incomingHalfEdges=$,v.outgoingHalfEdges=$.map(B=>B.reversed),v.edges=$.map(B=>B.edge),v.faces=$.map(B=>B.face).filter(B=>B!==null)}),{edges:b,vertices:p,faces:A,halfEdges:S,outerBoundary:P[0],innerBoundaries:x}};export{An as B,Os as D,It as G,ve as L,te as O,an as S,pn as _,ut as a,ht as b,me as c,Mn as d,vn as e,_n as f,wn as g,mn as h,Vn as i,ds as j,Qe as k,gs as l,xs as m,Ge as n,ms as o,Vs as p,_s as q,Bs as r,Ns as s,_t as t,Ts as u,ws as v,bs as w,Cs as x,Rn as y,Fn as z};
