import"../Vector2Property-DCXaH-JP.js";import{Q as d}from"../qunit-Bs7I1Tbv.js";import{a as m,c as q,b as p,d as S,s as f,g as y,e as z,f as U,h as E,i as A}from"../square-only-all-unrestricted-C-l069kK.js";import{B as r}from"../BinaryRuleSequence-QbUJFJaZ.js";import{g as B,i as O}from"../BinaryRuleCollection-Co2eOjDC.js";import{s as h}from"../PatternRule-CrjXMziT.js";import"../generalPatternBoardGenerations-Z1YspuhJ.js";import"../patternBoards-Hmq_9LOt.js";import"../getCoordinateClusteredMap-DCjAm76-.js";import"../getPeriodicTilingGenerator-o-Elo7dg.js";import"../getSolutionImpliedRules-FTQqQQkV.js";import"../FeatureSet-DDOmfIdB.js";import"../FaceColorDualFeature-DKZsSiFX.js";import"../logic-solver-O3GFcRDa.js";import"../HighlanderPruner-DdNF9lmw.js";d.module("pattern rule correctness",()=>{const e=(s,i)=>{i.patternBoards.forEach(l=>{const n=h(l);d.test(`${s} ${n}`,u=>{let a=0;const g=B(l,!1);let t=!0,c=null;i.forEachRule(o=>{t&&o.patternBoard===l&&(++a%50===1&&console.log(s,n,a-1),O(o,!0,g)||(t=!1,c=o.toCanonicalString()))}),u.ok(t,c??"all rules passed")})})};e("square-only-color-unrestricted",r.deserialize(m).collection),e("square-only-edge-sector",r.deserialize(q).collection),e("square-only-edge-sector-unrestricted",r.deserialize(p).collection),e("square-only-all",r.deserialize(S).collection),e("square-only-all-unrestricted",r.deserialize(f).collection),e("general-color-unrestricted",r.deserialize(y).collection),e("general-edge-sector",r.deserialize(z).collection),e("general-edge-sector-unrestricted",r.deserialize(U).collection),e("general-all",r.deserialize(E).collection),e("general-all-unrestricted",r.deserialize(A).collection)});window.assertions.enableAssert();
