import{V as O}from"../Vector2Property-DUQoL60W.js";import{Q as i}from"../qunit-Bk5N23En.js";import{av as S,am as p,aj as h,ak as g}from"../PuzzleModel-D24vwq4z.js";import{h as m,i as x,j as k,s as F,a as R,d as b,k as v}from"../getImpliedColorSquareBoardRules-LPy7EqRl.js";import{B as q,R as y}from"../PatternBoardRuleSet-B_DvC5lY.js";import"../getCoordinateClusteredMap-CiLx8OtO.js";import"../basicEdgeRuleSets-BEFGxTdZ.js";import"../basicColorRuleSets-BWEeX8Bg.js";i.module("zero",()=>{i.test("two numbers",e=>{e.equal(O.ZERO.x,0)})});console.log(S[0][0]);i.module("patternBoards",()=>{i.test("square pattern sanity",e=>{e.equal(S[0][0].vertices.length,4);for(const t of S)for(const o of t){const r=o.faces.filter(c=>!c.isExit);for(const c of r)e.equal(c.edges.length,4)}})});i.module("generation",()=>{i.test("getOnlyImpliedSquareBoardRules 0 0",e=>{const t=m(0,0),o=F[0];e.equal(JSON.stringify(t.serialize()),JSON.stringify(o.serialize()))}),i.test("getOnlyImpliedSquareBoardRules 1 0",e=>{const t=m(1,0),o=R[0];e.equal(JSON.stringify(t.serialize()),JSON.stringify(o.serialize()))}),i.test("getOnlyImpliedSquareBoardRules 1 1",e=>{const t=m(1,1),o=R[1];e.equal(JSON.stringify(t.serialize()),JSON.stringify(o.serialize()))}),i.test("getOnlyImpliedSectorSquareBoardRules 0 0",e=>{const t=x(0,0),o=b[0];e.equal(JSON.stringify(t.serialize()),JSON.stringify(o.serialize()))}),i.test("getImpliedColorSquareBoardRules 0 0",e=>{const t=k(0,0),o=v[0];e.equal(JSON.stringify(t.serialize()),JSON.stringify(o.serialize()))})});i.module("RichSolution",()=>{i.test("Basic Edge/Sector Construction",e=>{const t=S[0][0],o={solveEdges:!0,solveSectors:!0,solveFaceColors:!1,highlander:!0},r=new q(t,o),d=p.getSolutions(t,[]).map(s=>new y(t,r,s,o));for(const s of d){console.log(s.toDebugString());const u=r.getBitsPrimaryFeatures(s.solutionAttributeSet.data),B=r.getBitsPrimaryFeatures(s.solutionAttributeSet.optionalData);for(const l of t.edges)l.isExit?s.solutionSet.has(l)?(e.ok(!u.some(a=>a instanceof h&&a.edge===l),"should not have black exit edge"),e.ok(!u.some(a=>a instanceof g&&a.edge===l),"should not have red exit edge")):l.exitVertex.edges.some(n=>s.solutionSet.has(n))?e.ok(u.some(n=>n instanceof g&&n.edge===l),"has HARD red exit"):(e.ok(!u.some(n=>n instanceof g&&n.edge===l),"has soft red exit"),e.ok(B.some(n=>n instanceof g&&n.edge===l),"supports optional red")):s.solutionSet.has(l)?e.ok(u.some(a=>a instanceof h&&a.edge===l),"has non-exit black edge"):e.ok(u.some(a=>a instanceof g&&a.edge===l),"has non-exit red edge");const f=r.getBitsFeatureSet(s.solutionAttributeSet.data);e.ok(f!==null,"valid feature set"),console.log(f.toCanonicalString())}e.equal(d.length,15)}),i.test("Basic Face Construction",e=>{const t=S[0][0],o={solveEdges:!1,solveSectors:!1,solveFaceColors:!0,highlander:!1},r=new q(t,o),d=p.getSolutions(t,[]).map(s=>new y(t,r,s,o));for(const s of d){console.log(s.toDebugString());const u=r.getBitsFeatureSet(s.solutionAttributeSet.data);e.ok(u!==null,"valid feature set"),console.log(u.toCanonicalString())}e.equal(d.length,15)})});window.assertions.enableAssert();
