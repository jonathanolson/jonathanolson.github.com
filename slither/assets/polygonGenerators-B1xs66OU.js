var xt=Object.defineProperty;var Lt=(c,t,e)=>t in c?xt(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var E=(c,t,e)=>(Lt(c,typeof t!="symbol"?t+"":t,e),e);import{T as d,P as he,E as et,d as tt,o as be,c as ot,D as Nt,V as O,h as se,C as Ot,B as We,g as ie,R as Ve}from"./Vector2Property-95p6aBvi.js";import{D as X,B as re,g as M,k as Ae,N,P as W,M as ve,l as Rt,L as rt,C as Xe,m as st,T as it,G as At,R as It,H as at}from"./PhetioControlledVisibilityProperty-DXvpzwXO.js";import{h as Ye,k as L,L as Pe,_ as Z,G as Mt,e as A,f as I,m as nt}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{e as Ht,f as Dt,g as je,J as Bt,h as qe,i as Wt,j as Xt,v as Ue,k as Yt,l as _e,w as jt,m as Q,n as qt,q as Ut,x as _t,y as Jt,I as ee,G as Zt,E as zt,A as Gt,C as $t,c as K,N as Kt,O as Te,u as Qt,s as eo,r as to}from"./Theme-BAHTsAQQ.js";import{E as j,F as le,S as F,V as oo,C as De,B as Je}from"./BasicPuzzle-BS-Lz1E0.js";import{b as ro,L as so,a as io,c as ao,P as lt}from"./TextPushButton-DPrdGe0P.js";import{Q as ct,R as dt,T as ht,U as pt,V as ut,W as ft,C as fe,X as no,K as lo,L as co,Y as gt,Z as wt,_ as mt,$ as St,a0 as Ct,i as ho,a1 as po,F as uo,g as Ee,a as fo,I as z,a2 as go,a3 as wo,a4 as mo,a5 as So,a6 as Co,a7 as yo,a8 as Po,a9 as vo,aa as Eo,ab as Vo,J as pe,M as yt,s as Pt,O as vt,ac as bo}from"./SATSolver-BPZC_vN_.js";import{p as To,a as Fo,b as ko,c as xo,d as Lo,e as No,g as D,r as Oo,f as Ro,s as Ao,t as Io,h as Mo,i as Ho,j as Do,k as Bo,l as Wo,m as Xo,n as Yo,o as jo,q as qo,u as Uo,v as _o,w as Jo,x as Zo,y as zo,z as Go,A as $o,B as Ko}from"./getPeriodicTilingGenerator-B19VRuYW.js";const Et=(c,t,e,o)=>(s,r,p)=>{const a=[new ct(s,r),new dt(s,r)];return(c||t||e||o)&&(a.push(new ht(s,r)),(t||e||o)&&(a.push(new pt(s,r)),(e||o)&&(a.push(new ut(s,r)),o&&a.push(new ft(s,r))))),new fe(a)},Qo={edgesVisibleProperty:Ht,edgesHaveColorsProperty:Dt,faceColorsVisibleProperty:je,faceColorThresholdProperty:Bt,sectorsVisibleProperty:qe,sectorsNextToEdgesVisibleProperty:Wt,sectorsTrivialVisibleProperty:Xt,vertexStateVisibleProperty:Ue,allVertexStateVisibleProperty:Yt,faceStateVisibleProperty:_e,whiteLineVisibleProperty:jt,redLineVisibleProperty:Q,verticesVisibleProperty:qt,smallVertexProperty:Ut,redXsVisibleProperty:_t,redXsAlignedProperty:Jt,faceValueStyleProperty:ee,redLineStyleProperty:Zt,vertexStyleProperty:zt,joinedLinesJoinProperty:Gt,joinedLinesCapProperty:$t,safeSolverFactoryProperty:new X([je,qe,Ue,_e],(c,t,e,o)=>Et(c,t,e,o)),autoSolverFactoryProperty:no,theme:K},ae=(c,t,e,o,s)=>{const r=Et(c,t,e,o);return{faceColorsVisibleProperty:new re(c),sectorsVisibleProperty:new re(t),vertexStateVisibleProperty:new re(e),faceStateVisibleProperty:new re(o),safeSolverFactoryProperty:new he(r),autoSolverFactoryProperty:s?new X([s],p=>(a,h,i)=>new fe([r(a,h,i),p(a,h,i)])):new he(r)}},ge=new X([lo,co],(c,t)=>(e,o,s)=>new fe([new gt(e,o,{solveJointToRed:!0,solveForcedLineToBlack:c,solveAlmostEmptyToRed:!0},s?void 0:[]),new wt(e,o,{solveToRed:!0,solveToBlack:c},s?void 0:[]),...t?[new mt(e,o,{solveToRed:!0,solveToBlack:c,resolveAllRegions:!1},s?void 0:[])]:[]])),Vt=new X([ge],c=>(t,e,o)=>new fe([c(t,e,o),new St(t,e,o?void 0:[])])),bt={...ae(!0,!1,!1,!1,ge),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},er={...ae(!0,!1,!1,!1,ge),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},tr={...ae(!0,!1,!1,!1,new he((c,t,e)=>new fe([new Ct(c,t,{solveToRed:!0,solveToBlack:!0},e?void 0:[])]))),theme:K,edgesVisibleProperty:new d(!1),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},or={...ae(!1,!1,!1,!1,ge),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!0),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!0),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("square"),joinedLinesJoinProperty:new d("miter"),joinedLinesCapProperty:new d("square")},rr={...ae(!0,!0,!1,!1,Vt),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},sr={...ae(!0,!0,!1,!1,Vt),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},ir={...ae(!0,!1,!0,!1,ge),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},ar={...ae(!0,!1,!1,!0,ge),theme:K,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:Q,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:ee,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Ie={basicLines:bt,basicFaceColoring:er,pureFaceColor:tr,classic:or,basicSectors:rr,sectorsWithColors:sr,vertexState:ir,faceState:ar,custom:Qo},Ze=bt,nr=c=>({edgesVisibleProperty:new M(c,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new M(c,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new M(c,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new M(c,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new M(c,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new M(c,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new M(c,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new M(c,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new M(c,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new M(c,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new M(c,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new M(c,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new M(c,{derive:"verticesVisibleProperty"}),smallVertexProperty:new M(c,{derive:"smallVertexProperty"}),redXsVisibleProperty:new M(c,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new M(c,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new M(c,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new M(c,{derive:"redLineStyleProperty"}),vertexStyleProperty:new M(c,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new M(c,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new M(c,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new M(c,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new M(c,{derive:"autoSolverFactoryProperty"}),theme:Kt(new X([c],t=>t.theme))}),lr=new ro("puzzleStyle",{serialize:c=>Object.keys(Ie).find(t=>Ie[t]===c),deserialize:c=>c?Ie[c]??Ze:Ze}),oe=nr(lr),Kr=new so("showPuzzleStyleProperty",!1),H=class H extends et{constructor(t){super(),this.isEnabledProperty=t}};E(H,"EDGE_STATE",new H(new re(!0))),E(H,"EDGE_STATE_REVERSED",new H(new re(!0))),E(H,"FACE_COLOR_MATCH",new H(oe.faceColorsVisibleProperty)),E(H,"FACE_COLOR_OPPOSITE",new H(oe.faceColorsVisibleProperty)),E(H,"SECTOR_STATE",new H(oe.sectorsVisibleProperty)),E(H,"VERTEX_STATE",new H(oe.vertexStateVisibleProperty)),E(H,"FACE_STATE",new H(oe.faceStateVisibleProperty)),E(H,"FACE_VALUE",new H(new re(!1))),E(H,"DELETE_FACE",new H(new re(!1))),E(H,"enumeration",new tt(H));let U=H;const ne=new io("editModeProperty",U.EDGE_STATE);let Me=null;const ze=c=>{c||(ne.value=U.EDGE_STATE)};ne.link(c=>{Me&&Me.isEnabledProperty.unlink(ze),Me=c,c.isEnabledProperty.link(ze)});const Qr=c=>{c.isEnabledProperty.value&&(ne.value=c)},cr=new X([ne],c=>c===U.EDGE_STATE||c===U.EDGE_STATE_REVERSED),Tt=new X([ne],c=>c===U.FACE_COLOR_MATCH||c===U.FACE_COLOR_OPPOSITE),dr=new X([ne],c=>c===U.SECTOR_STATE),hr=new X([ne],c=>c===U.VERTEX_STATE),pr=new X([ne,Tt],(c,t)=>t||c===U.FACE_STATE||c===U.FACE_VALUE||c===U.DELETE_FACE),Fe=(c,t,e,o)=>{const s=new Ae({mouseButton:0,fire:a=>{var h;return e&&e(c,(h=a.domEvent)!=null&&h.shiftKey?2:0)}}),r=new Ae({mouseButton:2,fire:a=>{var h;return e&&e(c,(h=a.domEvent)!=null&&h.shiftKey?0:2)}}),p=new Ae({mouseButton:1,fire:a=>e&&e(c,1)});t.addInputListener(s),t.addInputListener(r),t.addInputListener(p),t.cursor="pointer",s.isHighlightedProperty.lazyLink(a=>{o&&o(c,a)}),t.disposeEmitter.addListener(()=>{s.dispose(),r.dispose(),p.dispose()})};class ke extends N{constructor(t,e,o,s){const r=be()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{}},s);super({pickableProperty:Tt}),this.outerBoundary=t,this.innerBoundaries=e,this.style=o,Fe(null,this,r.facePressListener,r.faceHoverListener);const p=t.map(g=>g.start.viewCoordinates),a=r.useBackgroundOffsetStroke,h=r.backgroundOffsetDistance,n=Ye(p)>0?-h:h,l=g=>{const S=new Mt;S.addShape(0,g),S.computeSimplifiedFaces(),S.computeFaceInclusion(y=>y[0]>0);const C=S.createFilledSubGraph(),P=C.facesToShape();return S.dispose(),C.dispose(),P},u=ke.getOffsetBackgroundShape(t,a,h),f=e.map(g=>{const S=g.map(P=>P.start.viewCoordinates),C=L.polygon(S);if(a)return l(C.getOffsetShape(n));{const y=C.getStrokedShape(new Pe({lineWidth:2*h})).subpaths.map(m=>new L([m]));return l(Z.minBy(y,m=>m.getArea()))}});this.children=[new W(u,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...f.map(g=>new W(g,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(t,e,o){const s=t.map(h=>h.start.viewCoordinates),r=L.polygon(s),a=Ye(s)>0?-o:o;if(e)return r.getOffsetShape(a).getSimplifiedAreaShape();{const h=r.getStrokedShape(new Pe({lineWidth:2*o})),i=h.subpaths.map(n=>new L([n]));try{return h.bounds.width===9.718028227819117?L.bounds(h.bounds):Z.maxBy(i,n=>n.getArea()).getSimplifiedAreaShape()}catch{return L.bounds(h.bounds)}}}}const me=.03,Se=.05,ur=L.circle(me).makeImmutable(),fr=L.circle(Se).makeImmutable(),gr=L.rect(-me,-me,2*me,2*me).makeImmutable(),wr=L.rect(-Se,-Se,2*Se,2*Se).makeImmutable();class mr extends N{constructor(t,e,o,s){super(),this.vertex=t;const r=new X([e,s.verticesVisibleProperty],(i,n)=>n&&t.edges.every(l=>i.getEdgeState(l)!==j.BLACK));this.disposeEmitter.addListener(()=>r.dispose());const p=new W(null,{translation:t.viewCoordinates,fill:s.theme.vertexColorProperty,visibleProperty:r});this.addChild(p);const a=ve.multilink([s.vertexStyleProperty,s.smallVertexProperty],(i,n)=>{i==="round"?p.shape=n?ur:fr:i==="square"?p.shape=n?gr:wr:A()&&I(!1,`unhandled vertex style: ${i}`)});this.disposeEmitter.addListener(()=>a.dispose());const h=i=>{this.visible=!i};o.link(h),this.disposeEmitter.addListener(()=>o.unlink(h))}}class Sr extends N{constructor(t,e,o,s){const r=be()({textOptions:{font:Te,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{}},s);super({}),this.face=t;const p=L.polygon(t.vertices.map(i=>i.viewCoordinates));this.mouseArea=p,this.touchArea=p,Fe(t,this,r.facePressListener,r.faceHoverListener);const a=new Rt("",ot({subScale:.7},r==null?void 0:r.textOptions)),h=ve.multilink([e,o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty],(i,n,l,u,f,g,S)=>{const C=i.getFaceValue(t);this.visible=!S;let P,y,m=!1,w=!1;if(C===null)P="",y=null;else{let k=0,x=0;for(const v of t.edges){const T=i.getEdgeState(v);T===j.BLACK?k++:T===j.WHITE&&x++}if(n==="static"||C===0)P=`${C}`;else if(n==="remaining")P=`${C-k}`,m=k>0;else if(n==="ratio")C-k===0?P="0":(P=`${C-k}<sub style="color: ${g.toCSS()};">/<sub>${x}</sub></sub>`,w=!0),m=k>0;else throw new Error(`unhandled faceValueStyle: ${n}`);k<C?y=l:k===C?y=u:y=f}a.string=P,a.fill=y,a.maxWidth=w?.8:.9,a.maxHeight=w?.8:.9,a.center=t.viewCoordinates,this.children=[a]});this.disposeEmitter.addListener(()=>h.dispose())}}const te=.06,Cr=new L().moveTo(-te,-te).lineTo(te,te).moveTo(-te,te).lineTo(te,-te).makeImmutable();class yr extends N{constructor(t,e,o,s,r){super({}),this.edge=t;const p=new X([e],m=>m.getEdgeState(t));this.disposeEmitter.addListener(()=>p.dispose());const a=t.start.viewCoordinates,h=t.end.viewCoordinates,i=a.average(h),n=new X([o,s.redXsVisibleProperty],(m,w)=>!m&&w);this.disposeEmitter.addListener(()=>n.dispose());const l=new W(Cr,{stroke:s.theme.xColorProperty,lineWidth:.02,center:i,visibleProperty:n}),u=m=>{l.rotation=m?h.minus(a).getAngle():0};s.redXsAlignedProperty.link(u),this.disposeEmitter.addListener(()=>s.redXsAlignedProperty.unlink(u));const f=new X([o,s.whiteLineVisibleProperty],(m,w)=>!m&&w);this.disposeEmitter.addListener(()=>f.dispose());const g=new rt(a.x,a.y,h.x,h.y,{lineWidth:.02,stroke:s.theme.whiteLineColorProperty,visibleProperty:f}),S=new X([o,s.redLineVisibleProperty],(m,w)=>w);this.disposeEmitter.addListener(()=>S.dispose());const C=new W(null,{lineWidth:.02,stroke:s.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:S}),P=m=>{m==="middle"?C.shape=new L().moveToPoint(i.blend(a,.35)).lineToPoint(i.blend(h,.35)).makeImmutable():m==="gap"?C.shape=new L().moveToPoint(a).lineToPoint(a.blend(i,.35)).moveToPoint(h.blend(i,.35)).lineToPoint(h).makeImmutable():m==="full"?C.shape=new L().moveToPoint(a).lineToPoint(h).makeImmutable():A()&&I(!1,`Unknown red line style: ${m}`)};s.redLineStyleProperty.link(P),this.disposeEmitter.addListener(()=>s.redLineStyleProperty.unlink(P));const y=r==null?void 0:r.edgePressListener;if(y){const m=new L;if(t.faces.length===2)m.polygon([a,t.faces[0].viewCoordinates,h,t.faces[1].viewCoordinates]);else{A()&&I(t.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const w=t.forwardHalf.face===null?t.forwardHalf:t.reversedHalf;A()&&I(w.previous.face===null),A()&&I(w.next.face===null);const k=w.start.viewCoordinates,x=w.end.viewCoordinates,v=w.previous.start.viewCoordinates,T=w.next.end.viewCoordinates,B=(J,G,V)=>{const R=G.minus(J).normalized(),b=V.minus(G).normalized();let q=R.minus(b);return q.getMagnitude()<1e-6?q=R.getPerpendicular():q=q.normalized(),Nt.triangleAreaSigned(J,G,G.plus(q))<0&&(q=q.negated()),q},xe=B(v,k,x),Le=B(k,x,T);m.polygon([k,t.faces[0].viewCoordinates,x,x.plus(Le.times(r.backgroundOffsetDistance)),k.plus(xe.times(r.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=m,Fe(t,this,y,r.edgeHoverListener)}p.link(m=>{m===j.WHITE?this.children=[g]:m===j.BLACK?this.children=[]:this.children=[C,l]})}}class Pr extends N{constructor(e,o,s,r){super({pickable:!1,visibleProperty:r.edgesVisibleProperty});E(this,"simpleRegionNodeMap",new Map);E(this,"regionIdMap",new Map);E(this,"weirdEdgeNodeMap",new Map);E(this,"regionContainer",new N);E(this,"weirdEdgeContainer",new N);E(this,"adjacentFacesMap",new Map);this.board=e,this.faceFilter=s,this.style=r,e.faces.forEach(h=>{this.adjacentFacesMap.set(h,h.edges.map(i=>i.getOtherFace(h)).filter(i=>i!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(h=>this.addRegion(h)),o.value.getWeirdEdges().forEach(h=>this.addWeirdEdge(h)),this.updateHues();const p=(h,i)=>{const n=i.getSimpleRegions(),l=h.getSimpleRegions(),u=i.getWeirdEdges(),f=h.getWeirdEdges(),g=[],S=[];nt(n,l,g,S,[]);const P=new Set(g);for(const y of S)if(this.regionIdMap.has(y.id)){const m=this.regionIdMap.get(y.id);this.replaceRegion(m,y),P.delete(m)}else this.addRegion(y);for(const y of P)this.removeRegion(y);for(const y of u)f.includes(y)||this.removeWeirdEdge(y);for(const y of f)u.includes(y)||this.addWeirdEdge(y);(S.length||g.length)&&this.updateHues()};o.lazyLink(p),this.disposeEmitter.addListener(()=>o.unlink(p)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const a=()=>this.updateHues();r.theme.simpleRegionHueLUTProperty.link(a),r.edgesHaveColorsProperty.lazyLink(a),this.disposeEmitter.addListener(()=>{r.theme.simpleRegionHueLUTProperty.unlink(a),r.edgesHaveColorsProperty.unlink(a)})}addRegion(e){const o=new de(e,this.style);this.simpleRegionNodeMap.set(e,o),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(o)}replaceRegion(e,o){A()&&I(e.id===o.id);const s=this.simpleRegionNodeMap.get(e);s.updateRegion(o),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(o,s),this.regionIdMap.delete(e.id),this.regionIdMap.set(o.id,o)}removeRegion(e){const o=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),o.dispose()}addWeirdEdge(e){const o=e.start.viewCoordinates,s=e.end.viewCoordinates,r=new rt(o.x,o.y,s.x,s.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(e,r),this.weirdEdgeContainer.addChild(r)}removeWeirdEdge(e){const o=this.weirdEdgeNodeMap.get(e);this.weirdEdgeContainer.removeChild(o),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const o=new O(0,0),s=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(1,0)},r=new Map,p=[];this.board.faces.forEach(n=>{r.set(n,[])});for(const n of e){const l=new Set;for(const f of n.simpleRegion.edges)for(const g of f.faces)l.add(g);const u=new Set;for(const f of l){u.add(f);for(const g of this.adjacentFacesMap.get(f))u.add(g)}for(const f of u){const g=r.get(f);if(g.length)for(const S of g){let C=!1;for(const P of p)if(P.a===S&&P.b===n){P.weight++,C=!0;break}C||p.push({a:S,b:n,weight:1})}g.push(n)}}const a=new Map;for(const n of e)a.set(n,O.ZERO.copy());const h=(n,l,u)=>{const f=a.get(n),g=a.get(l),S=n.hueVector.dot(l.hueVector),C=o.set(l.hueVector).subtract(n.hueVector);if(C.magnitude>1e-9){C.normalize();const P=.3,y=u*((Math.max(P,S)-P)/(1-P))**3;C.multiplyScalar(y),f.subtract(C),g.add(C)}};let i=1;for(let n=0;n<100;n++){i*=.99;for(const l of e)a.get(l).setXY(0,0);for(const l of p){const u=l.a,f=l.b,g=l.weight;h(u,f,g)}if(e.length<8)for(let l=0;l<e.length;l++){const u=e[l];for(let f=l+1;f<e.length;f++)h(u,e[f],.2)}for(const l of e){const u=a.get(l);u.multiplyScalar(i/l.edgeCount),l.hueVector.add(u),a.get(l).setXY(0,0)}s()}for(const n of e)n.updateHue()}}class de extends W{constructor(e,o){const s=O.createPolar(1,se.nextDoubleBetween(0,2*Math.PI));super(de.toShape(e),{stroke:de.hueVectorToPaint(s,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});E(this,"hueVector");E(this,"edgeCount");this.simpleRegion=e,this.style=o,this.hueVector=s,this.edgeCount=e.edges.length;const r=a=>{this.lineJoin=a};o.joinedLinesJoinProperty.link(r),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(r));const p=a=>{this.lineCap=a};o.joinedLinesCapProperty.link(p),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(p))}updateHue(){this.stroke=de.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:O.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=de.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,o){const s=o.theme.simpleRegionHueLUTProperty.value,r=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&I(r>=0&&r<s.length),o.edgesHaveColorsProperty.value?s[r]:o.theme.blackLineColorProperty}static toShape(e){const o=new L;let s=!0;for(const r of e.halfEdges)s&&(s=!1,o.moveToPoint(r.start.viewCoordinates)),o.lineToPoint(r.end.viewCoordinates);return e.isSolved&&o.close(),o.makeImmutable()}}class vr extends N{constructor(e,o,s,r){const p=new N;super({pickable:!1,children:[p]});E(this,"faceColorNodeMap",new Map);E(this,"faceColorIdMap",new Map);E(this,"adjacentFacesMap",new Map);E(this,"faceColorNodeContainer");E(this,"dualColorViews",new Set);this.board=e,this.stateProperty=o,this.faceFilter=s,this.style=r,this.faceColorNodeContainer=p,e.faces.forEach(n=>{s(n)&&this.adjacentFacesMap.set(n,n.edges.map(l=>l.getOtherFace(n)).filter(l=>l!==null))});{const n=o.value.getFaceColors();for(const l of n)this.addFaceColor(l,o.value.getFacesWithColor(l).filter(s));this.addDualColorViews(o.value,n)}this.updateHues();let a=o.value.clone();const h=n=>{const l=a;a=n.clone();const u=l.getFaceColors(),f=n.getFaceColors(),g=[],S=[],C=[];nt(u,f,g,S,C);const P=new Set(g),y=this.removeInvalidDualColorViews(n),m=[...y];for(const w of S)if(y.add(w),this.faceColorIdMap.has(w.id)){const k=this.faceColorIdMap.get(w.id);this.replaceFaceColor(k,w,n.getFacesWithColor(w).filter(s)),P.delete(k)}else this.addFaceColor(w,n.getFacesWithColor(w).filter(s));for(const w of C)this.updateFaceColor(w,n.getFacesWithColor(w).filter(s));for(const w of P)y.delete(w),this.removeFaceColor(w);this.addDualColorViews(n,[...y]),(S.length||g.length||m.length)&&this.updateHues()};o.lazyLink(h),this.disposeEmitter.addListener(()=>o.unlink(h)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const i=()=>this.updateHues();r.theme.faceColorBasicHueLUTProperty.lazyLink(i),r.theme.faceColorLightHueLUTProperty.lazyLink(i),r.theme.faceColorDarkHueLUTProperty.lazyLink(i),r.theme.faceColorInsideColorProperty.lazyLink(i),r.theme.faceColorOutsideColorProperty.lazyLink(i),r.theme.faceColorDefaultColorProperty.lazyLink(i),r.faceColorThresholdProperty.lazyLink(i),this.updateHues(),this.disposeEmitter.addListener(()=>{r.theme.faceColorBasicHueLUTProperty.unlink(i),r.theme.faceColorLightHueLUTProperty.unlink(i),r.theme.faceColorDarkHueLUTProperty.unlink(i),r.theme.faceColorInsideColorProperty.unlink(i),r.theme.faceColorOutsideColorProperty.unlink(i),r.theme.faceColorDefaultColorProperty.unlink(i),r.faceColorThresholdProperty.unlink(i)})}addFaceColor(e,o){const s=new Ce(e,o,this.style);this.faceColorNodeMap.set(e,s),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(s)}replaceFaceColor(e,o,s){A()&&I(e.id===o.id);const r=this.faceColorNodeMap.get(e);r.updateFaceColor(o,s),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(o,r),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(e,o){const s=this.faceColorNodeMap.get(e);let r=s.faces.length!==o.length;if(!r)for(let p=0;p<o.length;p++){const a=s.faces[p],h=o[p];if(a!==h){r=!0;break}}r&&s.updateFaceColor(e,o)}removeFaceColor(e){const o=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),o.dispose()}addDualColorViews(e,o){const s=new Set(o);for(;s.size;){const r=s.values().next().value;s.delete(r);const p=this.faceColorNodeMap.get(r);A()&&I(p);const a=e.getOppositeFaceColor(r);if(a){A()&&I(s.has(a)),s.delete(a);const h=this.faceColorNodeMap.get(a);A()&&I(h),this.dualColorViews.add(new Ge([p,h],this.style))}else this.dualColorViews.add(new Ge([p],this.style))}}removeInvalidDualColorViews(e){const o=new Set,s=new Set(e.getFaceColors());for(const r of[...this.dualColorViews])if(!r.isStillValidInState(this.stateProperty.value,s)){for(const p of r.colorNodes)o.add(p.faceColor);this.dualColorViews.delete(r),r.dispose()}return o}updateHues(){const e=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==le.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const o=new O(0,0),s=()=>{for(const n of e)n.hueVector.getMagnitude()>1e-6?n.hueVector.normalize():n.hueVector.setXY(se.nextDouble()-.5,se.nextDouble()-.5).normalize()},r=new Map,p=[];this.board.faces.forEach(n=>{this.faceFilter(n)&&r.set(n,[])});for(const n of e){const l=new Set;for(const f of n.faces)l.add(f);const u=new Set;for(const f of l){u.add(f);for(const g of this.adjacentFacesMap.get(f))u.add(g)}for(const f of u){const g=r.get(f);if(g){if(g.length)for(const S of g){let C=!1;for(const P of p)if(P.a===S&&P.b===n){P.weight++,C=!0;break}C||p.push({a:S,b:n,weight:1})}g.push(n)}}}const a=new Map;for(const n of e)a.set(n,O.ZERO.copy());const h=(n,l,u)=>{const f=a.get(n),g=a.get(l),S=n.hueVector.dot(l.hueVector),C=o.set(l.hueVector).subtract(n.hueVector).normalize(),P=.2,y=Math.abs(S),m=u*((Math.max(P,y)-P)/(1-P))**3;C.multiplyScalar(m),f.subtract(C),g.add(C)};let i=1;for(let n=0;n<100;n++){i*=.99;for(const l of e)a.get(l).setXY(0,0);for(const l of p){const u=l.a,f=l.b,g=l.weight;h(u,f,g)}if(e.length<8)for(let l=0;l<e.length;l++){const u=e[l];for(let f=l+1;f<e.length;f++)h(u,e[f],.2)}for(const l of e){const u=a.get(l);u.multiplyScalar(i/l.faceCount),l.hueVector.add(u),a.get(l).setXY(0,0)}s()}}for(const o of this.dualColorViews)o.updateHue()}}const $=class $ extends et{};E($,"BASIC",new $),E($,"PRIMARY",new $),E($,"SECONDARY",new $),E($,"enumeration",new tt($));let _=$;class Ge{constructor(t,e){E(this,"hueVector");E(this,"faceCount");if(this.colorNodes=t,this.style=e,A()&&I(t.length===1||t.length===2),this.faceCount=Z.sum(this.colorNodes.map(o=>o.faceCount)),t.forEach(o=>{o.dualColorView=this}),t.length===1)t[0].type=_.BASIC,this.hueVector=t[0].hueVector.copy();else{const o=t[0].faceCount>t[1].faceCount?t[0]:t[1],s=o===t[0]?t[1]:t[0];let r;o.type===_.PRIMARY?r=o:s.type===_.PRIMARY||o.type===_.SECONDARY?r=s:(s.type,_.SECONDARY,r=o);const p=r===o?s:o;this.hueVector=o.hueVector.copy(),r.type=_.PRIMARY,p.type=_.SECONDARY}}get faces(){return this.colorNodes.flatMap(t=>t.faces)}isStillValidInState(t,e){for(const o of this.colorNodes)if(!e.has(o.faceColor))return!1;return this.colorNodes.length===1?t.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:t.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const t of this.colorNodes)t.hueVector.set(this.hueVector),t.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const t of this.colorNodes)t.dualColorView=null}}class Ce extends W{constructor(e,o,s){const r=O.createPolar(1,se.nextDoubleBetween(0,2*Math.PI));super(Ce.toShape(o));E(this,"hueVector");E(this,"faceCount");E(this,"dualColorView",null);E(this,"type",_.BASIC);this.faceColor=e,this.faces=o,this.style=s,this.hueVector=r,this.faceCount=o.length}updateHue(e){e||this.faceColor.colorState!==le.UNDECIDED?this.fill=Ce.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:O.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,o){const s=o.length-this.faceCount;this.faceColor=e,this.faces=o,this.shape=Ce.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=s)}static hueVectorToPaint(e,o,s,r){const p=s===_.BASIC?r.theme.faceColorBasicHueLUTProperty.value:s===_.PRIMARY?r.theme.faceColorLightHueLUTProperty.value:r.theme.faceColorDarkHueLUTProperty.value,a=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&I(a>=0&&a<p.length);const h=p[a];if(o===le.UNDECIDED)return h;{const n=(o===le.INSIDE?r.theme.faceColorInsideColorProperty:r.theme.faceColorOutsideColorProperty).value,l=n.alpha,u=new Xe(h);return new Xe((1-l)*u.red+l*n.red,(1-l)*u.green+l*n.green,(1-l)*u.blue+l*n.blue).toCSS()}}static toShape(e){const o=new L;for(const s of e)o.polygon(s.vertices.map(r=>r.viewCoordinates));return o.makeImmutable()}}const $e=[.02,.02],Er=new Map([[F.NONE,[]],[F.ONLY_ZERO,[]],[F.ONLY_ONE,[]],[F.ONLY_TWO,[]],[F.NOT_ZERO,$e],[F.NOT_ONE,[]],[F.NOT_TWO,$e],[F.ANY,[]]]),He=.2,Ke=.02,ye=class ye extends N{constructor(t,e,o,s){super(),this.sector=t;const r=ye.getSectorBaseShape(t,s.backgroundOffsetDistance);this.mouseArea=r,this.touchArea=r,Fe(t,this,s.sectorPressListener,s.sectorHoverListener);const p=i=>{const n=t.start.viewCoordinates,l=t.end.viewCoordinates,u=t.next.end.viewCoordinates,f=n.minus(l),g=u.minus(l),S=f.normalized(),C=g.normalized(),P=C.minus(S).angle+Math.PI/2,y=f.angle;let m=g.angle;m<y&&(m+=2*Math.PI);const w=O.createPolar(.2,P),k=(v,T)=>(v.moveToPoint(S.timesScalar(T)),v.arcPoint(O.ZERO,T,y,m,!0),v),x=(v,T,B)=>(v.moveTo(T.x+B,T.y),v.circle(T,B),v);if(i===F.NONE)return new L().moveTo(w.x-.05,w.y-.05).lineTo(w.x+.05,w.y+.05).moveTo(w.x-.05,w.y+.05).lineTo(w.x+.05,w.y-.05).makeImmutable();if(i===F.ONLY_ZERO)return x(new L,w,.05).makeImmutable();if(i===F.ONLY_TWO)return new L().moveToPoint(S.timesScalar(.1).plus(w.timesScalar(.7))).lineToPoint(w.timesScalar(.7)).lineToPoint(C.timesScalar(.1).plus(w.timesScalar(.7))).makeImmutable();if(i===F.ONLY_ONE||i===F.NOT_TWO)return k(new L,He).makeImmutable();if(i===F.NOT_ZERO||i===F.NOT_ONE)return k(k(new L,He+Ke),He-Ke).makeImmutable();if(i===F.ANY)return x(x(x(new L,w,.05),w,.03),w,.01).makeImmutable();throw new Error("Unhandled sector state")},a=new W(null,{translation:t.end.viewCoordinates,lineWidth:.01,lineCap:"butt",visibleProperty:o.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>a.dispose()),this.addChild(a);const h=ve.multilink([e,o.sectorsNextToEdgesVisibleProperty,o.sectorsTrivialVisibleProperty],(i,n,l)=>{const u=i.getEdgeState(t.edge),f=i.getEdgeState(t.next.edge),g=i.getSectorState(t);let S=null,C=null,P=[],y=.01;if(n||u===j.WHITE&&f===j.WHITE){let m=F.trivialStates.includes(g);if(g===F.NOT_ONE){const w=t.end.edges.filter(x=>i.getEdgeState(x)===j.BLACK),k=t.end.edges.filter(x=>i.getEdgeState(x)===j.WHITE);w.length===0&&k.length===2&&(m=!0)}(l||!m)&&(S=p(g)??null,C=ye.getStrokeFromStyle(g,o)??null,P=Er.get(g)??[],P.length&&(y=.015))}a.shape=S,a.stroke=C,a.lineDash=P,a.lineWidth=y});this.disposeEmitter.addListener(()=>h.dispose())}static getSectorBaseShape(t,e){const o=t.start.viewCoordinates,s=t.end.viewCoordinates,r=t.next.end.viewCoordinates,p=o.minus(s),a=r.minus(s),h=p.normalized(),n=a.normalized().minus(h).angle+Math.PI/2,l=t.face?t.face.viewCoordinates:O.createPolar(e,n).plus(s),u=o.average(s),f=r.average(s);return L.polygon([u,s,f,l]).makeImmutable()}static getSectorArcShape(t,e){const o=t.start.viewCoordinates,s=t.end.viewCoordinates,r=t.next.end.viewCoordinates,p=o.minus(s),a=r.minus(s),h=p.normalized(),i=p.angle;let n=a.angle;return n<i&&(n+=2*Math.PI),new L().moveToPoint(s).lineToPoint(h.timesScalar(e).plus(s)).arcPoint(s,e,i,n,!0).close().makeImmutable()}static getStrokeFromStyle(t,e){return t===F.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:t===F.NOT_ZERO?e.theme.sectorNotZeroColorProperty:t===F.NOT_ONE?e.theme.sectorNotOneColorProperty:t===F.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}};E(ye,"nameMap",new Map([[F.NONE,"Invalid"],[F.ONLY_ZERO,"No Lines"],[F.ONLY_ONE,"Only One Line"],[F.ONLY_TWO,"Both Lines"],[F.NOT_ZERO,"At Least One Line"],[F.NOT_ONE,"Zero or Two Lines"],[F.NOT_TWO,"Less Than Two Lines"],[F.ANY,"Any Lines"]]));let ce=ye;class Vr extends N{constructor(t,e,o,s){super({pickable:!1}),this.vertex=t;const r=.12,a=t.edges.map(S=>S.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized()).map(S=>S.times(r)),i=L.polygon(Ot.grahamScan([O.ZERO,...a],!1)).getOffsetShape(-.05),n=new W(null,{stroke:s.theme.vertexStateLineProperty,lineWidth:.01}),l=new W(i,{translation:t.viewCoordinates,fill:s.theme.vertexStateBackgroundProperty,stroke:s.theme.vertexStateOutlineProperty,lineWidth:.01,children:[n,...a.map(S=>new st({radius:.02,translation:S,fill:s.theme.vertexStatePointProperty}))]});let u=null;const f=ve.multilink([e,s.vertexStateVisibleProperty,s.allVertexStateVisibleProperty],(S,C,P)=>{const y=()=>{this.children=[]};if(!C){y();return}const m=S.getVertexState(t);if(!P){let w=!1,k=!1;const x=new Set;for(const T of t.edges){const B=S.getEdgeState(T);w=w||B===j.BLACK,k=k||B===j.WHITE,B===j.WHITE&&x.add(T)}if(w||!k){y();return}if(oo.fromLookup(t,(T,B)=>x.has(T)&&x.has(B),!0).equals(m)){y();return}}if(!u||!u.equals(m)){u=m;const w=new L;for(const k of m.getAllowedPairs()){const x=v=>v.getOtherVertex(t).viewCoordinates.minus(t.viewCoordinates).normalized().times(r);w.moveToPoint(x(k[0])),w.lineToPoint(x(k[1]))}m.allowsEmpty()&&(w.moveTo(.03,0),w.circle(O.ZERO,.03),w.close()),w.makeImmutable(),n.shape=w}this.children=[l]});this.disposeEmitter.addListener(()=>f.dispose());const g=S=>{this.visible=!S};o.link(g),this.disposeEmitter.addListener(()=>o.unlink(g))}}class Ft extends it{constructor(t,e){const o=be()({font:Qt,fill:K.uiForegroundColorProperty},e);super(t,o)}}class br extends N{constructor(t,e,o,s){super({translation:t.viewCoordinates}),this.face=t;const r=ve.multilink([e,s.faceStateVisibleProperty],(a,h)=>{if(this.children=[],h){const i=a.getFaceState(t),n=i.possibilityCount===0||i.possibilityCount>9;let l;const u=i.possibilityCount===1?s.theme.faceValueCompletedColorProperty:s.theme.faceValueColorProperty;if(n)l=new Ft(i.possibilityCount,{font:Te,maxWidth:.4,maxHeight:.4});else{const f=new Set(t.vertices);l=new At({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(i.possibilityCount)),children:i.getAllowedCombinations().map(g=>{const S=new N,C=new Set(g.map(m=>m.start)),P=new Set(g.map(m=>m.end)),y=m=>m.minus(t.viewCoordinates);if(S.addChild(new W(L.polygon(t.vertices.map(m=>y(m.viewCoordinates))),{stroke:u,lineWidth:.03,opacity:.2})),C.size){const m=new L;if(g.length===t.edges.length)m.polygon(t.vertices.map(w=>y(w.viewCoordinates)));else{const w=new Set(g);for(;w.size;){const k=[...f].find(T=>[...w].filter(B=>B.start===T||B.end===T).length===1);A()&&I(k);let x=k,v=[...w].find(T=>T.start===x||T.end===x)??null;for(m.moveToPoint(y(x.viewCoordinates));v;)w.delete(v),x=v.getOtherVertex(x),m.lineToPoint(y(x.viewCoordinates)),v=[...w].find(T=>T.start===x||T.end===x)??null}}S.addChild(new W(m,{stroke:u,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const m of t.vertices)!C.has(m)&&!P.has(m)&&S.addChild(new st(.1,{fill:u,translation:y(m.viewCoordinates)}));return S}),maxWidth:.6,maxHeight:.6})}l.center=O.ZERO,this.addChild(l)}});this.disposeEmitter.addListener(()=>r.dispose());const p=a=>{this.visible=!a};o.link(p),this.disposeEmitter.addListener(()=>o.unlink(p))}}const Tr=new Pe({lineWidth:.2,lineCap:"round",lineJoin:"round"});class Fr extends N{constructor(t,e,o){let s;if(eo.value)if(t.type==="edge-state"){const r=new L().moveToPoint(t.edge.start.viewCoordinates).lineToPoint(t.edge.end.viewCoordinates);s=[new W(r.getStrokedShape(Tr),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(t.type==="face-color")if(t.face){const r=L.polygon(t.face.vertices.map(a=>a.viewCoordinates));s=[new W(r.getOffsetShape(-.1),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else s=[];else if(t.type==="sector"){const r=ce.getSectorArcShape(t.sector,.5);s=[new W(r.getOffsetShape(.05),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else s=[];else s=[];super({children:s}),this.hoverHighlight=t}}class kr extends N{constructor(t,e,o,s){let r=[];try{let p=new L;for(const h of t.faces)p.polygon(h.vertices.map(i=>i.viewCoordinates));if(t.faceColor.colorState===le.OUTSIDE)try{const h=L.polygon(e.outerBoundary.map(l=>l.start.viewCoordinates)),n=ke.getOffsetBackgroundShape(e.outerBoundary,s.useBackgroundOffsetStroke,s.backgroundOffsetDistance).shapeDifference(h);p=p.shapeUnion(n)}catch(h){console.error(h)}const a=new W(p.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});r.push(a)}catch(p){console.error(p)}super({children:r}),this.selectedFaceColorHighlight=t}}class xr extends N{constructor(t,e,o,s){const r=[],p=[],a=t.sector,h=t.currentState,i=ce.getSectorArcShape(a,.5),n=new W(i.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});r.push(n);const l=[];if(h===F.ANY&&(l.push(F.NOT_ZERO),l.push(F.NOT_ONE),l.push(F.NOT_TWO)),h.one&&h!==F.ONLY_ONE&&l.push(F.ONLY_ONE),l.length){const u=l.map(S=>{const C=ce.getStrokeFromStyle(S,o);return new ao({accessibleName:ce.nameMap.get(S),content:new It(0,0,25,25),listener:()=>{s.sectorSetListener&&s.sectorSetListener(a,S)},buttonAppearanceStrategy:to,baseColor:C,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});p.push(...u);const f=new lt(new at({children:u,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});p.push(f);const g=.1;r.push(f),f.centerBottom=n.centerTop.plusXY(0,-.15),f.top<e.top+g&&(f.centerTop=n.centerBottom.plusXY(0,.15)),f.left<e.left+g&&(f.left=e.left+g),f.right>e.right-g&&(f.right=e.right-g)}super({children:r}),this.selectedSectorEdit=t,this.disposeEmitter.addListener(()=>{p.forEach(u=>u.dispose())})}}class Qe extends N{constructor(e,o){const s=be()({textOptions:{font:Te,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new he(null),selectedFaceColorHighlightProperty:new he(null),selectedSectorEditProperty:new he(null),faceFilter:()=>!0,style:oe},o),r=s.style,p=new N({visibleProperty:r.faceColorsVisibleProperty}),a=new N({pickableProperty:pr}),h=new N({pickableProperty:dr}),i=new N({pickableProperty:cr}),n=new N({pickableProperty:hr}),l=new N,u=new N({pickable:!1}),f=new N({pickable:!1}),g=new N({pickable:!1}),S=new N({pickable:!1}),C=new N({pickable:!1}),P=new N,y=new X([e.stateProperty],v=>{if(v.getWeirdEdges().length||v.hasInvalidFaceColors())return!1;const T=v.getSimpleRegions();return T.length===1&&T[0].isSolved});p.addChild(new vr(e.board,e.stateProperty,s.faceFilter,r)),e.board.faces.forEach(v=>{s.faceFilter(v)&&(a.addChild(new Sr(v,e.stateProperty,r,s)),f.addChild(new br(v,e.stateProperty,y,r)))});const m=new ke(e.board.outerBoundary,e.board.innerBoundaries,r,s);e.board.vertices.forEach(v=>{v.faces.some(s.faceFilter)&&(n.addChild(new mr(v,e.stateProperty,y,r)),u.addChild(new Vr(v,e.stateProperty,y,r)))}),e.board.edges.forEach(v=>{v.faces.some(s.faceFilter)&&i.addChild(new yr(v,e.stateProperty,y,r,s))}),e.board.halfEdges.forEach(v=>{(v.face?s.faceFilter(v.face):s.faceFilter(v.reversed.face))&&h.addChild(new ce(v,e.stateProperty,r,s))}),l.addChild(new Pr(e.board,e.stateProperty,s.faceFilter,r));super(ot({children:[m,p,a,h,i,n,l,u,f,g,S,C,P]},s));E(this,"annotationContainer");E(this,"backgroundNode");this.puzzle=e,this.annotationContainer=g;const w=v=>{C.children.forEach(T=>T.dispose()),v&&C.addChild(new Fr(v,s.backgroundOffsetDistance,r))};s.hoverHighlightProperty.link(w),this.disposeEmitter.addListener(()=>s.hoverHighlightProperty.unlink(w));const k=v=>{S.children.forEach(T=>T.dispose()),v&&S.addChild(new kr(v,e.board,r,s))};s.selectedFaceColorHighlightProperty.link(k),this.disposeEmitter.addListener(()=>s.selectedFaceColorHighlightProperty.unlink(k));const x=v=>{P.children.forEach(T=>T.dispose()),v&&P.addChild(new xr(v,m,r,s))};s.selectedSectorEditProperty.link(x),this.disposeEmitter.addListener(()=>s.selectedSectorEditProperty.unlink(x)),this.disposeEmitter.addListener(()=>{[p,a,i,n,l,u,f,h].forEach(T=>{T.children.forEach(B=>B.dispose()),T.dispose()}),y.dispose(),m.dispose()}),this.backgroundNode=m}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}const Lr=(c,t)=>{ho(po,c,t,!0)};class es extends N{constructor(t,e,o,s=null){let r;const p=i=>new L().moveToPoint(i.start.viewCoordinates).lineToPoint(i.end.viewCoordinates).getStrokedShape(new Pe({lineWidth:.2,lineCap:"round"})).getStrokedShape(new Pe({lineWidth:.02})),a=(i,n)=>new W(p(i),{fill:n}),h=[];if(e.type==="ForcedLine")r=[a(e.whiteEdge,"red"),a(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")r=[a(e.whiteEdge,"red"),...e.redEdges.map(i=>a(i,"blue"))];else if(e.type==="JointToRed")r=[...e.whiteEdges.map(i=>a(i,"red")),...e.blackEdges.map(i=>a(i,"blue"))];else if(e.type==="FaceSatisfied")r=[...e.whiteEdges.map(i=>a(i,"red")),...e.blackEdges.map(i=>a(i,"blue"))];else if(e.type==="FaceAntiSatisfied")r=[...e.whiteEdges.map(i=>a(i,"red")),...e.redEdges.map(i=>a(i,"blue"))];else if(e.type==="ForcedSolveLoop")r=[...e.regionEdges.map(i=>a(i,"blue")),...e.pathEdges.map(i=>a(i,"red"))];else if(e.type==="PrematureForcedLoop")r=[...e.regionEdges.map(i=>a(i,"blue")),...e.pathEdges.map(i=>a(i,"red"))];else if(e.type==="CompletingEdgesAfterSolve")r=[...e.whiteEdges.map(i=>a(i,"red"))];else if(e.type==="FaceColoringBlackEdge")r=[a(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")r=[a(e.edge,"red")];else if(e.type==="FaceColorToBlack")r=[a(e.edge,"red")];else if(e.type==="FaceColorToRed")r=[a(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")r=[...e.face.edges.map(i=>a(i,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")r=[...e.balancedPairs.flatMap((i,n)=>{const l=["green","blue","black"][n%3],u=["magenta","orange","yellow"][n%3];return[...i[0].map(f=>a(f,l)),...i[1].map(f=>a(f,u))]})],e.type==="FaceColorMatchToRed"?r.push(...e.matchingEdges.map(i=>a(i,"red"))):e.type==="FaceColorMatchToBlack"?r.push(...e.matchingEdges.map(i=>a(i,"red"))):e.type==="FaceColorBalance"&&(r.push(...e.matchingEdges.map(i=>a(i,"orange"))),r.push(...e.oppositeEdges.map(i=>a(i,"red"))));else if(e.type==="DoubleMinusOneFaces")r=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")r=[e.sector.edge,e.sector.next.edge].map(i=>a(i,"red"));else if(e.type==="ForcedSector"){const i=[...e.toRedEdges,...e.toBlackEdges];r=[e.sector.edge,e.sector.next.edge].map(n=>a(n,i.includes(n)?"red":"blue"))}else if(e.type==="StaticFaceSectors")r=Z.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="VertexState")r=e.vertex.edges.map(i=>a(i,"blue"));else if(e.type==="VertexStateToEdge")r=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="VertexStateToSector")r=Z.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")r=Z.uniq([...e.facesA,...e.facesB].flatMap(i=>i.edges)).map(i=>a(i,"red"));else if(e.type==="FaceState")r=e.face.edges.map(i=>a(i,"red"));else if(e.type==="FaceStateToEdge")r=[...e.toBlackEdges.map(i=>a(i,"red")),...e.toRedEdges.map(i=>a(i,"red"))];else if(e.type==="FaceStateToSector")r=Z.uniq(e.sectors.flatMap(i=>[i.edge,i.next.edge])).map(i=>a(i,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const i=new Set([...e.facesA,...e.facesB].flatMap(l=>l.edges)),n=e.face.edges.filter(l=>!i.has(l));r=[...[...i].map(l=>a(l,"red")),...n.map(l=>a(l,"blue"))]}else if(e.type==="FaceStateToVertexState")r=e.face.edges.filter(n=>e.vertices.includes(n.start)||e.vertices.includes(n.end)).map(n=>a(n,"red"));else if(e.type==="Pattern"){const i=new Set(e.affectedEdges);if(e.affectedSectors.forEach(l=>{i.add(l.edge),i.add(l.next.edge)}),e.affectedFaces.forEach(l=>{l.edges.forEach(u=>i.add(u))}),r=[new N({children:[...i].map(l=>a(l,"red"))})],s){const l=We.NOTHING.copy();[e.input,e.output].forEach(V=>{V.faceValues.forEach(R=>{R.face&&R.face.vertices.forEach(b=>{l.addPoint(b.viewCoordinates)})}),[V.blackEdges,V.redEdges].forEach(R=>{R.forEach(b=>{l.addPoint(b.start.viewCoordinates),l.addPoint(b.end.viewCoordinates)})}),[V.sectorsNotZero,V.sectorsNotOne,V.sectorsNotTwo,V.sectorsOnlyOne].forEach(R=>{R.forEach(b=>{l.addPoint(b.start.viewCoordinates),l.addPoint(b.end.viewCoordinates),l.addPoint(b.next.end.viewCoordinates)})}),V.faceColorDuals.forEach(R=>{[R.primaryFaces,R.secondaryFaces].forEach(b=>{b.forEach(q=>{q&&q.vertices.forEach(Ne=>{l.addPoint(Ne.viewCoordinates)})})})})});const u=De.empty(t),f=De.empty(t),g=new Set(t.faces),S=(V,R)=>{R.faceValues.forEach(b=>{b.face&&(V.setFaceValue(b.face,b.value),g.delete(b.face))}),R.blackEdges.forEach(b=>{V.setEdgeState(b,j.BLACK)}),R.redEdges.forEach(b=>{V.setEdgeState(b,j.RED)}),R.sectorsNotZero.forEach(b=>{V.setSectorState(b,F.NOT_ZERO)}),R.sectorsNotOne.forEach(b=>{V.setSectorState(b,F.NOT_ONE)}),R.sectorsNotTwo.forEach(b=>{V.setSectorState(b,F.NOT_TWO)}),R.sectorsOnlyOne.forEach(b=>{V.setSectorState(b,F.ONLY_ONE)}),R.faceColorDuals.forEach(b=>{const q=(Y,we)=>{const Oe=Y?V.getFaceColor(Y):V.getOutsideColor(),Re=we?V.getFaceColor(we):V.getOutsideColor();new uo(Ee(V,Oe),Ee(V,Re)).apply(V)},Ne=(Y,we)=>{const Oe=Y?V.getFaceColor(Y):V.getOutsideColor(),Re=we?V.getFaceColor(we):V.getOutsideColor();new fo(Ee(V,Oe),Ee(V,Re)).apply(V)};for(let Y=1;Y<b.primaryFaces.length;Y++)q(b.primaryFaces[Y-1],b.primaryFaces[Y]);for(let Y=1;Y<b.secondaryFaces.length;Y++)q(b.secondaryFaces[Y-1],b.secondaryFaces[Y]);b.secondaryFaces.length&&Ne(b.primaryFaces[0],b.secondaryFaces[0])}),Lr(t,V)};S(u,e.input),S(f,e.output);const C=.2,P=l.dilated(C),y=new Set(t.faces.filter(V=>{const R=We.NOTHING.copy();return V.vertices.forEach(b=>{R.addPoint(b.viewCoordinates)}),R.intersectsBounds(P)})),m=V=>y.has(V),w=new Qe(new Je(t,u),{faceFilter:m}),k=new Qe(new Je(t,f),{faceFilter:m});h.push(()=>{w.dispose(),k.dispose()});const x=.5,v=.8,T=L.roundRectangle(P.x,P.y,P.width,P.height,x,x),B=new N({children:[...y].filter(V=>g.has(V)).map(V=>new it("?",{font:Te,maxWidth:.9,maxHeight:.9,fill:oe.theme.faceValueCompletedColorProperty,center:V.viewCoordinates}))}),xe=new N({children:[w,B],clipArea:T,scale:v}),Le=new N({children:[k,B],clipArea:T,scale:v}),J=new lt(new at({spacing:.2,children:[xe,Le]}),{cornerRadius:x*(v+.2),xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:oe.theme.patternAnnotationBackgroundColorProperty}),G=C+.05;J.centerBottom=l.centerTop.plusXY(0,-.15),J.top<s.top+G&&(J.centerTop=l.centerBottom.plusXY(0,.15)),J.left<s.left+G&&(J.left=s.left+G),J.right>s.right-G&&(J.right=s.right-G),r.push(J)}}else r=[],console.log(`unknown type: ${e.type}`);super({children:r,pickable:!1}),this.board=t,this.annotation=e,this.style=o,this.disposeEmitter.addListener(()=>h.forEach(i=>i()))}static getHintNode(t){return new Ft(t.type)}}class Nr{constructor(t,e,o){E(this,"edgeStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getEdgeState(t){return this.currentState.getEdgeState(t)}setEdgeState(t,e){if(A()&&I(this.board.edges.includes(t)),e!==j.WHITE){const o=this.solvedState.getEdgeState(t);if(e!==o)throw new z(`Attempt to make edge ${e} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Or{constructor(t,e,o){E(this,"faceColorsChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(t){return this.currentState.getFaceColor(t)}getFacesWithColor(t){return this.currentState.getFacesWithColor(t)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(t){return this.currentState.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(t,e,o,s,r){if(r)throw new z("invalid face color?");const p=new Set([...o.values(),...s.keys(),...o.values()]),a=new Map(this.currentState.getFaceColorMap());for(const n of o.keys())a.set(n,o.get(n));const h=n=>s.has(n)?s.get(n):[...t].includes(n)?this.currentState.getOppositeFaceColor(n):null,i=new Map;for(const n of a.keys()){const l=a.get(n);i.has(l)||i.set(l,new Set([n])),i.get(l).add(n)}for(const n of p){const l=i.get(n);if(!l)continue;const u=[...l];A()&&I(u.length>0);const f=this.solvedState.getFaceColor(u[0]);for(const S of u)if(this.solvedState.getFaceColor(S)!==f)throw new z("invalid face color");const g=h(n);if(g){let S;if(g.colorState===le.INSIDE?S=this.solvedState.getInsideColor():g.colorState===le.OUTSIDE?S=this.solvedState.getOutsideColor():S=this.solvedState.getFaceColor([...i.get(g)][0]),f===S)throw new z("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Rr{constructor(t,e,o){E(this,"simpleRegionsChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.currentState.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.currentState.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.currentState.getSimpleRegionWithId(t)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(t,e,o,s){if([...o].length)throw new z("weird edges added")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ar{constructor(t,e,o){E(this,"faceValueChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceValue(t){return this.currentState.getFaceValue(t)}setFaceValue(t,e){if(this.solvedState.getFaceValue(t)!==e)throw new z("invalid face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Ir{constructor(t,e,o){E(this,"sectorStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getSectorState(t){return this.currentState.getSectorState(t)}setSectorState(t,e){A()&&I(this.board.halfEdges.includes(t));const o=this.solvedState.getSectorState(t);if(!o.isSubsetOf(e))throw new z(`Attempt to make sector ${e} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Mr{constructor(t,e,o){E(this,"vertexStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getVertexState(t){return this.currentState.getVertexState(t)}setVertexState(t,e){A()&&I(this.board.vertices.includes(t));const o=this.solvedState.getVertexState(t);if(!o.isSubsetOf(e))throw new z(`Attempt to make vertex ${e} when it should be ${o}`);const s=this.currentState.getVertexState(t);if(!e.isSubsetOf(s))throw new z("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class Hr{constructor(t,e,o){E(this,"faceStateChangedEmitter",new ie);this.board=t,this.currentState=e,this.solvedState=o}getFaceState(t){return this.currentState.getFaceState(t)}setFaceState(t,e){A()&&I(this.board.faces.includes(t));const o=this.solvedState.getFaceState(t);if(!o.isSubsetOf(e))throw new z(`Attempt to make face ${e} when it should be ${o}`);const s=this.currentState.getFaceState(t);if(!e.isSubsetOf(s))throw new z("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}class ts{constructor(t,e,o){E(this,"anyStateChangedEmitter",new ie);E(this,"edgeStateValidator");E(this,"faceValueValidator");E(this,"simpleRegionDataValidator");E(this,"faceColorValidator");E(this,"sectorStateValidator");E(this,"vertexStateValidator");E(this,"faceStateValidator");A()&&I(t),A()&&I(o),this.edgeStateValidator=new Nr(t,e,o),this.faceValueValidator=new Ar(t,e,o),this.simpleRegionDataValidator=new Rr(t,e,o),this.faceColorValidator=new Or(t,e,o),this.sectorStateValidator=new Ir(t,e,o),this.vertexStateValidator=new Mr(t,e,o),this.faceStateValidator=new Hr(t,e,o)}getFaceValue(t){return this.faceValueValidator.getFaceValue(t)}setFaceValue(t,e){this.faceValueValidator.setFaceValue(t,e)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(t){return this.edgeStateValidator.getEdgeState(t)}setEdgeState(t,e){this.edgeStateValidator.setEdgeState(t,e)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(t){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(t)}getSimpleRegionWithEdge(t){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(t)}getSimpleRegionWithId(t){return this.simpleRegionDataValidator.getSimpleRegionWithId(t)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(t,e,o,s){this.simpleRegionDataValidator.modifyRegions(t,e,o,s)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(t){return this.faceColorValidator.getFaceColor(t)}getFacesWithColor(t){return this.faceColorValidator.getFacesWithColor(t)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(t){return this.faceColorValidator.getOppositeFaceColor(t)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(t,e,o,s,r){this.faceColorValidator.modifyFaceColors(t,e,o,s,r)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(t){return this.sectorStateValidator.getSectorState(t)}setSectorState(t,e){this.sectorStateValidator.setSectorState(t,e)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(t){return this.vertexStateValidator.getVertexState(t)}setVertexState(t,e){this.vertexStateValidator.setVertexState(t,e)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(t){return this.faceStateValidator.getFaceState(t)}setFaceState(t,e){this.faceStateValidator.setFaceState(t,e)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(t){throw new Error("unimplemented")}}const os=(c,t,e)=>new fe([new ct(c,t),new dt(c,t),new ht(c,t),new gt(c,t,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new wt(c,t,{solveToRed:!0,solveToBlack:!0}),new mt(c,t,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new go(c,t),new pt(c,t),new St(c,t),new wo(c,t),new ut(c,t),new mo(c,t,{solveToRed:!0,solveToBlack:!0}),new So(c,t),new Ct(c,t,{solveToRed:!0,solveToBlack:!0}),new Co(c,t,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new yo(c,t),new ft(c,t),new Po(c,t,{solveToRed:!0,solveToBlack:!0}),new vo(c,t),new Eo(c,t),new Vo(c,t)]);let ue=null,Be=0;const rs=()=>{if(ue&&(Be++,Be>5)){const c=ue;ue=null,c(null)}},Dr=async function(c){return new Promise((t,e)=>{ue=t,Be=0,pe.debugSleep&&console.log("sleep start"),setTimeout(()=>{pe.debugSleep&&console.log("sleep end"),ue===t&&(ue=null,t(null)),pe.debugSleep&&console.log("resolved")},c)})};class Br extends Error{constructor(){super("Interrupted")}}const kt=async function(c,t){if(await Dr(c),pe.debugSleep&&console.log("after sleep before interrupt check"),t.value)throw new Br},ss=async(c,t,e)=>{let o=0;for(;o++<100;){const s=De.fromFaces(c,()=>null),r=se.shuffle(c.faces);let p=-1,a=[];const h=i=>{try{return a=Pt(c,i,{maxIterations:1e4,failOnMultipleSolutions:!0}),a.length}catch(n){if(n instanceof vt)return 2;if(n instanceof bo)return 0;throw n}};for(const i of r){pe.debugSleep&&console.log("going to sleep"),t&&await kt(0,t),pe.debugSleep&&console.log("finished sleep, generating next!");let n=se.shuffle(Z.range(0,i.edges.length));n[0]===0&&(n=se.shuffle(n));for(const l of n){const u=s.createDelta();if(u.setFaceValue(i,l),p=h(u),p>=1){u.apply(s),e&&e.emit(c.faces.indexOf(i),l);break}}if(p===1)break}if(p===1)return yt(c,s,a[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},is=async(c,t=()=>!0,e,o)=>{const s=c.board,r=c.cleanState.clone(),p=se.shuffle(s.faces),a=h=>{try{return Pt(s,h,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(i){if(i instanceof vt)return!0;throw i}};A()&&I(!a(r),"Initial state has multiple solutions"),A()&&I(t(s,r.clone()),"Initial state is not easy enough");for(const h of p){e&&await kt(0,e);const i=r.getFaceValue(h);if(i===null){o&&o.emit(s.faces.indexOf(h),null);continue}const n=r.createDelta();n.setFaceValue(h,null),!a(n)&&t(s,n.clone())?(n.apply(r),o&&o.emit(s.faces.indexOf(h),null)):o&&o.emit(s.faces.indexOf(h),i)}return yt(c.board,r,c.blackEdges)},Wr={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new Ve(2,50)},height:{label:"Height",type:"integer",range:new Ve(2,50)}},defaultParameterValues:{width:6,height:10},generate:c=>{const t=c.width,e=c.height;return Z.range(0,e).flatMap(o=>Z.range(0,t).map(s=>[new O(s,o),new O(s+1,o),new O(s+1,o+1),new O(s,o+1)]))}},Xr={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new Ve(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new Ve(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:c=>{const t=c.radius,e=c.isPointyTop,o=c.holeRadius;let s,r;e?(s=new O(Math.sqrt(3),0),r=new O(Math.sqrt(3)/2,3/2)):(s=new O(3/2,Math.sqrt(3)/2),r=new O(0,Math.sqrt(3)));const p=[new O(1,0),new O(1,-1),new O(0,-1),new O(-1,0),new O(-1,1),new O(0,1)],a=Z.range(0,6).map(l=>p[l].plus(p[(l+1)%6])),h=l=>a.map(u=>u.plus(l.timesScalar(3))),i=(l,u)=>(Math.abs(l.x-u.x)+Math.abs(l.x+l.y-u.x-u.y)+Math.abs(l.y-u.y))/2,n=[];for(let l=-t;l<=t;l++)for(let u=Math.max(-t,-l-t);u<=Math.min(t,-l+t);u++){const f=new O(l,u);i(f,new O(0,0))>=o&&n.push(h(f).map(g=>s.timesScalar(g.x).plus(r.timesScalar(g.y)).timesScalar(1/3)))}return n}},Yr={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:c=>{const t={6:To,10:Fo,11:ko,13:xo,14:Lo,20:No}[c.radius];A()&&I(t);const e=.01,o=t.thinShape.subpaths.filter(r=>r.segments.length).map(r=>r.points.slice(0,-1).map(p=>p.timesScalar(e)));return[...t.thickShape.subpaths.filter(r=>r.segments.length).map(r=>r.points.slice(0,-1).map(p=>p.timesScalar(e))),...o]}},as=[Wr,D(Oo,{width:8,height:8}),Xr,D(Ro,{width:8,height:8,squareRegion:!0}),D(Ao,{width:5,height:6,squareRegion:!0}),D(Io,{width:6,height:5}),D(Mo,{width:9,height:9}),D(Ho,{width:9,height:9}),D(Do,{width:7,height:8}),D(Bo),D(Wo),D(Xo),D(Yo,{squareRegion:!0}),D(jo),D(qo),D(Uo,{width:9,height:9}),D(_o),D(Jo,{width:9,height:9}),D(Zo),D(zo),D(Go,{width:6,height:8,squareRegion:!0}),D($o),D(Ko),Yr];export{es as A,ts as C,U as E,br as F,Qe as P,Ft as U,Vr as V,os as a,bt as b,oe as c,er as d,ne as e,tr as f,or as g,rr as h,sr as i,ar as j,Qo as k,Kr as l,as as m,ss as n,is as o,lr as p,kt as q,Dr as r,Lr as s,Qr as t,ir as v,rs as w};
