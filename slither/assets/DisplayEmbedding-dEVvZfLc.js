var ot=Object.defineProperty;var rt=(h,r,e)=>r in h?ot(h,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[r]=e;var b=(h,r,e)=>(rt(h,typeof r!="symbol"?r+"":r,e),e);import{T as n,P as te,E as Ye,d as je,o as le,c as Xe,D as st,V as D,h as ue,C as it,B as Ce}from"./Vector2Property-95p6aBvi.js";import{D as B,B as Z,g as O,F as Pe,N as T,P as R,M as ce,l as nt,L as Ue,C as Ne,m as _e,T as qe,G as at,R as lt,H as Je}from"./PhetioControlledVisibilityProperty-Dfpbwmh8.js";import{E as H,F as ie,S as v,V as ct,B as ke,C as dt}from"./BasicPuzzle-Bj_Q7k9y.js";import{b as pt,L as ht,a as ut,c as ft,P as Ze}from"./TextPushButton-B9SU16pf.js";import{h as Fe,k as L,L as Ee,_ as be,G as gt,e as M,f as I,m as Ge,j as mt,d as wt}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{e as Ct,f as Pt,g as Oe,J as yt,h as xe,i as St,j as vt,v as Ae,k as Et,l as Me,w as bt,m as U,n as Vt,q as Lt,x as Tt,y as Nt,I as _,G as kt,E as Ft,A as Ot,C as xt,c as X,P as At,Q as fe,u as Mt,s as It,r as Bt}from"./Theme-D8pnKvi2.js";import{b as Rt,c as Ht,d as Dt,T as Wt,W as Yt,a0 as jt,C as Q,a5 as Xt,M as Ut,N as _t,P as qt,Q as Jt,e as Zt,Z as Ve,U as Gt,i as zt,a6 as $t,F as Kt,g as pe,a as Qt}from"./autoSolver-QR6dRopg.js";import{A as eo}from"./ShadedSphereNode-7H6IFzZB.js";import{d as to,B as oo,R as ro,S as so,a as io,b as no,c as ao,F as lo}from"./FaceColorDualFeature-B3Jbv5ZG.js";import{c as co}from"./getPeriodicTilingGenerator-BAI_tkyR.js";const ze=(h,r,e,t)=>(o,s,p)=>{const i=[new Rt(o,s),new Ht(o,s)];return(h||r||e||t)&&(i.push(new Dt(o,s)),(r||e||t)&&(i.push(new Wt(o,s)),(e||t)&&(i.push(new Yt(o,s)),t&&i.push(new jt(o,s))))),new Q(i)},po={edgesVisibleProperty:Ct,edgesHaveColorsProperty:Pt,faceColorsVisibleProperty:Oe,faceColorThresholdProperty:yt,sectorsVisibleProperty:xe,sectorsNextToEdgesVisibleProperty:St,sectorsTrivialVisibleProperty:vt,vertexStateVisibleProperty:Ae,allVertexStateVisibleProperty:Et,faceStateVisibleProperty:Me,whiteLineVisibleProperty:bt,redLineVisibleProperty:U,verticesVisibleProperty:Vt,smallVertexProperty:Lt,redXsVisibleProperty:Tt,redXsAlignedProperty:Nt,faceValueStyleProperty:_,redLineStyleProperty:kt,vertexStyleProperty:Ft,joinedLinesJoinProperty:Ot,joinedLinesCapProperty:xt,safeSolverFactoryProperty:new B([Oe,xe,Ae,Me],(h,r,e,t)=>ze(h,r,e,t)),autoSolverFactoryProperty:Xt,theme:X},G=(h,r,e,t,o)=>{const s=ze(h,r,e,t);return{faceColorsVisibleProperty:new Z(h),sectorsVisibleProperty:new Z(r),vertexStateVisibleProperty:new Z(e),faceStateVisibleProperty:new Z(t),safeSolverFactoryProperty:new te(s),autoSolverFactoryProperty:o?new B([o],p=>(i,l,d)=>new Q([s(i,l,d),p(i,l,d)])):new te(s)}},oe=new B([Ut,_t],(h,r)=>(e,t,o)=>new Q([new qt(e,t,{solveJointToRed:!0,solveForcedLineToBlack:h,solveAlmostEmptyToRed:!0},o?void 0:[]),new Jt(e,t,{solveToRed:!0,solveToBlack:h},o?void 0:[]),...r?[new Zt(e,t,{solveToRed:!0,solveToBlack:h,resolveAllRegions:!1},o?void 0:[])]:[]])),ho=new B([oe],h=>(r,e,t)=>new Q([h(r,e,t),new Ve(r,e,{solveToRed:!0,solveToBlack:!0})])),$e=new B([oe],h=>(r,e,t)=>new Q([h(r,e,t),new Gt(r,e,t?void 0:[])])),uo=new B([$e],h=>(r,e,t)=>new Q([h(r,e,t),new Ve(r,e,{solveToRed:!0,solveToBlack:!0})])),fo=h=>({...G(!1,!1,!1,!1,oe),theme:h,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:U,verticesVisibleProperty:new n(!0),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!0),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("square"),joinedLinesJoinProperty:new n("miter"),joinedLinesCapProperty:new n("square")}),go=h=>({...G(!0,!0,!1,!1,uo),theme:h,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")}),Ke={...G(!0,!1,!1,!1,oe),theme:X,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},mo={...G(!0,!1,!1,!1,ho),theme:X,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},wo={...G(!0,!1,!1,!1,new te((h,r,e)=>new Q([new Ve(h,r,{solveToRed:!0,solveToBlack:!0},e?void 0:[])]))),theme:X,edgesVisibleProperty:new n(!1),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!1),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},Co=fo(X),Po={...G(!0,!0,!1,!1,$e),theme:X,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!0),faceColorThresholdProperty:new n(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},yo=go(X),So={...G(!0,!1,!0,!1,oe),theme:X,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},vo={...G(!0,!1,!1,!0,oe),theme:X,edgesVisibleProperty:new n(!0),edgesHaveColorsProperty:new n(!1),faceColorThresholdProperty:new n(2),sectorsNextToEdgesVisibleProperty:new n(!1),sectorsTrivialVisibleProperty:new n(!1),allVertexStateVisibleProperty:new n(!1),whiteLineVisibleProperty:new n(!0),redLineVisibleProperty:U,verticesVisibleProperty:new n(!1),smallVertexProperty:new n(!1),redXsVisibleProperty:new n(!1),redXsAlignedProperty:new n(!1),faceValueStyleProperty:_,redLineStyleProperty:new n("middle"),vertexStyleProperty:new n("round"),joinedLinesJoinProperty:new n("round"),joinedLinesCapProperty:new n("round")},ye={basicLines:Ke,basicFaceColoring:mo,pureFaceColor:wo,classic:Co,basicSectors:Po,sectorsWithColors:yo,vertexState:So,faceState:vo,custom:po},Ie=Ke,Eo=h=>({edgesVisibleProperty:new O(h,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new O(h,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new O(h,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new O(h,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new O(h,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new O(h,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new O(h,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new O(h,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new O(h,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new O(h,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new O(h,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new O(h,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new O(h,{derive:"verticesVisibleProperty"}),smallVertexProperty:new O(h,{derive:"smallVertexProperty"}),redXsVisibleProperty:new O(h,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new O(h,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new O(h,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new O(h,{derive:"redLineStyleProperty"}),vertexStyleProperty:new O(h,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new O(h,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new O(h,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new O(h,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new O(h,{derive:"autoSolverFactoryProperty"}),theme:At(new B([h],r=>r.theme))}),bo=new pt("puzzleStyle",{serialize:h=>Object.keys(ye).find(r=>ye[r]===h),deserialize:h=>h?ye[h]??Ie:Ie}),$=Eo(bo),ir=new ht("showPuzzleStyleProperty",!1),x=class x extends Ye{constructor(r){super(),this.isEnabledProperty=r}};b(x,"EDGE_STATE",new x(new Z(!0))),b(x,"EDGE_STATE_REVERSED",new x(new Z(!0))),b(x,"FACE_COLOR_MATCH",new x($.faceColorsVisibleProperty)),b(x,"FACE_COLOR_OPPOSITE",new x($.faceColorsVisibleProperty)),b(x,"SECTOR_STATE",new x($.sectorsVisibleProperty)),b(x,"VERTEX_STATE",new x($.vertexStateVisibleProperty)),b(x,"FACE_STATE",new x($.faceStateVisibleProperty)),b(x,"FACE_VALUE",new x(new Z(!1))),b(x,"DELETE_FACE",new x(new Z(!1))),b(x,"enumeration",new je(x));let W=x;const z=new ut("editModeProperty",W.EDGE_STATE);let Se=null;const Be=h=>{h||(z.value=W.EDGE_STATE)};z.link(h=>{Se&&Se.isEnabledProperty.unlink(Be),Se=h,h.isEnabledProperty.link(Be)});const nr=h=>{h.isEnabledProperty.value&&(z.value=h)},Vo=new B([z],h=>h===W.EDGE_STATE||h===W.EDGE_STATE_REVERSED),Qe=new B([z],h=>h===W.FACE_COLOR_MATCH||h===W.FACE_COLOR_OPPOSITE),Lo=new B([z],h=>h===W.SECTOR_STATE),To=new B([z],h=>h===W.VERTEX_STATE),No=new B([z,Qe],(h,r)=>r||h===W.FACE_STATE||h===W.FACE_VALUE||h===W.DELETE_FACE),ge=(h,r,e,t)=>{const o=new Pe({mouseButton:0,fire:i=>{var l;return e&&e(h,(l=i.domEvent)!=null&&l.shiftKey?2:0)}}),s=new Pe({mouseButton:2,fire:i=>{var l;return e&&e(h,(l=i.domEvent)!=null&&l.shiftKey?0:2)}}),p=new Pe({mouseButton:1,fire:i=>e&&e(h,1)});r.addInputListener(o),r.addInputListener(s),r.addInputListener(p),r.cursor="pointer",o.isHighlightedProperty.lazyLink(i=>{t&&t(h,i)}),r.disposeEmitter.addListener(()=>{o.dispose(),s.dispose(),p.dispose()})};class me extends T{constructor(r,e,t,o){const s=le()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},o);super({pickableProperty:Qe}),this.outerBoundary=r,this.innerBoundaries=e,this.style=t,!s.noninteractive&&ge(null,this,s.facePressListener,s.faceHoverListener);const p=r.map(P=>P.start.viewCoordinates),i=s.useBackgroundOffsetStroke,l=s.backgroundOffsetDistance,a=Fe(p)>0?-l:l,c=P=>{const u=new gt;u.addShape(0,P),u.computeSimplifiedFaces(),u.computeFaceInclusion(S=>S[0]>0);const w=u.createFilledSubGraph(),m=w.facesToShape();return u.dispose(),w.dispose(),m},C=me.getOffsetBackgroundShape(r,i,l),g=e.map(P=>{const u=P.map(m=>m.start.viewCoordinates),w=L.polygon(u);if(i)return c(w.getOffsetShape(a));{const S=w.getStrokedShape(new Ee({lineWidth:2*l})).subpaths.map(f=>new L([f]));return c(be.minBy(S,f=>f.getArea()))}});this.children=[new R(C,{fill:t.theme.puzzleBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...g.map(P=>new R(P,{fill:t.theme.playAreaBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(r,e,t){const o=r.map(l=>l.start.viewCoordinates),s=L.polygon(o),i=Fe(o)>0?-t:t;if(e)return s.getOffsetShape(i).getSimplifiedAreaShape();{const l=s.getStrokedShape(new Ee({lineWidth:2*t})),d=l.subpaths.map(a=>new L([a]));try{return l.bounds.width===9.718028227819117?L.bounds(l.bounds):be.maxBy(d,a=>a.getArea()).getSimplifiedAreaShape()}catch{return L.bounds(l.bounds)}}}}const re=.03,se=.05,ko=L.circle(re).makeImmutable(),Fo=L.circle(se).makeImmutable(),Oo=L.rect(-re,-re,2*re,2*re).makeImmutable(),xo=L.rect(-se,-se,2*se,2*se).makeImmutable();class Ao extends T{constructor(r,e,t,o){super(),this.vertex=r;const s=new B([e,o.verticesVisibleProperty],(d,a)=>a&&r.edges.every(c=>d.getEdgeState(c)!==H.BLACK));this.disposeEmitter.addListener(()=>s.dispose());const p=new R(null,{translation:r.viewCoordinates,fill:o.theme.vertexColorProperty,visibleProperty:s});this.addChild(p);const i=ce.multilink([o.vertexStyleProperty,o.smallVertexProperty],(d,a)=>{d==="round"?p.shape=a?ko:Fo:d==="square"?p.shape=a?Oo:xo:M()&&I(!1,`unhandled vertex style: ${d}`)});this.disposeEmitter.addListener(()=>i.dispose());const l=d=>{this.visible=!d};t.link(l),this.disposeEmitter.addListener(()=>t.unlink(l))}}class Mo extends T{constructor(r,e,t,o){const s=le()({textOptions:{font:fe,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},o);super({}),this.face=r;const p=L.polygon(r.vertices.map(d=>d.viewCoordinates));this.mouseArea=p,this.touchArea=p,!s.noninteractive&&ge(r,this,s.facePressListener,s.faceHoverListener);const i=new nt("",Xe({subScale:.7},s==null?void 0:s.textOptions)),l=ce.multilink([e,t.faceValueStyleProperty,t.theme.faceValueColorProperty,t.theme.faceValueCompletedColorProperty,t.theme.faceValueErrorColorProperty,t.theme.faceValueRatioColorProperty,t.faceStateVisibleProperty],(d,a,c,C,g,P,u)=>{const w=d.getFaceValue(r);this.visible=!u;let m,S,f=!1,y=!1;if(w===null)m="",S=null;else{let N=0,V=0;for(const F of r.edges){const k=d.getEdgeState(F);k===H.BLACK?N++:k===H.WHITE&&V++}if(a==="static"||w===0)m=`${w}`;else if(a==="remaining")m=`${w-N}`,f=N>0;else if(a==="ratio")w-N===0?m="0":(m=`${w-N}<sub style="color: ${P.toCSS()};">/<sub>${V}</sub></sub>`,y=!0),f=N>0;else throw new Error(`unhandled faceValueStyle: ${a}`);N<w?S=c:N===w?S=C:S=g}i.string=m,i.fill=S,i.maxWidth=y?.8:.9,i.maxHeight=y?.8:.9,i.center=r.viewCoordinates,this.children=[i]});this.disposeEmitter.addListener(()=>l.dispose())}}const J=.07,Io=new L().moveTo(-J,-J).lineTo(J,J).moveTo(-J,J).lineTo(J,-J).makeImmutable();class Bo extends T{constructor(r,e,t,o,s){super({}),this.edge=r;const p=new B([e],f=>f.getEdgeState(r));this.disposeEmitter.addListener(()=>p.dispose());const i=r.start.viewCoordinates,l=r.end.viewCoordinates,d=i.average(l),a=new B([t,o.redXsVisibleProperty],(f,y)=>!f&&y);this.disposeEmitter.addListener(()=>a.dispose());const c=new R(Io,{stroke:o.theme.xColorProperty,lineWidth:.025,center:d,visibleProperty:a}),C=f=>{c.rotation=f?l.minus(i).getAngle():0};o.redXsAlignedProperty.link(C),this.disposeEmitter.addListener(()=>o.redXsAlignedProperty.unlink(C));const g=new B([t,o.whiteLineVisibleProperty],(f,y)=>!f&&y);this.disposeEmitter.addListener(()=>g.dispose());const P=new Ue(i.x,i.y,l.x,l.y,{lineWidth:.02,stroke:o.theme.whiteLineColorProperty,visibleProperty:g}),u=new B([t,o.redLineVisibleProperty],(f,y)=>y);this.disposeEmitter.addListener(()=>u.dispose());const w=new R(null,{lineWidth:.02,stroke:o.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:u}),m=f=>{f==="middle"?w.shape=new L().moveToPoint(d.blend(i,.35)).lineToPoint(d.blend(l,.35)).makeImmutable():f==="gap"?w.shape=new L().moveToPoint(i).lineToPoint(i.blend(d,.35)).moveToPoint(l.blend(d,.35)).lineToPoint(l).makeImmutable():f==="full"?w.shape=new L().moveToPoint(i).lineToPoint(l).makeImmutable():M()&&I(!1,`Unknown red line style: ${f}`)};o.redLineStyleProperty.link(m),this.disposeEmitter.addListener(()=>o.redLineStyleProperty.unlink(m));const S=s==null?void 0:s.edgePressListener;if(S){const f=new L;if(r.faces.length===2)f.polygon([i,r.faces[0].viewCoordinates,l,r.faces[1].viewCoordinates]);else{M()&&I(r.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const y=r.forwardHalf.face===null?r.forwardHalf:r.reversedHalf;M()&&I(y.previous.face===null),M()&&I(y.next.face===null);const N=y.start.viewCoordinates,V=y.end.viewCoordinates,F=y.previous.start.viewCoordinates,k=y.next.end.viewCoordinates,E=(Le,de,et)=>{const Te=de.minus(Le).normalized(),tt=et.minus(de).normalized();let q=Te.minus(tt);return q.getMagnitude()<1e-6?q=Te.getPerpendicular():q=q.normalized(),st.triangleAreaSigned(Le,de,de.plus(q))<0&&(q=q.negated()),q},A=E(F,N,V),we=E(N,V,k);f.polygon([N,r.faces[0].viewCoordinates,V,V.plus(we.times(s.backgroundOffsetDistance)),N.plus(A.times(s.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=f,!s.noninteractive&&ge(r,this,S,s.edgeHoverListener)}p.link(f=>{f===H.WHITE?this.children=[P]:f===H.BLACK?this.children=[]:this.children=[w,c]})}}class Ro extends T{constructor(e,t,o){super({pickable:!1,visibleProperty:o.edgesVisibleProperty});b(this,"simpleRegionNodeMap",new Map);b(this,"regionIdMap",new Map);b(this,"weirdEdgeNodeMap",new Map);b(this,"regionContainer",new T);b(this,"weirdEdgeContainer",new T);b(this,"adjacentFacesMap",new Map);this.board=e,this.style=o,e.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(l=>l.getOtherFace(i)).filter(l=>l!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],t.value.getSimpleRegions().forEach(i=>this.addRegion(i)),t.value.getWeirdEdges().forEach(i=>this.addWeirdEdge(i)),this.updateHues();const s=(i,l)=>{const d=l.getSimpleRegions(),a=i.getSimpleRegions(),c=l.getWeirdEdges(),C=i.getWeirdEdges(),g=[],P=[];Ge(d,a,g,P,[]);const w=new Set(g);for(const m of P)if(this.regionIdMap.has(m.id)){const S=this.regionIdMap.get(m.id);this.replaceRegion(S,m),w.delete(S)}else this.addRegion(m);for(const m of w)this.removeRegion(m);for(const m of c)C.includes(m)||this.removeWeirdEdge(m);for(const m of C)c.includes(m)||this.addWeirdEdge(m);(P.length||g.length)&&this.updateHues()};t.lazyLink(s),this.disposeEmitter.addListener(()=>t.unlink(s)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const p=()=>this.updateHues();o.theme.simpleRegionHueLUTProperty.link(p),o.edgesHaveColorsProperty.lazyLink(p),this.disposeEmitter.addListener(()=>{o.theme.simpleRegionHueLUTProperty.unlink(p),o.edgesHaveColorsProperty.unlink(p)})}addRegion(e){const t=new ee(e,this.style);this.simpleRegionNodeMap.set(e,t),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(t)}replaceRegion(e,t){M()&&I(e.id===t.id);const o=this.simpleRegionNodeMap.get(e);o.updateRegion(t),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(t,o),this.regionIdMap.delete(e.id),this.regionIdMap.set(t.id,t)}removeRegion(e){const t=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(t),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),t.dispose()}addWeirdEdge(e){const t=e.start.viewCoordinates,o=e.end.viewCoordinates,s=new Ue(t.x,t.y,o.x,o.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(e,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(e){const t=this.weirdEdgeNodeMap.get(e);this.weirdEdgeContainer.removeChild(t),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const t=new D(0,0),o=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(1,0)},s=new Map,p=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const c=new Set;for(const g of a.simpleRegion.edges)for(const P of g.faces)c.add(P);const C=new Set;for(const g of c){C.add(g);for(const P of this.adjacentFacesMap.get(g))C.add(P)}for(const g of C){const P=s.get(g);if(P.length)for(const u of P){let w=!1;for(const m of p)if(m.a===u&&m.b===a){m.weight++,w=!0;break}w||p.push({a:u,b:a,weight:1})}P.push(a)}}const i=new Map;for(const a of e)i.set(a,D.ZERO.copy());const l=(a,c,C)=>{const g=i.get(a),P=i.get(c),u=a.hueVector.dot(c.hueVector),w=t.set(c.hueVector).subtract(a.hueVector);if(w.magnitude>1e-9){w.normalize();const m=.3,S=C*((Math.max(m,u)-m)/(1-m))**3;w.multiplyScalar(S),g.subtract(w),P.add(w)}};let d=1;for(let a=0;a<100;a++){d*=.99;for(const c of e)i.get(c).setXY(0,0);for(const c of p){const C=c.a,g=c.b,P=c.weight;l(C,g,P)}if(e.length<8)for(let c=0;c<e.length;c++){const C=e[c];for(let g=c+1;g<e.length;g++)l(C,e[g],.2)}for(const c of e){const C=i.get(c);C.multiplyScalar(d/c.edgeCount),c.hueVector.add(C),i.get(c).setXY(0,0)}o()}for(const a of e)a.updateHue()}}class ee extends R{constructor(e,t){const o=D.createPolar(1,ue.nextDoubleBetween(0,2*Math.PI));super(ee.toShape(e),{stroke:ee.hueVectorToPaint(o,t),lineWidth:.1,lineCap:"square",lineJoin:"round"});b(this,"hueVector");b(this,"edgeCount");this.simpleRegion=e,this.style=t,this.hueVector=o,this.edgeCount=e.edges.length;const s=i=>{this.lineJoin=i};t.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>t.joinedLinesJoinProperty.unlink(s));const p=i=>{this.lineCap=i};t.joinedLinesCapProperty.link(p),this.disposeEmitter.addListener(()=>t.joinedLinesCapProperty.unlink(p))}updateHue(){this.stroke=ee.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=ee.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,t){const o=t.theme.simpleRegionHueLUTProperty.value,s=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return M()&&I(s>=0&&s<o.length),t.edgesHaveColorsProperty.value?o[s]:t.theme.blackLineColorProperty}static toShape(e){const t=new L;let o=!0;for(const s of e.halfEdges)o&&(o=!1,t.moveToPoint(s.start.viewCoordinates)),t.lineToPoint(s.end.viewCoordinates);return e.isSolved&&t.close(),t.makeImmutable()}}class Ho extends T{constructor(e,t,o){const s=new T;super({pickable:!1,children:[s]});b(this,"faceColorNodeMap",new Map);b(this,"faceColorIdMap",new Map);b(this,"adjacentFacesMap",new Map);b(this,"faceColorNodeContainer");b(this,"dualColorViews",new Set);this.board=e,this.stateProperty=t,this.style=o,this.faceColorNodeContainer=s,e.faces.forEach(d=>{this.adjacentFacesMap.set(d,d.edges.map(a=>a.getOtherFace(d)).filter(a=>a!==null))});{const d=t.value.getFaceColors();for(const a of d)this.addFaceColor(a,t.value.getFacesWithColor(a));this.addDualColorViews(t.value,d)}this.updateHues();let p=t.value.clone();const i=d=>{const a=p;p=d.clone();const c=a.getFaceColors(),C=d.getFaceColors(),g=[],P=[],u=[];Ge(c,C,g,P,u);const w=new Set(g),m=this.removeInvalidDualColorViews(d),S=[...m];for(const f of P)if(m.add(f),this.faceColorIdMap.has(f.id)){const y=this.faceColorIdMap.get(f.id);this.replaceFaceColor(y,f,d.getFacesWithColor(f)),w.delete(y)}else this.addFaceColor(f,d.getFacesWithColor(f));for(const f of u)this.updateFaceColor(f,d.getFacesWithColor(f));for(const f of w)m.delete(f),this.removeFaceColor(f);this.addDualColorViews(d,[...m]),(P.length||g.length||S.length)&&this.updateHues()};t.lazyLink(i),this.disposeEmitter.addListener(()=>t.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const l=()=>this.updateHues();o.theme.faceColorBasicHueLUTProperty.lazyLink(l),o.theme.faceColorLightHueLUTProperty.lazyLink(l),o.theme.faceColorDarkHueLUTProperty.lazyLink(l),o.theme.faceColorInsideColorProperty.lazyLink(l),o.theme.faceColorOutsideColorProperty.lazyLink(l),o.theme.faceColorDefaultColorProperty.lazyLink(l),o.faceColorThresholdProperty.lazyLink(l),this.updateHues(),this.disposeEmitter.addListener(()=>{o.theme.faceColorBasicHueLUTProperty.unlink(l),o.theme.faceColorLightHueLUTProperty.unlink(l),o.theme.faceColorDarkHueLUTProperty.unlink(l),o.theme.faceColorInsideColorProperty.unlink(l),o.theme.faceColorOutsideColorProperty.unlink(l),o.theme.faceColorDefaultColorProperty.unlink(l),o.faceColorThresholdProperty.unlink(l)})}addFaceColor(e,t){const o=new ne(e,t,this.style);this.faceColorNodeMap.set(e,o),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(o)}replaceFaceColor(e,t,o){M()&&I(e.id===t.id);const s=this.faceColorNodeMap.get(e);s.updateFaceColor(t,o),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(t,s),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(t.id,t)}updateFaceColor(e,t){const o=this.faceColorNodeMap.get(e);let s=o.faces.length!==t.length;if(!s)for(let p=0;p<t.length;p++){const i=o.faces[p],l=t[p];if(i!==l){s=!0;break}}s&&o.updateFaceColor(e,t)}removeFaceColor(e){const t=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(t),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),t.dispose()}addDualColorViews(e,t){const o=new Set(t);for(;o.size;){const s=o.values().next().value;o.delete(s);const p=this.faceColorNodeMap.get(s);M()&&I(p);const i=e.getOppositeFaceColor(s);if(i){M()&&I(o.has(i)),o.delete(i);const l=this.faceColorNodeMap.get(i);M()&&I(l),this.dualColorViews.add(new Re([p,l],this.style))}else this.dualColorViews.add(new Re([p],this.style))}}removeInvalidDualColorViews(e){const t=new Set,o=new Set(e.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,o)){for(const p of s.colorNodes)t.add(p.faceColor);this.dualColorViews.delete(s),s.dispose()}return t}updateHues(){const e=[...this.dualColorViews].filter(t=>t.colorNodes[0].faceColor.colorState!==ie.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:t.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const t=new D(0,0),o=()=>{for(const a of e)a.hueVector.getMagnitude()>1e-6?a.hueVector.normalize():a.hueVector.setXY(ue.nextDouble()-.5,ue.nextDouble()-.5).normalize()},s=new Map,p=[];this.board.faces.forEach(a=>{s.set(a,[])});for(const a of e){const c=new Set;for(const g of a.faces)c.add(g);const C=new Set;for(const g of c){C.add(g);for(const P of this.adjacentFacesMap.get(g))C.add(P)}for(const g of C){const P=s.get(g);if(P){if(P.length)for(const u of P){let w=!1;for(const m of p)if(m.a===u&&m.b===a){m.weight++,w=!0;break}w||p.push({a:u,b:a,weight:1})}P.push(a)}}}const i=new Map;for(const a of e)i.set(a,D.ZERO.copy());const l=(a,c,C)=>{const g=i.get(a),P=i.get(c),u=a.hueVector.dot(c.hueVector),w=t.set(c.hueVector).subtract(a.hueVector).normalize(),m=.2,S=Math.abs(u),f=C*((Math.max(m,S)-m)/(1-m))**3;w.multiplyScalar(f),g.subtract(w),P.add(w)};let d=1;for(let a=0;a<100;a++){d*=.99;for(const c of e)i.get(c).setXY(0,0);for(const c of p){const C=c.a,g=c.b,P=c.weight;l(C,g,P)}if(e.length<8)for(let c=0;c<e.length;c++){const C=e[c];for(let g=c+1;g<e.length;g++)l(C,e[g],.2)}for(const c of e){const C=i.get(c);C.multiplyScalar(d/c.faceCount),c.hueVector.add(C),i.get(c).setXY(0,0)}o()}}for(const t of this.dualColorViews)t.updateHue()}}const j=class j extends Ye{};b(j,"BASIC",new j),b(j,"PRIMARY",new j),b(j,"SECONDARY",new j),b(j,"enumeration",new je(j));let Y=j;class Re{constructor(r,e){b(this,"hueVector");b(this,"faceCount");if(this.colorNodes=r,this.style=e,M()&&I(r.length===1||r.length===2),this.faceCount=be.sum(this.colorNodes.map(t=>t.faceCount)),r.forEach(t=>{t.dualColorView=this}),r.length===1)r[0].type=Y.BASIC,this.hueVector=r[0].hueVector.copy();else{const t=r[0].faceCount>r[1].faceCount?r[0]:r[1],o=t===r[0]?r[1]:r[0];let s;t.type===Y.PRIMARY?s=t:o.type===Y.PRIMARY||t.type===Y.SECONDARY?s=o:(o.type,Y.SECONDARY,s=t);const p=s===t?o:t;this.hueVector=t.hueVector.copy(),s.type=Y.PRIMARY,p.type=Y.SECONDARY}}get faces(){return this.colorNodes.flatMap(r=>r.faces)}isStillValidInState(r,e){for(const t of this.colorNodes)if(!e.has(t.faceColor))return!1;return this.colorNodes.length===1?r.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:r.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const r of this.colorNodes)r.hueVector.set(this.hueVector),r.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const r of this.colorNodes)r.dualColorView=null}}class ne extends R{constructor(e,t,o){const s=D.createPolar(1,ue.nextDoubleBetween(0,2*Math.PI));super(ne.toShape(t));b(this,"hueVector");b(this,"faceCount");b(this,"dualColorView",null);b(this,"type",Y.BASIC);this.faceColor=e,this.faces=t,this.style=o,this.hueVector=s,this.faceCount=t.length}updateHue(e){e||this.faceColor.colorState!==ie.UNDECIDED?this.fill=ne.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,t){const o=t.length-this.faceCount;this.faceColor=e,this.faces=t,this.shape=ne.toShape(t),this.faceCount=t.length,this.dualColorView&&(this.dualColorView.faceCount+=o)}static hueVectorToPaint(e,t,o,s){const p=o===Y.BASIC?s.theme.faceColorBasicHueLUTProperty.value:o===Y.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,i=(Math.round(e.getAngle()*180/Math.PI)+360)%360;M()&&I(i>=0&&i<p.length);const l=p[i];if(t===ie.UNDECIDED)return l;{const a=(t===ie.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,c=a.alpha,C=new Ne(l);return new Ne((1-c)*C.red+c*a.red,(1-c)*C.green+c*a.green,(1-c)*C.blue+c*a.blue).toCSS()}}static toShape(e){const t=new L;for(const o of e)t.polygon(o.vertices.map(s=>s.viewCoordinates));return t.makeImmutable()}}const He=[.02,.02],Do=new Map([[v.NONE,[]],[v.ONLY_ZERO,[]],[v.ONLY_ONE,[]],[v.ONLY_TWO,[]],[v.NOT_ZERO,He],[v.NOT_ONE,[]],[v.NOT_TWO,He],[v.ANY,[]]]),ve=.2,De=.02,ae=class ae extends T{constructor(r,e,t,o){super(),this.sector=r;const s=ae.getSectorBaseShape(r,o.backgroundOffsetDistance);this.mouseArea=s,this.touchArea=s,!o.noninteractive&&ge(r,this,o.sectorPressListener,o.sectorHoverListener);const p=d=>{const a=r.start.viewCoordinates,c=r.end.viewCoordinates,C=r.next.end.viewCoordinates,g=a.minus(c),P=C.minus(c),u=g.normalized(),w=P.normalized(),m=w.minus(u).angle+Math.PI/2,S=g.angle;let f=P.angle;f<S&&(f+=2*Math.PI);const y=D.createPolar(.2,m),N=(F,k)=>(F.moveToPoint(u.timesScalar(k)),F.arcPoint(D.ZERO,k,S,f,!0),F),V=(F,k,E)=>(F.moveTo(k.x+E,k.y),F.circle(k,E),F);if(d===v.NONE)return new L().moveTo(y.x-.05,y.y-.05).lineTo(y.x+.05,y.y+.05).moveTo(y.x-.05,y.y+.05).lineTo(y.x+.05,y.y-.05).makeImmutable();if(d===v.ONLY_ZERO)return V(new L,y,.05).makeImmutable();if(d===v.ONLY_TWO)return new L().moveToPoint(u.timesScalar(.1).plus(y.timesScalar(.7))).lineToPoint(y.timesScalar(.7)).lineToPoint(w.timesScalar(.1).plus(y.timesScalar(.7))).makeImmutable();if(d===v.ONLY_ONE||d===v.NOT_TWO)return N(new L,ve).makeImmutable();if(d===v.NOT_ZERO||d===v.NOT_ONE)return N(N(new L,ve+De),ve-De).makeImmutable();if(d===v.ANY)return V(V(V(new L,y,.05),y,.03),y,.01).makeImmutable();throw new Error("Unhandled sector state")},i=new R(null,{translation:r.end.viewCoordinates,lineWidth:.01,lineCap:"butt",visibleProperty:t.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>i.dispose()),this.addChild(i);const l=ce.multilink([e,t.sectorsNextToEdgesVisibleProperty,t.sectorsTrivialVisibleProperty],(d,a,c)=>{const C=d.getEdgeState(r.edge),g=d.getEdgeState(r.next.edge),P=d.getSectorState(r);let u=null,w=null,m=[],S=.01;if(a||C===H.WHITE&&g===H.WHITE){let f=v.trivialStates.includes(P);if(P===v.NOT_ONE){const y=r.end.edges.filter(V=>d.getEdgeState(V)===H.BLACK),N=r.end.edges.filter(V=>d.getEdgeState(V)===H.WHITE);y.length===0&&N.length===2&&(f=!0)}(c||!f)&&(u=p(P)??null,w=ae.getStrokeFromStyle(P,t)??null,m=Do.get(P)??[],m.length&&(S=.015))}i.shape=u,i.stroke=w,i.lineDash=m,i.lineWidth=S});this.disposeEmitter.addListener(()=>l.dispose())}static getSectorBaseShape(r,e){const t=r.start.viewCoordinates,o=r.end.viewCoordinates,s=r.next.end.viewCoordinates,p=t.minus(o),i=s.minus(o),l=p.normalized(),a=i.normalized().minus(l).angle+Math.PI/2,c=r.face?r.face.viewCoordinates:D.createPolar(e,a).plus(o),C=t.average(o),g=s.average(o);return L.polygon([C,o,g,c]).makeImmutable()}static getSectorArcShape(r,e){const t=r.start.viewCoordinates,o=r.end.viewCoordinates,s=r.next.end.viewCoordinates,p=t.minus(o),i=s.minus(o),l=p.normalized(),d=p.angle;let a=i.angle;return a<d&&(a+=2*Math.PI),new L().moveToPoint(o).lineToPoint(l.timesScalar(e).plus(o)).arcPoint(o,e,d,a,!0).close().makeImmutable()}static getStrokeFromStyle(r,e){return r===v.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:r===v.NOT_ZERO?e.theme.sectorNotZeroColorProperty:r===v.NOT_ONE?e.theme.sectorNotOneColorProperty:r===v.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}};b(ae,"nameMap",new Map([[v.NONE,"Invalid"],[v.ONLY_ZERO,"No Lines"],[v.ONLY_ONE,"Only One Line"],[v.ONLY_TWO,"Both Lines"],[v.NOT_ZERO,"At Least One Line"],[v.NOT_ONE,"Zero or Two Lines"],[v.NOT_TWO,"Less Than Two Lines"],[v.ANY,"Any Lines"]]));let K=ae;class Wo extends T{constructor(r,e,t,o){super({pickable:!1}),this.vertex=r;const s=.12,i=r.edges.map(u=>u.getOtherVertex(r).viewCoordinates.minus(r.viewCoordinates).normalized()).map(u=>u.times(s)),d=L.polygon(it.grahamScan([D.ZERO,...i],!1)).getOffsetShape(-.05),a=new R(null,{stroke:o.theme.vertexStateLineProperty,lineWidth:.01}),c=new R(d,{translation:r.viewCoordinates,fill:o.theme.vertexStateBackgroundProperty,stroke:o.theme.vertexStateOutlineProperty,lineWidth:.01,children:[a,...i.map(u=>new _e({radius:.02,translation:u,fill:o.theme.vertexStatePointProperty}))]});let C=null;const g=ce.multilink([e,o.vertexStateVisibleProperty,o.allVertexStateVisibleProperty],(u,w,m)=>{const S=()=>{this.children=[]};if(!w){S();return}const f=u.getVertexState(r);if(!m){let y=!1,N=!1;const V=new Set;for(const k of r.edges){const E=u.getEdgeState(k);y=y||E===H.BLACK,N=N||E===H.WHITE,E===H.WHITE&&V.add(k)}if(y||!N){S();return}if(ct.fromLookup(r,(k,E)=>V.has(k)&&V.has(E),!0).equals(f)){S();return}}if(!C||!C.equals(f)){C=f;const y=new L;for(const N of f.getAllowedPairs()){const V=F=>F.getOtherVertex(r).viewCoordinates.minus(r.viewCoordinates).normalized().times(s);y.moveToPoint(V(N[0])),y.lineToPoint(V(N[1]))}f.allowsEmpty()&&(y.moveTo(.03,0),y.circle(D.ZERO,.03),y.close()),y.makeImmutable(),a.shape=y}this.children=[c]});this.disposeEmitter.addListener(()=>g.dispose());const P=u=>{this.visible=!u};t.link(P),this.disposeEmitter.addListener(()=>t.unlink(P))}}class Yo extends qe{constructor(r,e){const t=le()({font:Mt,fill:X.uiForegroundColorProperty},e);super(r,t)}}class jo extends T{constructor(r,e,t,o){super({translation:r.viewCoordinates}),this.face=r;const s=ce.multilink([e,o.faceStateVisibleProperty],(i,l)=>{if(this.children=[],l){const d=i.getFaceState(r),a=d.possibilityCount===0||d.possibilityCount>9;let c;const C=d.possibilityCount===1?o.theme.faceValueCompletedColorProperty:o.theme.faceValueColorProperty;if(a)c=new Yo(d.possibilityCount,{font:fe,maxWidth:.4,maxHeight:.4});else{const g=new Set(r.vertices);c=new at({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(d.possibilityCount)),children:d.getAllowedCombinations().map(P=>{const u=new T,w=new Set(P.map(f=>f.start)),m=new Set(P.map(f=>f.end)),S=f=>f.minus(r.viewCoordinates);if(u.addChild(new R(L.polygon(r.vertices.map(f=>S(f.viewCoordinates))),{stroke:C,lineWidth:.03,opacity:.2})),w.size){const f=new L;if(P.length===r.edges.length)f.polygon(r.vertices.map(y=>S(y.viewCoordinates)));else{const y=new Set(P);for(;y.size;){const N=[...g].find(k=>[...y].filter(E=>E.start===k||E.end===k).length===1);M()&&I(N);let V=N,F=[...y].find(k=>k.start===V||k.end===V)??null;for(f.moveToPoint(S(V.viewCoordinates));F;)y.delete(F),V=F.getOtherVertex(V),f.lineToPoint(S(V.viewCoordinates)),F=[...y].find(k=>k.start===V||k.end===V)??null}}u.addChild(new R(f,{stroke:C,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const f of r.vertices)!w.has(f)&&!m.has(f)&&u.addChild(new _e(.1,{fill:C,translation:S(f.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}c.center=D.ZERO,this.addChild(c)}});this.disposeEmitter.addListener(()=>s.dispose());const p=i=>{this.visible=!i};t.link(p),this.disposeEmitter.addListener(()=>t.unlink(p))}}const Xo=new Ee({lineWidth:.2,lineCap:"round",lineJoin:"round"});class Uo extends T{constructor(r,e,t){let o;if(It.value)if(r.type==="edge-state"){const s=new L().moveToPoint(r.edge.start.viewCoordinates).lineToPoint(r.edge.end.viewCoordinates);o=[new R(s.getStrokedShape(Xo),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(r.type==="face-color")if(r.face){const s=L.polygon(r.face.vertices.map(i=>i.viewCoordinates));o=[new R(s.getOffsetShape(-.1),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else o=[];else if(r.type==="sector"){const s=K.getSectorArcShape(r.sector,.5);o=[new R(s.getOffsetShape(.05),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else o=[];else o=[];super({children:o}),this.hoverHighlight=r}}class _o extends T{constructor(r,e,t,o){let s=[];try{let p=new L;for(const l of r.faces)p.polygon(l.vertices.map(d=>d.viewCoordinates));if(r.faceColor.colorState===ie.OUTSIDE)try{const l=L.polygon(e.outerBoundary.map(c=>c.start.viewCoordinates)),a=me.getOffsetBackgroundShape(e.outerBoundary,o.useBackgroundOffsetStroke,o.backgroundOffsetDistance).shapeDifference(l);p=p.shapeUnion(a)}catch(l){console.error(l)}const i=new R(p.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:t.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(i)}catch(p){console.error(p)}super({children:s}),this.selectedFaceColorHighlight=r}}class qo extends T{constructor(r,e,t,o){const s=[],p=[],i=r.sector,l=r.currentState,d=K.getSectorArcShape(i,.5),a=new R(d.getOffsetShape(.05),{stroke:t.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(a);const c=[];if(l===v.ANY&&(c.push(v.NOT_ZERO),c.push(v.NOT_ONE),c.push(v.NOT_TWO)),l.one&&l!==v.ONLY_ONE&&c.push(v.ONLY_ONE),c.length){const C=c.map(u=>{const w=K.getStrokeFromStyle(u,t);return new ft({accessibleName:K.nameMap.get(u),content:new lt(0,0,25,25),listener:()=>{o.sectorSetListener&&o.sectorSetListener(i,u)},buttonAppearanceStrategy:Bt,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});p.push(...C);const g=new Ze(new Je({children:C,spacing:10}),{xMargin:10,yMargin:10,fill:t.theme.uiBackgroundColorProperty,stroke:t.theme.uiForegroundColorProperty,scale:.01});p.push(g);const P=.1;s.push(g),g.centerBottom=a.centerTop.plusXY(0,-.15),g.top<e.top+P&&(g.centerTop=a.centerBottom.plusXY(0,.15)),g.left<e.left+P&&(g.left=e.left+P),g.right>e.right-P&&(g.right=e.right-P)}super({children:s}),this.selectedSectorEdit=r,this.disposeEmitter.addListener(()=>{p.forEach(C=>C.dispose())})}}class We extends T{constructor(e,t){const o=le()({textOptions:{font:fe,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new te(null),selectedFaceColorHighlightProperty:new te(null),selectedSectorEditProperty:new te(null),style:$,noninteractive:!1},t),s=o.style,p=new T({visibleProperty:s.faceColorsVisibleProperty}),i=new T({pickableProperty:No}),l=new T({pickableProperty:Lo}),d=new T({pickableProperty:Vo}),a=new T({pickableProperty:To}),c=new T,C=new T({pickable:!1}),g=new T({pickable:!1}),P=new T({pickable:null}),u=new T({pickable:!1}),w=new T({pickable:!1}),m=new T,S=new B([e.stateProperty],E=>{if(E.getWeirdEdges().length||E.hasInvalidFaceColors())return!1;const A=E.getSimpleRegions();return A.length===1&&A[0].isSolved});p.addChild(new Ho(e.board,e.stateProperty,s)),e.board.faces.forEach(E=>{i.addChild(new Mo(E,e.stateProperty,s,o)),g.addChild(new jo(E,e.stateProperty,S,s))});const f=new me(e.board.outerBoundary,e.board.innerBoundaries,s,o),y=E=>{E?e.board.vertices.forEach(A=>{a.addChild(new Ao(A,e.stateProperty,S,s))}):a.children.forEach(A=>A.dispose())};s.verticesVisibleProperty.link(y);const N=E=>{E?e.board.vertices.forEach(A=>{C.addChild(new Wo(A,e.stateProperty,S,s))}):C.children.forEach(A=>A.dispose())};s.vertexStateVisibleProperty.link(N),e.board.edges.forEach(E=>{d.addChild(new Bo(E,e.stateProperty,S,s,o))}),e.board.halfEdges.forEach(E=>{l.addChild(new K(E,e.stateProperty,s,o))}),c.addChild(new Ro(e.board,e.stateProperty,s));super(Xe({children:[f,p,i,l,d,a,c,C,g,P,u,w,m]},o));b(this,"annotationContainer");b(this,"backgroundNode");this.puzzle=e,this.annotationContainer=P;const V=E=>{w.children.forEach(A=>A.dispose()),E&&w.addChild(new Uo(E,o.backgroundOffsetDistance,s))};o.hoverHighlightProperty.link(V),this.disposeEmitter.addListener(()=>o.hoverHighlightProperty.unlink(V));const F=E=>{u.children.forEach(A=>A.dispose()),E&&u.addChild(new _o(E,e.board,s,o))};o.selectedFaceColorHighlightProperty.link(F),this.disposeEmitter.addListener(()=>o.selectedFaceColorHighlightProperty.unlink(F));const k=E=>{m.children.forEach(A=>A.dispose()),E&&m.addChild(new qo(E,f,s,o))};o.selectedSectorEditProperty.link(k),this.disposeEmitter.addListener(()=>o.selectedSectorEditProperty.unlink(k)),this.disposeEmitter.addListener(()=>{s.verticesVisibleProperty.unlink(y),s.vertexStateVisibleProperty.unlink(N),[p,i,d,a,c,C,g,l].forEach(A=>{A.children.forEach(we=>we.dispose()),A.dispose()}),S.dispose(),f.dispose()}),this.backgroundNode=f}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class ar extends T{constructor(r,e,t){const o=le()({style:$},t),s=e.getEmbeddedCompleteData(r.inputFeatureSet),p=e.getEmbeddedCompleteData(r.outputFeatureSet),i=new We(new ke(e.smallBoard,s),{noninteractive:!0,style:o.style}),l=new We(new ke(e.smallBoard,p),{noninteractive:!0,style:o.style}),d=r.highlander?new T({children:e.getEmbeddedQuestionFaces(r.inputFeatureSet).map(m=>new qe("?",{font:fe,maxWidth:.9,maxHeight:.9,opacity:.5,fill:r.highlander?o.style.theme.faceValueColorProperty:o.style.theme.faceValueCompletedColorProperty,center:m.viewCoordinates}))}):new T,c=e.tightBounds.dilated(.5),C=.5,g=L.roundRectangle(c.x,c.y,c.width,c.height,C,C),P=new T({children:[i,d],clipArea:g,localBounds:c}),u=new T({children:[l,d],clipArea:g,localBounds:c}),w=new Ze(new Je({spacing:.2,children:[P,new eo(0,0,20,0,{fill:o.style.theme.uiForegroundColorProperty,stroke:o.style.theme.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),u]}),{cornerRadius:C*1.2,xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:o.style.theme.patternAnnotationBackgroundColorProperty});o.children=[w],super(o),this.rule=r,this.displayEmbedding=e,this.disposeEmitter.addListener(()=>{i.dispose(),l.dispose()})}}const Jo=(h,r)=>{zt($t,h,r,!0)};class he{constructor(r,e,t,o,s,p,i,l,d,a){this.sourcePatternBoard=r,this.boardPatternBoard=e,this.largeBoard=t,this.embedding=o,this.smallBoard=s,this.toSmallFaceMap=p,this.toSmallEdgeMap=i,this.toSmallSectorMap=l,this.tightBounds=d,this.expandedBounds=a}mapFace(r){const e=this.embedding.mapFace(r),t=this.boardPatternBoard.getFace(e);if(t){const o=this.toSmallFaceMap.get(t);return M()&&I(o),o}else return null}mapEdge(r){return(r.isExit?this.embedding.mapExitEdges(r):[this.embedding.mapNonExitEdge(r)]).map(o=>this.boardPatternBoard.getEdge(o)).map(o=>{const s=this.toSmallEdgeMap.get(o);return M()&&I(s),s})}mapSector(r){const e=this.embedding.mapSector(r),t=this.boardPatternBoard.getSector(e),o=this.toSmallSectorMap.get(t);return M()&&I(o),o}getEmbeddedQuestionFaces(r){const e=new Set;for(const t of r.patternBoard.faces)if(r.getFaceValue(t)!==void 0){const o=this.mapFace(t);o&&e.add(o)}return this.smallBoard.faces.filter(t=>!e.has(t))}getEmbeddedCompleteData(r){const e=dt.empty(this.smallBoard);for(const t of r.getFeaturesArray())if(t instanceof to)t.value!==null&&e.setFaceValue(this.mapFace(t.face),t.value);else if(t instanceof oo)this.mapEdge(t.edge).forEach(o=>e.setEdgeState(o,H.BLACK));else if(t instanceof ro)this.mapEdge(t.edge).forEach(o=>e.setEdgeState(o,H.RED));else if(t instanceof so)e.setSectorState(this.mapSector(t.sector),v.NOT_ZERO);else if(t instanceof io)e.setSectorState(this.mapSector(t.sector),v.NOT_ONE);else if(t instanceof no)e.setSectorState(this.mapSector(t.sector),v.NOT_TWO);else if(t instanceof ao)e.setSectorState(this.mapSector(t.sector),v.ONLY_ONE);else if(t instanceof lo){const o=(p,i)=>{const l=this.mapFace(p),d=this.mapFace(i),a=l?e.getFaceColor(l):e.getOutsideColor(),c=d?e.getFaceColor(d):e.getOutsideColor();new Kt(pe(e,a),pe(e,c)).apply(e)},s=(p,i)=>{const l=this.mapFace(p),d=this.mapFace(i),a=l?e.getFaceColor(l):e.getOutsideColor(),c=d?e.getFaceColor(d):e.getOutsideColor();new Qt(pe(e,a),pe(e,c)).apply(e)};for(let p=1;p<t.primaryFaces.length;p++)o(t.primaryFaces[p-1],t.primaryFaces[p]);for(let p=1;p<t.secondaryFaces.length;p++)o(t.secondaryFaces[p-1],t.secondaryFaces[p]);t.secondaryFaces.length&&s(t.primaryFaces[0],t.secondaryFaces[0])}else throw new Error(`unhandled feature: ${t}`);return Jo(this.smallBoard,e),e}static getEmbeddingBounds(r,e,t){const o=Ce.NOTHING.copy(),s=i=>{o.addPoint(e.getVertex(t.mapVertex(i)).viewCoordinates)};r.vertices.forEach(s);const p=i=>{const l=e.getFace(t.mapFace(i));l&&l.vertices.forEach(d=>o.addPoint(d.viewCoordinates))};return r.faces.forEach(p),r.edges.forEach(i=>{let l;i.isExit?l=t.mapExitEdges(i).map(d=>e.getEdge(d)):l=[e.getEdge(t.mapNonExitEdge(i))],l.forEach(d=>{o.addPoint(d.start.viewCoordinates),o.addPoint(d.end.viewCoordinates)})}),o}static findBestEmbedding(r,e,t){const o=co(r,e);if(o.length===0)return null;const s=Ce.NOTHING.copy();t.vertices.forEach(d=>s.addPoint(d.viewCoordinates));const p=s.center;let i=null,l=Number.POSITIVE_INFINITY;for(let d=0;d<o.length;d++){const a=o[d],C=he.getEmbeddingBounds(r,e,a).center,g=p.distance(C);g<l&&(l=g,i=a)}return i}static getDisplayEmbedding(r,e,t,o){const s=he.getEmbeddingBounds(r,e,o),p=s.dilated(.5),i=t.faces.filter(u=>{const w=Ce.NOTHING.copy();return u.vertices.forEach(m=>w.addPoint(m.viewCoordinates)),p.intersectsBounds(w)}),l=t.vertices.filter(u=>u.faces.some(w=>i.includes(w))),d=mt({vertices:l.map(u=>({logicalCoordinates:u.logicalCoordinates,viewCoordinates:u.viewCoordinates})),faces:i.map(u=>({logicalCoordinates:u.logicalCoordinates,vertices:u.vertices.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates}))}))}),a=new wt(d),c=1e-6,C=new Map(i.map((u,w)=>{const m=a.faces.find(S=>S.viewCoordinates.equalsEpsilon(u.viewCoordinates,c));return M()&&I(m),[u,m]})),g=new Map(t.edges.map(u=>{const w=a.edges.find(m=>m.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c)&&m.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c)||m.start.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c)&&m.end.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c))??null;return w?[u,w]:null}).filter(u=>u!==null)),P=new Map(t.halfEdges.map(u=>{const w=a.halfEdges.find(m=>m.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,c)&&m.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,c))??null;return w?[u,w]:null}).filter(u=>u!==null));return M()&&I(o),new he(r,e,t,o,a,C,g,P,s,p)}}export{he as D,W as E,jo as F,We as P,Yo as U,Wo as V,mo as a,Ke as b,$ as c,wo as d,z as e,Co as f,Po as g,ge as h,No as i,yo as j,vo as k,po as l,ir as m,Eo as n,ar as o,bo as p,fo as q,go as r,Jo as s,nr as t,So as v};
