var ne=Object.defineProperty;var re=(a,e,s)=>e in a?ne(a,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[e]=s;var p=(a,e,s)=>(re(a,typeof e!="symbol"?e+"":e,s),s);import{_ as I,e as d,f as h}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{L as P}from"./logic-solver-DfLyjx-d.js";import{m as X,a as G,E as Y,d as _}from"./Vector2Property-95p6aBvi.js";import{g as ae}from"./patternBoards-DgFI8dKG.js";class W{constructor(e,s){this.value=e,this.name=s}}const H=a=>a instanceof W?a.name:a.logic,U={type:"true",logic:P.TRUE,parameters:[]};P.FALSE;const Z=a=>({type:"or",logic:P.or(...a.map(H)),parameters:a}),A=a=>({type:"and",logic:P.and(...a.map(H)),parameters:a}),V=a=>({type:"not",logic:P.not(H(a)),parameters:[a]}),ee=a=>({type:"exactly-one",logic:P.exactlyOne(...a.map(H)),parameters:a}),ce=a=>A(a.map(e=>V(e))),le=Z,de=a=>Z(a.map(e=>V(e))),he=(a,e)=>{if(e>0){const s=[le(a)];return X.forEachCombination(a,t=>{t.length===a.length-e+1&&s.push(V(A(t.map(i=>V(i)))))}),A(s)}else return U},se=(a,e)=>{const s=[];return X.forEachCombination(a,t=>{t.length===e+1&&s.push(Z(t.map(i=>V(i))))}),A(s)},te=a=>V(ee(a)),fe=a=>A([se(a,2),te(a)]),ie=(a,e)=>e===0?ce(a):A([he(a,e),se(a,e)]),oe=(a,e)=>Z(e.map(s=>s===0?A(a.map(t=>V(t))):s===a.length?A(a):ie(a,s))),ue=a=>oe(a,I.range(0,a.length+1).filter(e=>e%2===0)),ge=a=>oe(a,I.range(0,a.length+1).filter(e=>e%2===1));class m extends Error{constructor(e,s){super(`Feature ${e.toCanonicalString()} incompatible with ${s.map(t=>t.toCanonicalString()).join(", ")}`),this.mainFeature=e,this.incompatibleFeatures=s}}class O{constructor(e,s,t,i){p(this,"allFaces",new Set);p(this,"canonicalString",null);if(this.primaryFaces=e,this.secondaryFaces=s,this.sameColorPaths=t,this.oppositeColorPaths=i,d()&&h(e.length+s.length>1),d()&&h(e.length),this.allFaces=new Set([...e,...s]),this.allFaces.size!==e.length+s.length)throw new m(this,[])}toCanonicalString(){if(this.canonicalString===null){const e=I.sortBy(this.primaryFaces.map(n=>n.index)),s=I.sortBy(this.secondaryFaces.map(n=>n.index)),t=e.length>s.length||e.length===s.length&&e[0]<s[0],i=t?e:s,o=t?s:e;this.canonicalString=`face-color-dual-${i.join(",")}-${o.join(",")}`}return this.canonicalString}isPossibleWith(e){for(const s of this.sameColorPaths)if(s.filter(t=>e(t)).length%2!==0)return!1;for(const s of this.oppositeColorPaths)if(s.filter(t=>e(t)).length%2===0)return!1;return!0}getPossibleFormula(e){return A([...this.sameColorPaths.map(s=>ue(s.map(t=>e(t)))),...this.oppositeColorPaths.map(s=>ge(s.map(t=>e(t))))])}embedded(e){return[new O(this.primaryFaces.map(s=>e.mapFace(s)),this.secondaryFaces.map(s=>e.mapFace(s)),this.sameColorPaths.map(s=>s.map(t=>e.mapNonExitEdge(t))),this.oppositeColorPaths.map(s=>s.map(t=>e.mapNonExitEdge(t))))]}equals(e){if(!(e instanceof O)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(o=>i.includes(o));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}indexEquals(e){if(!(e instanceof O)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(o=>i.some(n=>o.index===n.index));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}isSubsetOf(e){if(!(e instanceof O)||this.allFaces.size>e.allFaces.size)return!1;for(const t of this.allFaces.values())if(!e.allFaces.has(t))return!1;return e.primaryFaces.includes(this.primaryFaces[0])?this.primaryFaces.every(t=>e.primaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.secondaryFaces.includes(t)):this.primaryFaces.every(t=>e.secondaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.primaryFaces.includes(t))}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face-color-dual",primaryFaces:this.primaryFaces.map(e=>e.index),secondaryFaces:this.secondaryFaces.map(e=>e.index),sameColorPaths:this.sameColorPaths.map(e=>e.map(s=>s.index)),oppositeColorPaths:this.oppositeColorPaths.map(e=>e.map(s=>s.index))}}overlapsWith(e){for(const s of this.allFaces)if(e.allFaces.has(s))return!0;return!1}union(e){const s=this.primaryFaces.some(i=>e.primaryFaces.includes(i))||this.secondaryFaces.some(i=>e.secondaryFaces.includes(i)),t=this.primaryFaces.some(i=>e.secondaryFaces.includes(i))||this.secondaryFaces.some(i=>e.primaryFaces.includes(i));return d()&&h(s||t),s&&t?null:s?O.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.primaryFaces])],[...new Set([...this.secondaryFaces,...e.secondaryFaces])]):O.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.secondaryFaces])],[...new Set([...this.secondaryFaces,...e.primaryFaces])])}isCompatibleWith(e){let s=!1,t=!1;const i=new Set([...this.allFaces].filter(o=>e.allFaces.has(o)));for(const o of this.primaryFaces)i.has(o)&&(e.primaryFaces.includes(o)&&(s=!0),e.secondaryFaces.includes(o)&&(t=!0));for(const o of this.secondaryFaces)i.has(o)&&(e.primaryFaces.includes(o)&&(t=!0),e.secondaryFaces.includes(o)&&(s=!0));return!s||!t}static areCanonicalWith(e,s){const t=e.map(i=>i.toCanonicalString()).sort().join("//");for(const i of s)if(e.map(n=>{const r=n.embedded(i);return d()&&h(r.length===1),r[0].toCanonicalString()}).sort().join("//")<t)return!1;return!0}static deserialize(e,s){return new O(e.primaryFaces.map(t=>s.faces[t]),e.secondaryFaces.map(t=>s.faces[t]),e.sameColorPaths.map(t=>t.map(i=>s.edges[i])),e.oppositeColorPaths.map(t=>t.map(i=>s.edges[i])))}static fromPrimarySecondaryFaces(e,s){d()&&h(e.length+s.length>1),d()&&h(e.length);const t=[],i=[],o=new Set([...e,...s]),n=e[0],r=new Set([n]);for(let c=1;r.size<o.size;c++){if(c>100)throw new Error("FaceColorDualFeature.fromPrimarySecondaryFaces: could not find all connections");const f=(l,y,w)=>{for(const b of l.edges){if(b.faces.length!==2||y.includes(b))continue;const z=b.faces.find(q=>q!==l);if(d()&&h(z),!r.has(z))if(o.has(z)){const q=[...y,b],B=w,L=z;e.includes(B)===e.includes(L)?t.push(q):i.push(q),r.add(z)}else f(z,[...y,b],w)}};[...r].forEach(l=>f(l,[],l))}return new O(e,s,t,i)}}class pe{constructor(e){p(this,"nameMap",new Map);p(this,"termMap",new Map);p(this,"solver",new P.Solver);e&&this.addFormulas(e)}addFormula(e){this.solver.require(e instanceof W?e.name:e.logic),this.addTermsFrom(e)}addFormulas(e){for(const s of e)this.addFormula(s)}addTermsFrom(e){if(e instanceof W)this.nameMap.has(e.name)?d()&&(h(this.nameMap.get(e.name)===e.value),h(this.termMap.get(e.value)===e.name)):(this.nameMap.set(e.name,e.value),d()&&h(!this.termMap.has(e.value)),this.termMap.set(e.value,e.name));else for(const s of e.parameters)this.addTermsFrom(s)}getNextSolution(){let e=null;if(P.disablingAssertions(()=>{e=this.solver.solve()}),e){const s=e.getTrueVars(),t=new Set(s),i=new Set([...this.nameMap.keys()].filter(o=>!t.has(o)));return this.solver.require(P.or(...[...t].map(o=>`-${o}`),...[...i].map(o=>o))),s.map(o=>{const n=this.nameMap.get(o);return d()&&h(n!==void 0),n})}else return null}}class me{constructor(e){this.vertex=e}isPossibleWith(e){const s=this.vertex.edges.filter(t=>e(t)).length;return s===0||s===2}getPossibleFormula(e){return fe(this.vertex.edges.map(s=>e(s)))}}class j{constructor(e){this.possibleLoops=e}isPossibleWith(e){return this.possibleLoops.every(s=>s.some(t=>!e(t)))}getPossibleFormula(e){return this.possibleLoops.length?A(this.possibleLoops.map(s=>de(s.map(t=>e(t))))):U}static fromBoard(e){return new j(j.findLoops(e.edges,e.vertices).map(s=>[...s]))}static findLoops(e,s){const t=[],i=new Set,o=new Set,n=[],r=(c,f)=>{for(const l of c.edges){if(l.vertices.length<2)continue;const y=l.vertices.find(w=>w!==c);if(d()&&h(y),!o.has(y))if(y===f&&n.length>=2){const w=[...n,l],b=w.map(z=>z.index).sort().join(",");i.has(b)||(i.add(b),t.push(new Set(w)))}else o.add(y),n.push(l),r(y,f),n.pop(),o.delete(y)}};for(const c of s)r(c,c);return t}}const Ee=a=>[...a.vertices.map(e=>new me(e)),j.fromBoard(a)];class R{constructor(e){p(this,"solver",new pe);p(this,"getFormula");this.getFormula=s=>new W(s,`e${s.index}`);for(const s of Ee(e))this.addFeature(s);e.vertices.length===0&&this.solver.addFormula(Z([this.getFormula(e.edges[0]),V(this.getFormula(e.edges[0]))]))}addFeature(e){this.solver.addFormula(e.getPossibleFormula(this.getFormula))}getNextSolution(){return this.solver.getNextSolution()}getRemainingSolutions(){const e=[];for(;;){const s=this.getNextSolution();if(s)e.push(s);else break}return e}static forEachSolution(e,s,t){const i=new R(e);for(const o of s)i.addFeature(o);for(;;){const o=i.getNextSolution();if(o)t(o);else break}}static countSolutions(e,s){let t=0;return R.forEachSolution(e,s,()=>{t++}),t}static getSolutions(e,s){const t=new R(e);for(const i of s)t.addFeature(i);return t.getRemainingSolutions()}static hasSolution(e,s){const t=new R(e);for(const i of s)t.addFeature(i);return t.getNextSolution()!==null}}const we=(a,e)=>{const s=new Map,t=n=>{const r=n.slice(),c=[];for(;r.length;){const l=r.find(B=>B.isExit);d()&&h(l);const y=B=>{const L=B.vertices.flatMap($=>$.edges).filter($=>r.includes($));return d()&&h(L.length===1),L[0]};G(r,l);let w=l;for(;w===l||!w.isExit;){const B=y(w);G(r,B),w=B}const b=w,z=Math.min(l.exitVertex.index,b.exitVertex.index),q=Math.max(l.exitVertex.index,b.exitVertex.index);c.push({minVertexIndex:z,maxVertexIndex:q})}const f=I.sortBy(c,l=>l.minVertexIndex);return`${e.map(l=>n.includes(l)?"1":"0")}${f.map(l=>`,c${l.minVertexIndex}-${l.maxVertexIndex}`)}`};for(const n of a){const r=t(n);s.has(r)?s.get(r).push(n):s.set(r,[n])}const i=[],o=[];for(const n of s.values())n.length>1?o.push(n):i.push(n[0]);return{highlanderSolutions:i,excludedSolutionGroups:o}};class C{constructor(e,s){this.face=e,this.value=s}toCanonicalString(){return`face-${this.face.index}-${this.value??"blank"}`}isPossibleWith(e){return this.face.edges.filter(t=>e(t)).length===this.value}getPossibleFormula(e){return this.value===null?U:ie(this.face.edges.map(s=>e(s)),this.value)}embedded(e){return[new C(e.mapFace(this.face),this.value)]}equals(e){return e instanceof C&&e.face===this.face&&e.value===this.value}indexEquals(e){return e instanceof C&&e.face.index===this.face.index&&e.value===this.value}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face",face:this.face.index,value:this.value}}static deserialize(e,s){return new C(s.faces[e.face],e.value)}}const ye=(a,e)=>{const s=e.filter(i=>i instanceof C),t=new Set(s.map(i=>i.face));return a.edges.filter(i=>i.isExit||i.faces.some(o=>!t.has(o)))};class u{constructor(e){this.edge=e}toCanonicalString(){return`red-${this.edge.index}`}isPossibleWith(e){return!e(this.edge)}getPossibleFormula(e){return V(e(this.edge))}embedded(e){return this.edge.isExit?e.mapExitEdges(this.edge).map(s=>new u(s)):[new u(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof u&&e.edge===this.edge}indexEquals(e){return e instanceof u&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"red-edge",edge:this.edge.index}}static deserialize(e,s){return new u(s.edges[e.edge])}}class g{constructor(e){this.edge=e}toCanonicalString(){return`black-${this.edge.index}`}isPossibleWith(e){return e(this.edge)}getPossibleFormula(e){return e(this.edge)}embedded(e){return this.edge.isExit?[]:[new g(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof g&&e.edge===this.edge}indexEquals(e){return e instanceof g&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"black-edge",edge:this.edge.index}}static deserialize(e,s){return new g(s.edges[e.edge])}}class F{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==1}getPossibleFormula(e){return te(this.sector.edges.map(s=>e(s)))}embedded(e){return[new F(e.mapSector(this.sector))]}equals(e){return e instanceof F&&e.sector===this.sector}indexEquals(e){return e instanceof F&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(c=>this.equals(c)))return!0;let s=!1,t=!1,i=!1,o=!1;const n=this.sector.edges[0],r=this.sector.edges[1];for(const c of e)c instanceof g&&(c.edge===n?s=!0:c.edge===r&&(t=!0)),c instanceof u&&(c.edge===n?i=!0:c.edge===r&&(o=!0));return s&&t||i&&o}serialize(){return{type:"sector-not-one",sector:this.sector.index}}static deserialize(e,s){return new F(s.sectors[e.sector])}}class v{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-zero-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==0}getPossibleFormula(e){return Z(this.sector.edges.map(s=>e(s)))}embedded(e){return[new v(e.mapSector(this.sector))]}equals(e){return e instanceof v&&e.sector===this.sector}indexEquals(e){return e instanceof v&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof g&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-zero",sector:this.sector.index}}static deserialize(e,s){return new v(s.sectors[e.sector])}}class M{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-two-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==2}getPossibleFormula(e){return Z(this.sector.edges.map(s=>V(e(s))))}embedded(e){return[new M(e.mapSector(this.sector))]}equals(e){return e instanceof M&&e.sector===this.sector}indexEquals(e){return e instanceof M&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof u&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-two",sector:this.sector.index}}static deserialize(e,s){return new M(s.sectors[e.sector])}}class x{constructor(e){this.sector=e}toCanonicalString(){return`sector-only-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length===1}getPossibleFormula(e){return ee(this.sector.edges.map(s=>e(s)))}embedded(e){return[new x(e.mapSector(this.sector))]}equals(e){return e instanceof x&&e.sector===this.sector}indexEquals(e){return e instanceof x&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(i=>this.equals(i)))return!0;let s=!1,t=!1;for(const i of e)i instanceof g&&this.sector.edges.includes(i.edge)?s=!0:i instanceof u&&this.sector.edges.includes(i.edge)&&(t=!0);return s&&t}serialize(){return{type:"sector-only-one",sector:this.sector.index}}static deserialize(e,s){return new x(s.sectors[e.sector])}}const N=class N extends Y{};p(N,"INCOMPATIBLE",new N),p(N,"NO_MATCH_NEEDS_FACE_VALUES",new N),p(N,"NO_MATCH_NEEDS_STATE",new N),p(N,"MATCH",new N),p(N,"enumeration",new _(N));let T=N;const Q=new WeakMap;class K{constructor(e){p(this,"connectedFacePairs",[]);p(this,"connectedExitFacePairs",[]);p(this,"connectedComponents",[]);this.patternBoard=e;for(const s of e.faces){const t=new Set([s]),i=[new J(s,[])];let o=!0;for(;i.length;){const n=i.shift(),{face:r,edges:c}=n;for(const f of r.edges)if(f.faces.length===2){const l=f.faces[0]===r?f.faces[1]:f.faces[0];if(!t.has(l)){const y=[...c,f];if(t.add(l),i.push(new J(l,y)),s.index<l.index){const w=new Se(s,l,y);this.connectedFacePairs.push(w),r.isExit&&l.isExit&&this.connectedExitFacePairs.push(w)}else o=!1}}}o&&this.connectedComponents.push([...t])}}static get(e){let s=Q.get(e);return s||(s=new K(e),Q.set(e,s)),s}}class Se{constructor(e,s,t){this.a=e,this.b=s,this.shortestPath=t,d()&&h(e.index<s.index)}containsFace(e){return this.a===e||this.b===e}containsFacePair(e,s){return this.a===e&&this.b===s||this.a===s&&this.b===e}}class J{constructor(e,s){this.face=e,this.edges=s}}const k=class k extends Y{};p(k,"INCOMPATIBLE",new k),p(k,"DORMANT",new k),p(k,"MATCH",new k),p(k,"enumeration",new _(k));let E=k;const S=[];class D{constructor(e,s=new Map,t=new Set,i=new Set,o=new Set,n=new Set,r=new Set,c=new Set,f=new Set,l=new Map,y=new Set,w=new Map){p(this,"size");this.patternBoard=e,this.faceValueMap=s,this.blackEdges=t,this.redEdges=i,this.sectorsNotZero=o,this.sectorsNotOne=n,this.sectorsNotTwo=r,this.sectorsOnlyOne=c,this.faceColorDualFeatures=f,this.faceToColorDualMap=l,this.sectors=y,this.edgeToSectorsMap=w,this.size=this.computeSize()}addFaceValue(e,s){const t=this.faceValueMap.get(e);if(t!==void 0){if(t!==s)throw new m(new C(e,s),[new C(e,t)])}else this.faceValueMap.set(e,s),this.size++;d()&&this.verifySize()}addSameColorFaces(e,s){this.addFaceColorDual(O.fromPrimarySecondaryFaces([e,s],[]))}addOppositeColorFaces(e,s){this.addFaceColorDual(O.fromPrimarySecondaryFaces([e],[s]))}addFaceColorDual(e){d()&&h(e);const s=e;for(const t of[...this.faceColorDualFeatures])if(e.overlapsWith(t)){const i=e.union(t);if(i)e=i,this.faceColorDualFeatures.delete(t),this.size-=t.allFaces.size-1;else throw new m(s,[t])}this.faceColorDualFeatures.add(e),this.size+=e.allFaces.size-1;for(const t of e.allFaces)this.faceToColorDualMap.set(t,e);d()&&this.verifySize()}addBlackEdge(e){if(d()&&h(e),this.blackEdges.has(e))return;if(this.redEdges.has(e))throw new m(new g(e),[new u(e)]);this.size++,this.blackEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];d()&&h(i);let o=0;if(this.sectorsNotZero.has(t)&&(this.sectorsNotZero.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.blackEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new m(new g(e),[new u(i),new F(t)]);o++}if(this.sectorsNotTwo.has(t))if(this.redEdges.has(i))this.sectorsNotTwo.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new m(new g(e),[new g(i),new M(t)]);o++}if(this.sectorsOnlyOne.has(t))if(this.redEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new m(new g(e),[new g(i),new x(t)]);o++}o===0&&this.removeSector(t)}d()&&this.verifySize()}addRedEdge(e){if(d()&&h(e),this.redEdges.has(e))return;if(this.blackEdges.has(e))throw new m(new u(e),[new g(e)]);this.size++,this.redEdges.add(e);const s=this.edgeToSectorsMap.get(e);if(s)for(const t of s){const i=e===t.edges[0]?t.edges[1]:t.edges[0];d()&&h(i);let o=0;if(this.sectorsNotTwo.has(t)&&(this.sectorsNotTwo.delete(t),this.size--),this.sectorsNotOne.has(t))if(this.redEdges.has(i))this.sectorsNotOne.delete(t),this.size--;else{if(this.blackEdges.has(i))throw new m(new u(e),[new g(i),new F(t)]);o++}if(this.sectorsNotZero.has(t))if(this.blackEdges.has(i))this.sectorsNotZero.delete(t),this.size--;else{if(this.redEdges.has(i))throw new m(new u(e),[new u(i),new v(t)]);o++}if(this.sectorsOnlyOne.has(t))if(this.blackEdges.has(i))this.sectorsOnlyOne.delete(t),this.size--;else{if(this.redEdges.has(i))throw new m(new u(e),[new u(i),new x(t)]);o++}o===0&&this.removeSector(t)}d()&&this.verifySize()}addSectorNotZero(e){if(d()&&h(e),this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);const i=this.redEdges.has(s),o=this.redEdges.has(t);if(i&&o)throw new m(new v(e),[new u(s),new u(t)]);this.blackEdges.has(s)||this.blackEdges.has(t)||(i?this.addBlackEdge(t):o?this.addBlackEdge(s):this.sectorsNotOne.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.size--,this.sectorsNotTwo.delete(e),this.addSectorOnlyOne(e)):(this.size++,this.sectorsNotZero.add(e),this.ensureSector(e)),d()&&this.verifySize())}addSectorNotOne(e){if(d()&&h(e),this.sectorsNotOne.has(e))return;const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t),n=this.redEdges.has(s),r=this.redEdges.has(t);if(i&&r)throw new m(new F(e),[new g(s),new u(t)]);if(o&&n)throw new m(new F(e),[new g(t),new u(s)]);if(this.sectorsOnlyOne.has(e))throw new m(new F(e),[new x(e)]);i&&o||n&&r||(i?this.addBlackEdge(t):o?this.addBlackEdge(s):n?this.addRedEdge(t):r?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.addBlackEdge(s),this.addBlackEdge(t)):this.sectorsNotTwo.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotOne.add(e),this.ensureSector(e)),d()&&this.verifySize())}addSectorNotTwo(e){if(d()&&h(e),this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t);if(i&&o)throw new m(new M(e),[new g(s),new g(t)]);this.redEdges.has(s)||this.redEdges.has(t)||(i?this.addRedEdge(t):o?this.addRedEdge(s):this.sectorsNotZero.has(e)?(this.size--,this.sectorsNotZero.delete(e),this.addSectorOnlyOne(e)):this.sectorsNotOne.has(e)?(this.addRedEdge(s),this.addRedEdge(t)):(this.size++,this.sectorsNotTwo.add(e),this.ensureSector(e)),d()&&this.verifySize())}addSectorOnlyOne(e){if(d()&&h(e),this.sectorsOnlyOne.has(e))return;const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);const i=this.blackEdges.has(s),o=this.blackEdges.has(t),n=this.redEdges.has(s),r=this.redEdges.has(t);if(i&&o)throw new m(new x(e),[new g(s),new g(t)]);if(n&&r)throw new m(new x(e),[new u(s),new u(t)]);if(this.sectorsNotOne.has(e))throw new m(new x(e),[new F(e)]);i&&r||o&&n||(i?this.addRedEdge(t):o?this.addRedEdge(s):n?this.addBlackEdge(t):r?this.addBlackEdge(s):this.sectorsNotZero.has(e)&&(this.size--,this.sectorsNotZero.delete(e)),this.sectorsNotTwo.has(e)&&(this.size--,this.sectorsNotTwo.delete(e)),this.size++,this.sectorsOnlyOne.add(e),this.ensureSector(e),d()&&this.verifySize())}addFeature(e){if(e instanceof C)this.addFaceValue(e.face,e.value);else if(e instanceof O)this.addFaceColorDual(e);else if(e instanceof g)this.addBlackEdge(e.edge);else if(e instanceof u)this.addRedEdge(e.edge);else if(e instanceof v)this.addSectorNotZero(e.sector);else if(e instanceof F)this.addSectorNotOne(e.sector);else if(e instanceof M)this.addSectorNotTwo(e.sector);else if(e instanceof x)this.addSectorOnlyOne(e.sector);else throw new Error(`unimplemented type of feature for FeatureSet: ${e}`);d()&&this.verifySize()}ensureSector(e){if(!this.sectors.has(e)){this.sectors.add(e);const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);let i=this.edgeToSectorsMap.get(s);i?i.add(e):(i=new Set([e]),this.edgeToSectorsMap.set(s,i));let o=this.edgeToSectorsMap.get(t);o?o.add(e):(o=new Set([e]),this.edgeToSectorsMap.set(t,o))}}removeSector(e){if(this.sectors.has(e)){this.sectors.delete(e);const s=e.edges[0],t=e.edges[1];d()&&h(s&&t);const i=this.edgeToSectorsMap.get(s);i&&(i.delete(e),i.size===0&&this.edgeToSectorsMap.delete(s));const o=this.edgeToSectorsMap.get(t);o&&(o.delete(e),o.size===0&&this.edgeToSectorsMap.delete(t))}}computeSize(){let e=this.faceValueMap.size+this.blackEdges.size+this.redEdges.size+this.sectorsNotZero.size+this.sectorsNotOne.size+this.sectorsNotTwo.size+this.sectorsOnlyOne.size;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}verifySize(){d()&&h(this.size===this.computeSize(),"size mismatch")}getInputDifficultyScoreA(){let e=0;e+=this.faceValueMap.size*.5,e+=this.blackEdges.size*1;for(const s of this.redEdges)e+=s.isExit?2.5:1.2;e+=this.sectorsOnlyOne.size*3,e+=this.sectorsNotOne.size*4,e+=this.sectorsNotTwo.size*4.1,e+=this.sectorsNotZero.size*4.2;for(const s of this.faceColorDualFeatures)e+=s.allFaces.size-1;return e}static empty(e){return new D(e)}static emptyWithVertexOrderLimit(e,s){const t=D.empty(e);for(const i of e.vertices)i.isExit&&i.edges.length>s&&t.addRedEdge(i.exitEdge);return t}static fromFeatures(e,s){const t=new D(e);for(const i of s)t.addFeature(i);return t}static fromSolution(e,s){return D.fromFeatures(e,[...e.edges.filter(t=>!s.includes(t)||!t.isExit).map(t=>s.includes(t)?new g(t):new u(t))])}clone(){return new D(this.patternBoard,new Map(this.faceValueMap),new Set(this.blackEdges),new Set(this.redEdges),new Set(this.sectorsNotZero),new Set(this.sectorsNotOne),new Set(this.sectorsNotTwo),new Set(this.sectorsOnlyOne),new Set(this.faceColorDualFeatures),new Map(this.faceToColorDualMap),new Set(this.sectors),new Map(this.edgeToSectorsMap))}getFeaturesArray(){return[...[...this.faceValueMap.entries()].map(([e,s])=>new C(e,s)),...this.faceColorDualFeatures,...[...this.blackEdges].map(e=>new g(e)),...[...this.redEdges].map(e=>new u(e)),...[...this.sectorsNotZero].map(e=>new v(e)),...[...this.sectorsNotOne].map(e=>new F(e)),...[...this.sectorsNotTwo].map(e=>new M(e)),...[...this.sectorsOnlyOne].map(e=>new x(e))]}getHighlanderFeaturesArray(){return this.getFeaturesArray().filter(e=>e instanceof C||e instanceof u&&e.edge.isExit)}getFaceValue(e){return this.faceValueMap.get(e)}impliesFaceValue(e,s){const t=this.faceValueMap.get(e);return t!==void 0&&t===s}impliesBlackEdge(e){return this.blackEdges.has(e)}impliesRedEdge(e){return this.redEdges.has(e)}impliesSectorNotZero(e){return this.sectorsNotZero.has(e)||this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])||this.blackEdges.has(e.edges[1])}impliesSectorNotOne(e){return this.sectorsNotOne.has(e)||this.blackEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])}impliesSectorNotTwo(e){return this.sectorsNotTwo.has(e)||this.sectorsOnlyOne.has(e)||this.redEdges.has(e.edges[0])||this.redEdges.has(e.edges[1])}impliesSectorOnlyOne(e){return this.sectorsOnlyOne.has(e)||this.blackEdges.has(e.edges[0])&&this.redEdges.has(e.edges[1])||this.redEdges.has(e.edges[0])&&this.blackEdges.has(e.edges[1])}impliesFaceColorDualFeature(e){for(const s of this.faceColorDualFeatures)if(e.isSubsetOf(s))return!0;return!1}impliesFeature(e){if(e instanceof O)return this.impliesFaceColorDualFeature(e);if(e instanceof g)return this.impliesBlackEdge(e.edge);if(e instanceof u)return this.impliesRedEdge(e.edge);if(e instanceof v)return this.impliesSectorNotZero(e.sector);if(e instanceof F)return this.impliesSectorNotOne(e.sector);if(e instanceof M)return this.impliesSectorNotTwo(e.sector);if(e instanceof x)return this.impliesSectorOnlyOne(e.sector);if(e instanceof C)return this.impliesFaceValue(e.face,e.value);throw new Error(`unimplemented type of feature for FeatureSet: ${e}`)}getAffectedEdges(){return new Set([...this.blackEdges,...this.redEdges,...this.edgeToSectorsMap.keys()])}getAffectedSectors(){return new Set([...this.sectorsNotZero.values(),...this.sectorsNotOne.values(),...this.sectorsNotTwo.values(),...this.sectorsOnlyOne.values()])}getAffectedFaces(){return new Set([...this.faceValueMap.keys()])}isIsomorphicTo(e){if(this.patternBoard!==e.patternBoard||!this.hasSameShapeAs(e))return!1;const s=ae(this.patternBoard,this.patternBoard);for(const t of s)try{const i=this.embedded(this.patternBoard,t);if(i&&i.equals(e))return!0}catch(i){if(!(i instanceof m))throw i}return!1}isCanonicalWith(e){S.length=0;for(const s of e)d()&&h(s.isAutomorphism),s.isIdentityAutomorphism||S.push(s);if(S.length===0)return!0;if(this.faceValueMap.size)for(let s=0;s<this.patternBoard.faces.length&&S.length;s++){const t=this.patternBoard.faces[s],i=this.faceValueMap.get(t),o=i===void 0?-2:i===null?-1:i;for(let n=0;n<S.length;n++){const c=S[n].faceInverseMap.get(t);d()&&h(c);const f=this.faceValueMap.get(c),l=f===void 0?-2:f===null?-1:f;if(l<o)return!1;l>o&&(S.splice(n,1),n--)}}if(this.blackEdges.size||this.redEdges.size)for(let s=0;s<this.patternBoard.edges.length&&S.length;s++){const t=this.patternBoard.edges[s],i=this.blackEdges.has(t)?1:this.redEdges.has(t)?2:0;for(let o=0;o<S.length;o++){const r=S[o].edgeInverseMap.get(t);d()&&h(r);const c=this.blackEdges.has(r)?1:this.redEdges.has(r)?2:0;if(c<i)return!1;c>i&&(S.splice(o,1),o--)}}if(this.sectorsNotZero.size||this.sectorsNotOne.size||this.sectorsNotTwo.size||this.sectorsOnlyOne.size)for(let s=0;s<this.patternBoard.sectors.length&&S.length;s++){const t=this.patternBoard.sectors[s],i=(this.sectorsOnlyOne.has(t)?1:0)+(this.sectorsNotOne.has(t)?2:0)+(this.sectorsNotTwo.has(t)?4:0)+(this.sectorsNotZero.has(t)?8:0);for(let o=0;o<S.length;o++){const r=S[o].sectorInverseMap.get(t);d()&&h(r);const c=(this.sectorsOnlyOne.has(r)?1:0)+(this.sectorsNotOne.has(r)?2:0)+(this.sectorsNotTwo.has(r)?4:0)+(this.sectorsNotZero.has(r)?8:0);if(c<i)return!1;c>i&&(S.splice(o,1),o--)}}return!(this.faceColorDualFeatures.size&&!O.areCanonicalWith([...this.faceColorDualFeatures],S))}embedded(e,s){try{return D.fromFeatures(e,this.getFeaturesArray().flatMap(t=>t.embedded(s)))}catch(t){if(t instanceof m)return null;throw t}}hasSameShapeAs(e){return this.faceValueMap.size===e.faceValueMap.size&&this.blackEdges.size===e.blackEdges.size&&this.redEdges.size===e.redEdges.size&&this.sectorsNotZero.size===e.sectorsNotZero.size&&this.sectorsNotOne.size===e.sectorsNotOne.size&&this.sectorsNotTwo.size===e.sectorsNotTwo.size&&this.sectorsOnlyOne.size===e.sectorsOnlyOne.size&&this.faceColorDualFeatures.size===e.faceColorDualFeatures.size}getBoardMatchState(e,s,t=!1){let i=!0;for(const[o,n]of this.faceValueMap)if(e.faceValues[s.mapFace(o).index]!==n)return E.INCOMPATIBLE;for(const o of this.blackEdges){d()&&h(!o.isExit);const n=s.mapNonExitEdge(o).index;if(!e.blackEdgeValues[n]){if(i=!1,e.redEdgeValues[n])return E.INCOMPATIBLE;if(t)return E.DORMANT}}for(const o of this.redEdges)if(o.isExit){const n=s.mapExitEdges(o);for(const r of n){const c=r.index;if(!e.redEdgeValues[c]){if(i=!1,e.blackEdgeValues[c])return E.INCOMPATIBLE;if(t)return E.DORMANT}}}else{const n=s.mapNonExitEdge(o).index;if(!e.redEdgeValues[n]){if(i=!1,e.blackEdgeValues[n])return E.INCOMPATIBLE;if(t)return E.DORMANT}}for(const o of this.sectorsNotZero){const n=s.mapSector(o).index;if(!e.sectorNotZeroValues[n]&&(i=!1,t))return E.DORMANT}for(const o of this.sectorsNotOne){const n=s.mapSector(o).index;if(!e.sectorNotOneValues[n]&&(i=!1,t))return E.DORMANT}for(const o of this.sectorsNotTwo){const n=s.mapSector(o).index;if(!e.sectorNotTwoValues[n]&&(i=!1,t))return E.DORMANT}for(const o of this.sectorsOnlyOne){const n=s.mapSector(o).index;if(!e.sectorOnlyOneValues[n]&&(i=!1,t))return E.DORMANT}for(const o of this.faceColorDualFeatures){const n=o.primaryFaces.map(f=>e.faceColors[s.mapFace(f).index]),r=n[0];d()&&h(r);for(const f of n)if(f!==r&&(i=!1,t))return E.DORMANT;const c=o.secondaryFaces.map(f=>e.faceColors[s.mapFace(f).index]);if(c.length>1){const f=c[0];for(const l of c)if(l!==f&&(i=!1,t))return E.DORMANT}if(c.length){const f=o.secondaryFaces.map(l=>e.oppositeFaceColors[s.mapFace(l).index]);for(const l of f)if(l!==r&&(i=!1,t))return E.DORMANT;if(!i&&!t){for(const l of f)if(c.includes(l))return E.INCOMPATIBLE}}if(!i&&!t){const f=o.primaryFaces.map(l=>e.oppositeFaceColors[s.mapFace(l).index]);for(const l of n)if(c.includes(l))return E.INCOMPATIBLE;for(const l of f)if(n.includes(l))return E.INCOMPATIBLE}}return i?E.MATCH:E.DORMANT}getShapeString(){return`${this.faceValueMap.size} ${this.blackEdges.size} ${this.redEdges.size} ${this.sectorsNotZero.size} ${this.sectorsNotOne.size} ${this.sectorsNotTwo.size} ${this.sectorsOnlyOne.size} ${this.faceColorDualFeatures.size}`}isSubsetOf(e){for(const s of this.blackEdges)if(!e.impliesBlackEdge(s))return!1;for(const s of this.redEdges)if(!e.impliesRedEdge(s))return!1;for(const[s,t]of this.faceValueMap)if(!e.impliesFaceValue(s,t))return!1;for(const s of this.sectorsNotZero)if(!e.impliesSectorNotZero(s))return!1;for(const s of this.sectorsNotOne)if(!e.impliesSectorNotOne(s))return!1;for(const s of this.sectorsNotTwo)if(!e.impliesSectorNotTwo(s))return!1;for(const s of this.sectorsOnlyOne)if(!e.impliesSectorOnlyOne(s))return!1;for(const s of this.faceColorDualFeatures)if(!e.impliesFaceColorDualFeature(s))return!1;return!0}equals(e){if(!this.hasSameShapeAs(e))return!1;for(const[t,i]of this.faceValueMap)if(e.faceValueMap.get(t)!==i)return!1;for(const t of this.blackEdges)if(!e.blackEdges.has(t))return!1;for(const t of this.redEdges)if(!e.redEdges.has(t))return!1;for(const t of this.sectorsNotZero)if(!e.sectorsNotZero.has(t))return!1;for(const t of this.sectorsNotOne)if(!e.sectorsNotOne.has(t))return!1;for(const t of this.sectorsNotTwo)if(!e.sectorsNotTwo.has(t))return!1;for(const t of this.sectorsOnlyOne)if(!e.sectorsOnlyOne.has(t))return!1;const s=new Set;e.faceColorDualFeatures.forEach(t=>s.add(t.toCanonicalString()));for(const t of this.faceColorDualFeatures)if(!s.has(t.toCanonicalString()))return!1;return!0}applyFeaturesFrom(e){e.getFeaturesArray().forEach(s=>this.addFeature(s))}union(e){if(this.size<e.size)return e.union(this);const s=this.clone();try{return s.applyFeaturesFrom(e),s}catch(t){if(t instanceof m)return null;throw t}}isCompatibleWith(e){return this.union(e)!==null}getQuickCompatibilityWith(e){let s=!0;for(const i of this.blackEdges){if(e.impliesRedEdge(i))return T.INCOMPATIBLE;s&&!e.impliesBlackEdge(i)&&(s=!1)}for(const i of this.redEdges){if(e.impliesBlackEdge(i))return T.INCOMPATIBLE;s&&!e.impliesRedEdge(i)&&(s=!1)}for(const i of this.sectorsNotZero)s&&!e.impliesSectorNotZero(i)&&(s=!1);for(const i of this.sectorsNotOne){if(e.impliesSectorOnlyOne(i))return T.INCOMPATIBLE;s&&!e.impliesSectorNotOne(i)&&(s=!1)}for(const i of this.sectorsNotTwo)s&&!e.impliesSectorNotTwo(i)&&(s=!1);for(const i of this.sectorsOnlyOne){if(e.impliesSectorNotOne(i))return T.INCOMPATIBLE;s&&!e.impliesSectorOnlyOne(i)&&(s=!1)}for(const i of this.faceColorDualFeatures)s&&!e.impliesFaceColorDualFeature(i)&&(s=!1);let t=!0;for(const[i,o]of this.faceValueMap){const n=e.getFaceValue(i);if(n===void 0)t=!1;else if(n!==o)return T.INCOMPATIBLE}return t?s?T.MATCH:T.NO_MATCH_NEEDS_STATE:T.NO_MATCH_NEEDS_FACE_VALUES}toCanonicalString(){return`feat:${I.sortBy(this.getFeaturesArray().map(e=>e.toCanonicalString())).join("/")}`}getSolutions(e=!1){const s=this.getFeaturesArray();let t=R.getSolutions(this.patternBoard,s);return t.length&&e&&(t=we(t,ye(this.patternBoard,s)).highlanderSolutions),t}hasSolution(e=!1){return e?this.getSolutions(e).length>0:R.hasSolution(this.patternBoard,this.getFeaturesArray())}addSolvedEdgeFeatures(e){const s=new Array(this.patternBoard.edges.length).fill(!1),t=new Array(this.patternBoard.edges.length).fill(!1),i=new Set(this.patternBoard.edges),o=new Set(this.patternBoard.vertices.filter(n=>n.isExit));for(const n of e){const r=new Set(i);for(const c of n)s[c.index]=!0,r.delete(c);for(const c of r)t[c.index]=!0;for(const c of[...o])n.has(c.exitEdge)&&o.delete(c),c.edges.filter(f=>n.has(f)).length<2&&o.delete(c)}for(const n of this.patternBoard.edges)if(!n.isExit){const r=s[n.index],c=t[n.index];r&&!c&&this.addBlackEdge(n),!r&&c&&this.addRedEdge(n)}for(const n of o)this.addRedEdge(n.exitEdge)}addSolvedSectorFeatures(e){const s=new Array(this.patternBoard.sectors.length).fill(!1),t=new Array(this.patternBoard.sectors.length).fill(!1),i=new Array(this.patternBoard.sectors.length).fill(!1);for(const o of e)for(const n of this.patternBoard.sectors){const r=(o.has(n.edges[0])?1:0)+(o.has(n.edges[1])?1:0);r===0?s[n.index]=!0:r===1?t[n.index]=!0:r===2&&(i[n.index]=!0)}for(const o of this.patternBoard.sectors){const n=s[o.index],r=t[o.index],c=i[o.index];r&&!n&&!c?this.addSectorOnlyOne(o):n&&r&&!c?this.addSectorNotTwo(o):n&&c&&!r?this.addSectorNotOne(o):!n&&r&&c&&this.addSectorNotZero(o)}}addSolvedFaceColorDualFeatures(e){d()&&h(e.length>0);const s=K.get(this.patternBoard),t=new Set(s.connectedFacePairs.map(i=>new Oe(i)));for(const i of e)for(const o of[...t]){let n=!0;for(const r of o.pair.shortestPath)i.has(r)&&(n=!n);n?o.isOnlyOpposite=!1:o.isOnlySame=!1,!o.isOnlySame&&!o.isOnlyOpposite&&t.delete(o)}for(const i of t)i.isOnlySame?this.addSameColorFaces(i.pair.a,i.pair.b):i.isOnlyOpposite&&this.addOppositeColorFaces(i.pair.a,i.pair.b)}serialize(){const e={};return this.faceValueMap.size>0&&(e.faceValues=[...this.faceValueMap.entries()].map(([s,t])=>({face:s.index,value:t}))),this.blackEdges.size>0&&(e.blackEdges=[...this.blackEdges].map(s=>s.index)),this.redEdges.size>0&&(e.redEdges=[...this.redEdges].map(s=>s.index)),this.sectorsNotZero.size>0&&(e.sectorsNotZero=[...this.sectorsNotZero].map(s=>s.index)),this.sectorsNotOne.size>0&&(e.sectorsNotOne=[...this.sectorsNotOne].map(s=>s.index)),this.sectorsNotTwo.size>0&&(e.sectorsNotTwo=[...this.sectorsNotTwo].map(s=>s.index)),this.sectorsOnlyOne.size>0&&(e.sectorsOnlyOne=[...this.sectorsOnlyOne].map(s=>s.index)),this.faceColorDualFeatures.size>0&&(e.faceColorDualFeatures=[...this.faceColorDualFeatures].map(s=>s.serialize())),e}static deserialize(e,s){const t=new D(s);for(const i of e.faceValues||[])t.addFaceValue(s.faces[i.face],i.value);for(const i of e.blackEdges||[])t.addBlackEdge(s.edges[i]);for(const i of e.redEdges||[])t.addRedEdge(s.edges[i]);for(const i of e.sectorsNotZero||[])t.addSectorNotZero(s.sectors[i]);for(const i of e.sectorsNotOne||[])t.addSectorNotOne(s.sectors[i]);for(const i of e.sectorsNotTwo||[])t.addSectorNotTwo(s.sectors[i]);for(const i of e.sectorsOnlyOne||[])t.addSectorOnlyOne(s.sectors[i]);for(const i of e.faceColorDualFeatures||[])t.addFaceColorDual(O.deserialize(i,s));return t}}const ze={solveEdges:!0,solveFaceColors:!1,solveSectors:!1,highlander:!1};class Oe{constructor(e){p(this,"isOnlySame",!0);p(this,"isOnlyOpposite",!0);this.pair=e}}export{g as B,E as F,m as I,R as P,u as R,v as S,W as T,F as a,M as b,x as c,O as d,C as e,K as f,pe as g,D as h,ye as i,we as j,Ee as k,Z as l,ze as m,T as n};
