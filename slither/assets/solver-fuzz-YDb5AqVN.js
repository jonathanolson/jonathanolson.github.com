import"./Vector2Property-DCXaH-JP.js";import{N as E,f as x,B as H}from"./PhetioControlledVisibilityProperty-sdyDHryr.js";import{S as F,H as W}from"./getCoordinateClusteredMap-BFcIYRrL.js";import{p as k,g as D,a as L,s as d,A as h}from"./polygonGenerators-OyeK22CV.js";import{E as y,B as M,s as f}from"./BasicPuzzle-CWyNbg6B.js";import{P as V,a as z,C as G,c as v}from"./standardSolverFactory-u1dqHpQB.js";import"./TextPushButton-F5WNyFmI.js";import{U as I}from"./SATSolver-DjD4IKFy.js";import{_ as S,a as q,b as K}from"./createBoardDescriptor-DQiPBFka.js";import{P as O}from"./getPeriodicTilingGenerator-9D05ORtn.js";import"./Theme-Bnv1SKXL.js";import"./ShadedSphereNode-CfSdIz5V.js";import"./FaceColorDualFeature-D9dVWw2V.js";import"./operations-BoJEwKFC.js";import"./logic-solver-PjryYC9f.js";import"./computeEmbeddings-DgNcEsIq.js";window.assertions.enableAssert();const A=new E,R=new E({renderer:"svg",children:[A]}),c=new x(R,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(c.domElement);c.setWidthHeight(window.innerWidth,window.innerHeight);console.log("test");const T=e=>{const r=e.generate(e.defaultParameterValues);return new O(r,e.scale??1)},P=[new F(10,10),new W(4,1,!0),...k.map(T)];(async()=>{let e=null;const r=new H(!1);for(;;){console.log("board loaded");const t=P[Math.floor(Math.random()*P.length)],b=await D(t,r),p=await L(b,()=>!0,r),l=p.cleanState.clone();p.blackEdges.forEach(u=>l.setEdgeState(u,y.BLACK)),I(t,l);const m=M.fromSolvedPuzzle(p);e&&e.dispose(),e=new V(m,{scale:30,left:20,top:20}),A.addChild(e),c.updateDisplay(),await d(50);const o=m.stateProperty.value.clone(),w=z(t,o),g=()=>{m.stateProperty.value=o.clone(),c.updateDisplay()};let B=0;for(;!f(o);){if(e.clearAnnotationNodes(),B++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const u=o.clone(),N=w.clone(u),n=w.nextAction();if(n){console.log(n);const s=new G(t,o,l);e.addAnnotationNode(new h(t,n.annotation,v)),g(),await d(0);try{n.apply(s)}catch(i){console.error(i);debugger;const a=N.nextAction();a&&a.apply(s)}n.apply(o)}else if(!f(o)){const s=z(t,o),i=s.nextAction();if(i)throw e.addAnnotationNode(new h(t,i.annotation,v)),g(),await d(0),new Error("Fresh solver should not have any actions");s.dispose();const a=S.find(S.shuffle(t.edges),C=>o.getEdgeState(C)===y.WHITE);if(q()&&K(a),o.setEdgeState(a,l.getEdgeState(a)),console.log("setting white edge to red/black",a),!w.dirty)throw new Error("Solver should be dirty after setting edge state")}g(),await d(0)}if(!f(o))throw new Error("Solver did not solve the puzzle")}})();
