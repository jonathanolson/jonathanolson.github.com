import{B as J,g as q,R as B,V as n}from"./Vector2Property-DCXaH-JP.js";import{N as R,T as pe,H as ge,P as ue}from"./PhetioControlledVisibilityProperty-C1zM_Uw1.js";import{_ as T,S as K,L as $,a as z,b as G}from"./getCoordinateClusteredMap-s__X_7ZN.js";import{P as ee,c as se,U as he,s as fe}from"./standardSolverFactory-U_y7DXis.js";import{C as W,B as re,E as te,S as N}from"./BasicPuzzle-Chl7u5zQ.js";import{F as ne,b as M,c as me,S as F,g as le,s as ie,O as ae,Q as Se}from"./SATSolver-CBmz_N3P.js";import{P as we}from"./TextPushButton-BPfgO3qK.js";import{p as ye}from"./Theme-C7QtLKXh.js";import{p as Ee,a as Te,b as Fe,c as be,d as xe,e as Ce,g as h,r as ke,f as ve,s as Oe,t as Re,h as Ne,i as Me,j as qe,k as Be,l as Pe,m as Ve,n as Ae,o as He,q as Ie,u as ze,v as Ge,w as We,x as Le,y as _e,z as je,A as De,B as Ye}from"./getPeriodicTilingGenerator-qmRzQaR8.js";class cs extends R{constructor(c,e,f,d=null){let r;const m=s=>new K().moveToPoint(s.start.viewCoordinates).lineToPoint(s.end.viewCoordinates).getStrokedShape(new $({lineWidth:.2,lineCap:"round"})).getStrokedShape(new $({lineWidth:.02})),t=(s,o)=>new ue(m(s),{fill:o}),w=[];if(e.type==="ForcedLine")r=[t(e.whiteEdge,"red"),t(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")r=[t(e.whiteEdge,"red"),...e.redEdges.map(s=>t(s,"blue"))];else if(e.type==="JointToRed")r=[...e.whiteEdges.map(s=>t(s,"red")),...e.blackEdges.map(s=>t(s,"blue"))];else if(e.type==="FaceSatisfied")r=[...e.whiteEdges.map(s=>t(s,"red")),...e.blackEdges.map(s=>t(s,"blue"))];else if(e.type==="FaceAntiSatisfied")r=[...e.whiteEdges.map(s=>t(s,"red")),...e.redEdges.map(s=>t(s,"blue"))];else if(e.type==="ForcedSolveLoop")r=[...e.regionEdges.map(s=>t(s,"blue")),...e.pathEdges.map(s=>t(s,"red"))];else if(e.type==="PrematureForcedLoop")r=[...e.regionEdges.map(s=>t(s,"blue")),...e.pathEdges.map(s=>t(s,"red"))];else if(e.type==="CompletingEdgesAfterSolve")r=[...e.whiteEdges.map(s=>t(s,"red"))];else if(e.type==="FaceColoringBlackEdge")r=[t(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")r=[t(e.edge,"red")];else if(e.type==="FaceColorToBlack")r=[t(e.edge,"red")];else if(e.type==="FaceColorToRed")r=[t(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")r=[...e.face.edges.map(s=>t(s,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")r=[...e.balancedPairs.flatMap((s,o)=>{const l=["green","blue","black"][o%3],g=["magenta","orange","yellow"][o%3];return[...s[0].map(y=>t(y,l)),...s[1].map(y=>t(y,g))]})],e.type==="FaceColorMatchToRed"?r.push(...e.matchingEdges.map(s=>t(s,"red"))):e.type==="FaceColorMatchToBlack"?r.push(...e.matchingEdges.map(s=>t(s,"red"))):e.type==="FaceColorBalance"&&(r.push(...e.matchingEdges.map(s=>t(s,"orange"))),r.push(...e.oppositeEdges.map(s=>t(s,"red"))));else if(e.type==="DoubleMinusOneFaces")r=[...e.toBlackEdges.map(s=>t(s,"red")),...e.toRedEdges.map(s=>t(s,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")r=[e.sector.edge,e.sector.next.edge].map(s=>t(s,"red"));else if(e.type==="ForcedSector"){const s=[...e.toRedEdges,...e.toBlackEdges];r=[e.sector.edge,e.sector.next.edge].map(o=>t(o,s.includes(o)?"red":"blue"))}else if(e.type==="StaticFaceSectors")r=T.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>t(s,"red"));else if(e.type==="VertexState")r=e.vertex.edges.map(s=>t(s,"blue"));else if(e.type==="VertexStateToEdge")r=[...e.toBlackEdges.map(s=>t(s,"red")),...e.toRedEdges.map(s=>t(s,"red"))];else if(e.type==="VertexStateToSector")r=T.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>t(s,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")r=T.uniq([...e.facesA,...e.facesB].flatMap(s=>s.edges)).map(s=>t(s,"red"));else if(e.type==="FaceState")r=e.face.edges.map(s=>t(s,"red"));else if(e.type==="FaceStateToEdge")r=[...e.toBlackEdges.map(s=>t(s,"red")),...e.toRedEdges.map(s=>t(s,"red"))];else if(e.type==="FaceStateToSector")r=T.uniq(e.sectors.flatMap(s=>[s.edge,s.next.edge])).map(s=>t(s,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const s=new Set([...e.facesA,...e.facesB].flatMap(l=>l.edges)),o=e.face.edges.filter(l=>!s.has(l));r=[...[...s].map(l=>t(l,"red")),...o.map(l=>t(l,"blue"))]}else if(e.type==="FaceStateToVertexState")r=e.face.edges.filter(o=>e.vertices.includes(o.start)||e.vertices.includes(o.end)).map(o=>t(o,"red"));else if(e.type==="Pattern"){const s=new Set(e.affectedEdges);if(e.affectedSectors.forEach(l=>{s.add(l.edge),s.add(l.next.edge)}),e.affectedFaces.forEach(l=>{l.edges.forEach(g=>s.add(g))}),r=[new R({children:[...s].map(l=>t(l,"red"))})],d){const l=J.NOTHING.copy();[e.input,e.output].forEach(i=>{i.faceValues.forEach(u=>{u.face&&u.face.vertices.forEach(a=>{l.addPoint(a.viewCoordinates)})}),[i.blackEdges,i.redEdges].forEach(u=>{u.forEach(a=>{l.addPoint(a.start.viewCoordinates),l.addPoint(a.end.viewCoordinates)})}),[i.sectorsNotZero,i.sectorsNotOne,i.sectorsNotTwo,i.sectorsOnlyOne].forEach(u=>{u.forEach(a=>{l.addPoint(a.start.viewCoordinates),l.addPoint(a.end.viewCoordinates),l.addPoint(a.next.end.viewCoordinates)})}),i.faceColorDuals.forEach(u=>{[u.primaryFaces,u.secondaryFaces].forEach(a=>{a.forEach(v=>{v&&v.vertices.forEach(A=>{l.addPoint(A.viewCoordinates)})})})})});const g=W.empty(c),y=W.empty(c),x=new Set(c.faces),_=(i,u)=>{u.faceValues.forEach(a=>{a.face&&(i.setFaceValue(a.face,a.value),x.delete(a.face))}),u.blackEdges.forEach(a=>{i.setEdgeState(a,te.BLACK)}),u.redEdges.forEach(a=>{i.setEdgeState(a,te.RED)}),u.sectorsNotZero.forEach(a=>{i.setSectorState(a,N.NOT_ZERO)}),u.sectorsNotOne.forEach(a=>{i.setSectorState(a,N.NOT_ONE)}),u.sectorsNotTwo.forEach(a=>{i.setSectorState(a,N.NOT_TWO)}),u.sectorsOnlyOne.forEach(a=>{i.setSectorState(a,N.ONLY_ONE)}),u.faceColorDuals.forEach(a=>{const v=(S,O)=>{const H=S?i.getFaceColor(S):i.getOutsideColor(),I=O?i.getFaceColor(O):i.getOutsideColor();new ne(M(i,H),M(i,I)).apply(i)},A=(S,O)=>{const H=S?i.getFaceColor(S):i.getOutsideColor(),I=O?i.getFaceColor(O):i.getOutsideColor();new me(M(i,H),M(i,I)).apply(i)};for(let S=1;S<a.primaryFaces.length;S++)v(a.primaryFaces[S-1],a.primaryFaces[S]);for(let S=1;S<a.secondaryFaces.length;S++)v(a.secondaryFaces[S-1],a.secondaryFaces[S]);a.secondaryFaces.length&&A(a.primaryFaces[0],a.secondaryFaces[0])}),fe(c,i)};_(g,e.input),_(y,e.output);const j=.2,C=l.dilated(j),D=new Set(c.faces.filter(i=>{const u=J.NOTHING.copy();return i.vertices.forEach(a=>{u.addPoint(a.viewCoordinates)}),u.intersectsBounds(C)})),Y=i=>D.has(i),Z=new ee(new re(c,g),{noninteractive:!0,faceFilter:Y}),Q=new ee(new re(c,y),{noninteractive:!0,faceFilter:Y});w.push(()=>{Z.dispose(),Q.dispose()});const P=.5,V=.8,U=K.roundRectangle(C.x,C.y,C.width,C.height,P,P),X=new R({children:[...D].filter(i=>x.has(i)).map(i=>new pe("?",{font:ye,maxWidth:.9,maxHeight:.9,fill:se.theme.faceValueCompletedColorProperty,center:i.viewCoordinates}))}),oe=new R({children:[Z,X],clipArea:U,scale:V}),de=new R({children:[Q,X],clipArea:U,scale:V}),E=new we(new ge({spacing:.2,children:[oe,de]}),{cornerRadius:P*(V+.2),xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:se.theme.patternAnnotationBackgroundColorProperty}),k=j+.05;E.centerBottom=l.centerTop.plusXY(0,-.15),E.top<d.top+k&&(E.centerTop=l.centerBottom.plusXY(0,.15)),E.left<d.left+k&&(E.left=d.left+k),E.right>d.right-k&&(E.right=d.right-k),r.push(E)}}else r=[],console.log(`unknown type: ${e.type}`);super({children:r,pickable:!1}),this.board=c,this.annotation=e,this.style=f,this.disposeEmitter.addListener(()=>w.forEach(s=>s()))}static getHintNode(c){return new he(c.type)}}let b=null,L=0;const os=()=>{if(b&&(L++,L>5)){const p=b;b=null,p(null)}},Ze=async function(p){return new Promise((c,e)=>{b=c,L=0,F.debugSleep&&console.log("sleep start"),setTimeout(()=>{F.debugSleep&&console.log("sleep end"),b===c&&(b=null,c(null)),F.debugSleep&&console.log("resolved")},p)})};class Qe extends Error{constructor(){super("Interrupted")}}const ce=async function(p,c){if(await Ze(p),F.debugSleep&&console.log("after sleep before interrupt check"),c.value)throw new Qe},ds=async(p,c,e)=>{let f=0;for(;f++<100;){const d=W.fromFaces(p,()=>null),r=q.shuffle(p.faces);let m=-1,t=[];const w=s=>{try{return t=ie(p,s,{maxIterations:1e4,failOnMultipleSolutions:!0}),t.length}catch(o){if(o instanceof ae)return 2;if(o instanceof Se)return 0;throw o}};for(const s of r){F.debugSleep&&console.log("going to sleep"),c&&await ce(0,c),F.debugSleep&&console.log("finished sleep, generating next!");let o=q.shuffle(T.range(0,s.edges.length));o[0]===0&&(o=q.shuffle(o));for(const l of o){const g=d.createDelta();if(g.setFaceValue(s,l),m=w(g),m>=1){g.apply(d),e&&e.emit(p.faces.indexOf(s),l);break}}if(m===1)break}if(m===1)return le(p,d,t[0])}throw new Error("Failed to generate a puzzle, board might not be solvable")},ps=async(p,c=()=>!0,e,f)=>{const d=p.board,r=p.cleanState.clone(),m=q.shuffle(d.faces),t=w=>{try{return ie(d,w,{maxIterations:1e4,failOnMultipleSolutions:!0}),!1}catch(s){if(s instanceof ae)return!0;throw s}};z()&&G(!t(r),"Initial state has multiple solutions"),z()&&G(c(d,r.clone()),"Initial state is not easy enough");for(const w of m){e&&await ce(0,e);const s=r.getFaceValue(w);if(s===null){f&&f.emit(d.faces.indexOf(w),null);continue}const o=r.createDelta();o.setFaceValue(w,null),!t(o)&&c(d,o.clone())?(o.apply(r),f&&f.emit(d.faces.indexOf(w),null)):f&&f.emit(d.faces.indexOf(w),s)}return le(p.board,r,p.blackEdges)},Ue={name:"Square",parameters:{width:{label:"Width",type:"integer",range:new B(2,50)},height:{label:"Height",type:"integer",range:new B(2,50)}},defaultParameterValues:{width:6,height:10},generate:p=>{const c=p.width,e=p.height;return T.range(0,e).flatMap(f=>T.range(0,c).map(d=>[new n(d,f),new n(d+1,f),new n(d+1,f+1),new n(d,f+1)]))}},Xe={name:"Hexagonal",parameters:{radius:{label:"Radius",type:"integer",range:new B(1,30)},isPointyTop:{label:"Pointy Top",type:"boolean"},holeRadius:{label:"Hole Radius",type:"integer",range:new B(0,25),advanced:!0}},defaultParameterValues:{radius:4,isPointyTop:!0,holeRadius:0},generate:p=>{const c=p.radius,e=p.isPointyTop,f=p.holeRadius;let d,r;e?(d=new n(Math.sqrt(3),0),r=new n(Math.sqrt(3)/2,3/2)):(d=new n(3/2,Math.sqrt(3)/2),r=new n(0,Math.sqrt(3)));const m=[new n(1,0),new n(1,-1),new n(0,-1),new n(-1,0),new n(-1,1),new n(0,1)],t=T.range(0,6).map(l=>m[l].plus(m[(l+1)%6])),w=l=>t.map(g=>g.plus(l.timesScalar(3))),s=(l,g)=>(Math.abs(l.x-g.x)+Math.abs(l.x+l.y-g.x-g.y)+Math.abs(l.y-g.y))/2,o=[];for(let l=-c;l<=c;l++)for(let g=Math.max(-c,-l-c);g<=Math.min(c,-l+c);g++){const y=new n(l,g);s(y,new n(0,0))>=f&&o.push(w(y).map(x=>d.timesScalar(x.x).plus(r.timesScalar(x.y)).timesScalar(1/3)))}return o}},Je={name:"Penrose",parameters:{radius:{label:"Radius",type:"choice",choices:[{value:"6",label:"6"},{value:"10",label:"10"},{value:"11",label:"11"},{value:"13",label:"13"},{value:"14",label:"14"},{value:"20",label:"20"}]}},defaultParameterValues:{radius:"6"},generate:p=>{const c={6:Ee,10:Te,11:Fe,13:be,14:xe,20:Ce}[p.radius];z()&&G(c);const e=.01,f=c.thinShape.subpaths.filter(r=>r.segments.length).map(r=>r.points.slice(0,-1).map(m=>m.timesScalar(e)));return[...c.thickShape.subpaths.filter(r=>r.segments.length).map(r=>r.points.slice(0,-1).map(m=>m.timesScalar(e))),...f]}},gs=[Ue,h(ke,{width:8,height:8}),Xe,h(ve,{width:8,height:8,squareRegion:!0}),h(Oe,{width:5,height:6,squareRegion:!0}),h(Re,{width:6,height:5}),h(Ne,{width:9,height:9}),h(Me,{width:9,height:9}),h(qe,{width:7,height:8}),h(Be),h(Pe),h(Ve),h(Ae,{squareRegion:!0}),h(He),h(Ie),h(ze,{width:9,height:9}),h(Ge),h(We,{width:9,height:9}),h(Le),h(_e),h(je,{width:6,height:8,squareRegion:!0}),h(De),h(Ye),Je];export{cs as A,ps as a,ds as g,ce as i,gs as p,Ze as s,os as w};
