import{N as v,U as N,aa as b,af as B,p as x,E as f,s as C,r as D,ag as h,ah as F,ai as H,_ as z,a as M,b as W}from"./getCoordinateCluteredMap-Bn-bMSm1.js";import{J as L,K as V,M as k,P as G,N as d,A as y,O as I}from"./GenerateNode-CnpADHOY.js";window.assertions.enableAssert();const S=new v,K=new v({renderer:"svg",children:[S]}),i=new N(K,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(i.domElement);i.setWidthHeight(window.innerWidth,window.innerHeight);console.log("test");const O=e=>{const n=e.generate(e.defaultParameterValues);return new I(n,e.scale??1)},m=[new b(10,10),new B(4,1,!0),...L.map(O)];(async()=>{let e=null;const n=new x(!1);for(;;){console.log("board loaded");const t=m[Math.floor(Math.random()*m.length)],P=await V(t,n),r=await k(P,()=>!0,n),s=r.cleanState.clone();r.blackEdges.forEach(o=>s.setEdgeState(o,f.BLACK)),C(t,s);const c=D.fromSolvedPuzzle(r);e&&e.dispose(),e=new G(c,{scale:30,left:20,top:20}),S.addChild(e),i.updateDisplay(),await d(50);const a=c.stateProperty.value.clone(),u=h(t,a),w=()=>{c.stateProperty.value=a.clone(),i.updateDisplay()};let E=0;for(;u.dirty;){if(e.clearAnnotationNodes(),E++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const o=u.nextAction();if(o){console.log(o);const l=new F(t,a,s);e.addAnnotationNode(new y(o.annotation)),w(),await d(0),o.apply(l),o.apply(a)}else if(!H(a)){const l=h(t,a),g=l.nextAction();if(g)throw e.addAnnotationNode(new y(g.annotation)),w(),await d(0),new Error("Fresh solver should not have any actions");l.dispose();const p=z.find(z.shuffle(t.edges),A=>a.getEdgeState(A)===f.WHITE);M()&&W(p),a.setEdgeState(p,s.getEdgeState(p))}w(),await d(0)}}})();
