var P=Object.defineProperty;var f=(i,e,r)=>e in i?P(i,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):i[e]=r;var o=(i,e,r)=>(f(i,typeof e!="symbol"?e+"":e,r),r);import{B as g}from"./BinaryRuleCollection-Co2eOjDC.js";import{d as u,s as B}from"./PatternRule-CrjXMziT.js";import{g as C}from"./generalPatternBoardGenerations-Z1YspuhJ.js";import{n as p,v as b,I as y,J as O,K as T,L as F,M as L,N as $,O as w,P as G,t as N,x as S,p as M,q as R}from"./patternBoards-Hmq_9LOt.js";import{a as v,b as m}from"./getCoordinateClusteredMap-DCjAm76-.js";import{g as j}from"./getSolutionImpliedRules-FTQqQQkV.js";class d{constructor(e){o(this,"boardType");o(this,"solveEdges");o(this,"solveSectors");o(this,"solveFaceColors");o(this,"highlander");o(this,"vertexOrderLimit");o(this,"collection");o(this,"processedBoards");o(this,"currentBoards");this.boardType=e.boardType,this.solveEdges=e.solveEdges,this.solveSectors=e.solveSectors,this.solveFaceColors=e.solveFaceColors,this.highlander=e.highlander,this.vertexOrderLimit=e.vertexOrderLimit,this.collection=g.deserialize(e.collection),this.processedBoards=e.processedBoards.map(u),this.currentBoards=e.currentBoards.map(u)}getName(){return d.getName(this)}getGenerations(){const e={general:[...p.map(r=>[r]),...C],square:[[b],[y],[O],[T],[F],[L],[$],[w],[G],...N],hexagonal:[...p.map(r=>[r]),...S]}[this.boardType];return v()&&m(e,`Unknown board type: ${this.boardType}`),e}getCurrentGeneration(){return this.getGenerations().find(r=>r.some(t=>!this.processedBoards.includes(t)))??null}getNextBoard(){const e=this.getCurrentGeneration();if(e){const r=e.filter(t=>!this.processedBoards.includes(t)&&!this.currentBoards.includes(t));return r.length?r[0]:null}else return null}getStatusString(){const e=this.getName(),r=this.getCurrentGeneration();if(r){let t=`${e}
`;const h=r.filter(s=>this.processedBoards.includes(s)),a=r.filter(s=>this.currentBoards.includes(s));v()&&m(a.length===this.currentBoards.length);const x=r.filter(s=>!this.processedBoards.includes(s)&&!this.currentBoards.includes(s)),E=s=>{let n=`${Math.floor(100*s/r.length)}`;n.length===1&&(n=" "+n);let l=`${s}`;for(;l.length<`${r.length}`.length;)l=" "+l;return`${n}% ${l}/${r.length}`},c=(s,n)=>`  ${E(s.length)} ${n} ${s.map(l=>l.name).join(", ")}
`;return t+=c(h,"processed | "),t+=c(a,"current   | "),t+=c(x,"remaining | "),t}else return`${e} (complete)`}getCollectionForBoard(e){const r=M.get(e);v()&&m(r,"planarPatternMap should be defined");const t=this.collection.withPatternBoardFilter(a=>R(a,e).length>0),h=j(e,{solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,includeFaceValueZero:e.faces.filter(a=>!a.isExit).length===1,prefilterRules:t.getRules()});return g.fromRules(h)}addProcessingBoard(e){this.currentBoards.push(e)}removeProcessingBoard(e){this.currentBoards=this.currentBoards.filter(r=>r!==e)}addProcessedBoardCollection(e,r){this.collection=this.collection.withRules(r.getRules()),this.processedBoards.push(e),this.removeProcessingBoard(e)}serialize(){return{boardType:this.boardType,solveEdges:this.solveEdges,solveSectors:this.solveSectors,solveFaceColors:this.solveFaceColors,highlander:this.highlander,vertexOrderLimit:this.vertexOrderLimit,collection:this.collection.serialize(),processedBoards:this.processedBoards.map(B),currentBoards:this.currentBoards.map(B)}}static deserialize(e){return new d(e)}static empty(e){return new d({boardType:e.boardType,solveEdges:e.solveEdges,solveSectors:e.solveSectors,solveFaceColors:e.solveFaceColors,highlander:e.highlander,vertexOrderLimit:e.vertexOrderLimit,collection:g.empty().serialize(),processedBoards:[],currentBoards:[]})}static getName(e){let r=`${e.boardType}-`;if(e.vertexOrderLimit!==null)if(e.boardType==="square"&&e.vertexOrderLimit===4||e.boardType==="hexagonal"&&e.vertexOrderLimit===3)r+="only-";else throw new Error("Specify naming convention for vertexOrderLimit");if(e.solveEdges&&e.solveSectors&&e.solveFaceColors)r+="all";else{let t=!1;e.solveEdges&&(r+="edge",t=!0),e.solveSectors&&(t&&(r+="-"),r+="sector",t=!0),e.solveFaceColors&&(t&&(r+="-"),r+="color",t=!0)}return e.highlander||(r+="-unrestricted"),r}}export{d as B};
