var I=Object.defineProperty;var w=(c,t,e)=>t in c?I(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var m=(c,t,e)=>(w(c,typeof t!="symbol"?t+"":t,e),e);import{b as a,c as y,F as M}from"./FeatureSet-CUuwAkcj.js";import{_ as D,a as p,b as l}from"./createBoardDescriptor-DQiPBFka.js";import{g as R}from"./getEmbeddings-BW9bZEIh.js";import{E as k,d as L}from"./Vector2Property-DCXaH-JP.js";import{m as H,M as V,z as q,N as z,B as P}from"./patternBoards-BWMN3hEW.js";import{P as O}from"./PatternBoardSolver-FUiAf3Qg.js";import{d as v,R as U,B as $,S as Q,a as Z,b as W,c as j,F as T}from"./FaceColorDualFeature-D9dVWw2V.js";const G=c=>c.name?c.name:H(c.descriptor),C=c=>{let t=V(c);if(t)return t;const e=q(c);return t=z(e),t||new P(e)},S=class S extends k{};m(S,"INCOMPATIBLE",new S),m(S,"INCONSEQUENTIAL",new S),m(S,"DORMANT",new S),m(S,"ACTIONABLE",new S),m(S,"enumeration",new L(S));let F=S;class J{constructor(t){m(this,"featureArray",[]);m(this,"featureMatchers",[]);m(this,"featureSetMatchers",[]);this.patternBoard=t;for(const e of t.faces){const r=e.isExit?[null]:[...D.range(0,e.edges.length),null];for(const s of r)this.featureArray.push(new v(e,s)),this.featureMatchers.push((i,n)=>i.faceValues[n.mapFace(e).index]===s?a.MATCH:a.INCOMPATIBLE),this.featureSetMatchers.push((i,n)=>i.impliesFaceValue(n.mapFace(e),s)?a.MATCH:a.INCOMPATIBLE)}for(const e of t.edges)this.featureArray.push(new U(e)),this.featureMatchers.push((r,s)=>{if(e.isExit){const i=s.mapExitEdges(e);let n=!0;for(const u of i){const o=u.index;if(r.redEdgeValues[o])continue;if(n=!1,r.blackEdgeValues[o])return a.INCOMPATIBLE}return n?a.MATCH:a.DORMANT}else{const i=s.mapNonExitEdge(e).index;return r.redEdgeValues[i]?a.MATCH:r.blackEdgeValues[i]?a.INCOMPATIBLE:a.DORMANT}}),this.featureSetMatchers.push((r,s)=>{if(e.isExit){const i=s.mapExitEdges(e);let n=!0;for(const u of i){if(r.impliesRedEdge(u))continue;if(n=!1,r.impliesBlackEdge(u))return a.INCOMPATIBLE}return n?a.MATCH:a.DORMANT}else{const i=s.mapNonExitEdge(e);return r.impliesRedEdge(i)?a.MATCH:r.impliesBlackEdge(i)?a.INCOMPATIBLE:a.DORMANT}}),e.isExit||(this.featureArray.push(new $(e)),this.featureMatchers.push((r,s)=>{const i=s.mapNonExitEdge(e).index;return r.blackEdgeValues[i]?a.MATCH:r.redEdgeValues[i]?a.INCOMPATIBLE:a.DORMANT}),this.featureSetMatchers.push((r,s)=>{const i=s.mapNonExitEdge(e);return r.impliesBlackEdge(i)?a.MATCH:r.impliesRedEdge(i)?a.INCOMPATIBLE:a.DORMANT}));for(const e of t.sectors)this.featureArray.push(new Q(e)),this.featureMatchers.push((r,s)=>r.sectorNotZeroValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotZero(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new Z(e)),this.featureMatchers.push((r,s)=>r.sectorNotOneValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotOne(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new W(e)),this.featureMatchers.push((r,s)=>r.sectorNotTwoValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotTwo(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new j(e)),this.featureMatchers.push((r,s)=>r.sectorOnlyOneValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorOnlyOne(s.mapSector(e))?a.MATCH:a.DORMANT);p()&&l(this.featureArray.length===this.featureMatchers.length),p()&&l(this.featureArray.length===this.featureSetMatchers.length),p()&&l(this.featureArray.length<=254,"Our limit for encoding in a byte")}}const b=new WeakMap,x=c=>{let t=b.get(c);return t||(t=new J(c),b.set(c,t)),t};class g{constructor(t,e,r,s=!1){this.patternBoard=t,this.inputFeatureSet=e,this.outputFeatureSet=r,this.highlander=s}getInputDifficultyScoreA(){return this.inputFeatureSet.getInputDifficultyScoreA()+.75*this.patternBoard.vertices.length}getInputDifficultyScoreB(){return this.inputFeatureSet.getInputDifficultyScoreB()}embedded(t,e){const r=this.inputFeatureSet.embedded(t,e);if(r===null)return null;const s=this.outputFeatureSet.embedded(t,e);return s===null?null:new g(t,r,s,this.highlander)}getEmbeddedRules(t){return t.map(e=>this.embedded(e.targetPatternBoard,e)).filter(e=>e!==null)}isIsomorphicTo(t){if(this.patternBoard!==t.patternBoard||!this.inputFeatureSet.hasSameShapeAs(t.inputFeatureSet)||!this.outputFeatureSet.hasSameShapeAs(t.outputFeatureSet))return!1;const e=R(this.patternBoard,this.patternBoard);for(const r of e){const s=this.embedded(this.patternBoard,r);if(s&&s.inputFeatureSet.equals(t.inputFeatureSet)&&s.outputFeatureSet.equals(t.outputFeatureSet))return!0}return!1}isSubsetOf(t){return this.inputFeatureSet.isSubsetOf(t.inputFeatureSet)&&this.outputFeatureSet.isSubsetOf(t.outputFeatureSet)}matches(t){return this.inputFeatureSet.isSubsetOf(t)}getMatchState(t){const e=this.inputFeatureSet.getQuickCompatibilityWith(t);return e===y.INCOMPATIBLE||e===y.NO_MATCH_NEEDS_FACE_VALUES?F.INCOMPATIBLE:this.outputFeatureSet.isSubsetOf(t)?F.INCONSEQUENTIAL:e===y.NO_MATCH_NEEDS_STATE?F.DORMANT:F.ACTIONABLE}isRedundant(t){if(this.isTrivial())return!0;const e=this.outputFeatureSet,r=t.filter(s=>s.outputFeatureSet.isSubsetOf(e));return this.outputFeatureSet.isSubsetOf(g.withRulesApplied(this.patternBoard,this.inputFeatureSet,r))}hasApplication(t){return this.matches(t)&&!this.outputFeatureSet.isSubsetOf(t)}apply(t){p()&&l(this.hasApplication(t)),t.applyFeaturesFrom(this.outputFeatureSet)}isTrivial(){return this.outputFeatureSet.isSubsetOf(this.inputFeatureSet)}isCorrectSlow(){const t=O.countSolutions(this.patternBoard,this.inputFeatureSet.getFeaturesArray()),e=O.countSolutions(this.patternBoard,this.outputFeatureSet.getFeaturesArray());return t===e}toCanonicalString(){return`rule:${this.inputFeatureSet.toCanonicalString()}->${this.outputFeatureSet.toCanonicalString()}`}equals(t){return this.patternBoard===t.patternBoard&&this.inputFeatureSet.equals(t.inputFeatureSet)&&this.outputFeatureSet.equals(t.outputFeatureSet)&&this.highlander===t.highlander}getBinaryIdentifier(){const t=this.patternBoard.name;if(!t)throw new Error("Pattern board must have a name");const e=this.getBinary([this.patternBoard]).slice(1),r=btoa(String.fromCharCode.apply(null,[this.highlander?1:0,...e])),s=`${t}/${r}`;if(p()){const i=g.fromBinaryIdentifier(s);l(i.equals(this),"round-trip equality")}return s}static fromBinaryIdentifier(t){const e=t.indexOf("/"),r=t.slice(0,e),s=t.slice(e+1),i=atob(s).split("").map(u=>u.charCodeAt(0)),n=C(r);return g.fromBinary([n],[0,...i.slice(1)],0,i[0]!==0)}getBinary(t){const e=[],r=t.indexOf(this.patternBoard);p()&&l(r!==-1&&r<256,"pattern board index"),e.push(r);const s=x(this.patternBoard),i=this.inputFeatureSet.getFeaturesArray(),n=this.outputFeatureSet.getFeaturesArray().filter(o=>!i.some(h=>h.equals(o))),u=o=>{const h=o.filter(d=>!(d instanceof T)),A=o.filter(d=>d instanceof T);for(const d of h){const f=s.featureArray.findIndex(E=>E.equals(d));p()&&l(f!==-1,"feature index"),e.push(f)}for(const d of A){e.push(254);for(const f of d.primaryFaces)p()&&l(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),e.push(f.index);for(const f of d.secondaryFaces)p()&&l(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),e.push(f.index|128)}};if(u(i),e.push(255),u(n),e.push(255),p()){const o=new Uint8Array(e),h=g.fromBinary(t,o,0,this.highlander);l(h.equals(this),"round-trip equality")}return e}static fromBinary(t,e,r,s){const i=e[r++],n=t[i];p()&&l(n,"pattern board");const u=x(n),o=()=>{const d=M.empty(n);for(;;){const f=e[r++];if(f===255)return d;if(f===254){const E=[],N=[];for(;;){const B=e[r++];if(B===255||B===254){r--;break}B&128?N.push(n.faces[B&127]):E.push(n.faces[B])}d.addFeature(T.fromPrimarySecondaryFaces(E,N))}else d.addFeature(u.featureArray[f])}},h=o(),A=o().union(h);return p()&&l(A),new g(n,h,A,s)}serialize(){const t={patternBoard:G(this.patternBoard),input:this.inputFeatureSet.serialize(),output:this.outputFeatureSet.serialize()};return this.highlander&&(t.highlander=!0),t}collectionSerialize(t){return{...this.serialize(),patternBoard:t}}static deserialize(t){const e=C(t.patternBoard);return new g(e,M.deserialize(t.input,e),M.deserialize(t.output,e),t.highlander??!1)}static collectionDeserialize(t,e){const r=t[e.patternBoard];return p()&&l(r,"pattern board"),new g(r,M.deserialize(e.input,r),M.deserialize(e.output,r),e.highlander??!1)}static withRulesApplied(t,e,r){p()&&l(r.every(o=>o.patternBoard===t),"embedding check");let s=r,i=[];const n=e.clone();let u=!0;for(;u;){u=!1;for(const o of s){const h=o.getMatchState(n);h===F.ACTIONABLE?(o.apply(n),u=!0):h===F.DORMANT&&i.push(o)}s=i,i=[]}return n}}export{g as P,F as a,C as d,x as g,G as s};
