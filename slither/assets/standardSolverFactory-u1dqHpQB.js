var ft=Object.defineProperty;var gt=(l,e,t)=>e in l?ft(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var v=(l,e,t)=>(gt(l,typeof e!="symbol"?e+"":e,t),t);import{f as d,P as re,E as je,d as Xe,o as de,c as Ue,D as mt,V as H,g as ge,C as wt,B as ye,T as G}from"./Vector2Property-DCXaH-JP.js";import{e as B,B as $,D as A,F as Pe,N as L,P as M,M as he,l as Ct,L as _e,C as Ne,m as Je,T as qe,G as St,R as yt,H as Ze}from"./PhetioControlledVisibilityProperty-sdyDHryr.js";import{E as D,F as ee,S as E,V as Pt,B as ke,C as vt}from"./BasicPuzzle-CWyNbg6B.js";import{a as Vt,b as Et,L as bt,R as Ft,P as ze}from"./TextPushButton-F5WNyFmI.js";import{c as xe,S as T,L as be,_ as Fe,G as Tt,a as k,b as x,j as $e,i as Lt}from"./createBoardDescriptor-DQiPBFka.js";import{h as Nt,i as kt,j as Oe,M as xt,k as Re,l as Ot,m as Rt,v as Ae,n as At,q as Ie,w as It,x as J,y as Mt,z as Bt,A as Dt,B as Ht,L as q,J as Wt,H as Yt,D as jt,F as Xt,c as j,N as Ut,O as me,u as _t,s as Jt,r as qt}from"./Theme-Bnv1SKXL.js";import{e as Ge,f as Ke,h as Qe,W as et,X as tt,Y as ot,C as se,Z as Zt,Q as zt,R as $t,_ as rt,$ as st,j as it,a0 as nt,a1 as at,i as Gt,a2 as Kt,F as Qt,c as ue,d as eo,I as X,a3 as to,a4 as oo,a5 as ro,a6 as so,a7 as io,a8 as no,a9 as ao,aa as lo,ab as co,ac as ho}from"./SATSolver-DjD4IKFy.js";import{A as po}from"./ShadedSphereNode-CfSdIz5V.js";import{d as uo,B as fo,R as go,S as mo,a as wo,b as Co,c as So,F as yo}from"./FaceColorDualFeature-D9dVWw2V.js";import{c as Po}from"./computeEmbeddings-DgNcEsIq.js";import{B as vo}from"./getCoordinateClusteredMap-BFcIYRrL.js";const lt=(l,e,t,o)=>(r,s,p)=>{const n=[new Ge(r,s),new Ke(r,s)];return(l||e||t||o)&&(n.push(new Qe(r,s)),(e||t||o)&&(n.push(new et(r,s)),(t||o)&&(n.push(new tt(r,s)),o&&n.push(new ot(r,s))))),new se(n)},Vo={edgesVisibleProperty:Nt,edgesHaveColorsProperty:kt,faceColorsVisibleProperty:Oe,faceColorThresholdProperty:xt,sectorsVisibleProperty:Re,sectorsNextToEdgesVisibleProperty:Ot,sectorsTrivialVisibleProperty:Rt,vertexStateVisibleProperty:Ae,allVertexStateVisibleProperty:At,faceStateVisibleProperty:Ie,whiteLineVisibleProperty:It,redLineVisibleProperty:J,verticesVisibleProperty:Mt,smallVertexProperty:Bt,redXsVisibleProperty:Dt,redXsAlignedProperty:Ht,faceValueStyleProperty:q,redLineStyleProperty:Wt,vertexStyleProperty:Yt,joinedLinesJoinProperty:jt,joinedLinesCapProperty:Xt,safeSolverFactoryProperty:new B([Oe,Re,Ae,Ie],(l,e,t,o)=>lt(l,e,t,o)),autoSolverFactoryProperty:Zt,theme:j},K=(l,e,t,o,r)=>{const s=lt(l,e,t,o);return{faceColorsVisibleProperty:new $(l),sectorsVisibleProperty:new $(e),vertexStateVisibleProperty:new $(t),faceStateVisibleProperty:new $(o),safeSolverFactoryProperty:new re(s),autoSolverFactoryProperty:r?new B([r],p=>(n,h,c)=>new se([s(n,h,c),p(n,h,c)])):new re(s)}},ie=new B([zt,$t],(l,e)=>(t,o,r)=>new se([new rt(t,o,{solveJointToRed:!0,solveForcedLineToBlack:l,solveAlmostEmptyToRed:!0},r?void 0:[]),new st(t,o,{solveToRed:!0,solveToBlack:l},r?void 0:[]),...e?[new it(t,o,{solveToRed:!0,solveToBlack:l,resolveAllRegions:!1},r?void 0:[])]:[]])),ct=new B([ie],l=>(e,t,o)=>new se([l(e,t,o),new nt(e,t,o?void 0:[])])),dt={...K(!0,!1,!1,!1,ie),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Eo={...K(!0,!1,!1,!1,ie),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},bo={...K(!0,!1,!1,!1,new re((l,e,t)=>new se([new at(l,e,{solveToRed:!0,solveToBlack:!0},t?void 0:[])]))),theme:j,edgesVisibleProperty:new d(!1),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Fo={...K(!1,!1,!1,!1,ie),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!1),redLineVisibleProperty:J,verticesVisibleProperty:new d(!0),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!0),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("square"),joinedLinesJoinProperty:new d("miter"),joinedLinesCapProperty:new d("square")},To={...K(!0,!0,!1,!1,ct),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!0),faceColorThresholdProperty:new d(Number.POSITIVE_INFINITY),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},Lo={...K(!0,!0,!1,!1,ct),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},No={...K(!0,!1,!0,!1,ie),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},ko={...K(!0,!1,!1,!0,ie),theme:j,edgesVisibleProperty:new d(!0),edgesHaveColorsProperty:new d(!1),faceColorThresholdProperty:new d(2),sectorsNextToEdgesVisibleProperty:new d(!1),sectorsTrivialVisibleProperty:new d(!1),allVertexStateVisibleProperty:new d(!1),whiteLineVisibleProperty:new d(!0),redLineVisibleProperty:J,verticesVisibleProperty:new d(!1),smallVertexProperty:new d(!1),redXsVisibleProperty:new d(!1),redXsAlignedProperty:new d(!1),faceValueStyleProperty:q,redLineStyleProperty:new d("middle"),vertexStyleProperty:new d("round"),joinedLinesJoinProperty:new d("round"),joinedLinesCapProperty:new d("round")},ve={basicLines:dt,basicFaceColoring:Eo,pureFaceColor:bo,classic:Fo,basicSectors:To,sectorsWithColors:Lo,vertexState:No,faceState:ko,custom:Vo},Me=dt,xo=l=>({edgesVisibleProperty:new A(l,{derive:"edgesVisibleProperty"}),edgesHaveColorsProperty:new A(l,{derive:"edgesHaveColorsProperty"}),faceColorsVisibleProperty:new A(l,{derive:"faceColorsVisibleProperty"}),faceColorThresholdProperty:new A(l,{derive:"faceColorThresholdProperty"}),sectorsVisibleProperty:new A(l,{derive:"sectorsVisibleProperty"}),sectorsNextToEdgesVisibleProperty:new A(l,{derive:"sectorsNextToEdgesVisibleProperty"}),sectorsTrivialVisibleProperty:new A(l,{derive:"sectorsTrivialVisibleProperty"}),vertexStateVisibleProperty:new A(l,{derive:"vertexStateVisibleProperty"}),allVertexStateVisibleProperty:new A(l,{derive:"allVertexStateVisibleProperty"}),faceStateVisibleProperty:new A(l,{derive:"faceStateVisibleProperty"}),whiteLineVisibleProperty:new A(l,{derive:"whiteLineVisibleProperty"}),redLineVisibleProperty:new A(l,{derive:"redLineVisibleProperty"}),verticesVisibleProperty:new A(l,{derive:"verticesVisibleProperty"}),smallVertexProperty:new A(l,{derive:"smallVertexProperty"}),redXsVisibleProperty:new A(l,{derive:"redXsVisibleProperty"}),redXsAlignedProperty:new A(l,{derive:"redXsAlignedProperty"}),faceValueStyleProperty:new A(l,{derive:"faceValueStyleProperty"}),redLineStyleProperty:new A(l,{derive:"redLineStyleProperty"}),vertexStyleProperty:new A(l,{derive:"vertexStyleProperty"}),joinedLinesJoinProperty:new A(l,{derive:"joinedLinesJoinProperty"}),joinedLinesCapProperty:new A(l,{derive:"joinedLinesCapProperty"}),safeSolverFactoryProperty:new A(l,{derive:"safeSolverFactoryProperty"}),autoSolverFactoryProperty:new A(l,{derive:"autoSolverFactoryProperty"}),theme:Ut(new B([l],e=>e.theme))}),Oo=new Vt("puzzleStyle",{serialize:l=>Object.keys(ve).find(e=>ve[e]===l),deserialize:l=>l?ve[l]??Me:Me}),_=xo(Oo),Pr=new Et("showPuzzleStyleProperty",!1),I=class I extends je{constructor(e){super(),this.isEnabledProperty=e}};v(I,"EDGE_STATE",new I(new $(!0))),v(I,"EDGE_STATE_REVERSED",new I(new $(!0))),v(I,"FACE_COLOR_MATCH",new I(_.faceColorsVisibleProperty)),v(I,"FACE_COLOR_OPPOSITE",new I(_.faceColorsVisibleProperty)),v(I,"SECTOR_STATE",new I(_.sectorsVisibleProperty)),v(I,"VERTEX_STATE",new I(_.vertexStateVisibleProperty)),v(I,"FACE_STATE",new I(_.faceStateVisibleProperty)),v(I,"FACE_VALUE",new I(new $(!1))),v(I,"DELETE_FACE",new I(new $(!1))),v(I,"enumeration",new Xe(I));let W=I;const Q=new bt("editModeProperty",W.EDGE_STATE);let Ve=null;const Be=l=>{l||(Q.value=W.EDGE_STATE)};Q.link(l=>{Ve&&Ve.isEnabledProperty.unlink(Be),Ve=l,l.isEnabledProperty.link(Be)});const vr=l=>{l.isEnabledProperty.value&&(Q.value=l)},Ro=new B([Q],l=>l===W.EDGE_STATE||l===W.EDGE_STATE_REVERSED),ht=new B([Q],l=>l===W.FACE_COLOR_MATCH||l===W.FACE_COLOR_OPPOSITE),Ao=new B([Q],l=>l===W.SECTOR_STATE),Io=new B([Q],l=>l===W.VERTEX_STATE),Mo=new B([Q,ht],(l,e)=>e||l===W.FACE_STATE||l===W.FACE_VALUE||l===W.DELETE_FACE),we=(l,e,t,o)=>{const r=new Pe({mouseButton:0,fire:n=>{var h;return t&&t(l,(h=n.domEvent)!=null&&h.shiftKey?2:0)}}),s=new Pe({mouseButton:2,fire:n=>{var h;return t&&t(l,(h=n.domEvent)!=null&&h.shiftKey?0:2)}}),p=new Pe({mouseButton:1,fire:n=>t&&t(l,1)});e.addInputListener(r),e.addInputListener(s),e.addInputListener(p),e.cursor="pointer",r.isHighlightedProperty.lazyLink(n=>{o&&o(l,n)}),e.disposeEmitter.addListener(()=>{r.dispose(),s.dispose(),p.dispose()})};class Ce extends L{constructor(e,t,o,r){const s=de()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},r);super({pickableProperty:ht}),this.outerBoundary=e,this.innerBoundaries=t,this.style=o,!s.noninteractive&&we(null,this,s.facePressListener,s.faceHoverListener);const p=e.map(m=>m.start.viewCoordinates),n=s.useBackgroundOffsetStroke,h=s.backgroundOffsetDistance,i=xe(p)>0?-h:h,a=m=>{const u=new Tt;u.addShape(0,m),u.computeSimplifiedFaces(),u.computeFaceInclusion(P=>P[0]>0);const w=u.createFilledSubGraph(),y=w.facesToShape();return u.dispose(),w.dispose(),y},g=Ce.getOffsetBackgroundShape(e,n,h),f=t.map(m=>{const u=m.map(y=>y.start.viewCoordinates),w=T.polygon(u);if(n)return a(w.getOffsetShape(i));{const P=w.getStrokedShape(new be({lineWidth:2*h})).subpaths.map(S=>new T([S]));return a(Fe.minBy(P,S=>S.getArea()))}});this.children=[new M(g,{fill:o.theme.puzzleBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...f.map(m=>new M(m,{fill:o.theme.playAreaBackgroundColorProperty,stroke:o.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(e,t,o){const r=e.map(h=>h.start.viewCoordinates),s=T.polygon(r),n=xe(r)>0?-o:o;if(t)return s.getOffsetShape(n).getSimplifiedAreaShape();{const h=s.getStrokedShape(new be({lineWidth:2*o})),c=h.subpaths.map(i=>new T([i]));try{return h.bounds.width===9.718028227819117?T.bounds(h.bounds):Fe.maxBy(c,i=>i.getArea()).getSimplifiedAreaShape()}catch{return T.bounds(h.bounds)}}}}const ne=.03,ae=.05,Bo=T.circle(ne).makeImmutable(),Do=T.circle(ae).makeImmutable(),Ho=T.rect(-ne,-ne,2*ne,2*ne).makeImmutable(),Wo=T.rect(-ae,-ae,2*ae,2*ae).makeImmutable();class Yo extends L{constructor(e,t,o,r){super(),this.vertex=e;const s=new B([t,r.verticesVisibleProperty],(c,i)=>i&&e.edges.every(a=>c.getEdgeState(a)!==D.BLACK));this.disposeEmitter.addListener(()=>s.dispose());const p=new M(null,{translation:e.viewCoordinates,fill:r.theme.vertexColorProperty,visibleProperty:s});this.addChild(p);const n=he.multilink([r.vertexStyleProperty,r.smallVertexProperty],(c,i)=>{c==="round"?p.shape=i?Bo:Do:c==="square"?p.shape=i?Ho:Wo:k()&&x(!1,`unhandled vertex style: ${c}`)});this.disposeEmitter.addListener(()=>n.dispose());const h=c=>{this.visible=!c};o.link(h),this.disposeEmitter.addListener(()=>o.unlink(h))}}class jo extends L{constructor(e,t,o,r){const s=de()({textOptions:{font:me,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{},noninteractive:!1},r);super({}),this.face=e;const p=T.polygon(e.vertices.map(c=>c.viewCoordinates));this.mouseArea=p,this.touchArea=p,!s.noninteractive&&we(e,this,s.facePressListener,s.faceHoverListener);const n=new Ct("",Ue({subScale:.7},s==null?void 0:s.textOptions)),h=he.multilink([t,o.faceValueStyleProperty,o.theme.faceValueColorProperty,o.theme.faceValueCompletedColorProperty,o.theme.faceValueErrorColorProperty,o.theme.faceValueRatioColorProperty,o.faceStateVisibleProperty],(c,i,a,g,f,m,u)=>{const w=c.getFaceValue(e);this.visible=!u;let y,P,S=!1,C=!1;if(w===null)y="",P=null;else{let b=0,F=0;for(const O of e.edges){const N=c.getEdgeState(O);N===D.BLACK?b++:N===D.WHITE&&F++}if(i==="static"||w===0)y=`${w}`;else if(i==="remaining")y=`${w-b}`,S=b>0;else if(i==="ratio")w-b===0?y="0":(y=`${w-b}<sub style="color: ${m.toCSS()};">/<sub>${F}</sub></sub>`,C=!0),S=b>0;else throw new Error(`unhandled faceValueStyle: ${i}`);b<w?P=a:b===w?P=g:P=f}n.string=y,n.fill=P,n.maxWidth=C?.8:.9,n.maxHeight=C?.8:.9,n.center=e.viewCoordinates,this.children=[n]});this.disposeEmitter.addListener(()=>h.dispose())}}const z=.07,Xo=new T().moveTo(-z,-z).lineTo(z,z).moveTo(-z,z).lineTo(z,-z).makeImmutable();class Uo extends L{constructor(e,t,o,r,s){super({}),this.edge=e;const p=new B([t],S=>S.getEdgeState(e));this.disposeEmitter.addListener(()=>p.dispose());const n=e.start.viewCoordinates,h=e.end.viewCoordinates,c=n.average(h),i=new B([o,r.redXsVisibleProperty],(S,C)=>!S&&C);this.disposeEmitter.addListener(()=>i.dispose());const a=new M(Xo,{stroke:r.theme.xColorProperty,lineWidth:.025,center:c,visibleProperty:i}),g=S=>{a.rotation=S?h.minus(n).getAngle():0};r.redXsAlignedProperty.link(g),this.disposeEmitter.addListener(()=>r.redXsAlignedProperty.unlink(g));const f=new B([o,r.whiteLineVisibleProperty],(S,C)=>!S&&C);this.disposeEmitter.addListener(()=>f.dispose());const m=new _e(n.x,n.y,h.x,h.y,{lineWidth:.02,stroke:r.theme.whiteLineColorProperty,visibleProperty:f}),u=new B([o,r.redLineVisibleProperty],(S,C)=>C);this.disposeEmitter.addListener(()=>u.dispose());const w=new M(null,{lineWidth:.02,stroke:r.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:u}),y=S=>{S==="middle"?w.shape=new T().moveToPoint(c.blend(n,.35)).lineToPoint(c.blend(h,.35)).makeImmutable():S==="gap"?w.shape=new T().moveToPoint(n).lineToPoint(n.blend(c,.35)).moveToPoint(h.blend(c,.35)).lineToPoint(h).makeImmutable():S==="full"?w.shape=new T().moveToPoint(n).lineToPoint(h).makeImmutable():k()&&x(!1,`Unknown red line style: ${S}`)};r.redLineStyleProperty.link(y),this.disposeEmitter.addListener(()=>r.redLineStyleProperty.unlink(y));const P=s==null?void 0:s.edgePressListener;if(P){const S=new T;if(e.faces.length===2)S.polygon([n,e.faces[0].viewCoordinates,h,e.faces[1].viewCoordinates]);else{k()&&x(e.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const C=e.forwardHalf.face===null?e.forwardHalf:e.reversedHalf;k()&&x(C.previous.face===null),k()&&x(C.next.face===null);const b=C.start.viewCoordinates,F=C.end.viewCoordinates,O=C.previous.start.viewCoordinates,N=C.next.end.viewCoordinates,V=(Te,pe,pt)=>{const Le=pe.minus(Te).normalized(),ut=pt.minus(pe).normalized();let Z=Le.minus(ut);return Z.getMagnitude()<1e-6?Z=Le.getPerpendicular():Z=Z.normalized(),mt.triangleAreaSigned(Te,pe,pe.plus(Z))<0&&(Z=Z.negated()),Z},R=V(O,b,F),Se=V(b,F,N);S.polygon([b,e.faces[0].viewCoordinates,F,F.plus(Se.times(s.backgroundOffsetDistance)),b.plus(R.times(s.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=S,!s.noninteractive&&we(e,this,P,s.edgeHoverListener)}p.link(S=>{S===D.WHITE?this.children=[m]:S===D.BLACK?this.children=[]:this.children=[w,a]})}}class _o extends L{constructor(t,o,r,s){super({pickable:!1,visibleProperty:s.edgesVisibleProperty});v(this,"simpleRegionNodeMap",new Map);v(this,"regionIdMap",new Map);v(this,"weirdEdgeNodeMap",new Map);v(this,"regionContainer",new L);v(this,"weirdEdgeContainer",new L);v(this,"adjacentFacesMap",new Map);this.board=t,this.faceFilter=r,this.style=s,t.faces.forEach(h=>{this.adjacentFacesMap.set(h,h.edges.map(c=>c.getOtherFace(h)).filter(c=>c!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],o.value.getSimpleRegions().forEach(h=>this.addRegion(h)),o.value.getWeirdEdges().forEach(h=>this.addWeirdEdge(h)),this.updateHues();const p=(h,c)=>{const i=c.getSimpleRegions(),a=h.getSimpleRegions(),g=c.getWeirdEdges(),f=h.getWeirdEdges(),m=[],u=[];$e(i,a,m,u,[]);const y=new Set(m);for(const P of u)if(this.regionIdMap.has(P.id)){const S=this.regionIdMap.get(P.id);this.replaceRegion(S,P),y.delete(S)}else this.addRegion(P);for(const P of y)this.removeRegion(P);for(const P of g)f.includes(P)||this.removeWeirdEdge(P);for(const P of f)g.includes(P)||this.addWeirdEdge(P);(u.length||m.length)&&this.updateHues()};o.lazyLink(p),this.disposeEmitter.addListener(()=>o.unlink(p)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const n=()=>this.updateHues();s.theme.simpleRegionHueLUTProperty.link(n),s.edgesHaveColorsProperty.lazyLink(n),this.disposeEmitter.addListener(()=>{s.theme.simpleRegionHueLUTProperty.unlink(n),s.edgesHaveColorsProperty.unlink(n)})}addRegion(t){const o=new oe(t,this.style);this.simpleRegionNodeMap.set(t,o),this.regionIdMap.set(t.id,t),this.regionContainer.addChild(o)}replaceRegion(t,o){k()&&x(t.id===o.id);const r=this.simpleRegionNodeMap.get(t);r.updateRegion(o),this.simpleRegionNodeMap.delete(t),this.simpleRegionNodeMap.set(o,r),this.regionIdMap.delete(t.id),this.regionIdMap.set(o.id,o)}removeRegion(t){const o=this.simpleRegionNodeMap.get(t);this.regionContainer.removeChild(o),this.simpleRegionNodeMap.delete(t),this.regionIdMap.delete(t.id),o.dispose()}addWeirdEdge(t){const o=t.start.viewCoordinates,r=t.end.viewCoordinates,s=new _e(o.x,o.y,r.x,r.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(t,s),this.weirdEdgeContainer.addChild(s)}removeWeirdEdge(t){const o=this.weirdEdgeNodeMap.get(t);this.weirdEdgeContainer.removeChild(o),this.weirdEdgeNodeMap.delete(t)}updateHues(){const t=[...this.simpleRegionNodeMap.values()];if(t.length<2)return;const o=new H(0,0),r=()=>{for(const i of t)i.hueVector.getMagnitude()>1e-6?i.hueVector.normalize():i.hueVector.setXY(1,0)},s=new Map,p=[];this.board.faces.forEach(i=>{s.set(i,[])});for(const i of t){const a=new Set;for(const f of i.simpleRegion.edges)for(const m of f.faces)a.add(m);const g=new Set;for(const f of a){g.add(f);for(const m of this.adjacentFacesMap.get(f))g.add(m)}for(const f of g){const m=s.get(f);if(m.length)for(const u of m){let w=!1;for(const y of p)if(y.a===u&&y.b===i){y.weight++,w=!0;break}w||p.push({a:u,b:i,weight:1})}m.push(i)}}const n=new Map;for(const i of t)n.set(i,H.ZERO.copy());const h=(i,a,g)=>{const f=n.get(i),m=n.get(a),u=i.hueVector.dot(a.hueVector),w=o.set(a.hueVector).subtract(i.hueVector);if(w.magnitude>1e-9){w.normalize();const y=.3,P=g*((Math.max(y,u)-y)/(1-y))**3;w.multiplyScalar(P),f.subtract(w),m.add(w)}};let c=1;for(let i=0;i<100;i++){c*=.99;for(const a of t)n.get(a).setXY(0,0);for(const a of p){const g=a.a,f=a.b,m=a.weight;h(g,f,m)}if(t.length<8)for(let a=0;a<t.length;a++){const g=t[a];for(let f=a+1;f<t.length;f++)h(g,t[f],.2)}for(const a of t){const g=n.get(a);g.multiplyScalar(c/a.edgeCount),a.hueVector.add(g),n.get(a).setXY(0,0)}r()}for(const i of t)i.updateHue()}}class oe extends M{constructor(t,o){const r=H.createPolar(1,ge.nextDoubleBetween(0,2*Math.PI));super(oe.toShape(t),{stroke:oe.hueVectorToPaint(r,o),lineWidth:.1,lineCap:"square",lineJoin:"round"});v(this,"hueVector");v(this,"edgeCount");this.simpleRegion=t,this.style=o,this.hueVector=r,this.edgeCount=t.edges.length;const s=n=>{this.lineJoin=n};o.joinedLinesJoinProperty.link(s),this.disposeEmitter.addListener(()=>o.joinedLinesJoinProperty.unlink(s));const p=n=>{this.lineCap=n};o.joinedLinesCapProperty.link(p),this.disposeEmitter.addListener(()=>o.joinedLinesCapProperty.unlink(p))}updateHue(){this.stroke=oe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:H.X_UNIT,this.style)}updateRegion(t){this.simpleRegion=t,this.shape=oe.toShape(t),this.edgeCount=t.edges.length}static hueVectorToPaint(t,o){const r=o.theme.simpleRegionHueLUTProperty.value,s=(Math.round(t.getAngle()*180/Math.PI)+360)%360;return k()&&x(s>=0&&s<r.length),o.edgesHaveColorsProperty.value?r[s]:o.theme.blackLineColorProperty}static toShape(t){const o=new T;let r=!0;for(const s of t.halfEdges)r&&(r=!1,o.moveToPoint(s.start.viewCoordinates)),o.lineToPoint(s.end.viewCoordinates);return t.isSolved&&o.close(),o.makeImmutable()}}class Jo extends L{constructor(t,o,r,s){const p=new L;super({pickable:!1,children:[p]});v(this,"faceColorNodeMap",new Map);v(this,"faceColorIdMap",new Map);v(this,"adjacentFacesMap",new Map);v(this,"faceColorNodeContainer");v(this,"dualColorViews",new Set);this.board=t,this.stateProperty=o,this.faceFilter=r,this.style=s,this.faceColorNodeContainer=p,t.faces.forEach(i=>{r(i)&&this.adjacentFacesMap.set(i,i.edges.map(a=>a.getOtherFace(i)).filter(a=>a!==null))});{const i=o.value.getFaceColors();for(const a of i)this.addFaceColor(a,o.value.getFacesWithColor(a).filter(r));this.addDualColorViews(o.value,i)}this.updateHues();let n=o.value.clone();const h=i=>{const a=n;n=i.clone();const g=a.getFaceColors(),f=i.getFaceColors(),m=[],u=[],w=[];$e(g,f,m,u,w);const y=new Set(m),P=this.removeInvalidDualColorViews(i),S=[...P];for(const C of u)if(P.add(C),this.faceColorIdMap.has(C.id)){const b=this.faceColorIdMap.get(C.id);this.replaceFaceColor(b,C,i.getFacesWithColor(C).filter(r)),y.delete(b)}else this.addFaceColor(C,i.getFacesWithColor(C).filter(r));for(const C of w)this.updateFaceColor(C,i.getFacesWithColor(C).filter(r));for(const C of y)P.delete(C),this.removeFaceColor(C);this.addDualColorViews(i,[...P]),(u.length||m.length||S.length)&&this.updateHues()};o.lazyLink(h),this.disposeEmitter.addListener(()=>o.unlink(h)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const c=()=>this.updateHues();s.theme.faceColorBasicHueLUTProperty.lazyLink(c),s.theme.faceColorLightHueLUTProperty.lazyLink(c),s.theme.faceColorDarkHueLUTProperty.lazyLink(c),s.theme.faceColorInsideColorProperty.lazyLink(c),s.theme.faceColorOutsideColorProperty.lazyLink(c),s.theme.faceColorDefaultColorProperty.lazyLink(c),s.faceColorThresholdProperty.lazyLink(c),this.updateHues(),this.disposeEmitter.addListener(()=>{s.theme.faceColorBasicHueLUTProperty.unlink(c),s.theme.faceColorLightHueLUTProperty.unlink(c),s.theme.faceColorDarkHueLUTProperty.unlink(c),s.theme.faceColorInsideColorProperty.unlink(c),s.theme.faceColorOutsideColorProperty.unlink(c),s.theme.faceColorDefaultColorProperty.unlink(c),s.faceColorThresholdProperty.unlink(c)})}addFaceColor(t,o){const r=new le(t,o,this.style);this.faceColorNodeMap.set(t,r),this.faceColorIdMap.set(t.id,t),this.faceColorNodeContainer.addChild(r)}replaceFaceColor(t,o,r){k()&&x(t.id===o.id);const s=this.faceColorNodeMap.get(t);s.updateFaceColor(o,r),this.faceColorNodeMap.delete(t),this.faceColorNodeMap.set(o,s),this.faceColorIdMap.delete(t.id),this.faceColorIdMap.set(o.id,o)}updateFaceColor(t,o){const r=this.faceColorNodeMap.get(t);let s=r.faces.length!==o.length;if(!s)for(let p=0;p<o.length;p++){const n=r.faces[p],h=o[p];if(n!==h){s=!0;break}}s&&r.updateFaceColor(t,o)}removeFaceColor(t){const o=this.faceColorNodeMap.get(t);this.faceColorNodeContainer.removeChild(o),this.faceColorNodeMap.delete(t),this.faceColorIdMap.delete(t.id),o.dispose()}addDualColorViews(t,o){const r=new Set(o);for(;r.size;){const s=r.values().next().value;r.delete(s);const p=this.faceColorNodeMap.get(s);k()&&x(p);const n=t.getOppositeFaceColor(s);if(n){k()&&x(r.has(n)),r.delete(n);const h=this.faceColorNodeMap.get(n);k()&&x(h),this.dualColorViews.add(new De([p,h],this.style))}else this.dualColorViews.add(new De([p],this.style))}}removeInvalidDualColorViews(t){const o=new Set,r=new Set(t.getFaceColors());for(const s of[...this.dualColorViews])if(!s.isStillValidInState(this.stateProperty.value,r)){for(const p of s.colorNodes)o.add(p.faceColor);this.dualColorViews.delete(s),s.dispose()}return o}updateHues(){const t=[...this.dualColorViews].filter(o=>o.colorNodes[0].faceColor.colorState!==ee.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:o.faceCount>=this.style.faceColorThresholdProperty.value);if(t.length>=2){const o=new H(0,0),r=()=>{for(const i of t)i.hueVector.getMagnitude()>1e-6?i.hueVector.normalize():i.hueVector.setXY(ge.nextDouble()-.5,ge.nextDouble()-.5).normalize()},s=new Map,p=[];this.board.faces.forEach(i=>{this.faceFilter(i)&&s.set(i,[])});for(const i of t){const a=new Set;for(const f of i.faces)a.add(f);const g=new Set;for(const f of a){g.add(f);for(const m of this.adjacentFacesMap.get(f))g.add(m)}for(const f of g){const m=s.get(f);if(m){if(m.length)for(const u of m){let w=!1;for(const y of p)if(y.a===u&&y.b===i){y.weight++,w=!0;break}w||p.push({a:u,b:i,weight:1})}m.push(i)}}}const n=new Map;for(const i of t)n.set(i,H.ZERO.copy());const h=(i,a,g)=>{const f=n.get(i),m=n.get(a),u=i.hueVector.dot(a.hueVector),w=o.set(a.hueVector).subtract(i.hueVector).normalize(),y=.2,P=Math.abs(u),S=g*((Math.max(y,P)-y)/(1-y))**3;w.multiplyScalar(S),f.subtract(w),m.add(w)};let c=1;for(let i=0;i<100;i++){c*=.99;for(const a of t)n.get(a).setXY(0,0);for(const a of p){const g=a.a,f=a.b,m=a.weight;h(g,f,m)}if(t.length<8)for(let a=0;a<t.length;a++){const g=t[a];for(let f=a+1;f<t.length;f++)h(g,t[f],.2)}for(const a of t){const g=n.get(a);g.multiplyScalar(c/a.faceCount),a.hueVector.add(g),n.get(a).setXY(0,0)}r()}}for(const o of this.dualColorViews)o.updateHue()}}const U=class U extends je{};v(U,"BASIC",new U),v(U,"PRIMARY",new U),v(U,"SECONDARY",new U),v(U,"enumeration",new Xe(U));let Y=U;class De{constructor(e,t){v(this,"hueVector");v(this,"faceCount");if(this.colorNodes=e,this.style=t,k()&&x(e.length===1||e.length===2),this.faceCount=Fe.sum(this.colorNodes.map(o=>o.faceCount)),e.forEach(o=>{o.dualColorView=this}),e.length===1)e[0].type=Y.BASIC,this.hueVector=e[0].hueVector.copy();else{const o=e[0].faceCount>e[1].faceCount?e[0]:e[1],r=o===e[0]?e[1]:e[0];let s;o.type===Y.PRIMARY?s=o:r.type===Y.PRIMARY||o.type===Y.SECONDARY?s=r:(r.type,Y.SECONDARY,s=o);const p=s===o?r:o;this.hueVector=o.hueVector.copy(),s.type=Y.PRIMARY,p.type=Y.SECONDARY}}get faces(){return this.colorNodes.flatMap(e=>e.faces)}isStillValidInState(e,t){for(const o of this.colorNodes)if(!t.has(o.faceColor))return!1;return this.colorNodes.length===1?e.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:e.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const e of this.colorNodes)e.hueVector.set(this.hueVector),e.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const e of this.colorNodes)e.dualColorView=null}}class le extends M{constructor(t,o,r){const s=H.createPolar(1,ge.nextDoubleBetween(0,2*Math.PI));super(le.toShape(o));v(this,"hueVector");v(this,"faceCount");v(this,"dualColorView",null);v(this,"type",Y.BASIC);this.faceColor=t,this.faces=o,this.style=r,this.hueVector=s,this.faceCount=o.length}updateHue(t){t||this.faceColor.colorState!==ee.UNDECIDED?this.fill=le.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:H.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(t,o){const r=o.length-this.faceCount;this.faceColor=t,this.faces=o,this.shape=le.toShape(o),this.faceCount=o.length,this.dualColorView&&(this.dualColorView.faceCount+=r)}static hueVectorToPaint(t,o,r,s){const p=r===Y.BASIC?s.theme.faceColorBasicHueLUTProperty.value:r===Y.PRIMARY?s.theme.faceColorLightHueLUTProperty.value:s.theme.faceColorDarkHueLUTProperty.value,n=(Math.round(t.getAngle()*180/Math.PI)+360)%360;k()&&x(n>=0&&n<p.length);const h=p[n];if(o===ee.UNDECIDED)return h;{const i=(o===ee.INSIDE?s.theme.faceColorInsideColorProperty:s.theme.faceColorOutsideColorProperty).value,a=i.alpha,g=new Ne(h);return new Ne((1-a)*g.red+a*i.red,(1-a)*g.green+a*i.green,(1-a)*g.blue+a*i.blue).toCSS()}}static toShape(t){const o=new T;for(const r of t)o.polygon(r.vertices.map(s=>s.viewCoordinates));return o.makeImmutable()}}const He=[.02,.02],qo=new Map([[E.NONE,[]],[E.ONLY_ZERO,[]],[E.ONLY_ONE,[]],[E.ONLY_TWO,[]],[E.NOT_ZERO,He],[E.NOT_ONE,[]],[E.NOT_TWO,He],[E.ANY,[]]]),Ee=.2,We=.02,ce=class ce extends L{constructor(e,t,o,r){super(),this.sector=e;const s=ce.getSectorBaseShape(e,r.backgroundOffsetDistance);this.mouseArea=s,this.touchArea=s,!r.noninteractive&&we(e,this,r.sectorPressListener,r.sectorHoverListener);const p=c=>{const i=e.start.viewCoordinates,a=e.end.viewCoordinates,g=e.next.end.viewCoordinates,f=i.minus(a),m=g.minus(a),u=f.normalized(),w=m.normalized(),y=w.minus(u).angle+Math.PI/2,P=f.angle;let S=m.angle;S<P&&(S+=2*Math.PI);const C=H.createPolar(.2,y),b=(O,N)=>(O.moveToPoint(u.timesScalar(N)),O.arcPoint(H.ZERO,N,P,S,!0),O),F=(O,N,V)=>(O.moveTo(N.x+V,N.y),O.circle(N,V),O);if(c===E.NONE)return new T().moveTo(C.x-.05,C.y-.05).lineTo(C.x+.05,C.y+.05).moveTo(C.x-.05,C.y+.05).lineTo(C.x+.05,C.y-.05).makeImmutable();if(c===E.ONLY_ZERO)return F(new T,C,.05).makeImmutable();if(c===E.ONLY_TWO)return new T().moveToPoint(u.timesScalar(.1).plus(C.timesScalar(.7))).lineToPoint(C.timesScalar(.7)).lineToPoint(w.timesScalar(.1).plus(C.timesScalar(.7))).makeImmutable();if(c===E.ONLY_ONE||c===E.NOT_TWO)return b(new T,Ee).makeImmutable();if(c===E.NOT_ZERO||c===E.NOT_ONE)return b(b(new T,Ee+We),Ee-We).makeImmutable();if(c===E.ANY)return F(F(F(new T,C,.05),C,.03),C,.01).makeImmutable();throw new Error("Unhandled sector state")},n=new M(null,{translation:e.end.viewCoordinates,lineWidth:.01,lineCap:"butt",visibleProperty:o.sectorsVisibleProperty});this.disposeEmitter.addListener(()=>n.dispose()),this.addChild(n);const h=he.multilink([t,o.sectorsNextToEdgesVisibleProperty,o.sectorsTrivialVisibleProperty],(c,i,a)=>{const g=c.getEdgeState(e.edge),f=c.getEdgeState(e.next.edge),m=c.getSectorState(e);let u=null,w=null,y=[],P=.01;if(i||g===D.WHITE&&f===D.WHITE){let S=E.trivialStates.includes(m);if(m===E.NOT_ONE){const C=e.end.edges.filter(F=>c.getEdgeState(F)===D.BLACK),b=e.end.edges.filter(F=>c.getEdgeState(F)===D.WHITE);C.length===0&&b.length===2&&(S=!0)}(a||!S)&&(u=p(m)??null,w=ce.getStrokeFromStyle(m,o)??null,y=qo.get(m)??[],y.length&&(P=.015))}n.shape=u,n.stroke=w,n.lineDash=y,n.lineWidth=P});this.disposeEmitter.addListener(()=>h.dispose())}static getSectorBaseShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,p=o.minus(r),n=s.minus(r),h=p.normalized(),i=n.normalized().minus(h).angle+Math.PI/2,a=e.face?e.face.viewCoordinates:H.createPolar(t,i).plus(r),g=o.average(r),f=s.average(r);return T.polygon([g,r,f,a]).makeImmutable()}static getSectorArcShape(e,t){const o=e.start.viewCoordinates,r=e.end.viewCoordinates,s=e.next.end.viewCoordinates,p=o.minus(r),n=s.minus(r),h=p.normalized(),c=p.angle;let i=n.angle;return i<c&&(i+=2*Math.PI),new T().moveToPoint(r).lineToPoint(h.timesScalar(t).plus(r)).arcPoint(r,t,c,i,!0).close().makeImmutable()}static getStrokeFromStyle(e,t){return e===E.ONLY_ONE?t.theme.sectorOnlyOneColorProperty:e===E.NOT_ZERO?t.theme.sectorNotZeroColorProperty:e===E.NOT_ONE?t.theme.sectorNotOneColorProperty:e===E.NOT_TWO?t.theme.sectorNotTwoColorProperty:t.theme.sectorOtherColorProperty}};v(ce,"nameMap",new Map([[E.NONE,"Invalid"],[E.ONLY_ZERO,"No Lines"],[E.ONLY_ONE,"Only One Line"],[E.ONLY_TWO,"Both Lines"],[E.NOT_ZERO,"At Least One Line"],[E.NOT_ONE,"Zero or Two Lines"],[E.NOT_TWO,"Less Than Two Lines"],[E.ANY,"Any Lines"]]));let te=ce;class Zo extends L{constructor(e,t,o,r){super({pickable:!1}),this.vertex=e;const s=.12,n=e.edges.map(u=>u.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized()).map(u=>u.times(s)),c=T.polygon(wt.grahamScan([H.ZERO,...n],!1)).getOffsetShape(-.05),i=new M(null,{stroke:r.theme.vertexStateLineProperty,lineWidth:.01}),a=new M(c,{translation:e.viewCoordinates,fill:r.theme.vertexStateBackgroundProperty,stroke:r.theme.vertexStateOutlineProperty,lineWidth:.01,children:[i,...n.map(u=>new Je({radius:.02,translation:u,fill:r.theme.vertexStatePointProperty}))]});let g=null;const f=he.multilink([t,r.vertexStateVisibleProperty,r.allVertexStateVisibleProperty],(u,w,y)=>{const P=()=>{this.children=[]};if(!w){P();return}const S=u.getVertexState(e);if(!y){let C=!1,b=!1;const F=new Set;for(const N of e.edges){const V=u.getEdgeState(N);C=C||V===D.BLACK,b=b||V===D.WHITE,V===D.WHITE&&F.add(N)}if(C||!b){P();return}if(Pt.fromLookup(e,(N,V)=>F.has(N)&&F.has(V),!0).equals(S)){P();return}}if(!g||!g.equals(S)){g=S;const C=new T;for(const b of S.getAllowedPairs()){const F=O=>O.getOtherVertex(e).viewCoordinates.minus(e.viewCoordinates).normalized().times(s);C.moveToPoint(F(b[0])),C.lineToPoint(F(b[1]))}S.allowsEmpty()&&(C.moveTo(.03,0),C.circle(H.ZERO,.03),C.close()),C.makeImmutable(),i.shape=C}this.children=[a]});this.disposeEmitter.addListener(()=>f.dispose());const m=u=>{this.visible=!u};o.link(m),this.disposeEmitter.addListener(()=>o.unlink(m))}}class zo extends qe{constructor(e,t){const o=de()({font:_t,fill:j.uiForegroundColorProperty},t);super(e,o)}}class $o extends L{constructor(e,t,o,r){super({translation:e.viewCoordinates}),this.face=e;const s=he.multilink([t,r.faceStateVisibleProperty],(n,h)=>{if(this.children=[],h){const c=n.getFaceState(e),i=c.possibilityCount===0||c.possibilityCount>9;let a;const g=c.possibilityCount===1?r.theme.faceValueCompletedColorProperty:r.theme.faceValueColorProperty;if(i)a=new zo(c.possibilityCount,{font:me,maxWidth:.4,maxHeight:.4});else{const f=new Set(e.vertices);a=new St({spacing:1.5,autoColumns:Math.ceil(Math.sqrt(c.possibilityCount)),children:c.getAllowedCombinations().map(m=>{const u=new L,w=new Set(m.map(S=>S.start)),y=new Set(m.map(S=>S.end)),P=S=>S.minus(e.viewCoordinates);if(u.addChild(new M(T.polygon(e.vertices.map(S=>P(S.viewCoordinates))),{stroke:g,lineWidth:.03,opacity:.2})),w.size){const S=new T;if(m.length===e.edges.length)S.polygon(e.vertices.map(C=>P(C.viewCoordinates)));else{const C=new Set(m);for(;C.size;){const b=[...f].find(N=>[...C].filter(V=>V.start===N||V.end===N).length===1);k()&&x(b);let F=b,O=[...C].find(N=>N.start===F||N.end===F)??null;for(S.moveToPoint(P(F.viewCoordinates));O;)C.delete(O),F=O.getOtherVertex(F),S.lineToPoint(P(F.viewCoordinates)),O=[...C].find(N=>N.start===F||N.end===F)??null}}u.addChild(new M(S,{stroke:g,lineWidth:.15,lineCap:"round",lineJoin:"round"}))}for(const S of e.vertices)!w.has(S)&&!y.has(S)&&u.addChild(new Je(.1,{fill:g,translation:P(S.viewCoordinates)}));return u}),maxWidth:.6,maxHeight:.6})}a.center=H.ZERO,this.addChild(a)}});this.disposeEmitter.addListener(()=>s.dispose());const p=n=>{this.visible=!n};o.link(p),this.disposeEmitter.addListener(()=>o.unlink(p))}}const Go=new be({lineWidth:.2,lineCap:"round",lineJoin:"round"});class Ko extends L{constructor(e,t,o){let r;if(Jt.value)if(e.type==="edge-state"){const s=new T().moveToPoint(e.edge.start.viewCoordinates).lineToPoint(e.edge.end.viewCoordinates);r=[new M(s.getStrokedShape(Go),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(e.type==="face-color")if(e.face){const s=T.polygon(e.face.vertices.map(n=>n.viewCoordinates));r=[new M(s.getOffsetShape(-.1),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else if(e.type==="sector"){const s=te.getSectorArcShape(e.sector,.5);r=[new M(s.getOffsetShape(.05),{stroke:o.theme.hoverHighlightColorProperty,lineWidth:.02})]}else r=[];else r=[];super({children:r}),this.hoverHighlight=e}}class Qo extends L{constructor(e,t,o,r){let s=[];try{let p=new T;for(const h of e.faces)p.polygon(h.vertices.map(c=>c.viewCoordinates));if(e.faceColor.colorState===ee.OUTSIDE)try{const h=T.polygon(t.outerBoundary.map(a=>a.start.viewCoordinates)),i=Ce.getOffsetBackgroundShape(t.outerBoundary,r.useBackgroundOffsetStroke,r.backgroundOffsetDistance).shapeDifference(h);p=p.shapeUnion(i)}catch(h){console.error(h)}const n=new M(p.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:o.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});s.push(n)}catch(p){console.error(p)}super({children:s}),this.selectedFaceColorHighlight=e}}class er extends L{constructor(e,t,o,r){const s=[],p=[],n=e.sector,h=e.currentState,c=te.getSectorArcShape(n,.5),i=new M(c.getOffsetShape(.05),{stroke:o.theme.selectedSectorEditColorProperty,lineWidth:.02});s.push(i);const a=[];if(h===E.ANY&&(a.push(E.NOT_ZERO),a.push(E.NOT_ONE),a.push(E.NOT_TWO)),h.one&&h!==E.ONLY_ONE&&a.push(E.ONLY_ONE),a.length){const g=a.map(u=>{const w=te.getStrokeFromStyle(u,o);return new Ft({accessibleName:te.nameMap.get(u),content:new yt(0,0,25,25),listener:()=>{r.sectorSetListener&&r.sectorSetListener(n,u)},buttonAppearanceStrategy:qt,baseColor:w,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});p.push(...g);const f=new ze(new Ze({children:g,spacing:10}),{xMargin:10,yMargin:10,fill:o.theme.uiBackgroundColorProperty,stroke:o.theme.uiForegroundColorProperty,scale:.01});p.push(f);const m=.1;s.push(f),f.centerBottom=i.centerTop.plusXY(0,-.15),f.top<t.top+m&&(f.centerTop=i.centerBottom.plusXY(0,.15)),f.left<t.left+m&&(f.left=t.left+m),f.right>t.right-m&&(f.right=t.right-m)}super({children:s}),this.selectedSectorEdit=e,this.disposeEmitter.addListener(()=>{p.forEach(g=>g.dispose())})}}class Ye extends L{constructor(t,o){const r=de()({textOptions:{font:me,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new re(null),selectedFaceColorHighlightProperty:new re(null),selectedSectorEditProperty:new re(null),faceFilter:()=>!0,style:_,noninteractive:!1},o),s=r.style,p=new L({visibleProperty:s.faceColorsVisibleProperty}),n=new L({pickableProperty:Mo}),h=new L({pickableProperty:Ao}),c=new L({pickableProperty:Ro}),i=new L({pickableProperty:Io}),a=new L,g=new L({pickable:!1}),f=new L({pickable:!1}),m=new L({pickable:!1}),u=new L({pickable:!1}),w=new L({pickable:!1}),y=new L,P=new B([t.stateProperty],V=>{if(V.getWeirdEdges().length||V.hasInvalidFaceColors())return!1;const R=V.getSimpleRegions();return R.length===1&&R[0].isSolved});p.addChild(new Jo(t.board,t.stateProperty,r.faceFilter,s)),t.board.faces.forEach(V=>{r.faceFilter(V)&&(n.addChild(new jo(V,t.stateProperty,s,r)),f.addChild(new $o(V,t.stateProperty,P,s)))});const S=new Ce(t.board.outerBoundary,t.board.innerBoundaries,s,r),C=V=>{V?t.board.vertices.forEach(R=>{R.faces.some(r.faceFilter)&&i.addChild(new Yo(R,t.stateProperty,P,s))}):i.children.forEach(R=>R.dispose())};s.verticesVisibleProperty.link(C);const b=V=>{V?t.board.vertices.forEach(R=>{R.faces.some(r.faceFilter)&&g.addChild(new Zo(R,t.stateProperty,P,s))}):g.children.forEach(R=>R.dispose())};s.vertexStateVisibleProperty.link(b),t.board.edges.forEach(V=>{V.faces.some(r.faceFilter)&&c.addChild(new Uo(V,t.stateProperty,P,s,r))}),t.board.halfEdges.forEach(V=>{(V.face?r.faceFilter(V.face):r.faceFilter(V.reversed.face))&&h.addChild(new te(V,t.stateProperty,s,r))}),a.addChild(new _o(t.board,t.stateProperty,r.faceFilter,s));super(Ue({children:[S,p,n,h,c,i,a,g,f,m,u,w,y]},r));v(this,"annotationContainer");v(this,"backgroundNode");this.puzzle=t,this.annotationContainer=m;const F=V=>{w.children.forEach(R=>R.dispose()),V&&w.addChild(new Ko(V,r.backgroundOffsetDistance,s))};r.hoverHighlightProperty.link(F),this.disposeEmitter.addListener(()=>r.hoverHighlightProperty.unlink(F));const O=V=>{u.children.forEach(R=>R.dispose()),V&&u.addChild(new Qo(V,t.board,s,r))};r.selectedFaceColorHighlightProperty.link(O),this.disposeEmitter.addListener(()=>r.selectedFaceColorHighlightProperty.unlink(O));const N=V=>{y.children.forEach(R=>R.dispose()),V&&y.addChild(new er(V,S,s,r))};r.selectedSectorEditProperty.link(N),this.disposeEmitter.addListener(()=>r.selectedSectorEditProperty.unlink(N)),this.disposeEmitter.addListener(()=>{s.verticesVisibleProperty.unlink(C),s.vertexStateVisibleProperty.unlink(b),[p,n,c,i,a,g,f,h].forEach(R=>{R.children.forEach(Se=>Se.dispose()),R.dispose()}),P.dispose(),S.dispose()}),this.backgroundNode=S}addAnnotationNode(t){this.annotationContainer.addChild(t)}removeAnnotationNode(t){this.annotationContainer.removeChild(t)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}class Vr extends L{constructor(e,t,o){const r=de()({style:_},o),s=t.getEmbeddedCompleteData(e.inputFeatureSet),p=t.getEmbeddedCompleteData(e.outputFeatureSet),n=new Ye(new ke(t.smallBoard,s),{noninteractive:!0,style:r.style}),h=new Ye(new ke(t.smallBoard,p),{noninteractive:!0,style:r.style}),c=e.highlander?new L({children:t.getEmbeddedQuestionFaces(e.inputFeatureSet).map(y=>new qe("?",{font:me,maxWidth:.9,maxHeight:.9,opacity:.5,fill:e.highlander?_.theme.faceValueColorProperty:_.theme.faceValueCompletedColorProperty,center:y.viewCoordinates}))}):new L,a=t.tightBounds.dilated(.5),g=.5,f=T.roundRectangle(a.x,a.y,a.width,a.height,g,g),m=new L({children:[n,c],clipArea:f,localBounds:a}),u=new L({children:[h,c],clipArea:f,localBounds:a}),w=new ze(new Ze({spacing:.2,children:[m,new po(0,0,20,0,{fill:j.uiForegroundColorProperty,stroke:j.uiForegroundColorProperty,headHeight:7,headWidth:7,tailWidth:1,layoutOptions:{align:"center"},opacity:.6,scale:1/30}),u]}),{cornerRadius:g*1.2,xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:_.theme.patternAnnotationBackgroundColorProperty});r.children=[w],super(r),this.rule=e,this.displayEmbedding=t,this.disposeEmitter.addListener(()=>{n.dispose(),h.dispose()})}}const tr=(l,e)=>{Gt(Kt,l,e,!0)};class fe{constructor(e,t,o,r,s,p,n,h,c,i){this.sourcePatternBoard=e,this.boardPatternBoard=t,this.largeBoard=o,this.embedding=r,this.smallBoard=s,this.toSmallFaceMap=p,this.toSmallEdgeMap=n,this.toSmallSectorMap=h,this.tightBounds=c,this.expandedBounds=i}mapFace(e){const t=this.embedding.mapFace(e),o=this.boardPatternBoard.getFace(t);if(o){const r=this.toSmallFaceMap.get(o);return k()&&x(r),r}else return null}mapEdge(e){return(e.isExit?this.embedding.mapExitEdges(e):[this.embedding.mapNonExitEdge(e)]).map(r=>this.boardPatternBoard.getEdge(r)).map(r=>{const s=this.toSmallEdgeMap.get(r);return k()&&x(s),s})}mapSector(e){const t=this.embedding.mapSector(e),o=this.boardPatternBoard.getSector(t),r=this.toSmallSectorMap.get(o);return k()&&x(r),r}getEmbeddedQuestionFaces(e){const t=new Set;for(const o of e.patternBoard.faces)if(e.getFaceValue(o)!==void 0){const r=this.mapFace(o);r&&t.add(r)}return this.smallBoard.faces.filter(o=>!t.has(o))}getEmbeddedCompleteData(e){const t=vt.empty(this.smallBoard);for(const o of e.getFeaturesArray())if(o instanceof uo)o.value!==null&&t.setFaceValue(this.mapFace(o.face),o.value);else if(o instanceof fo)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,D.BLACK));else if(o instanceof go)this.mapEdge(o.edge).forEach(r=>t.setEdgeState(r,D.RED));else if(o instanceof mo)t.setSectorState(this.mapSector(o.sector),E.NOT_ZERO);else if(o instanceof wo)t.setSectorState(this.mapSector(o.sector),E.NOT_ONE);else if(o instanceof Co)t.setSectorState(this.mapSector(o.sector),E.NOT_TWO);else if(o instanceof So)t.setSectorState(this.mapSector(o.sector),E.ONLY_ONE);else if(o instanceof yo){const r=(p,n)=>{const h=this.mapFace(p),c=this.mapFace(n),i=h?t.getFaceColor(h):t.getOutsideColor(),a=c?t.getFaceColor(c):t.getOutsideColor();new Qt(ue(t,i),ue(t,a)).apply(t)},s=(p,n)=>{const h=this.mapFace(p),c=this.mapFace(n),i=h?t.getFaceColor(h):t.getOutsideColor(),a=c?t.getFaceColor(c):t.getOutsideColor();new eo(ue(t,i),ue(t,a)).apply(t)};for(let p=1;p<o.primaryFaces.length;p++)r(o.primaryFaces[p-1],o.primaryFaces[p]);for(let p=1;p<o.secondaryFaces.length;p++)r(o.secondaryFaces[p-1],o.secondaryFaces[p]);o.secondaryFaces.length&&s(o.primaryFaces[0],o.secondaryFaces[0])}else throw new Error(`unhandled feature: ${o}`);return tr(this.smallBoard,t),t}static getEmbeddingBounds(e,t,o){const r=ye.NOTHING.copy(),s=n=>{r.addPoint(t.getVertex(o.mapVertex(n)).viewCoordinates)};e.vertices.forEach(s);const p=n=>{const h=t.getFace(o.mapFace(n));h&&h.vertices.forEach(c=>r.addPoint(c.viewCoordinates))};return e.faces.forEach(p),e.edges.forEach(n=>{let h;n.isExit?h=o.mapExitEdges(n).map(c=>t.getEdge(c)):h=[t.getEdge(o.mapNonExitEdge(n))],h.forEach(c=>{r.addPoint(c.start.viewCoordinates),r.addPoint(c.end.viewCoordinates)})}),r}static findBestEmbedding(e,t,o){const r=Po(e,t);if(r.length===0)return null;const s=ye.NOTHING.copy();o.vertices.forEach(c=>s.addPoint(c.viewCoordinates));const p=s.center;let n=null,h=Number.POSITIVE_INFINITY;for(let c=0;c<r.length;c++){const i=r[c],g=fe.getEmbeddingBounds(e,t,i).center,f=p.distance(g);f<h&&(h=f,n=i)}return n}static getDisplayEmbedding(e,t,o,r){const s=fe.getEmbeddingBounds(e,t,r),p=s.dilated(.5),n=o.faces.filter(u=>{const w=ye.NOTHING.copy();return u.vertices.forEach(y=>w.addPoint(y.viewCoordinates)),p.intersectsBounds(w)}),h=o.vertices.filter(u=>u.faces.some(w=>n.includes(w))),c=Lt({vertices:h.map(u=>({logicalCoordinates:u.logicalCoordinates,viewCoordinates:u.viewCoordinates})),faces:n.map(u=>({logicalCoordinates:u.logicalCoordinates,vertices:u.vertices.map(w=>({logicalCoordinates:w.logicalCoordinates,viewCoordinates:w.viewCoordinates}))}))}),i=new vo(c),a=1e-6,g=new Map(n.map((u,w)=>{const y=i.faces.find(P=>P.viewCoordinates.equalsEpsilon(u.viewCoordinates,a));return k()&&x(y),[u,y]})),f=new Map(o.edges.map(u=>{const w=i.edges.find(y=>y.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,a)&&y.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,a)||y.start.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,a)&&y.end.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,a))??null;return w?[u,w]:null}).filter(u=>u!==null)),m=new Map(o.halfEdges.map(u=>{const w=i.halfEdges.find(y=>y.start.viewCoordinates.equalsEpsilon(u.start.viewCoordinates,a)&&y.end.viewCoordinates.equalsEpsilon(u.end.viewCoordinates,a))??null;return w?[u,w]:null}).filter(u=>u!==null));return k()&&x(r),new fe(e,t,o,r,i,g,f,m,s,p)}}class or{constructor(e,t,o){v(this,"edgeStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getEdgeState(e){return this.currentState.getEdgeState(e)}setEdgeState(e,t){if(k()&&x(this.board.edges.includes(e)),t!==D.WHITE){const o=this.solvedState.getEdgeState(e);if(t!==o)throw new X(`Attempt to make edge ${t} when it should be ${o}`)}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class rr{constructor(e,t,o){v(this,"faceColorsChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceColors(){return this.currentState.getFaceColors()}getInsideColor(){return this.currentState.getInsideColor()}getOutsideColor(){return this.currentState.getOutsideColor()}getFaceColor(e){return this.currentState.getFaceColor(e)}getFacesWithColor(e){return this.currentState.getFacesWithColor(e)}getFaceColorMap(){return this.currentState.getFaceColorMap()}getOppositeFaceColor(e){return this.currentState.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.currentState.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){if(s)throw new X("invalid face color?");const p=new Set([...o.values(),...r.keys(),...o.values()]),n=new Map(this.currentState.getFaceColorMap());for(const i of o.keys())n.set(i,o.get(i));const h=i=>r.has(i)?r.get(i):[...e].includes(i)?this.currentState.getOppositeFaceColor(i):null,c=new Map;for(const i of n.keys()){const a=n.get(i);c.has(a)||c.set(a,new Set([i])),c.get(a).add(i)}for(const i of p){const a=c.get(i);if(!a)continue;const g=[...a];k()&&x(g.length>0);const f=this.solvedState.getFaceColor(g[0]);for(const u of g)if(this.solvedState.getFaceColor(u)!==f)throw new X("invalid face color");const m=h(i);if(m){let u;if(m.colorState===ee.INSIDE?u=this.solvedState.getInsideColor():m.colorState===ee.OUTSIDE?u=this.solvedState.getOutsideColor():u=this.solvedState.getFaceColor([...c.get(m)][0]),f===u)throw new X("opposite colors are the same")}}}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class sr{constructor(e,t,o){v(this,"simpleRegionsChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getSimpleRegions(){return this.currentState.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.currentState.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.currentState.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.currentState.getSimpleRegionWithId(e)}getWeirdEdges(){return this.currentState.getWeirdEdges()}modifyRegions(e,t,o,r){if([...o].length)throw new X("weird edges added")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class ir{constructor(e,t,o){v(this,"faceValueChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceValue(e){return this.currentState.getFaceValue(e)}setFaceValue(e,t){if(this.solvedState.getFaceValue(e)!==t)throw new X("invalid face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class nr{constructor(e,t,o){v(this,"sectorStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getSectorState(e){return this.currentState.getSectorState(e)}setSectorState(e,t){k()&&x(this.board.halfEdges.includes(e));const o=this.solvedState.getSectorState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make sector ${t} when it should be ${o}`)}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class ar{constructor(e,t,o){v(this,"vertexStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getVertexState(e){return this.currentState.getVertexState(e)}setVertexState(e,t){k()&&x(this.board.vertices.includes(e));const o=this.solvedState.getVertexState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make vertex ${t} when it should be ${o}`);const r=this.currentState.getVertexState(e);if(!t.isSubsetOf(r))throw new X("Do not generalize vertex state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class lr{constructor(e,t,o){v(this,"faceStateChangedEmitter",new G);this.board=e,this.currentState=t,this.solvedState=o}getFaceState(e){return this.currentState.getFaceState(e)}setFaceState(e,t){k()&&x(this.board.faces.includes(e));const o=this.solvedState.getFaceState(e);if(!o.isSubsetOf(t))throw new X(`Attempt to make face ${t} when it should be ${o}`);const r=this.currentState.getFaceState(e);if(!t.isSubsetOf(r))throw new X("Do not generalize face state")}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}class Er{constructor(e,t,o){v(this,"anyStateChangedEmitter",new G);v(this,"edgeStateValidator");v(this,"faceValueValidator");v(this,"simpleRegionDataValidator");v(this,"faceColorValidator");v(this,"sectorStateValidator");v(this,"vertexStateValidator");v(this,"faceStateValidator");k()&&x(e),k()&&x(o),this.edgeStateValidator=new or(e,t,o),this.faceValueValidator=new ir(e,t,o),this.simpleRegionDataValidator=new sr(e,t,o),this.faceColorValidator=new rr(e,t,o),this.sectorStateValidator=new nr(e,t,o),this.vertexStateValidator=new ar(e,t,o),this.faceStateValidator=new lr(e,t,o)}getFaceValue(e){return this.faceValueValidator.getFaceValue(e)}setFaceValue(e,t){this.faceValueValidator.setFaceValue(e,t)}get faceValueChangedEmitter(){return this.faceValueValidator.faceValueChangedEmitter}getEdgeState(e){return this.edgeStateValidator.getEdgeState(e)}setEdgeState(e,t){this.edgeStateValidator.setEdgeState(e,t)}get edgeStateChangedEmitter(){return this.edgeStateValidator.edgeStateChangedEmitter}getSimpleRegions(){return this.simpleRegionDataValidator.getSimpleRegions()}getSimpleRegionWithVertex(e){return this.simpleRegionDataValidator.getSimpleRegionWithVertex(e)}getSimpleRegionWithEdge(e){return this.simpleRegionDataValidator.getSimpleRegionWithEdge(e)}getSimpleRegionWithId(e){return this.simpleRegionDataValidator.getSimpleRegionWithId(e)}getWeirdEdges(){return this.simpleRegionDataValidator.getWeirdEdges()}modifyRegions(e,t,o,r){this.simpleRegionDataValidator.modifyRegions(e,t,o,r)}get simpleRegionsChangedEmitter(){return this.simpleRegionDataValidator.simpleRegionsChangedEmitter}getFaceColors(){return this.faceColorValidator.getFaceColors()}getInsideColor(){return this.faceColorValidator.getInsideColor()}getOutsideColor(){return this.faceColorValidator.getOutsideColor()}getFaceColor(e){return this.faceColorValidator.getFaceColor(e)}getFacesWithColor(e){return this.faceColorValidator.getFacesWithColor(e)}getFaceColorMap(){return this.faceColorValidator.getFaceColorMap()}getOppositeFaceColor(e){return this.faceColorValidator.getOppositeFaceColor(e)}hasInvalidFaceColors(){return this.faceColorValidator.hasInvalidFaceColors()}modifyFaceColors(e,t,o,r,s){this.faceColorValidator.modifyFaceColors(e,t,o,r,s)}get faceColorsChangedEmitter(){return this.faceColorValidator.faceColorsChangedEmitter}getSectorState(e){return this.sectorStateValidator.getSectorState(e)}setSectorState(e,t){this.sectorStateValidator.setSectorState(e,t)}get sectorStateChangedEmitter(){return this.sectorStateValidator.sectorStateChangedEmitter}getVertexState(e){return this.vertexStateValidator.getVertexState(e)}setVertexState(e,t){this.vertexStateValidator.setVertexState(e,t)}get vertexStateChangedEmitter(){return this.vertexStateValidator.vertexStateChangedEmitter}getFaceState(e){return this.faceStateValidator.getFaceState(e)}setFaceState(e,t){this.faceStateValidator.setFaceState(e,t)}get faceStateChangedEmitter(){return this.faceStateValidator.faceStateChangedEmitter}clone(){return this}createDelta(){return this}serializeState(e){throw new Error("unimplemented")}}const br=(l,e,t)=>new se([new Ge(l,e),new Ke(l,e),new Qe(l,e),new rt(l,e,{solveJointToRed:!0,solveForcedLineToBlack:!0,solveAlmostEmptyToRed:!0}),new st(l,e,{solveToRed:!0,solveToBlack:!0}),new it(l,e,{solveToRed:!0,solveToBlack:!0,resolveAllRegions:!1}),new to(l,e),new et(l,e),new nt(l,e),new oo(l,e),new tt(l,e),new ro(l,e,{solveToRed:!0,solveToBlack:!0}),new so(l,e),new at(l,e,{solveToRed:!0,solveToBlack:!0}),new io(l,e,{solveToRed:!0,solveToBlack:!0,solveColors:!0,allowPartialReduction:!0}),new no(l,e),new ot(l,e),new ao(l,e,{solveToRed:!0,solveToBlack:!0}),new lo(l,e),new co(l,e),new ho(l,e)]);export{Er as C,fe as D,W as E,$o as F,Ye as P,zo as U,Zo as V,br as a,Pr as b,_ as c,Fo as d,Q as e,xo as f,dt as g,Eo as h,bo as i,To as j,Lo as k,Vr as l,Oo as m,ko as n,Vo as o,ve as p,tr as s,vr as t,No as v};
