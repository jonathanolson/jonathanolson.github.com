var I=Object.defineProperty;var w=(c,t,e)=>t in c?I(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var g=(c,t,e)=>(w(c,typeof t!="symbol"?t+"":t,e),e);import{F as D,e as a,R,B as k,S as L,a as H,b as V,c as q,n as y,P as O,f as M,d as T}from"./FeatureSet-Brj-qr45.js";import{_ as P,a as p,b as l}from"./getCoordinateClusteredMap-s__X_7ZN.js";import{o as z,X as v,G as U,I as $,B as Q,n as Z}from"./patternBoards-CdPs5rJx.js";import{E as W,d as G}from"./Vector2Property-DCXaH-JP.js";const S=class S extends W{};g(S,"INCOMPATIBLE",new S),g(S,"INCONSEQUENTIAL",new S),g(S,"DORMANT",new S),g(S,"ACTIONABLE",new S),g(S,"enumeration",new G(S));let A=S;const X=c=>c.name?c.name:z(c.descriptor),C=c=>{let t=v(c);if(t)return t;const e=U(c);return t=$(e),t||new Q(e)};class j{constructor(t){g(this,"featureArray",[]);g(this,"featureMatchers",[]);g(this,"featureSetMatchers",[]);this.patternBoard=t;for(const e of t.faces){const r=e.isExit?[null]:[...P.range(0,e.edges.length),null];for(const s of r)this.featureArray.push(new D(e,s)),this.featureMatchers.push((i,n)=>i.faceValues[n.mapFace(e).index]===s?a.MATCH:a.INCOMPATIBLE),this.featureSetMatchers.push((i,n)=>i.impliesFaceValue(n.mapFace(e),s)?a.MATCH:a.INCOMPATIBLE)}for(const e of t.edges)this.featureArray.push(new R(e)),this.featureMatchers.push((r,s)=>{if(e.isExit){const i=s.mapExitEdges(e);let n=!0;for(const u of i){const o=u.index;if(r.redEdgeValues[o])continue;if(n=!1,r.blackEdgeValues[o])return a.INCOMPATIBLE}return n?a.MATCH:a.DORMANT}else{const i=s.mapNonExitEdge(e).index;return r.redEdgeValues[i]?a.MATCH:r.blackEdgeValues[i]?a.INCOMPATIBLE:a.DORMANT}}),this.featureSetMatchers.push((r,s)=>{if(e.isExit){const i=s.mapExitEdges(e);let n=!0;for(const u of i){if(r.impliesRedEdge(u))continue;if(n=!1,r.impliesBlackEdge(u))return a.INCOMPATIBLE}return n?a.MATCH:a.DORMANT}else{const i=s.mapNonExitEdge(e);return r.impliesRedEdge(i)?a.MATCH:r.impliesBlackEdge(i)?a.INCOMPATIBLE:a.DORMANT}}),e.isExit||(this.featureArray.push(new k(e)),this.featureMatchers.push((r,s)=>{const i=s.mapNonExitEdge(e).index;return r.blackEdgeValues[i]?a.MATCH:r.redEdgeValues[i]?a.INCOMPATIBLE:a.DORMANT}),this.featureSetMatchers.push((r,s)=>{const i=s.mapNonExitEdge(e);return r.impliesBlackEdge(i)?a.MATCH:r.impliesRedEdge(i)?a.INCOMPATIBLE:a.DORMANT}));for(const e of t.sectors)this.featureArray.push(new L(e)),this.featureMatchers.push((r,s)=>r.sectorNotZeroValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotZero(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new H(e)),this.featureMatchers.push((r,s)=>r.sectorNotOneValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotOne(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new V(e)),this.featureMatchers.push((r,s)=>r.sectorNotTwoValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorNotTwo(s.mapSector(e))?a.MATCH:a.DORMANT),this.featureArray.push(new q(e)),this.featureMatchers.push((r,s)=>r.sectorOnlyOneValues[s.mapSector(e).index]?a.MATCH:a.DORMANT),this.featureSetMatchers.push((r,s)=>r.impliesSectorOnlyOne(s.mapSector(e))?a.MATCH:a.DORMANT);p()&&l(this.featureArray.length===this.featureMatchers.length),p()&&l(this.featureArray.length===this.featureSetMatchers.length),p()&&l(this.featureArray.length<=254,"Our limit for encoding in a byte")}}const b=new WeakMap,x=c=>{let t=b.get(c);return t||(t=new j(c),b.set(c,t)),t};class m{constructor(t,e,r,s=!1){this.patternBoard=t,this.inputFeatureSet=e,this.outputFeatureSet=r,this.highlander=s}getInputDifficultyScoreA(){return this.inputFeatureSet.getInputDifficultyScoreA()+.75*this.patternBoard.vertices.length}embedded(t,e){const r=this.inputFeatureSet.embedded(t,e);if(r===null)return null;const s=this.outputFeatureSet.embedded(t,e);return s===null?null:new m(t,r,s,this.highlander)}getEmbeddedRules(t){return t.map(e=>this.embedded(e.targetPatternBoard,e)).filter(e=>e!==null)}isIsomorphicTo(t){if(this.patternBoard!==t.patternBoard||!this.inputFeatureSet.hasSameShapeAs(t.inputFeatureSet)||!this.outputFeatureSet.hasSameShapeAs(t.outputFeatureSet))return!1;const e=Z(this.patternBoard,this.patternBoard);for(const r of e){const s=this.embedded(this.patternBoard,r);if(s&&s.inputFeatureSet.equals(t.inputFeatureSet)&&s.outputFeatureSet.equals(t.outputFeatureSet))return!0}return!1}isSubsetOf(t){return this.inputFeatureSet.isSubsetOf(t.inputFeatureSet)&&this.outputFeatureSet.isSubsetOf(t.outputFeatureSet)}matches(t){return this.inputFeatureSet.isSubsetOf(t)}getMatchState(t){const e=this.inputFeatureSet.getQuickCompatibilityWith(t);return e===y.INCOMPATIBLE||e===y.NO_MATCH_NEEDS_FACE_VALUES?A.INCOMPATIBLE:this.outputFeatureSet.isSubsetOf(t)?A.INCONSEQUENTIAL:e===y.NO_MATCH_NEEDS_STATE?A.DORMANT:A.ACTIONABLE}isRedundant(t){if(this.isTrivial())return!0;const e=this.outputFeatureSet,r=t.filter(s=>s.outputFeatureSet.isSubsetOf(e));return this.outputFeatureSet.isSubsetOf(m.withRulesApplied(this.patternBoard,this.inputFeatureSet,r))}hasApplication(t){return this.matches(t)&&!this.outputFeatureSet.isSubsetOf(t)}apply(t){p()&&l(this.hasApplication(t)),t.applyFeaturesFrom(this.outputFeatureSet)}isTrivial(){return this.outputFeatureSet.isSubsetOf(this.inputFeatureSet)}isCorrectSlow(){const t=O.countSolutions(this.patternBoard,this.inputFeatureSet.getFeaturesArray()),e=O.countSolutions(this.patternBoard,this.outputFeatureSet.getFeaturesArray());return t===e}toCanonicalString(){return`rule:${this.inputFeatureSet.toCanonicalString()}->${this.outputFeatureSet.toCanonicalString()}`}equals(t){return this.patternBoard===t.patternBoard&&this.inputFeatureSet.equals(t.inputFeatureSet)&&this.outputFeatureSet.equals(t.outputFeatureSet)&&this.highlander===t.highlander}getBinaryIdentifier(){const t=this.patternBoard.name;if(!t)throw new Error("Pattern board must have a name");const e=this.getBinary([this.patternBoard]).slice(1),r=btoa(String.fromCharCode.apply(null,[this.highlander?1:0,...e])),s=`${t}/${r}`;if(p()){const i=m.fromBinaryIdentifier(s);l(i.equals(this),"round-trip equality")}return s}static fromBinaryIdentifier(t){const e=t.indexOf("/"),r=t.slice(0,e),s=t.slice(e+1),i=atob(s).split("").map(u=>u.charCodeAt(0)),n=C(r);return m.fromBinary([n],[0,...i.slice(1)],0,i[0]!==0)}getBinary(t){const e=[],r=t.indexOf(this.patternBoard);p()&&l(r!==-1&&r<256,"pattern board index"),e.push(r);const s=x(this.patternBoard),i=this.inputFeatureSet.getFeaturesArray(),n=this.outputFeatureSet.getFeaturesArray().filter(o=>!i.some(h=>h.equals(o))),u=o=>{const h=o.filter(d=>!(d instanceof T)),F=o.filter(d=>d instanceof T);for(const d of h){const f=s.featureArray.findIndex(E=>E.equals(d));p()&&l(f!==-1,"feature index"),e.push(f)}for(const d of F){e.push(254);for(const f of d.primaryFaces)p()&&l(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),e.push(f.index);for(const f of d.secondaryFaces)p()&&l(f.index<126,"need room to disambiguate from 0xff/0xfe once high bit is set"),e.push(f.index|128)}};if(u(i),e.push(255),u(n),e.push(255),p()){const o=new Uint8Array(e),h=m.fromBinary(t,o,0,this.highlander);l(h.equals(this),"round-trip equality")}return e}static fromBinary(t,e,r,s){const i=e[r++],n=t[i];p()&&l(n,"pattern board");const u=x(n),o=()=>{const d=M.empty(n);for(;;){const f=e[r++];if(f===255)return d;if(f===254){const E=[],N=[];for(;;){const B=e[r++];if(B===255||B===254){r--;break}B&128?N.push(n.faces[B&127]):E.push(n.faces[B])}d.addFeature(T.fromPrimarySecondaryFaces(E,N))}else d.addFeature(u.featureArray[f])}},h=o(),F=o().union(h);return p()&&l(F),new m(n,h,F,s)}serialize(){const t={patternBoard:X(this.patternBoard),input:this.inputFeatureSet.serialize(),output:this.outputFeatureSet.serialize()};return this.highlander&&(t.highlander=!0),t}collectionSerialize(t){return{...this.serialize(),patternBoard:t}}static deserialize(t){const e=C(t.patternBoard);return new m(e,M.deserialize(t.input,e),M.deserialize(t.output,e),t.highlander??!1)}static collectionDeserialize(t,e){const r=t[e.patternBoard];return p()&&l(r,"pattern board"),new m(r,M.deserialize(e.input,r),M.deserialize(e.output,r),e.highlander??!1)}static withRulesApplied(t,e,r){p()&&l(r.every(o=>o.patternBoard===t),"embedding check");let s=r,i=[];const n=e.clone();let u=!0;for(;u;){u=!1;for(const o of s){const h=o.getMatchState(n);h===A.ACTIONABLE?(o.apply(n),u=!0):h===A.DORMANT&&i.push(o)}s=i,i=[]}return n}}export{m as P,A as a,C as d,x as g,X as s};
