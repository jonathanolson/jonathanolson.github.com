var z=Object.defineProperty;var H=(g,t,e)=>t in g?z(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var h=(g,t,e)=>(H(g,typeof t!="symbol"?t+"":t,e),e);import{g as P,p as k,s as _,m as U,n as v,y as Z,B as G,o as Y}from"./patternBoards-CAxgrjj1.js";import{P as W}from"./PatternRule-GYGPQH88.js";import{e as p,f,_ as A}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{m as J,f as Q,d as R,R as D,h as C,I as tt,B as et,S as st,a as nt,b as it,i as L,P as rt}from"./FeatureSet-CNv15qKr.js";import{E as at,d as ot,l as X,c as j}from"./Vector2Property-95p6aBvi.js";const ut={...J,featureLimit:Number.POSITIVE_INFINITY,hitFeatureLimitCallback:null,includeFaceValueZero:!1,prefilterRules:null,logModulo:1e6,vertexOrderLimit:null};class F{constructor(t,e){this.numAttributes=t,this.data=e}or(t){p()&&f(this.numAttributes===t.numAttributes),this.data=this.data|t.data}and(t){p()&&f(this.numAttributes===t.numAttributes),this.data=this.data&t.data}not(){this.data=(1n<<BigInt(this.numAttributes))-1n-this.data}set(t){p()&&f(t<this.numAttributes&&t>=0),this.data|=1n<<BigInt(t)}clear(t){this.data&=~(1n<<BigInt(t))}isLessThan(t){return p()&&f(this.numAttributes===t.numAttributes),this.data<t.data}isLessThanOrEqual(t){return p()&&f(this.numAttributes===t.numAttributes),this.data<=t.data}isLessThanI(t,e){if(p()&&f(this.numAttributes===t.numAttributes),!t.hasAttribute(e)||this.hasAttribute(e))return!1;const s=~((1n<<BigInt(e+1))-1n),n=this.data&s,i=t.data&s;return n===i}union(t){return p()&&f(this.numAttributes===t.numAttributes),new F(this.numAttributes,this.data|t.data)}intersection(t){return p()&&f(this.numAttributes===t.numAttributes),new F(this.numAttributes,this.data&t.data)}complement(){return new F(this.numAttributes,(1n<<BigInt(this.numAttributes))-1n-this.data)}clone(){return new F(this.numAttributes,this.data)}equals(t){return this.data===t.data}isSubsetOf(t){return(this.data&t.data)===this.data}isProperSubsetOf(t){return this.isSubsetOf(t)&&!this.equals(t)}isEmpty(){return this.data===0n}getCardinality(){let t=0n,e=this.data;for(;e;)t+=e&1n,e>>=1n;return Number(t)}withAttribute(t){return new F(this.numAttributes,this.data|1n<<BigInt(t))}withLowestBitSet(t){return new F(this.numAttributes,this.data&~((1n<<BigInt(t))-1n)|1n<<BigInt(t))}hasAttribute(t){return(this.data&1n<<BigInt(t))!==0n}getAttributes(){const t=[];for(let e=0;e<this.numAttributes;e++)this.hasAttribute(e)&&t.push(e);return t}toString(){return`[${A.range(0,this.numAttributes).map(t=>this.hasAttribute(t)?"1":"0").join("")} (${this.getAttributes().join(",")}) #${this.numAttributes}]`}static getEmpty(t){return new F(t,0n)}static getFull(t){return new F(t,(1n<<BigInt(t))-1n)}static fromBinary(t,e){return p()&&f(e<1n<<BigInt(t)&&e>=0n),new F(t,e)}static fromCallback(t,e){let s=0n;for(let n=0;n<t;n++)e(n)&&(s|=1n<<BigInt(n));return new F(t,s)}}class O extends F{constructor(e,s,n){super(e,s);h(this,"optionalDataComplement");h(this,"withOptionalData");this.optionalData=n,this.optionalDataComplement=(1n<<BigInt(e))-1n-this.optionalData,this.withOptionalData=s|this.optionalData,p()&&f((s&n)===0n)}hasOptionalAttribute(e){return(this.optionalData&1n<<BigInt(e))!==0n}getOptionalAttributes(){const e=[];for(let s=0;s<this.numAttributes;s++)this.hasOptionalAttribute(s)&&e.push(s);return e}toString(){const e=`OPT: [${A.range(0,this.numAttributes).map(s=>this.hasOptionalAttribute(s)?"1":"0").join("")} (${this.getOptionalAttributes().join(",")})`;return`${super.toString()} ${e})`}static fromSolutionBinary(e,s,n){return new O(e,s,n)}static solutionClosure(e,s,n){let i=(1n<<BigInt(e))-1n;const r=s.length;for(let o=0;o<r;o++){const a=s[o];(n&a.withOptionalData)===n&&(i&=a.data|n&a.optionalData)}return i}}class V{constructor(t,e){this.antecedent=t,this.consequent=e}toString(){return`${this.antecedent.toString()} -> ${this.consequent.toString()}`}static implicationSetClosure(t,e){let s=e,n=!0;for(;n;){n=!1;const i=t.length;for(let r=0;r<i;r++){const o=t[r],a=o.antecedent,c=o.consequent,u=s;(a&u)===a&&a!==u&&(c&u)!==c&&(s|=c,n=!0)}}return s}static implicationSetClosureLessThanI(t,e,s){if((e&1n<<BigInt(s))!==0n)return null;let n=e&~((1n<<BigInt(s))-1n)|1n<<BigInt(s),r=~((1n<<BigInt(s+1))-1n)&~n,o=!0;for(;o;){o=!1;const a=t.length;for(let c=0;c<a;c++){const u=t[c],l=u.antecedent,m=u.consequent;if((l&n)===l&&l!==n&&(m&n)!==m){if(m&r)return null;n|=m,o=!0}}}return n}}class lt{static forEachImplication(t,e,s,n){const i=(n==null?void 0:n.logModulo)??1e6,r=n==null?void 0:n.logModuloCallback,o=[];let a=0n;const c=new Array(t).fill(0n);let u=0;const l=Date.now();for(;a!==null;){u++,u%i===0&&r&&r(u,a,o,Math.round((Date.now()-l)/1e3));const m=e(a);if(a!==m){const d=new V(a,m);s(d),o.push(d);let x=a;if(x!==0n&&(x&x-1n)===0n){let S=0;for(;x>1n;)x>>=1n,S++;const B=~((1n<<BigInt(S+1))-1n);c[S]|=B&m}}let b=null;for(let d=0;d<t;d++){if((a&c[d])!==c[d])continue;const x=V.implicationSetClosureLessThanI(o,a,d);if(x!==null){b=x;break}}if(b!==null)a=b;else break}}}const $=(g,t)=>(g.withOptionalData&1n<<BigInt(t))!==0n;class ct{constructor(t,e){h(this,"singleAttributeObjectsMap");h(this,"doubleAttributeObjectsMap");this.numAttributes=t,this.solutionAttributeSets=e,e.length>350?(this.singleAttributeObjectsMap=A.range(0,t).map(s=>e.filter(n=>$(n,s))),console.log(`single filter size: ${A.sum(this.singleAttributeObjectsMap.map(s=>s.length))}`),e.length>1500?(this.doubleAttributeObjectsMap=A.range(0,t).map(s=>A.range(s+1,t).map(n=>this.singleAttributeObjectsMap[s].filter(i=>$(i,n)))),console.log(`double filter size: ${A.sum(this.doubleAttributeObjectsMap.map(s=>A.sum(s.map(n=>n.length))))}`)):this.doubleAttributeObjectsMap=null):(this.singleAttributeObjectsMap=null,this.doubleAttributeObjectsMap=null)}getSolutionAttributeSets(t){let e=this.solutionAttributeSets;if(this.singleAttributeObjectsMap){let s=[],n=t,i=0;for(;n>0n;)n&1n&&s.push(i),n>>=1n,i++;if(this.doubleAttributeObjectsMap&&s.length>=2)for(let r=0;r<s.length-1;r++){const o=s[r],a=s[r+1],c=this.doubleAttributeObjectsMap[o][a-(o+1)];c.length<e.length&&(e=c)}else if(s.length>=1)for(let r=0;r<s.length;r++){const o=this.singleAttributeObjectsMap[s[r]];o.length<e.length&&(e=o)}}return e}}class ht{constructor(t,e){h(this,"numAttributes");h(this,"numNonExitEdges");h(this,"sectorBaseIndex");h(this,"facePairBaseIndex");h(this,"extraPairs",[]);h(this,"primaryFeatures",[]);h(this,"allFeatures",[]);h(this,"empty",0n);h(this,"full");this.patternBoard=t;const s=Q.get(t);let n=0,i=0;if(e.solveEdges)for(const r of t.edges)if(r.isExit){p()&&f(i===r.index+n),i++;const o=new D(r);this.primaryFeatures.push(o),this.allFeatures.push([o])}else{p()&&f(i===2*r.index),n++,i+=2;const o=new D(r),a=new et(r);this.primaryFeatures.push(o),this.primaryFeatures.push(a),this.allFeatures.push([o]),this.allFeatures.push([a])}if(this.sectorBaseIndex=i,e.solveSectors)for(const r of t.sectors){p()&&f(i===3*r.index+this.sectorBaseIndex),i+=3;const o=new st(r),a=new nt(r),c=new it(r);this.primaryFeatures.push(o),this.primaryFeatures.push(a),this.primaryFeatures.push(c),this.allFeatures.push([o]),this.allFeatures.push([a]),this.allFeatures.push([c])}if(this.facePairBaseIndex=i,e.solveFaceColors)for(const r of s.connectedFacePairs){const o=R.fromPrimarySecondaryFaces([r.a,r.b],[]),a=R.fromPrimarySecondaryFaces([r.a],[r.b]);e.solveEdges&&r.shortestPath.length===1?(this.allFeatures[this.getNonExitRedIndex(r.shortestPath[0])].push(o),this.allFeatures[this.getNonExitBlackIndex(r.shortestPath[0])].push(a)):(this.extraPairs.push(r),i+=2,this.primaryFeatures.push(o),this.primaryFeatures.push(a),this.allFeatures.push([o]),this.allFeatures.push([a]))}this.numNonExitEdges=n,this.numAttributes=i,this.full=(1n<<BigInt(this.numAttributes))-1n}getSolutionAttributeSet(t){let e=0n,s=0n;const n=i=>t.has(i);for(let i=0;i<this.numAttributes;i++){const r=this.primaryFeatures[i];r instanceof D&&r.edge.isExit?r.edge.exitVertex.edges.every(o=>!n(o))?s|=1n<<BigInt(i):n(r.edge)||(e|=1n<<BigInt(i)):r.isPossibleWith(n)&&(e|=1n<<BigInt(i))}return O.fromSolutionBinary(this.numAttributes,e,s)}getFeatureSetBits(t){let e=0n;for(let s=0;s<this.numAttributes;s++){const n=this.primaryFeatures[s];t.impliesFeature(n)&&(e|=1n<<BigInt(s))}return e}bitsHaveIndex(t,e){return(t&1n<<BigInt(e))!==0n}getBitsIndices(t){const e=[];for(let s=0;s<this.numAttributes;s++)this.bitsHaveIndex(t,s)&&e.push(s);return e}getBitsPrimaryFeatures(t){const e=[];for(let s=0;s<this.numAttributes;s++)this.bitsHaveIndex(t,s)&&e.push(this.primaryFeatures[s]);return e}getBitsFeatureSet(t){if(t===this.full)return null;const e=C.empty(this.patternBoard);for(let s=0;s<this.numAttributes;s++)if(this.bitsHaveIndex(t,s)){const n=this.primaryFeatures[s];try{e.addFeature(n)}catch(i){if(i instanceof tt)return null;throw i}}return e}getBinaryString(t){return A.range(0,this.numAttributes).map(e=>this.bitsHaveIndex(t,e)?"1":"0").join("")}getIndicesString(t){return this.getBitsIndices(t).join(",")}getFeaturesString(t){return this.getBitsPrimaryFeatures(t).map(e=>e.toCanonicalString()).join(", ")}getFeaturesSetString(t){const e=this.getBitsFeatureSet(t);return e?e.toCanonicalString():"null"}getNonExitRedIndex(t){return 2*t.index}getNonExitBlackIndex(t){return 2*t.index+1}getExitIndex(t){return this.numNonExitEdges+t.index}getSectorNotZeroIndex(t){return 3*t.index+this.sectorBaseIndex}getSectorNotOneIndex(t){return 3*t.index+this.sectorBaseIndex+1}getSectorNotTwoIndex(t){return 3*t.index+this.sectorBaseIndex+2}getNonExitEdgeRedMask(t){return 1n<<BigInt(2*t.index)}getNonExitEdgeBlackMask(t){return 1n<<BigInt(2*t.index+1)}getNonExitEdgeMask(t){return 3n<<BigInt(2*t.index)}getExitEdgeMask(t){return 1n<<BigInt(this.numNonExitEdges+t.index)}getEdgeMask(t){return t.isExit?this.getExitEdgeMask(t):this.getNonExitEdgeMask(t)}getSectorNotZeroMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex)}getSectorNotOneMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+1)}getSectorNotTwoMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+2)}getSectorMask(t){return 7n<<BigInt(3*t.index+this.sectorBaseIndex)}}class gt{constructor(t,e){this.minVertexIndex=t,this.maxVertexIndex=e}}class dt{constructor(t,e,s,n){h(this,"solutionSet");h(this,"isEdgeBlack");h(this,"solutionAttributeSet");h(this,"richEdgeStateMap",new Map);h(this,"vertexConnection",null);h(this,"vertexConnectionKey",null);this.patternBoard=t,this.binaryFeatureMap=e,this.solution=s,p()&&f(this.patternBoard===e.patternBoard),this.solutionSet=new Set(s),this.isEdgeBlack=i=>this.solutionSet.has(i),this.solutionAttributeSet=e.getSolutionAttributeSet(this.solutionSet);for(const i of t.edges){let r;i.isExit?this.isEdgeBlack(i)?r=w.EXIT_BLACK:i.exitVertex.edges.every(o=>!this.isEdgeBlack(o))?r=w.EXIT_SOFT_RED_DOUBLE_BLACK:r=w.EXIT_HARD_RED:r=this.isEdgeBlack(i)?w.NON_EXIT_BLACK:w.NON_EXIT_RED,this.richEdgeStateMap.set(i,r)}if(n.highlander)if(t.faces.some(i=>!i.isExit)){const i=new Set(this.solutionSet),r=[];for(;i.size;){let a;for(const d of i)if(d.isExit){a=d;break}p()&&f(a);const c=d=>{for(const x of d.vertices)for(const S of x.edges)if(i.has(S))return S;throw new Error("no next edge found")};i.delete(a);let u=a;for(;u===a||!u.isExit;){const d=c(u);i.delete(d),u=d}const l=u,m=Math.min(a.exitVertex.index,l.exitVertex.index),b=Math.max(a.exitVertex.index,l.exitVertex.index);r.push(new gt(m,b))}const o=A.sortBy(r,a=>a.minVertexIndex);this.vertexConnection=o,this.vertexConnectionKey=o.map(a=>`c${a.minVertexIndex}-${a.maxVertexIndex}`).join(",")}else this.vertexConnection=[],this.vertexConnectionKey=""}isCompatibleWithFeature(t){return t.isPossibleWith(this.isEdgeBlack)}isCompatibleWithFeatureSet(t){return t.getFeaturesArray().every(e=>this.isCompatibleWithFeature(e))}toDebugString(){return`[${this.binaryFeatureMap.getBinaryString(this.solutionAttributeSet.data)}] (${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.data)}) opt:(${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.optionalData)}) ${this.vertexConnectionKey??""}`}}const E=class E extends at{};h(E,"NON_EXIT_RED",new E),h(E,"NON_EXIT_BLACK",new E),h(E,"EXIT_HARD_RED",new E),h(E,"EXIT_BLACK",new E),h(E,"EXIT_SOFT_RED_DOUBLE_BLACK",new E),h(E,"enumeration",new ot(E));let w=E;class M{constructor(t,e,s){h(this,"exitEdgeIndices");h(this,"solutionAttributeSetLists");this.initialFeatureSet=t,this.binaryFeatureMap=e,this.richSolutions=s;const n=t.patternBoard,i=n.edges.filter(a=>a.isExit);this.exitEdgeIndices=i.map(a=>e.getExitIndex(a)),this.solutionAttributeSetLists=new Array(1<<i.length).fill([]);const r=L(n,t.getFeaturesArray()),o=(a,c,u)=>{if(a===i.length){const l=M.filterWithInfo(s,r,u).map(m=>m.solutionAttributeSet);this.solutionAttributeSetLists[c]=l}else o(a+1,c,u),o(a+1,c|1<<a,[...u,i[a]])};o(0,0,[])}getSolutionAttributeSets(t){let e=0;for(let s=0;s<this.exitEdgeIndices.length;s++){const n=this.exitEdgeIndices[s];(t&1n<<BigInt(n))!==0n&&(e|=1<<s)}return this.solutionAttributeSetLists[e]}static filterWithFeatureSet(t,e){const s=L(e.patternBoard,e.getFeaturesArray()),n=e.patternBoard.edges.filter(i=>i.isExit&&e.impliesRedEdge(i));return M.filterWithInfo(t,s,n)}static getHighlanderKeyWithFeatureSet(t,e){const s=L(e.patternBoard,e.getFeaturesArray()),n=new Set(e.patternBoard.edges.filter(i=>i.isExit&&e.impliesRedEdge(i)));return M.getHighlanderKeyWithInfo(t,s,n)}static getHighlanderKeyWithInfo(t,e,s){return e.map(n=>{const i=t.richEdgeStateMap.get(n);return p()&&f(i),n.isExit?s.has(n)?i===w.EXIT_BLACK?"1":"0":i===w.EXIT_SOFT_RED_DOUBLE_BLACK?"2":i===w.EXIT_BLACK?"1":"0":i===w.NON_EXIT_BLACK?"1":"0"}).join("")+"/"+t.vertexConnectionKey}static filterWithInfo(t,e,s){const n=new Map,i=new Set(s);for(const r of t){const o=M.getHighlanderKeyWithInfo(r,e,i);n.has(o)?n.set(o,null):n.set(o,r)}return[...n.values()].filter(r=>{if(r===null)return!1;for(const o of s)if(r.solutionSet.has(o))return!1;return!0})}}const pt={logModulo:1e6},ft=(g,t,e,s,n,i)=>{const r=X()({},pt,i),o={solveEdges:t,solveSectors:e,solveFaceColors:s,highlander:n},a=g.patternBoard,c=g.getFeaturesArray(),u=new ht(a,o),l=u.numAttributes,b=rt.getSolutions(a,c).map(B=>new dt(a,u,B,o));let d;if(n){const B=new M(g,u,b);d=I=>{const y=B.getSolutionAttributeSets(I);return O.solutionClosure(l,y,I)}}else{const B=new ct(l,b.map(I=>u.getSolutionAttributeSet(I.solutionSet)));d=I=>{const y=B.getSolutionAttributeSets(I);return O.solutionClosure(l,y,I)}}const x=(1n<<BigInt(l))-1n,S=[];return lt.forEachImplication(l,d,B=>{if(B.consequent===x)return;const I=g.clone(),y=g.clone(),T=u.getBitsFeatureSet(B.antecedent);I.applyFeaturesFrom(T);const q=u.getBitsFeatureSet(B.consequent);y.applyFeaturesFrom(q),!I.equals(y)&&S.push(new W(a,I,y,n))},{logModulo:r.logModulo,logModuloCallback:(B,I,y,T)=>{console.log(`${B.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")} [${u.getBinaryString(I)}] (${u.getIndicesString(I)}) ${y.length} ${T}s`)}}),S},K=(g,t)=>{const e=X()({},ut,t);p()&&f(!isFinite(e.featureLimit));const s=P(g,g),n=e.highlander?g.faces.filter(l=>{if(!l.isExit||l.edges.length!==1)return!1;const b=l.edges[0].faces.find(d=>d!==l);return b?!b.isExit:!1}):[],i=[],r=[...g.faces.filter(l=>!l.isExit),...n],o=(l,m)=>{if(m===r.length)l.isCanonicalWith(s)&&i.push(l);else{const b=r[m],d=b.isExit?[]:A.range(e.includeFaceValueZero?0:1,b.edges.length);e.highlander&&d.push(null),o(l,m+1);for(const x of d){const S=l.clone();S.addFaceValue(b,x),o(S,m+1)}}},a=e.vertexOrderLimit===null?C.empty(g):C.emptyWithVertexOrderLimit(g,e.vertexOrderLimit);o(a,0);const c=(e.prefilterRules??[]).flatMap(l=>l.getEmbeddedRules(P(l.patternBoard,g))),u=[];for(const l of i){console.log(l.toCanonicalString());const m=ft(l,e.solveEdges,e.solveSectors,e.solveFaceColors,e.highlander,{logModulo:e.logModulo});for(const b of m)b.isRedundant(c)||(u.push(b),c.push(...b.getEmbeddedRules(s)))}return A.sortBy(u,l=>l.inputFeatureSet.getInputDifficultyScoreA())};class N{constructor(t,e,s=[],n=!1){this.patternBoard=t,this.mapping=e,this.rules=s,this.highlander=n,p()&&f(s.every(i=>i.patternBoard===t))}static createImplied(t,e,s,n){p()&&f(t),p()&&f(e);const i=s.flatMap(a=>a.rules),r=j({},n,{prefilterRules:i}),o=K(t,r);return new N(t,e,o,!!(n!=null&&n.highlander))}static createImpliedChained(t,e,s){let n=e.flatMap(r=>r.rules);const i=[];for(let r=0;r<t.length;r++){const o=t[r],a=k.get(o);p()&&f(a);const c=j({},s,{prefilterRules:n}),u=K(o,c);u.length&&i.push(new N(o,a,u,!!(s!=null&&s.highlander))),n=[...n,...u]}return i}serialize(){const t={patternBoard:_(this.patternBoard.descriptor),mapping:U(this.mapping),rules:this.rules.map(e=>({input:e.inputFeatureSet.serialize(),output:e.outputFeatureSet.serialize()}))};return this.highlander&&(t.highlander=!0),t}static deserialize(t){const e=!!t.highlander,s=v(t.patternBoard);let n,i,r=Z(s);r?(n=r,i=k.get(n),p()&&f(i)):(n=new G(v(t.patternBoard)),i=Y(t.mapping,n),k.set(n,i));const o=t.rules.map(a=>new W(n,C.deserialize(a.input,n),C.deserialize(a.output,n),e));return new N(n,i,o,e)}}export{ht as B,M as H,N as P,dt as R};
