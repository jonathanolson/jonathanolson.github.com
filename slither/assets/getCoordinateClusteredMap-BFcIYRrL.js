var D=Object.defineProperty;var y=(g,e,s)=>e in g?D(g,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):g[e]=s;var d=(g,e,s)=>(y(g,typeof e!="symbol"?e+"":e,s),s);import{a as H,b as n,_ as p,i as B,z as V}from"./createBoardDescriptor-DQiPBFka.js";import{V as i}from"./Vector2Property-DCXaH-JP.js";class q{constructor(e){d(this,"edges");d(this,"vertices");d(this,"faces");d(this,"halfEdges");d(this,"outerBoundary");d(this,"innerBoundaries");this.boardDescriptor=e,this.edges=e.edges,this.vertices=e.vertices,this.faces=e.faces,this.halfEdges=e.halfEdges,this.outerBoundary=e.outerBoundary,this.innerBoundaries=e.innerBoundaries}}const S=g=>{H()&&(g.edges.forEach(e=>{const s=e.forwardHalf,a=e.reversedHalf;n(s.edge===e),n(a.edge===e),n(!s.isReversed),n(a.isReversed),n(s.reversed===a),n(a.reversed===s),n(s.start===e.start),n(s.end===e.end),n(a.start===e.end),n(a.end===e.start),n(s.next.previous===s),n(s.previous.next===s),n(a.next.previous===a),n(a.previous.next===a),n(s.next!==s),n(s.previous!==s),n(a.next!==a),n(a.previous!==a),n(s.next.face===s.face),n(s.previous.face===s.face),n(a.next.face===a.face),n(a.previous.face===a.face),n(s.face===e.forwardFace),n(a.face===e.reversedFace)}),g.vertices.forEach(e=>{e.incomingHalfEdges.forEach(t=>{n(t.end===e)}),e.outgoingHalfEdges.forEach(t=>{n(t.start===e)});const s=t=>e.incomingHalfEdges[(t+e.incomingHalfEdges.length)%e.incomingHalfEdges.length],a=t=>e.outgoingHalfEdges[(t+e.outgoingHalfEdges.length)%e.outgoingHalfEdges.length];p.range(0,e.incomingHalfEdges.length).forEach(t=>{const c=s(t),o=a(t);n(c.reversed===o),n(c.next===a(t-1)),n(o.previous===s(t+1))}),e.edges.forEach(t=>{n(t.start===e||t.end===e),n(e.incomingHalfEdges.includes(t.forwardHalf)||e.outgoingHalfEdges.includes(t.forwardHalf)),n(e.incomingHalfEdges.includes(t.reversedHalf)||e.outgoingHalfEdges.includes(t.reversedHalf)),t.forwardFace&&(n(t.forwardFace.vertices.includes(e)),n(e.faces.includes(t.forwardFace))),t.reversedFace&&(n(t.reversedFace.vertices.includes(e)),n(e.faces.includes(t.reversedFace)))}),e.faces.forEach(t=>{n(t.vertices.includes(e))})}))};class k extends q{constructor(s,a,t,c=0){let o,u;t?(o=new i(Math.sqrt(3),0).timesScalar(a),u=new i(Math.sqrt(3)/2,3/2).timesScalar(a)):(o=new i(3/2,Math.sqrt(3)/2).timesScalar(a),u=new i(0,Math.sqrt(3)).timesScalar(a));const l=[new i(1,0),new i(1,-1),new i(0,-1),new i(-1,0),new i(-1,1),new i(0,1)],h=p.range(0,6).map(r=>l[r].plus(l[(r+1)%6])),m=r=>h.map(f=>f.plus(r.timesScalar(3))),E=(r,f)=>(Math.abs(r.x-f.x)+Math.abs(r.x+r.y-f.x-f.y)+Math.abs(r.y-f.y))/2,v=[];for(let r=-s;r<=s;r++)for(let f=Math.max(-s,-r-s);f<=Math.min(s,-r+s);f++){const w=new i(r,f);E(w,new i(0,0))>=c&&v.push(w)}const M=p.uniqWith(v.flatMap(m),(r,f)=>r.equals(f)).map(r=>({logicalCoordinates:r,viewCoordinates:o.timesScalar(r.x).plus(u.timesScalar(r.y)).timesScalar(1/3)})),C=v.map(r=>({logicalCoordinates:r,vertices:m(r).map(f=>{const w=M.find(F=>F.logicalCoordinates.equals(f));return H()&&n(w),w})}));super(B(V({vertices:M,faces:C},a)));d(this,"isHexagonal",!0);this.radius=s,this.scale=a,this.isPointyTop=t,this.holeRadius=c,H()&&S(this)}static enumeratePointyFaceCoordinates(s){const a=[];for(let t=-s;t<=s;t++)for(let c=Math.max(-s,-t-s);c<=Math.min(s,-t+s);c++)a.push(new i(c,t));return a}}class z extends q{constructor(s,a){const t=[],c=new Map,o=(l,h)=>{const m=`${l},${h}`;if(!c.has(m)){const E={logicalCoordinates:new i(l,h),viewCoordinates:new i(l,h)};t.push(E),c.set(m,E)}return c.get(m)},u=p.range(0,a).flatMap(l=>p.range(0,s).map(h=>({logicalCoordinates:new i(h,l),vertices:[o(h,l),o(h+1,l),o(h+1,l+1),o(h,l+1)]})));super(B({vertices:t,faces:u}));d(this,"isSquare",!0);this.width=s,this.height=a,H()&&S(this)}}const A=(g,e)=>{const s=p.sortBy(g),a=[];let t=[];for(let o=0;o<s.length;o++){const u=s[o];t.length===0||Math.abs(t[t.length-1]-u)<=e?t.push(u):(a.push(t),t=[u])}t.length>0&&a.push(t);const c=new Map;return a.forEach(o=>{const u=p.sum(o)/o.length;o.forEach(l=>c.set(l,u))}),c};export{q as B,k as H,z as S,A as g,S as v};
