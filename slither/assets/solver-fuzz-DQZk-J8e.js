import{N as E,ai as C,az as x,aE as F,u as H,E as y,aF as k,x as W,aG as z,aH as f,aI as D,_ as v,a as G,b as I}from"./getCoordinateCluteredMap-D2JcnBY_.js";import{p as L,k as M,l as V,P as q,m as d,A as m,n as K}from"./GenerateNode-D6dy5KtZ.js";window.assertions.enableAssert();const P=new E,O=new E({renderer:"svg",children:[P]}),c=new C(O,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(c.domElement);c.setWidthHeight(window.innerWidth,window.innerHeight);console.log("test");const R=e=>{const l=e.generate(e.defaultParameterValues);return new K(l,e.scale??1)},S=[new x(10,10),new F(4,1,!0),...L.map(R)];(async()=>{let e=null;const l=new H(!1);for(;;){console.log("board loaded");const a=S[Math.floor(Math.random()*S.length)],A=await M(a,l),w=await V(A,()=>!0,l),r=w.cleanState.clone();w.blackEdges.forEach(h=>r.setEdgeState(h,y.BLACK)),k(a,r);const p=W.fromSolvedPuzzle(w);e&&e.dispose(),e=new q(p,{scale:30,left:20,top:20}),P.addChild(e),c.updateDisplay(),await d(50);const o=p.stateProperty.value.clone(),g=z(a,o),u=()=>{p.stateProperty.value=o.clone(),c.updateDisplay()};let b=0;for(;!f(o);){if(e.clearAnnotationNodes(),b++>1e5)throw new Error("Solver iteration limit exceeded? Looped?");const h=o.clone(),N=g.clone(h),n=g.nextAction();if(n){console.log(n);const s=new D(a,o,r);e.addAnnotationNode(new m(n.annotation)),u(),await d(0);try{n.apply(s)}catch(i){console.error(i);debugger;const t=N.nextAction();t&&t.apply(s)}n.apply(o)}else if(!f(o)){const s=z(a,o),i=s.nextAction();if(i)throw e.addAnnotationNode(new m(i.annotation)),u(),await d(0),new Error("Fresh solver should not have any actions");s.dispose();const t=v.find(v.shuffle(a.edges),B=>o.getEdgeState(B)===y.WHITE);if(G()&&I(t),o.setEdgeState(t,r.getEdgeState(t)),console.log("setting white edge to red/black",t),!g.dirty)throw new Error("Solver should be dirty after setting edge state")}u(),await d(0)}if(!f(o))throw new Error("Solver did not solve the puzzle")}})();
