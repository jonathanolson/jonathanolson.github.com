import"./Vector2Property-DCXaH-JP.js";import{N as m,e as S}from"./PhetioControlledVisibilityProperty-C1zM_Uw1.js";import{P as g}from"./PatternBoardRuleSet-BglMViWi.js";import{P as z,s as B,d as w}from"./PatternRule-L1F6UIQ_.js";import{a as R,b as f,B as s}from"./BinaryRuleCollection-DM-D9egP.js";import{_ as N}from"./getCoordinateClusteredMap-s__X_7ZN.js";import{n as h,u as b}from"./patternBoards-CdPs5rJx.js";import{B as u}from"./BinaryRuleSequence-COfdv3qY.js";import"./FeatureSet-Brj-qr45.js";import"./logic-solver-C8wJkzp2.js";import"./getSolutionImpliedRules-a_Xnq1eI.js";import"./HighlanderPruner-DN835Mbg.js";import"./getPeriodicTilingGenerator-qmRzQaR8.js";import"./generalPatternBoardGenerations-DiISise0.js";class c{constructor(t,e){this.patternBoards=t,this.serializedRules=e}getRules(){const t=[];return this.forEachRule(e=>t.push(e)),t}get size(){return this.serializedRules.length}getRule(t){return z.collectionDeserialize(this.patternBoards,this.serializedRules[t])}forEachRule(t){for(let e=0;e<this.serializedRules.length;e++){const o=z.collectionDeserialize(this.patternBoards,this.serializedRules[e]);t(o)}}addRule(t){this.patternBoards.includes(t.patternBoard)||this.patternBoards.push(t.patternBoard),this.serializedRules.push(t.collectionSerialize(this.patternBoards.indexOf(t.patternBoard)))}addNonredundantRuleSet(t,e=Number.POSITIVE_INFINITY){const o=this.getRules().flatMap(a=>a.getEmbeddedRules(h(a.patternBoard,t.patternBoard)));let n=0,r=0,l=0,d=0;for(const a of t.rules){const p=a.getInputDifficultyScoreA();if(d=Math.max(d,p),t.patternBoard.faces.length>1&&p>e){l++;continue}a.isRedundant(o)||(this.addRule(a),n+=p,r++,o.push(...a.getEmbeddedRules(h(a.patternBoard,t.patternBoard))))}console.log(`added ${r}, skipped ${l} with average score ${Math.round(n/r)}, maxEncounteredScore ${d}`)}combineWith(t){const e=t.getRules();let o=null,n=[];for(let r=0;r<e.length;r++){r%100===0&&console.log(r,e.length);const l=e[r],d=l.patternBoard;d!==o&&(n=this.getRules().flatMap(a=>a.getEmbeddedRules(h(a.patternBoard,d))),o=d),l.isRedundant(n)||(this.addRule(l),n.push(...l.getEmbeddedRules(h(l.patternBoard,d))))}}serialize(){return{patternBoards:this.patternBoards.map(B),rules:R(JSON.stringify(this.serializedRules))}}static deserialize(t){const e=t.patternBoards.map(w),o=f(t.rules);if(o===null)throw console.log(t.rules),new Error("Failed to decompress rules!");{const n=JSON.parse(o);return new c(e,n)}}static empty(){return new c([],[])}static fromRules(t){const e=N.uniq(t.map(n=>n.patternBoard)),o=t.map(n=>n.collectionSerialize(e.indexOf(n.patternBoard)));return new c(e,o)}}const q=new m,E=new m({renderer:"svg",children:[q]}),C=new S(E,{allowWebGL:!0,allowBackingScaleAntialiasing:!0,allowSceneOverflow:!1});document.body.appendChild(C.domElement);C.setWidthHeight(window.innerWidth,window.innerHeight);window.standardSquareBoardGenerations=b;window.getSequenceName=i=>u.getName(i);window.getEmptySequence=i=>u.empty(i).serialize();window.getSequenceStatus=i=>u.deserialize(i).getStatusString();window.getNextBoardInSequence=i=>{const e=u.deserialize(i).getNextBoard();return e?B(e):null};window.getSequenceWithProcessingBoard=(i,t)=>{const e=u.deserialize(i),o=w(t);return e.addProcessingBoard(o),e.serialize()};window.getSequenceWithoutProcessingBoard=(i,t)=>{const e=u.deserialize(i),o=w(t);return e.removeProcessingBoard(o),e.serialize()};window.getSequenceWithCollection=(i,t,e)=>{const o=u.deserialize(i),n=w(t),r=s.deserialize(e);return o.addProcessedBoardCollection(n,r),o.serialize()};window.getCollectionForSequence=(i,t)=>{const e=u.deserialize(i),o=w(t);return e.getCollectionForBoard(o).serialize()};window.withCollection=(i,t)=>{const e=s.deserialize(i),o=s.deserialize(t);return e.withCollection(o).serialize()};window.withCollectionNonequal=(i,t)=>{const e=s.deserialize(i),o=s.deserialize(t);return e.withCollectionNonequal(o).serialize()};window.withCollectionNonredundant=(i,t)=>{const e=s.deserialize(i),o=s.deserialize(t);return e.withCollectionNonredundant(o).serialize()};window.withoutCollectionNonequal=(i,t)=>{const e=s.deserialize(i),o=s.deserialize(t);return e.withoutCollectionNonequal(o).serialize()};window.withoutCollectionNonredundant=(i,t)=>{const e=s.deserialize(i),o=s.deserialize(t);return e.withoutCollectionNonredundant(o).serialize()};window.addRuleSetToCollection=(i,t,e=Number.POSITIVE_INFINITY)=>{try{console.log(`input: ${i.rules.slice(0,20)}...${i.rules.slice(-20)}`);const o=c.deserialize(i),n=g.deserialize(t);o.addNonredundantRuleSet(n,e);const r=o.serialize();if(!c.deserialize(r))throw new Error("Failed to deserialize what we serialized");return console.log(`output: ${r.rules.slice(0,20)}...${r.rules.slice(-20)}`),r}catch(o){throw console.log(`${o} ${o==null?void 0:o.stack}`),o}};window.addRuleSetToBinaryCollection=(i,t,e=Number.POSITIVE_INFINITY)=>{try{const o=s.deserialize(i),n=g.deserialize(t),l=o.withNonredundantRuleSet(n,e).serialize();if(!s.deserialize(l))throw new Error("Failed to deserialize what we serialized");return l}catch(o){throw console.log(`${o} ${o==null?void 0:o.stack}`),o}};window.combineCollections=(i,t)=>{try{const e=c.deserialize(i),o=c.deserialize(t);return e.combineWith(o),e.serialize()}catch(e){throw console.log(`${e} ${e==null?void 0:e.stack}`),e}};
