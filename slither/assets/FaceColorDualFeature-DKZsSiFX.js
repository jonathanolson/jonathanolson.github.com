var M=Object.defineProperty;var U=(n,e,s)=>e in n?M(n,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[e]=s;var P=(n,e,s)=>(U(n,typeof e!="symbol"?e+"":e,s),s);import{_ as y,a as g,b as m}from"./getCoordinateClusteredMap-DCjAm76-.js";import{L as F}from"./logic-solver-O3GFcRDa.js";import{m as O}from"./Vector2Property-DCXaH-JP.js";class G{constructor(e,s){this.value=e,this.name=s}}const z=n=>n instanceof G?n.name:n.logic,W={type:"true",logic:F.TRUE,parameters:[]};F.FALSE;const b=n=>({type:"or",logic:F.or(...n.map(z)),parameters:n}),d=n=>({type:"and",logic:F.and(...n.map(z)),parameters:n}),u=n=>({type:"not",logic:F.not(z(n)),parameters:[n]}),R=n=>({type:"exactly-one",logic:F.exactlyOne(...n.map(z)),parameters:n}),H=n=>d(n.map(e=>u(e))),J=b,ee=n=>b(n.map(e=>u(e))),K=(n,e)=>{if(e>0){const s=[J(n)];return O.forEachCombination(n,t=>{t.length===n.length-e+1&&s.push(u(d(t.map(i=>u(i)))))}),d(s)}else return W},A=(n,e)=>{const s=[];return O.forEachCombination(n,t=>{t.length===e+1&&s.push(b(t.map(i=>u(i))))}),d(s)},I=n=>u(R(n)),se=n=>d([A(n,2),I(n)]),j=(n,e)=>e===0?H(n):d([K(n,e),A(n,e)]),L=(n,e)=>b(e.map(s=>s===0?d(n.map(t=>u(t))):s===n.length?d(n):j(n,s))),N=n=>L(n,y.range(0,n.length+1).filter(e=>e%2===0)),Q=n=>L(n,y.range(0,n.length+1).filter(e=>e%2===1));class C{constructor(e,s){this.face=e,this.value=s}toCanonicalString(){return`face-${this.face.index}-${this.value??"blank"}`}isPossibleWith(e){return this.face.edges.filter(t=>e(t)).length===this.value}getPossibleFormula(e){return this.value===null?W:j(this.face.edges.map(s=>e(s)),this.value)}embedded(e){return[new C(e.mapFace(this.face),this.value)]}equals(e){return e instanceof C&&e.face===this.face&&e.value===this.value}indexEquals(e){return e instanceof C&&e.face.index===this.face.index&&e.value===this.value}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face",face:this.face.index,value:this.value}}static deserialize(e,s){return new C(s.faces[e.face],e.value)}}class f{constructor(e){this.edge=e}toCanonicalString(){return`black-${this.edge.index}`}isPossibleWith(e){return e(this.edge)}getPossibleFormula(e){return e(this.edge)}embedded(e){return this.edge.isExit?[]:[new f(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof f&&e.edge===this.edge}indexEquals(e){return e instanceof f&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"black-edge",edge:this.edge.index}}static deserialize(e,s){return new f(s.edges[e.edge])}}class l{constructor(e){this.edge=e}toCanonicalString(){return`red-${this.edge.index}`}isPossibleWith(e){return!e(this.edge)}getPossibleFormula(e){return u(e(this.edge))}embedded(e){return this.edge.isExit?e.mapExitEdges(this.edge).map(s=>new l(s)):[new l(e.mapNonExitEdge(this.edge))]}equals(e){return e instanceof l&&e.edge===this.edge}indexEquals(e){return e instanceof l&&e.edge.index===this.edge.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"red-edge",edge:this.edge.index}}static deserialize(e,s){return new l(s.edges[e.edge])}}class S{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-zero-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==0}getPossibleFormula(e){return b(this.sector.edges.map(s=>e(s)))}embedded(e){return[new S(e.mapSector(this.sector))]}equals(e){return e instanceof S&&e.sector===this.sector}indexEquals(e){return e instanceof S&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof f&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-zero",sector:this.sector.index}}static deserialize(e,s){return new S(s.sectors[e.sector])}}class q{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==1}getPossibleFormula(e){return I(this.sector.edges.map(s=>e(s)))}embedded(e){return[new q(e.mapSector(this.sector))]}equals(e){return e instanceof q&&e.sector===this.sector}indexEquals(e){return e instanceof q&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(a=>this.equals(a)))return!0;let s=!1,t=!1,i=!1,r=!1;const c=this.sector.edges[0],h=this.sector.edges[1];for(const a of e)a instanceof f&&(a.edge===c?s=!0:a.edge===h&&(t=!0)),a instanceof l&&(a.edge===c?i=!0:a.edge===h&&(r=!0));return s&&t||i&&r}serialize(){return{type:"sector-not-one",sector:this.sector.index}}static deserialize(e,s){return new q(s.sectors[e.sector])}}class w{constructor(e){this.sector=e}toCanonicalString(){return`sector-not-two-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length!==2}getPossibleFormula(e){return b(this.sector.edges.map(s=>u(e(s))))}embedded(e){return[new w(e.mapSector(this.sector))]}equals(e){return e instanceof w&&e.sector===this.sector}indexEquals(e){return e instanceof w&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){return e.some(s=>this.equals(s)||s instanceof l&&this.sector.edges.includes(s.edge))}serialize(){return{type:"sector-not-two",sector:this.sector.index}}static deserialize(e,s){return new w(s.sectors[e.sector])}}class v{constructor(e){this.sector=e}toCanonicalString(){return`sector-only-one-${this.sector.index}`}isPossibleWith(e){return this.sector.edges.filter(t=>e(t)).length===1}getPossibleFormula(e){return R(this.sector.edges.map(s=>e(s)))}embedded(e){return[new v(e.mapSector(this.sector))]}equals(e){return e instanceof v&&e.sector===this.sector}indexEquals(e){return e instanceof v&&e.sector.index===this.sector.index}isSubsetOf(e){return this.equals(e)}isRedundant(e){if(e.some(i=>this.equals(i)))return!0;let s=!1,t=!1;for(const i of e)i instanceof f&&this.sector.edges.includes(i.edge)?s=!0:i instanceof l&&this.sector.edges.includes(i.edge)&&(t=!0);return s&&t}serialize(){return{type:"sector-only-one",sector:this.sector.index}}static deserialize(e,s){return new v(s.sectors[e.sector])}}class V extends Error{constructor(e,s){super(`Feature ${e.toCanonicalString()} incompatible with ${s.map(t=>t.toCanonicalString()).join(", ")}`),this.mainFeature=e,this.incompatibleFeatures=s}}class o{constructor(e,s){P(this,"allFaces",new Set);P(this,"canonicalString",null);P(this,"sameColorPaths",null);P(this,"oppositeColorPaths",null);if(this.primaryFaces=e,this.secondaryFaces=s,g()&&m(e.length+s.length>1),g()&&m(e.length),this.allFaces=new Set([...e,...s]),this.allFaces.size!==e.length+s.length)throw new V(this,[])}toCanonicalString(){if(this.canonicalString===null){const e=y.sortBy(this.primaryFaces.map(c=>c.index)),s=y.sortBy(this.secondaryFaces.map(c=>c.index)),t=e.length>s.length||e.length===s.length&&e[0]<s[0],i=t?e:s,r=t?s:e;this.canonicalString=`face-color-dual-${i.join(",")}-${r.join(",")}`}return this.canonicalString}isPossibleWith(e){for(const s of this.getSameColorPaths())if(s.filter(t=>e(t)).length%2!==0)return!1;for(const s of this.getOppositeColorPaths())if(s.filter(t=>e(t)).length%2===0)return!1;return!0}getPossibleFormula(e){return d([...this.getSameColorPaths().map(s=>N(s.map(t=>e(t)))),...this.getOppositeColorPaths().map(s=>Q(s.map(t=>e(t))))])}embedded(e){const s=y.uniq(this.primaryFaces.map(i=>e.mapFace(i))),t=y.uniq(this.secondaryFaces.map(i=>e.mapFace(i)));return s.length===1&&t.length===0?[]:[new o(s,t)]}equals(e){if(!(e instanceof o)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(r=>i.includes(r));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}indexEquals(e){if(!(e instanceof o)||this.primaryFaces.length+this.secondaryFaces.length!==e.primaryFaces.length+e.secondaryFaces.length)return!1;const s=(t,i)=>t.length===i.length&&t.every(r=>i.some(c=>r.index===c.index));return s(this.primaryFaces,e.primaryFaces)&&s(this.secondaryFaces,e.secondaryFaces)||s(this.primaryFaces,e.secondaryFaces)&&s(this.secondaryFaces,e.primaryFaces)}isSubsetOf(e){if(!(e instanceof o)||this.allFaces.size>e.allFaces.size)return!1;for(const t of this.allFaces.values())if(!e.allFaces.has(t))return!1;return e.primaryFaces.includes(this.primaryFaces[0])?this.primaryFaces.every(t=>e.primaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.secondaryFaces.includes(t)):this.primaryFaces.every(t=>e.secondaryFaces.includes(t))&&this.secondaryFaces.every(t=>e.primaryFaces.includes(t))}isRedundant(e){return e.some(s=>this.equals(s))}serialize(){return{type:"face-color-dual",primaryFaces:this.primaryFaces.map(e=>e.index),secondaryFaces:this.secondaryFaces.map(e=>e.index)}}overlapsWith(e){for(const s of this.allFaces)if(e.allFaces.has(s))return!0;return!1}union(e){const s=this.primaryFaces.some(i=>e.primaryFaces.includes(i))||this.secondaryFaces.some(i=>e.secondaryFaces.includes(i)),t=this.primaryFaces.some(i=>e.secondaryFaces.includes(i))||this.secondaryFaces.some(i=>e.primaryFaces.includes(i));return g()&&m(s||t),s&&t?null:s?o.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.primaryFaces])],[...new Set([...this.secondaryFaces,...e.secondaryFaces])]):o.fromPrimarySecondaryFaces([...new Set([...this.primaryFaces,...e.secondaryFaces])],[...new Set([...this.secondaryFaces,...e.primaryFaces])])}ensurePaths(){if(this.sameColorPaths===null){const e=[],s=[],t=new Set([...this.primaryFaces,...this.secondaryFaces]),i=this.primaryFaces[0],r=new Set([i]);for(let c=1;r.size<t.size;c++){if(c>100)throw new Error("FaceColorDualFeature.fromPrimarySecondaryFaces: could not find all connections");const h=(a,k,$)=>{for(const x of a.edges){if(x.faces.length!==2||k.includes(x))continue;const p=x.faces.find(E=>E!==a);if(g()&&m(p),!r.has(p))if(t.has(p)){const E=[...k,x],T=$,B=p;this.primaryFaces.includes(T)===this.primaryFaces.includes(B)?e.push(E):s.push(E),r.add(p)}else h(p,[...k,x],$)}};[...r].forEach(a=>h(a,[],a))}this.sameColorPaths=e,this.oppositeColorPaths=s}}getSameColorPaths(){return this.ensurePaths(),this.sameColorPaths}getOppositeColorPaths(){return this.ensurePaths(),this.oppositeColorPaths}isCompatibleWith(e){let s=!1,t=!1;const i=new Set([...this.allFaces].filter(r=>e.allFaces.has(r)));for(const r of this.primaryFaces)i.has(r)&&(e.primaryFaces.includes(r)&&(s=!0),e.secondaryFaces.includes(r)&&(t=!0));for(const r of this.secondaryFaces)i.has(r)&&(e.primaryFaces.includes(r)&&(t=!0),e.secondaryFaces.includes(r)&&(s=!0));return!s||!t}static areCanonicalWith(e,s){const t=e.map(i=>i.toCanonicalString()).sort().join("//");for(const i of s)if(e.map(c=>{const h=c.embedded(i);return g()&&m(h.length===1),h[0].toCanonicalString()}).sort().join("//")<t)return!1;return!0}static deserialize(e,s){return new o(e.primaryFaces.map(t=>s.faces[t]),e.secondaryFaces.map(t=>s.faces[t]))}static fromPrimarySecondaryFaces(e,s){return g()&&m(e.length+s.length>1),g()&&m(e.length),new o(e,s)}}export{f as B,o as F,V as I,l as R,S,G as T,q as a,w as b,v as c,C as d,se as e,d as f,ee as g,W as h,u as i,b as l};
