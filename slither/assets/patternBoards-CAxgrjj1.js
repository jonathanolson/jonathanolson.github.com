var Fe=Object.defineProperty;var Pe=(t,e,s)=>e in t?Fe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var G=(t,e,s)=>(Pe(t,typeof e!="symbol"?e+"":e,s),s);import{e as h,f as d,_ as T,S as Se,H as Be}from"./getCoordinateClusteredMap-DnTHDDo2.js";import{V as y}from"./Vector2Property-95p6aBvi.js";import{P as ve,g as J,t as Ne,f as Ce,r as Ge,s as Te,h as Ae,j as ze,k as Ie,o as $e,w as Oe,y as ke,z as je}from"./getPeriodicTilingGenerator-B19VRuYW.js";class le{constructor(e,s,a,i,x,f,c){G(this,"isAutomorphism");G(this,"isIdentityAutomorphism");G(this,"vertexInverseMap");G(this,"edgeInverseMap");G(this,"sectorInverseMap");G(this,"faceInverseMap");this.sourcePatternBoard=e,this.targetPatternBoard=s,this.vertexMap=a,this.nonExitEdgeMap=i,this.exitEdgeMap=x,this.sectorMap=f,this.faceMap=c,this.isAutomorphism=e===s,this.isAutomorphism&&(this.vertexInverseMap=new Map(Array.from(a).map(([r,n])=>[n,r])),this.sectorInverseMap=new Map(Array.from(f).map(([r,n])=>[n,r])),this.faceInverseMap=new Map(Array.from(c).map(([r,n])=>[n,r])),this.edgeInverseMap=new Map([...Array.from(i).map(([r,n])=>[n,r]),...Array.from(x).map(([r,n])=>(h()&&d(n.length===1),[n[0],r]))])),this.isIdentityAutomorphism=this.computeIsIdentityAutomorphism()}getVertexMap(){return this.vertexMap}getNonExitEdgeMap(){return this.nonExitEdgeMap}getExitEdgeMap(){return this.exitEdgeMap}getSectorMap(){return this.sectorMap}getFaceMap(){return this.faceMap}mapVertex(e){const s=this.vertexMap.get(e);return h()&&d(s),s}mapNonExitEdge(e){const s=this.nonExitEdgeMap.get(e);return h()&&d(s),s}mapExitEdges(e){const s=this.exitEdgeMap.get(e);return h()&&d(s),s}mapSector(e){const s=this.sectorMap.get(e);return h()&&d(s),s}mapFace(e){const s=this.faceMap.get(e);return h()&&d(s),s}equals(e){return this.vertexMap.size===e.vertexMap.size&&this.nonExitEdgeMap.size===e.nonExitEdgeMap.size&&this.exitEdgeMap.size===e.exitEdgeMap.size&&this.sectorMap.size===e.sectorMap.size&&this.faceMap.size===e.faceMap.size&&Array.from(this.vertexMap).every(([s,a])=>e.vertexMap.get(s)===a)&&Array.from(this.nonExitEdgeMap).every(([s,a])=>e.nonExitEdgeMap.get(s)===a)&&Array.from(this.exitEdgeMap).every(([s,a])=>e.exitEdgeMap.get(s)===a)&&Array.from(this.sectorMap).every(([s,a])=>e.sectorMap.get(s)===a)&&Array.from(this.faceMap).every(([s,a])=>e.faceMap.get(s)===a)}toString(){return`Embedding(
  vertexMap: ${[...this.vertexMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
  nonExitEdgeMap: ${[...this.nonExitEdgeMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  exitEdgeMap: ${[...this.exitEdgeMap].map(e=>`${e[0].index} => [${e[1].map(s=>s.index).join(", ")}]`).join(", ")}
  sectorMap: ${[...this.sectorMap].map(e=>`${e[0].index} => ${e[1].index}`).join(", ")}
  faceMap: ${[...this.faceMap].map(e=>`${e[0].index} ${e[0].isExit?"->":"=>"} ${e[1].index}`).join(", ")}
)`}computeIsIdentityAutomorphism(){if(this.sourcePatternBoard!==this.targetPatternBoard)return!1;for(const e of this.vertexMap.keys())if(this.vertexMap.get(e)!==e)return!1;for(const e of this.nonExitEdgeMap.keys())if(this.nonExitEdgeMap.get(e)!==e)return!1;for(const e of this.exitEdgeMap.keys())if(this.exitEdgeMap.get(e).length!==1||this.exitEdgeMap.get(e)[0]!==e)return!1;for(const e of this.sectorMap.keys())if(this.sectorMap.get(e)!==e)return!1;for(const e of this.faceMap.keys())if(this.faceMap.get(e)!==e)return!1;return!0}}const qe=(t,e)=>{if(t.faces.filter(i=>!i.isExit).length>e.faces.filter(i=>!i.isExit).length||t.sectors.length>e.sectors.length||t.edges.filter(i=>!i.isExit).length>e.edges.filter(i=>!i.isExit).length||t.vertices.length>e.vertices.length)return[];const s=[],a=t.faces.filter(i=>!i.isExit);if(a.length){const i=a[0],x=[i],f=[],c=[],r=new Set(a.slice(1)),n=new Set(i.edges),l=new Set(i.vertices);for(;r.size;){const o=T.maxBy([...r],u=>{let g=0;for(const p of u.edges)n.has(p)&&(g+=5);for(const p of u.vertices)l.has(p)&&(g+=1);return g});h()&&d(o),x.push(o),f.push(T.findIndex(o.edges,u=>n.has(u))),c.push(T.findIndex(o.vertices,u=>l.has(u))),r.delete(o);for(const u of o.edges)n.add(u);for(const u of o.vertices)l.add(u)}const v=(o,u,g)=>{if(o.edges.length!==u.edges.length)return!1;for(let p=0;p<o.edges.length;p++){const E=o.edges[p],M=u.edges[g.mapEdgeIndex(p)];h()&&d(E.faces.includes(o)),h()&&d(M.faces.includes(u));const w=E.faces[0]===o?E.faces[1]:E.faces[0];if(!w.isExit){const V=M.faces[0]===u?M.faces[1]:M.faces[0];if(V.isExit||w.edges.length!==V.edges.length)return!1}}return!0};for(const o of e.faces)if(!o.isExit&&o.edges.length===i.edges.length)for(const u of re.allForOrder(o.edges.length)){if(!v(i,o,u))continue;const g=new Map,p=new Map,E=new Map,M=new Map,w=new Map;g.set(i,u),p.set(i,o),E.set(o,i);for(let F=0;F<i.vertices.length;F++){const P=i.vertices[F],S=o.vertices[u.mapVertexIndex(F)];M.set(P,S),w.set(S,P)}const V=(F,P,S,$,N,O)=>{if(h()&&d(N.size===O.size),F===x.length){h()&&d(N.size===t.vertices.length);const m=new Map,K=new Set;for(const[B,A]of S){const C=P.get(B);for(let k=0;k<B.edges.length;k++){const L=B.edges[k],j=A.edges[C.mapEdgeIndex(k)];h()&&m.has(L)&&d(m.get(L)===j),m.set(L,j),K.add(j)}}h()&&d(m.size===t.edges.filter(B=>!B.isExit).length);const ie=new Map;for(const B of t.edges.filter(A=>A.isExit)){const A=B.exitVertex;h()&&d(A);const C=N.get(A);h()&&d(C),ie.set(B,C.edges.filter(k=>!K.has(k)))}for(const B of t.faces.filter(A=>A.isExit)){const A=B.edges[0];h()&&d(A&&B.edges.length===1);const C=m.get(A),k=A.faces[0]===B?A.faces[1]:A.faces[0],L=S.get(k),j=C.faces[0]===L?C.faces[1]:C.faces[0];h()&&d(j),S.set(B,j)}const R=new Map;for(const B of t.sectors){const A=B.face,C=S.get(A);h()&&d(C);const k=B.edges[0],L=B.edges[1],j=m.get(k),Q=m.get(L);h()&&d(j&&Q);const q=C.sectors.find(U=>U.edges.includes(j)&&U.edges.includes(Q));h()&&d(q),R.set(B,q)}s.push(new le(t,e,N,m,ie,R,S))}else{const m=x[F],K=f[F-1],ie=c[F-1];if(K>=0){const R=m.edges[K],B=R.vertices[0],A=R.vertices[1],C=N.get(B),k=N.get(A),L=R.faces[0]===m?R.faces[1]:R.faces[0],j=S.get(L);h()&&d(j);const Q=j.edges.find(ee=>ee.vertices.includes(C)&&ee.vertices.includes(k));h()&&d(Q);const q=Q.faces[0]===j?Q.faces[1]:Q.faces[0];if(q.isExit||$.has(q))return;const U=m.vertices.indexOf(B),Y=m.vertices.indexOf(A),X=q.vertices.indexOf(C),te=q.vertices.indexOf(k),oe=(U+1)%m.vertices.length===Y,ge=(X+1)%q.vertices.length===te,b=oe===ge?1:-1,_=(X-U*b+m.vertices.length)%m.vertices.length,Z=new re(m.vertices.length,_,b);if(h()&&d(Z.mapVertexIndex(U)===X),h()&&d(Z.mapVertexIndex(Y)===te),!v(m,q,Z)||(S.set(m,q),$.set(q,m),S.size!==$.size))return;for(let ee=0;ee<m.vertices.length;ee++){const ae=m.vertices[ee],ce=q.vertices[Z.mapVertexIndex(ee)];if(N.has(ae)){if(N.get(ae)!==ce)return}else N.set(ae,ce);if(O.has(ce)){if(O.get(ce)!==ae)return}else O.set(ce,ae);h()&&d(N.size===O.size)}P.set(m,Z),V(F+1,P,S,$,N,O)}else{h()&&d(ie>=0,"If this is not satisfied, we have disconnected components OR orderedFaces order is bad");const R=m.vertices[ie],B=N.get(R),A=B.faces.filter(C=>!C.isExit&&!$.has(C));for(const C of A){const k=m.vertices.indexOf(R),L=C.vertices.indexOf(B);h()&&d(k>=0),h()&&d(L>=0);for(const j of[1,-1]){const Q=(L-k*j+m.vertices.length)%m.vertices.length,q=new re(m.vertices.length,Q,j);if(!v(m,C,q))continue;let U=!0;const Y=new Map(N),X=new Map(O);for(let b=0;b<m.vertices.length;b++){const _=m.vertices[b],Z=C.vertices[q.mapVertexIndex(b)];if(Y.has(_)){if(Y.get(_)!==Z){U=!1;break}}else Y.set(_,Z);if(X.has(Z)){if(X.get(Z)!==_){U=!1;break}}else X.set(Z,_);h()&&d(Y.size===X.size)}if(!U)continue;const te=new Map(S),oe=new Map($);if(te.set(m,C),oe.set(C,m),te.size!==oe.size)continue;const ge=new Map(P);ge.set(m,q),V(F+1,ge,te,oe,Y,X)}}}}};V(1,g,p,E,M,w)}}else if(t.vertices.length===1){const i=t.vertices[0];h()&&d(i.edges.length===t.edges.length);const x=i.edges.filter(n=>!n.isExit),f=i.edges.filter(n=>!n.isExit).length,c=i.isExit,r=T.range(0,f).map(n=>{const l=x[n],v=x.slice(0,n+1);return i.sectors.filter(o=>o.edges.includes(l)&&o.edges.every(u=>v.includes(u)))});if(h()&&d(r.flat().length===i.sectors.length),h()&&!i.isExit){d(i.sectors.length===f);for(let n=0;n<f;n++){const l=i.edges[n],v=i.edges[(n+1)%f],o=i.sectors[n],u=i.faces[n];d(o.edges.includes(l)),d(o.edges.includes(v)),d(o.face===u)}}for(const n of e.vertices){if(c){if(n.edges.length<f||n.sectors.length<i.sectors.length)continue}else{if(n.isExit||n.edges.length!==f)continue;h()&&d(n.sectors.length===f)}const l=new Map([[i,n]]),v=(o,u,g,p)=>{if(o===f){h()&&d(u.size===x.length),h()&&d(g.size===t.sectors.length);const E=c?new Map([[i.exitEdge,n.edges.filter(w=>!p.has(w))]]):new Map,M=new Map([...g.keys()].map(w=>[w.face,g.get(w).face]));if(i.sectors.length===0)for(const[w,V]of u){const F=w.faces[0],P=w.faces[1];h()&&d(F.isExit&&P.isExit),M.set(F,V.faces[0]),M.set(P,V.faces[1])}else if(c){for(const w of t.faces.filter(V=>V.isExit))if(w.edges.length===1){const V=w.edges[0];h()&&d(V&&w.edges.length===1);const F=u.get(V);h()&&d(F);const P=V.faces[0]===w?V.faces[1]:V.faces[0],S=M.get(P);h()&&d(S);const $=F.faces[0]===S?F.faces[1]:F.faces[0];h()&&d($),M.set(w,$)}}else for(const w of t.sectors){const V=w.face,P=g.get(w).face;M.set(V,P)}s.push(new le(t,e,l,u,E,g,M))}else{const E=x[o],M=r[o];for(const w of n.edges){if(w.isExit||p.has(w))continue;const V=[];let F=!0;for(const P of M){const S=P.edges[0],$=P.edges[1],N=S===E?w:u.get(S),O=$===E?w:u.get($);h()&&d(N&&O);const m=n.sectors.find(K=>K.edges.includes(N)&&K.edges.includes(O)&&(f>2||!V.includes(K)))??null;if(m)V.push(m);else{F=!1;break}}if(F){const P=new Map(u);P.set(E,w);const S=new Map(g);for(let N=0;N<M.length;N++)S.set(M[N],V[N]);const $=new Set(p);$.add(w),v(o+1,P,S,$)}}}};v(0,new Map,new Map,new Set)}}else if(t.vertices.length===0&&t.edges.length===1){const i=t.edges[0];for(const x of e.edges.filter(f=>!f.isExit))s.push(new le(t,e,new Map,new Map([[i,x]]),new Map,new Map,new Map([[i.faces[0],x.faces[0]],[i.faces[1],x.faces[1]]])))}else throw new Error("pattern search not implemented generally yet");return h()&&t===e&&d(s.filter(i=>i.isIdentityAutomorphism).length===1),s};class re{constructor(e,s,a){this.edgeCount=e,this.offset=s,this.direction=a,h()&&d(a===1||a===-1)}mapVertexIndex(e){return(this.offset+e*this.direction+this.edgeCount)%this.edgeCount}mapEdgeIndex(e){return this.direction===1?(this.offset+e)%this.edgeCount:(this.offset-e-1+2*this.edgeCount)%this.edgeCount}toString(){return`FaceMapping( edgeCount=${this.edgeCount}, offset=${this.offset}, direction=${this.direction} )`}toDetailedString(e,s){return`FaceMapping( vertices: ${T.range(0,this.edgeCount).map(a=>`${e.vertices[a].index} => ${s.vertices[this.mapVertexIndex(a)].index}`).join(", ")}, edges: ${T.range(0,this.edgeCount).map(a=>{const i=e.edges[a],x=s.edges[this.mapEdgeIndex(a)];return`#${i.index} (${i.vertices.map(f=>f.index).join(",")}) => #${x.index} (${x.vertices.map(f=>f.index).join(",")})`}).join(", ")} )`}static allForOrder(e){return[...T.range(0,e).map(s=>new re(e,s,1)),...T.range(0,e).map(s=>new re(e,s,-1))]}}const ue=new WeakMap,pe=(t,e)=>{let s=ue.get(t)??null;s||(s=new WeakMap,ue.set(t,s));let a=s.get(e)??null;return a||(a=qe(t,e),s.set(e,a)),a},De=(t,e)=>{if(t.numNonExitVertices!==e.numNonExitVertices||t.numExitVertices!==e.numExitVertices||t.type!==e.type)return!1;if(t.type==="faces"&&e.type==="faces"){if(t.vertexLists.length!==e.vertexLists.length)return!1;for(let s=0;s<t.vertexLists.length;s++){if(t.vertexLists[s].length!==e.vertexLists[s].length)return!1;for(let a=0;a<t.vertexLists[s].length;a++)if(t.vertexLists[s][a]!==e.vertexLists[s][a])return!1}}if(t.type==="non-exit-vertex"&&e.type==="non-exit-vertex"&&t.edgeCount!==e.edgeCount)return!1;if(t.type==="exit-vertex"&&e.type==="exit-vertex"){if(t.edgeCount!==e.edgeCount||t.spans.length!==e.spans.length)return!1;for(let s=0;s<t.spans.length;s++)if(t.spans[s]!==e.spans[s])return!1}return!0},Le=t=>{const e=[];e.push(t.numNonExitVertices),e.push(t.numExitVertices),e.push(t.type),t.type==="faces"?e.push(t.vertexLists):(t.type==="non-exit-vertex"||t.type==="exit-vertex")&&(e.push(t.edgeCount),t.type==="exit-vertex"&&e.push(t.spans));const s=JSON.stringify(e);return h()&&d(De(we(s),t)),s},we=t=>{const e=JSON.parse(t),s=e.shift(),a=e.shift(),i=e.shift();return i==="faces"?{numNonExitVertices:s,numExitVertices:a,type:i,vertexLists:e.shift()}:i==="non-exit-vertex"?{numNonExitVertices:s,numExitVertices:a,type:i,edgeCount:e.shift()}:i==="exit-vertex"?{numNonExitVertices:s,numExitVertices:a,type:i,edgeCount:e.shift(),spans:e.shift()}:{numNonExitVertices:s,numExitVertices:a,type:i}};class Ee{constructor(e,s){G(this,"exitEdge",null);G(this,"edges",[]);G(this,"sectors",[]);G(this,"faces",[]);this.index=e,this.isExit=s}}class se{constructor(e,s,a=null){G(this,"vertices");G(this,"sectors",[]);G(this,"faces",[]);this.index=e,this.isExit=s,this.exitVertex=a,this.vertices=a?[a]:[]}}class he{constructor(e,s,a){G(this,"face");this.index=e,this.vertex=s,this.edges=a}}class H{constructor(e,s,a,i,x){this.index=e,this.isExit=s,this.vertices=a,this.edges=i,this.sectors=x}}class I{constructor(e,s){G(this,"name");G(this,"vertices");G(this,"edges");G(this,"sectors");G(this,"faces");this.descriptor=e;const a=[...T.range(0,e.numNonExitVertices).map(c=>new Ee(c,!1)),...T.range(0,e.numExitVertices).map(c=>new Ee(c+e.numNonExitVertices,!0))];let i=[],x=[],f=[];if(e.type==="faces"){for(const c of e.vertexLists){const r=c.map(o=>a[o]),n=r.map((o,u)=>{const g=r[(u+1)%r.length],p=o.edges.find(E=>E.vertices.includes(g));if(p)return p;{const E=new se(i.length,!1),M=o.index<g.index?o:g,w=o.index<g.index?g:o;return E.vertices.push(M),E.vertices.push(w),i.push(E),o.edges.push(E),g.edges.push(E),E}}),l=n.map((o,u)=>{const g=n[(u+1)%n.length],p=o.vertices.find(M=>g.vertices.includes(M));h()&&d(p);const E=new he(x.length,p,[o,g]);return x.push(E),o.sectors.push(E),g.sectors.push(E),p.sectors.push(E),E}),v=new H(f.length,!1,r,n,l);f.push(v),r.forEach(o=>{o.faces.push(v)}),l.forEach(o=>{o.face=v}),n.forEach(o=>{o.faces.push(v)})}i.forEach(c=>{if(c.faces.length<2){h()&&d(c.faces.length===1);const r=new H(f.length,!0,c.vertices,[c],[]);f.push(r),c.faces.push(r),c.vertices.forEach(n=>{n.faces.push(r)})}}),a.forEach(c=>{if(c.isExit){const r=new se(i.length,!0,c);i.push(r),c.edges.push(r),c.exitEdge=r}})}else if(e.type==="edge"){h()&&d(a.length===0);const c=new se(0,!1,null);i.push(c);const r=new H(0,!0,[],[c],[]);f.push(r);const n=new H(1,!0,[],[c],[]);f.push(n),c.faces.push(r),c.faces.push(n)}else if(e.type==="non-exit-vertex"){h()&&d(a.length===1&&!a[0].isExit);const c=a[0];i.push(...T.range(0,e.edgeCount).map(r=>{const n=new se(r,!1);return c.edges.push(n),n.vertices.push(c),n})),x.push(...T.range(0,e.edgeCount).map(r=>{const n=new he(r,c,[i[r],i[(r+1)%e.edgeCount]]);return n.edges.forEach(l=>{l.sectors.push(n)}),c.sectors.push(n),n})),f.push(...T.range(0,e.edgeCount).map(r=>{const n=x[r],l=new H(r,!0,[c],[i[r],i[(r+1)%e.edgeCount]],[n]);return c.faces.push(l),l.edges.forEach(v=>{v.faces.push(l)}),n.face=l,l}))}else if(e.type==="exit-vertex"){h()&&d(a.length===1&&a[0].isExit);const c=a[0];i.push(...T.range(0,e.edgeCount).map(n=>{const l=new se(n,!1);return c.edges.push(l),l.vertices.push(c),l}));const r=new se(i.length,!0,c);if(i.push(r),c.edges.push(r),c.exitEdge=r,e.spans.length){const n=[];let l=0;e.spans.forEach((v,o)=>{const u=l,g=u+v;l=g+1,n.push(T.range(u,g+1).map(p=>i[p]))}),h()&&d(l===e.edgeCount),n.forEach(v=>{for(let o=0;o<v.length-1;o++){const u=v[o],g=v[o+1],p=new he(x.length,c,[u,g]);x.push(p),u.sectors.push(p),g.sectors.push(p),c.sectors.push(p);const E=new H(f.length,!0,[c],[u,g],[p]);f.push(E),c.faces.push(E),u.faces.push(E),g.faces.push(E),p.face=E}}),n.forEach(v=>{const o=v[0],u=v[v.length-1],g=new H(f.length,!0,[c],[o],[]);f.push(g),o.faces.push(g),c.faces.push(g);const p=new H(f.length,!0,[c],[u],[]);f.push(p),u.faces.push(p),c.faces.push(p)})}else{h()&&d(e.edgeCount===2);const n=i[0],l=i[1],v=new H(f.length,!0,[c],[n],[]);f.push(v),n.faces.push(v),c.faces.push(v);const o=new H(f.length,!0,[c],[n],[]);f.push(o),n.faces.push(o),c.faces.push(o);const u=new H(f.length,!0,[c],[l],[]);f.push(u),l.faces.push(u),c.faces.push(u);const g=new H(f.length,!0,[c],[l],[]);f.push(g),l.faces.push(g),c.faces.push(g)}}else throw new Error(`Invalid descriptor: ${e}`);this.vertices=a,this.edges=i,this.sectors=x,this.faces=f,s&&(this.name=s)}serialize(){return Le(this.descriptor)}static deserialize(e){return new I(we(e))}}const He=new WeakMap,ne=.3,Re=t=>(h()&&d(t.vertices.length===0),h()&&d(t.sectors.length===0),h()&&d(t.faces.length===2),h()&&d(t.edges.length===1),{vertexMap:new Map,edgeMap:new Map([[t.edges[0],[new y(0,0),new y(1,0)]]]),sectorMap:new Map,faceMap:new Map([[t.faces[0],[new y(0,0),new y(1,0),new y(.5,ne)]],[t.faces[1],[new y(0,0),new y(.5,-ne),new y(1,0)]]])}),me=t=>{h()&&d(t.vertices.length===1);const e=t.edges.filter(r=>!r.isExit),s=e.length,a=s===2&&t.sectors.length?3:s,i=new Map([[t.vertices[0],y.ZERO]]),x=new Map;t.edges.forEach((r,n)=>{x.set(r,[y.ZERO,y.createPolar(1,2*Math.PI*n/a)])});const f=new Map;t.sectors.forEach(r=>{const n=r.edges[0],l=r.edges[1];(n.index+1)%s!==l.index?f.set(r,[x.get(n)[1],y.ZERO,x.get(l)[1]]):f.set(r,[x.get(l)[1],y.ZERO,x.get(n)[1]])});const c=new Map;return s===2&&t.sectors.length===0?(e[0].faces.forEach((r,n)=>{c.set(r,n===0?[new y(0,0),new y(1,0),new y(.5,ne)]:[new y(0,0),new y(.5,-ne),new y(1,0)])}),e[1].faces.forEach((r,n)=>{c.set(r,n===0?[new y(0,0),new y(-.5,ne),new y(-1,0)]:[new y(0,0),new y(-1,0),new y(-.5,-ne)])})):(t.sectors.forEach((r,n)=>{const l=f.get(r).slice();n===1&&s===2&&(l[1]=l[0].plus(l[2]).negated()),c.set(r.face,l)}),t.faces.forEach(r=>{if(!c.has(r)){h()&&d(r.edges.length===1);const n=r.edges[0],l=x.get(n);h()&&d(n.sectors.length===1);const v=n.sectors[0];{const o=l[1].perpendicular;let u=0;f.get(v).forEach(p=>u+=p.dot(o));const g=l[1].timesScalar(.5);c.set(r,[l[1],y.ZERO,g.plus(o.times(-Math.sign(u)*.5*Math.sin(2*Math.PI/3/s)))])}}})),{vertexMap:i,edgeMap:x,sectorMap:f,faceMap:c}},Bt=t=>{if(h()){const r=n=>{d(n.every(l=>l.index<n.length))};r([...t.vertexMap.keys()]),r([...t.edgeMap.keys()]),r([...t.sectorMap.keys()]),r([...t.faceMap.keys()])}const e=T.sortBy([...t.vertexMap.keys()],r=>r.index),s=T.sortBy([...t.edgeMap.keys()],r=>r.index),a=T.sortBy([...t.sectorMap.keys()],r=>r.index),i=T.sortBy([...t.faceMap.keys()],r=>r.index),x=r=>[r.x,r.y],f=r=>{for(let n=0;n<e.length;n++)if(t.vertexMap.get(e[n]).equals(r))return n;return x(r)},c=JSON.stringify([e.map(r=>x(t.vertexMap.get(r))),s.map(r=>t.edgeMap.get(r).map(f)),a.map(r=>t.sectorMap.get(r).map(x)),i.map(r=>t.faceMap.get(r).map(x))]);if(h()){const r=Ze(c,{vertices:e,edges:s,sectors:a,faces:i,descriptor:{}}),n=(l,v)=>{if(l.length!==v.length)return!1;for(let o=0;o<l.length;o++)if(!l[o].equals(v[o]))return!1;return!0};e.forEach(l=>d(t.vertexMap.get(l).equals(r.vertexMap.get(l)))),s.forEach(l=>d(n(t.edgeMap.get(l),r.edgeMap.get(l)))),a.forEach(l=>d(n(t.sectorMap.get(l),r.sectorMap.get(l)))),i.forEach(l=>d(n(t.faceMap.get(l),r.faceMap.get(l))))}return c},Ze=(t,e)=>{const s=JSON.parse(t),a=s[0],i=s[1],x=s[2],f=s[3],c=new Map,r=new Map,n=new Map,l=new Map;a.forEach((o,u)=>{c.set(e.vertices[u],new y(o[0],o[1]))});const v=o=>typeof o=="number"?c.get(e.vertices[o]):new y(o[0],o[1]);return i.forEach((o,u)=>{r.set(e.edges[u],[v(o[0]),v(o[1])])}),x.forEach((o,u)=>{n.set(e.sectors[u],[v(o[0]),v(o[1]),v(o[2])])}),f.forEach((o,u)=>{l.set(e.faces[u],o.map(g=>new y(g[0],g[1])))}),{vertexMap:c,edgeMap:r,sectorMap:n,faceMap:l}},Me=(t,e)=>t.vertices.length!==e.vertices.length||t.edges.length!==e.edges.length||t.faces.length!==e.faces.length||t.sectors.length!==e.sectors.length||t.vertices.filter(s=>s.isExit).length!==e.vertices.filter(s=>s.isExit).length||t.edges.filter(s=>s.isExit).length!==e.edges.filter(s=>s.isExit).length||t.faces.filter(s=>s.isExit).length!==e.faces.filter(s=>s.isExit).length?!1:pe(t,e).length>0&&pe(e,t).length>0,Je=(t,e)=>{if(t.forwardHalf.next.edge===e)return t.forwardHalf;if(t.reversedHalf.next.edge===e)return t.reversedHalf;if(e.forwardHalf.next.edge===t)return e.forwardHalf;if(e.reversedHalf.next.edge===t)return e.reversedHalf;throw new Error("Edges are not connected")};class z extends I{constructor(s,a){const i=new Set,x=new Set;a.forEach(g=>{g.vertices.forEach(p=>{i.add(p)}),g.edges.forEach(p=>{x.add(p)})});const f=Array.from(x),c=[],r=[];for(const g of i)g.faces.every(p=>a.includes(p))?r.push(g):c.push(g);const n=[...r,...c];super({numNonExitVertices:r.length,numExitVertices:c.length,type:"faces",vertexLists:a.map(g=>g.vertices.map(p=>n.indexOf(p)))});G(this,"patternBoard");G(this,"planarPatternMap");this.originalBoard=s,this.originalBoardFaces=a;const l=new Map(n.map((g,p)=>[this.vertices[p],g.viewCoordinates])),v=new Map;this.edges.forEach(g=>{if(!g.isExit){const p=n[g.vertices[0].index],E=n[g.vertices[1].index];v.set(g,[p.viewCoordinates,E.viewCoordinates])}});const o=new Map;this.sectors.forEach(g=>{h()&&d(g.edges.length===2);const p=n[g.edges[0].vertices[0].index],E=n[g.edges[0].vertices[1].index],M=n[g.edges[1].vertices[0].index],w=n[g.edges[1].vertices[1].index],V=f.find(O=>O.vertices.includes(p)&&O.vertices.includes(E)),F=f.find(O=>O.vertices.includes(M)&&O.vertices.includes(w));h()&&d(V&&F);const P=Je(V,F);h()&&d(P);const S=P.start.viewCoordinates,$=P.end.viewCoordinates,N=P.next.end.viewCoordinates;o.set(g,[S,$,N])});const u=new Map;this.faces.forEach(g=>{if(!g.isExit){const p=g.vertices.map(w=>n[w.index]),E=a.find(w=>w.vertices.every(V=>p.includes(V)));h()&&d(E);const M=E.vertices.map(w=>w.viewCoordinates);u.set(g,M)}}),this.faces.forEach(g=>{if(g.isExit){h()&&d(g.edges.length===1);const p=g.edges[0],E=n[p.vertices[0].index],M=n[p.vertices[1].index];h()&&d(E&&M);const w=f.find(P=>P.vertices.includes(E)&&P.vertices.includes(M));h()&&d(w);const V=a.includes(w.faces[0])?w.faces[1]:w.faces[0];h()&&d(V,"Did we hit null as in --- edge of board? can we expand the search pattern?");const F=[E.viewCoordinates,M.viewCoordinates,E.viewCoordinates.average(M.viewCoordinates).average(V.viewCoordinates)];u.set(g,F)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:l,edgeMap:v,sectorMap:o,faceMap:u}}static getSemiAdjacentFaces(s,a){const i=new Set;return a.vertices.forEach(x=>{x.faces.forEach(f=>{f!==a&&i.add(f)})}),i}static getFirstGeneration(s){const a=T.uniq(s.faces.map(x=>x.vertices.length)),i=s.vertices.map(x=>x.viewCoordinates).reduce((x,f)=>x.plus(f)).timesScalar(1/s.vertices.length);return a.map(x=>{const f=T.minBy(s.faces.filter(c=>c.vertices.length===x),c=>c.viewCoordinates.distanceSquared(i));return h()&&d(f),new z(s,[f])})}static getNextGeneration(s){const a=[];return s.forEach(i=>{const x=new Set;i.originalBoardFaces.forEach(f=>{z.getSemiAdjacentFaces(i.originalBoard,f).forEach(c=>{i.originalBoardFaces.includes(c)||x.add(c)})}),x.forEach(f=>{const c=[...i.originalBoardFaces,f],r=new z(i.originalBoard,c);a.some(n=>Me(n,r))||a.push(r)})}),a}static getFirstNGenerations(s,a){const x=[z.getFirstGeneration(s)];for(let f=0;f<a-1;f++)x.push(z.getNextGeneration(x[x.length-1]));return x}static getUniformTilingGenerations(s,a){const i=s.generate({width:15,height:15}),x=new ve(i,s.scale??1);return z.getFirstNGenerations(x,a)}}const xe=new I({numNonExitVertices:0,numExitVertices:0,type:"edge"},"single-edge"),We=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]},"vertex-2-exit-none"),Ue=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]},"vertex-2-exit-one"),Ke=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]},"vertex-3-exit-two-adjacent"),Qe=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]},"vertex-4-exit-two-opposite"),Xe=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]},"vertex-4-exit-three-adjacent"),Ye=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[2,1]},"vertex-5-exit-two-one"),be=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[4]},"vertex-5-exit-four"),_e=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[1,1,1]},"vertex-6-exit-triple"),et=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[2,2]},"vertex-6-exit-two-two"),tt=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[3,1]},"vertex-6-exit-three-one"),st=new I({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[5]},"vertex-6-exit-five"),nt=new I({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2},"vertex-2"),rt=new I({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3},"vertex-3"),it=new I({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4},"vertex-4"),ot=new I({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:5},"vertex-5"),at=new I({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:6},"vertex-6"),Ve=[We,Ue,Ke,Qe,Xe,Ye,be,_e,et,tt,st],ye=[nt,rt,it,ot,at],Nt=[xe,...Ve,...ye],W=t=>{const e=t.generate({width:20,height:20});return new ve(e,t.scale??1)},de=[],ct=t=>de.find(e=>T.isEqual(e.descriptor,t))??null,gt=t=>{const e=ct(t.descriptor);return e||(de.find(s=>Me(t,s))??null)},Ct=t=>de.find(e=>e.name===t)??null,fe=(t,e)=>{const s=gt(t);return s||(de.push(t),He.set(t,e),t)},D=(t,e)=>e.map((s,a)=>s.map((i,x)=>(i.name=`${t}-${a}-${x}`,fe(i,i.planarPatternMap))));fe(xe,Re(xe));Ve.forEach(t=>fe(t,me(t)));ye.forEach(t=>fe(t,me(t)));const dt=t=>z.getFirstNGenerations(W(J(Ne)),t),ft=t=>z.getFirstNGenerations(new Se(20,20),t),lt=t=>z.getFirstNGenerations(W(J(Ce)),t),ht=t=>z.getFirstNGenerations(new Be(10,1,!0),t),xt=t=>z.getFirstNGenerations(W(J(Ge)),t),ut=t=>z.getFirstNGenerations(W(J(Te)),t),pt=t=>z.getFirstNGenerations(W(J(Ae)),t),Et=t=>z.getFirstNGenerations(W(J(ze)),t),vt=t=>z.getFirstNGenerations(W(J(Ie)),t),wt=t=>z.getFirstNGenerations(W(J($e)),t),mt=t=>z.getFirstNGenerations(W(J(Oe)),t),Mt=t=>z.getFirstNGenerations(W(J(ke)),t),Vt=t=>z.getFirstNGenerations(W(J(je)),t),Gt=D("square",ft(5)),Tt=D("hexagonal",ht(4)),At=D("triangular",dt(4)),zt=D("cairo",lt(4)),It=D("rhombille",xt(4)),$t=D("snub-square",ut(3)),Ot=D("trihexagonal",pt(3)),kt=D("floret-pentagonal",Et(3)),jt=D("deltoidal-trihexagonal",vt(3)),qt=D("portugal",wt(3)),Dt=D("rhombitrihexagonal",mt(3)),Lt=D("prismatic-pentagonal",Mt(3)),Ht=D("elongated-triangular",Vt(3));export{I as B,z as F,Me as a,Nt as b,Je as c,Gt as d,At as e,xe as f,pe as g,Tt as h,It as i,zt as j,$t as k,Ot as l,Bt as m,we as n,Ze as o,He as p,kt as q,jt as r,Le as s,qt as t,Dt as u,ye as v,Lt as w,Ht as x,ct as y,Ct as z};
