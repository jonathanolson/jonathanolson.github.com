var K=Object.defineProperty;var w=(d,t,i)=>t in d?K(d,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):d[t]=i;var o=(d,t,i)=>(w(d,typeof t!="symbol"?t+"":t,i),i);import{a as p,b as A,_ as y}from"./getCoordinateClusteredMap-DCjAm76-.js";import{g as m}from"./FeatureSet-DDOmfIdB.js";import{E as L,d as T}from"./Vector2Property-DCXaH-JP.js";class S{constructor(t,i){this.minVertexIndex=t,this.maxVertexIndex=i}}const a=class a extends L{};o(a,"NON_EXIT_RED",new a),o(a,"NON_EXIT_BLACK",new a),o(a,"EXIT_HARD_RED",new a),o(a,"EXIT_BLACK",new a),o(a,"EXIT_SOFT_RED_DOUBLE_BLACK",new a),o(a,"enumeration",new T(a));let x=a;class v{constructor(t,i,r){o(this,"solutionSet");o(this,"isEdgeBlack");o(this,"richEdgeStateMap",new Map);o(this,"vertexConnection",null);o(this,"vertexConnectionKey",null);this.patternBoard=t,this.solution=i,this.solutionSet=new Set(i),this.isEdgeBlack=e=>this.solutionSet.has(e);for(const e of t.edges){let s;e.isExit?this.isEdgeBlack(e)?s=x.EXIT_BLACK:e.exitVertex.edges.every(c=>!this.isEdgeBlack(c))?s=x.EXIT_SOFT_RED_DOUBLE_BLACK:s=x.EXIT_HARD_RED:s=this.isEdgeBlack(e)?x.NON_EXIT_BLACK:x.NON_EXIT_RED,this.richEdgeStateMap.set(e,s)}if(r)if(t.faces.some(e=>!e.isExit)){const e=new Set(this.solutionSet),s=[];for(;e.size;){let n;for(const h of e)if(h.isExit){n=h;break}p()&&A(n);const l=h=>{for(const C of h.vertices)for(const B of C.edges)if(e.has(B))return B;throw new Error("no next edge found")};e.delete(n);let E=n;for(;E===n||!E.isExit;){const h=l(E);e.delete(h),E=h}const u=E,f=Math.min(n.exitVertex.index,u.exitVertex.index),I=Math.max(n.exitVertex.index,u.exitVertex.index);s.push(new S(f,I))}const c=y.sortBy(s,n=>n.minVertexIndex);this.vertexConnection=c,this.vertexConnectionKey=c.map(n=>`c${n.minVertexIndex}-${n.maxVertexIndex}`).join(",")}else this.vertexConnection=[],this.vertexConnectionKey=""}isCompatibleWithFeature(t){return t.isPossibleWith(this.isEdgeBlack)}isCompatibleWithFeatureSet(t){return t.getFeaturesArray().every(i=>this.isCompatibleWithFeature(i))}toDebugString(){return`[${this.patternBoard.edges.map(t=>this.isEdgeBlack(t)?"1":"0")}] ${this.vertexConnectionKey??""}`}}class g{constructor(t,i,r){o(this,"exitEdgeIndices");o(this,"solutionAttributeSetLists");this.initialFeatureSet=t,this.binaryFeatureMap=i,this.richSolutions=r;const e=t.patternBoard,s=e.edges.filter(l=>l.isExit);this.exitEdgeIndices=s.map(l=>i.getExitIndex(l)),this.solutionAttributeSetLists=new Array(1<<s.length).fill([]);const c=m(e,t.getFeaturesArray()),n=(l,E,u)=>{if(l===s.length){const f=g.filterWithInfo(r,c,u).map(I=>I.solutionAttributeSet);this.solutionAttributeSetLists[E]=f}else n(l+1,E,u),n(l+1,E|1<<l,[...u,s[l]])};n(0,0,[])}getSolutionAttributeSets(t){let i=0;for(let r=0;r<this.exitEdgeIndices.length;r++){const e=this.exitEdgeIndices[r];(t&1n<<BigInt(e))!==0n&&(i|=1<<r)}return this.solutionAttributeSetLists[i]}static filterWithFeatureSet(t,i){const r=m(i.patternBoard,i.getFeaturesArray()),e=i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s));return g.filterWithInfo(t,r,e)}static getHighlanderKeyWithFeatureSet(t,i){const r=m(i.patternBoard,i.getFeaturesArray()),e=new Set(i.patternBoard.edges.filter(s=>s.isExit&&i.impliesRedEdge(s)));return g.getHighlanderKeyWithInfo(t,r,e)}static getHighlanderKeyWithInfo(t,i,r){return i.map(e=>{const s=t.richEdgeStateMap.get(e);return p()&&A(s),e.isExit?r.has(e)?s===x.EXIT_BLACK?"1":"0":s===x.EXIT_SOFT_RED_DOUBLE_BLACK?"2":s===x.EXIT_BLACK?"1":"0":s===x.NON_EXIT_BLACK?"1":"0"}).join("")+"/"+t.vertexConnectionKey}static filterWithInfo(t,i,r){const e=new Map,s=new Set(r);for(const c of t){const n=g.getHighlanderKeyWithInfo(c,i,s);e.has(n)?e.set(n,null):e.set(n,c)}return[...e.values()].filter(c=>{if(c===null)return!1;for(const n of r)if(c.solutionSet.has(n))return!1;return!0})}}export{v as G,g as H};
