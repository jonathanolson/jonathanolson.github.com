var X=Object.defineProperty;var Y=(e,t,n)=>t in e?X(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var y=(e,t,n)=>(Y(e,typeof t!="symbol"?t+"":t,n),n);import{a as w,b as E,_ as V}from"./createBoardDescriptor-DQiPBFka.js";import{g as b,p as _}from"./getEmbeddings-BW9bZEIh.js";import{V as v}from"./Vector2Property-DCXaH-JP.js";import{P as j,g as C,t as ee,f as te,r as se,s as ne,h as re,j as ae,k as ie,o as oe,w as ce,y as de,z as ge}from"./getPeriodicTilingGenerator-9D05ORtn.js";import{S as le,H as ue}from"./getCoordinateClusteredMap-BFcIYRrL.js";const xe=(e,t)=>{if(e.numNonExitVertices!==t.numNonExitVertices||e.numExitVertices!==t.numExitVertices||e.type!==t.type)return!1;if(e.type==="faces"&&t.type==="faces"){if(e.vertexLists.length!==t.vertexLists.length)return!1;for(let n=0;n<e.vertexLists.length;n++){if(e.vertexLists[n].length!==t.vertexLists[n].length)return!1;for(let d=0;d<e.vertexLists[n].length;d++)if(e.vertexLists[n][d]!==t.vertexLists[n][d])return!1}}if(e.type==="non-exit-vertex"&&t.type==="non-exit-vertex"&&e.edgeCount!==t.edgeCount)return!1;if(e.type==="exit-vertex"&&t.type==="exit-vertex"){if(e.edgeCount!==t.edgeCount||e.spans.length!==t.spans.length)return!1;for(let n=0;n<e.spans.length;n++)if(e.spans[n]!==t.spans[n])return!1}return!0},he=e=>{const t=[];t.push(e.numNonExitVertices),t.push(e.numExitVertices),t.push(e.type),e.type==="faces"?t.push(e.vertexLists):(e.type==="non-exit-vertex"||e.type==="exit-vertex")&&(t.push(e.edgeCount),e.type==="exit-vertex"&&t.push(e.spans));const n=JSON.stringify(t);return w()&&E(xe(z(n),e)),n},z=e=>{const t=JSON.parse(e),n=t.shift(),d=t.shift(),g=t.shift();return g==="faces"?{numNonExitVertices:n,numExitVertices:d,type:g,vertexLists:t.shift()}:g==="non-exit-vertex"?{numNonExitVertices:n,numExitVertices:d,type:g,edgeCount:t.shift()}:g==="exit-vertex"?{numNonExitVertices:n,numExitVertices:d,type:g,edgeCount:t.shift(),spans:t.shift()}:{numNonExitVertices:n,numExitVertices:d,type:g}};class k{constructor(t,n){y(this,"exitEdge",null);y(this,"edges",[]);y(this,"sectors",[]);y(this,"faces",[]);this.index=t,this.isExit=n}}class q{constructor(t,n,d=null){y(this,"vertices");y(this,"sectors",[]);y(this,"faces",[]);this.index=t,this.isExit=n,this.exitVertex=d,this.vertices=d?[d]:[]}}class R{constructor(t,n,d){y(this,"face");this.index=t,this.vertex=n,this.edges=d}}class G{constructor(t,n,d,g,u){this.index=t,this.isExit=n,this.vertices=d,this.edges=g,this.sectors=u}}class P{constructor(t,n){y(this,"name");y(this,"vertices");y(this,"edges");y(this,"sectors");y(this,"faces");this.descriptor=t;const d=[...V.range(0,t.numNonExitVertices).map(r=>new k(r,!1)),...V.range(0,t.numExitVertices).map(r=>new k(r+t.numNonExitVertices,!0))];let g=[],u=[],l=[];if(t.type==="faces"){for(const r of t.vertexLists){const s=r.map(c=>d[c]),a=s.map((c,f)=>{const i=s[(f+1)%s.length],x=c.edges.find(p=>p.vertices.includes(i));if(x)return x;{const p=new q(g.length,!1),N=c.index<i.index?c:i,M=c.index<i.index?i:c;return p.vertices.push(N),p.vertices.push(M),g.push(p),c.edges.push(p),i.edges.push(p),p}}),o=a.map((c,f)=>{const i=a[(f+1)%a.length],x=c.vertices.find(N=>i.vertices.includes(N));w()&&E(x);const p=new R(u.length,x,[c,i]);return u.push(p),c.sectors.push(p),i.sectors.push(p),x.sectors.push(p),p}),h=new G(l.length,!1,s,a,o);l.push(h),s.forEach(c=>{c.faces.push(h)}),o.forEach(c=>{c.face=h}),a.forEach(c=>{c.faces.push(h)})}g.forEach(r=>{if(r.faces.length<2){w()&&E(r.faces.length===1);const s=new G(l.length,!0,r.vertices,[r],[]);l.push(s),r.faces.push(s),r.vertices.forEach(a=>{a.faces.push(s)})}}),d.forEach(r=>{if(r.isExit){const s=new q(g.length,!0,r);g.push(s),r.edges.push(s),r.exitEdge=s}})}else if(t.type==="edge"){w()&&E(d.length===0);const r=new q(0,!1,null);g.push(r);const s=new G(0,!0,[],[r],[]);l.push(s);const a=new G(1,!0,[],[r],[]);l.push(a),r.faces.push(s),r.faces.push(a)}else if(t.type==="non-exit-vertex"){w()&&E(d.length===1&&!d[0].isExit);const r=d[0];g.push(...V.range(0,t.edgeCount).map(s=>{const a=new q(s,!1);return r.edges.push(a),a.vertices.push(r),a})),u.push(...V.range(0,t.edgeCount).map(s=>{const a=new R(s,r,[g[s],g[(s+1)%t.edgeCount]]);return a.edges.forEach(o=>{o.sectors.push(a)}),r.sectors.push(a),a})),l.push(...V.range(0,t.edgeCount).map(s=>{const a=u[s],o=new G(s,!0,[r],[g[s],g[(s+1)%t.edgeCount]],[a]);return r.faces.push(o),o.edges.forEach(h=>{h.faces.push(o)}),a.face=o,o}))}else if(t.type==="exit-vertex"){w()&&E(d.length===1&&d[0].isExit);const r=d[0];g.push(...V.range(0,t.edgeCount).map(a=>{const o=new q(a,!1);return r.edges.push(o),o.vertices.push(r),o}));const s=new q(g.length,!0,r);if(g.push(s),r.edges.push(s),r.exitEdge=s,t.spans.length){const a=[];let o=0;t.spans.forEach((h,c)=>{const f=o,i=f+h;o=i+1,a.push(V.range(f,i+1).map(x=>g[x]))}),w()&&E(o===t.edgeCount),a.forEach(h=>{for(let c=0;c<h.length-1;c++){const f=h[c],i=h[c+1],x=new R(u.length,r,[f,i]);u.push(x),f.sectors.push(x),i.sectors.push(x),r.sectors.push(x);const p=new G(l.length,!0,[r],[f,i],[x]);l.push(p),r.faces.push(p),f.faces.push(p),i.faces.push(p),x.face=p}}),a.forEach(h=>{const c=h[0],f=h[h.length-1],i=new G(l.length,!0,[r],[c],[]);l.push(i),c.faces.push(i),r.faces.push(i);const x=new G(l.length,!0,[r],[f],[]);l.push(x),f.faces.push(x),r.faces.push(x)})}else{w()&&E(t.edgeCount===2);const a=g[0],o=g[1],h=new G(l.length,!0,[r],[a],[]);l.push(h),a.faces.push(h),r.faces.push(h);const c=new G(l.length,!0,[r],[a],[]);l.push(c),a.faces.push(c),r.faces.push(c);const f=new G(l.length,!0,[r],[o],[]);l.push(f),o.faces.push(f),r.faces.push(f);const i=new G(l.length,!0,[r],[o],[]);l.push(i),o.faces.push(i),r.faces.push(i)}}else throw new Error(`Invalid descriptor: ${t}`);this.vertices=d,this.edges=g,this.sectors=u,this.faces=l,n&&(this.name=n)}serialize(){return he(this.descriptor)}static deserialize(t){return new P(z(t))}}const fe=(e,t)=>{if(e.forwardHalf.next.edge===t)return e.forwardHalf;if(e.reversedHalf.next.edge===t)return e.reversedHalf;if(t.forwardHalf.next.edge===e)return t.forwardHalf;if(t.reversedHalf.next.edge===e)return t.reversedHalf;throw new Error("Edges are not connected")},O=.3,pe=e=>(w()&&E(e.vertices.length===0),w()&&E(e.sectors.length===0),w()&&E(e.faces.length===2),w()&&E(e.edges.length===1),{vertexMap:new Map,edgeMap:new Map([[e.edges[0],[new v(0,0),new v(1,0)]]]),sectorMap:new Map,faceMap:new Map([[e.faces[0],[new v(0,0),new v(1,0),new v(.5,O)]],[e.faces[1],[new v(0,0),new v(.5,-O),new v(1,0)]]])}),J=e=>{w()&&E(e.vertices.length===1);const t=e.edges.filter(s=>!s.isExit),n=t.length,d=n===2&&e.sectors.length?3:n,g=new Map([[e.vertices[0],v.ZERO]]),u=new Map;e.edges.forEach((s,a)=>{u.set(s,[v.ZERO,v.createPolar(1,2*Math.PI*a/d)])});const l=new Map;e.sectors.forEach(s=>{const a=s.edges[0],o=s.edges[1];(a.index+1)%n!==o.index?l.set(s,[u.get(a)[1],v.ZERO,u.get(o)[1]]):l.set(s,[u.get(o)[1],v.ZERO,u.get(a)[1]])});const r=new Map;return n===2&&e.sectors.length===0?(t[0].faces.forEach((s,a)=>{r.set(s,a===0?[new v(0,0),new v(1,0),new v(.5,O)]:[new v(0,0),new v(.5,-O),new v(1,0)])}),t[1].faces.forEach((s,a)=>{r.set(s,a===0?[new v(0,0),new v(-.5,O),new v(-1,0)]:[new v(0,0),new v(-1,0),new v(-.5,-O)])})):(e.sectors.forEach((s,a)=>{const o=l.get(s).slice();a===1&&n===2&&(o[1]=o[0].plus(o[2]).negated()),r.set(s.face,o)}),e.faces.forEach(s=>{if(!r.has(s)){w()&&E(s.edges.length===1);const a=s.edges[0],o=u.get(a);w()&&E(a.sectors.length===1);const h=a.sectors[0];{const c=o[1].perpendicular;let f=0;l.get(h).forEach(x=>f+=x.dot(c));const i=o[1].timesScalar(.5);r.set(s,[o[1],v.ZERO,i.plus(c.times(-Math.sign(f)*.5*Math.sin(2*Math.PI/3/n)))])}}})),{vertexMap:g,edgeMap:u,sectorMap:l,faceMap:r}},ht=e=>{if(w()){const s=a=>{E(a.every(o=>o.index<a.length))};s([...e.vertexMap.keys()]),s([...e.edgeMap.keys()]),s([...e.sectorMap.keys()]),s([...e.faceMap.keys()])}const t=V.sortBy([...e.vertexMap.keys()],s=>s.index),n=V.sortBy([...e.edgeMap.keys()],s=>s.index),d=V.sortBy([...e.sectorMap.keys()],s=>s.index),g=V.sortBy([...e.faceMap.keys()],s=>s.index),u=s=>[s.x,s.y],l=s=>{for(let a=0;a<t.length;a++)if(e.vertexMap.get(t[a]).equals(s))return a;return u(s)},r=JSON.stringify([t.map(s=>u(e.vertexMap.get(s))),n.map(s=>e.edgeMap.get(s).map(l)),d.map(s=>e.sectorMap.get(s).map(u)),g.map(s=>e.faceMap.get(s).map(u))]);if(w()){const s=ve(r,{vertices:t,edges:n,sectors:d,faces:g,descriptor:{}}),a=(o,h)=>{if(o.length!==h.length)return!1;for(let c=0;c<o.length;c++)if(!o[c].equals(h[c]))return!1;return!0};t.forEach(o=>E(e.vertexMap.get(o).equals(s.vertexMap.get(o)))),n.forEach(o=>E(a(e.edgeMap.get(o),s.edgeMap.get(o)))),d.forEach(o=>E(a(e.sectorMap.get(o),s.sectorMap.get(o)))),g.forEach(o=>E(a(e.faceMap.get(o),s.faceMap.get(o))))}return r},ve=(e,t)=>{const n=JSON.parse(e),d=n[0],g=n[1],u=n[2],l=n[3],r=new Map,s=new Map,a=new Map,o=new Map;d.forEach((c,f)=>{r.set(t.vertices[f],new v(c[0],c[1]))});const h=c=>typeof c=="number"?r.get(t.vertices[c]):new v(c[0],c[1]);return g.forEach((c,f)=>{s.set(t.edges[f],[h(c[0]),h(c[1])])}),u.forEach((c,f)=>{a.set(t.sectors[f],[h(c[0]),h(c[1]),h(c[2])])}),l.forEach((c,f)=>{o.set(t.faces[f],c.map(i=>new v(i[0],i[1])))}),{vertexMap:r,edgeMap:s,sectorMap:a,faceMap:o}},Z=(e,t)=>e.vertices.length!==t.vertices.length||e.edges.length!==t.edges.length||e.faces.length!==t.faces.length||e.sectors.length!==t.sectors.length||e.vertices.filter(n=>n.isExit).length!==t.vertices.filter(n=>n.isExit).length||e.edges.filter(n=>n.isExit).length!==t.edges.filter(n=>n.isExit).length||e.faces.filter(n=>n.isExit).length!==t.faces.filter(n=>n.isExit).length?!1:b(e,t).length>0&&b(t,e).length>0;class m extends P{constructor(n,d){const g=new Set,u=new Set;d.forEach(i=>{i.vertices.forEach(x=>{g.add(x)}),i.edges.forEach(x=>{u.add(x)})});const l=Array.from(u),r=[],s=[];for(const i of g)i.faces.every(x=>d.includes(x))?s.push(i):r.push(i);const a=[...s,...r];super({numNonExitVertices:s.length,numExitVertices:r.length,type:"faces",vertexLists:d.map(i=>i.vertices.map(x=>a.indexOf(x)))});y(this,"patternBoard");y(this,"planarPatternMap");this.originalBoard=n,this.originalBoardFaces=d;const o=new Map(a.map((i,x)=>[this.vertices[x],i.viewCoordinates])),h=new Map;this.edges.forEach(i=>{if(!i.isExit){const x=a[i.vertices[0].index],p=a[i.vertices[1].index];h.set(i,[x.viewCoordinates,p.viewCoordinates])}});const c=new Map;this.sectors.forEach(i=>{w()&&E(i.edges.length===2);const x=a[i.edges[0].vertices[0].index],p=a[i.edges[0].vertices[1].index],N=a[i.edges[1].vertices[0].index],M=a[i.edges[1].vertices[1].index],T=l.find(D=>D.vertices.includes(x)&&D.vertices.includes(p)),L=l.find(D=>D.vertices.includes(N)&&D.vertices.includes(M));w()&&E(T&&L);const F=fe(T,L);w()&&E(F);const Q=F.start.viewCoordinates,U=F.end.viewCoordinates,W=F.next.end.viewCoordinates;c.set(i,[Q,U,W])});const f=new Map;this.faces.forEach(i=>{if(!i.isExit){const x=i.vertices.map(M=>a[M.index]),p=d.find(M=>M.vertices.every(T=>x.includes(T)));w()&&E(p);const N=p.vertices.map(M=>M.viewCoordinates);f.set(i,N)}}),this.faces.forEach(i=>{if(i.isExit){w()&&E(i.edges.length===1);const x=i.edges[0],p=a[x.vertices[0].index],N=a[x.vertices[1].index];w()&&E(p&&N);const M=l.find(F=>F.vertices.includes(p)&&F.vertices.includes(N));w()&&E(M);const T=d.includes(M.faces[0])?M.faces[1]:M.faces[0];w()&&E(T,"Did we hit null as in --- edge of board? can we expand the search pattern?");const L=[p.viewCoordinates,N.viewCoordinates,p.viewCoordinates.average(N.viewCoordinates).average(T.viewCoordinates)];f.set(i,L)}}),this.patternBoard=this,this.planarPatternMap={vertexMap:o,edgeMap:h,sectorMap:c,faceMap:f}}static getSemiAdjacentFaces(n,d){const g=new Set;return d.vertices.forEach(u=>{u.faces.forEach(l=>{l!==d&&g.add(l)})}),g}static getFirstGeneration(n){const d=V.uniq(n.faces.map(u=>u.vertices.length)),g=n.vertices.map(u=>u.viewCoordinates).reduce((u,l)=>u.plus(l)).timesScalar(1/n.vertices.length);return d.map(u=>{const l=V.minBy(n.faces.filter(r=>r.vertices.length===u),r=>r.viewCoordinates.distanceSquared(g));return w()&&E(l),new m(n,[l])})}static getNextGeneration(n){const d=[];return n.forEach(g=>{const u=new Set;g.originalBoardFaces.forEach(l=>{m.getSemiAdjacentFaces(g.originalBoard,l).forEach(r=>{g.originalBoardFaces.includes(r)||u.add(r)})}),u.forEach(l=>{const r=[...g.originalBoardFaces,l],s=new m(g.originalBoard,r);d.some(a=>Z(a,s))||d.push(s)})}),d}static getFirstNGenerations(n,d){const u=[m.getFirstGeneration(n)];for(let l=0;l<d-1;l++)u.push(m.getNextGeneration(u[u.length-1]));return u}static getUniformTilingGenerations(n,d){const g=n.generate({width:15,height:15}),u=new j(g,n.scale??1);return m.getFirstNGenerations(u,d)}}const I=new P({numNonExitVertices:0,numExitVertices:0,type:"edge"},"single-edge"),Ee=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[]},"vertex-2-exit-none"),we=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:2,spans:[1]},"vertex-2-exit-one"),me=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:3,spans:[2]},"vertex-3-exit-two-adjacent"),Pe=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[1,1]},"vertex-4-exit-two-opposite"),ye=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:4,spans:[3]},"vertex-4-exit-three-adjacent"),Me=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[2,1]},"vertex-5-exit-two-one"),Ve=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:5,spans:[4]},"vertex-5-exit-four"),Be=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[1,1,1]},"vertex-6-exit-triple"),Ne=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[2,2]},"vertex-6-exit-two-two"),Ge=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[3,1]},"vertex-6-exit-three-one"),Ce=new P({numNonExitVertices:0,numExitVertices:1,type:"exit-vertex",edgeCount:6,spans:[5]},"vertex-6-exit-five"),Se=new P({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:2},"vertex-2"),Te=new P({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:3},"vertex-3"),Fe=new P({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:4},"vertex-4"),qe=new P({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:5},"vertex-5"),Oe=new P({numNonExitVertices:1,numExitVertices:0,type:"non-exit-vertex",edgeCount:6},"vertex-6"),$=[Ee,we,me,Pe,ye,Me,Ve,Be,Ne,Ge,Ce],K=[Se,Te,Fe,qe,Oe],ft=[I,...$,...K],S=e=>{const t=e.generate({width:20,height:20});return new j(t,e.scale??1)},A=[],De=e=>A.find(t=>V.isEqual(t.descriptor,e))??null,Le=e=>{const t=De(e.descriptor);return t||(A.find(n=>Z(e,n))??null)},pt=e=>A.find(t=>t.name===e)??null,H=(e,t)=>{const n=Le(e);return n||(A.push(e),_.set(e,t),e)},B=(e,t)=>t.map((n,d)=>n.map((g,u)=>(g.name=`${e}-${d}-${u}`,H(g,g.planarPatternMap))));H(I,pe(I));$.forEach(e=>H(e,J(e)));K.forEach(e=>H(e,J(e)));const Ae=S(C(ee)),He=new le(20,20),Re=S(C(te)),Ie=new ue(10,1,!0),be=S(C(se)),ke=S(C(ne)),je=S(C(re)),ze=S(C(ae)),Je=S(C(ie)),Ze=S(C(oe)),$e=S(C(ce)),Ke=S(C(de)),Qe=S(C(ge)),Ue=e=>m.getFirstNGenerations(Ae,e),We=e=>m.getFirstNGenerations(He,e),Xe=e=>m.getFirstNGenerations(Re,e),Ye=e=>m.getFirstNGenerations(Ie,e),_e=e=>m.getFirstNGenerations(be,e),et=e=>m.getFirstNGenerations(ke,e),tt=e=>m.getFirstNGenerations(je,e),st=e=>m.getFirstNGenerations(ze,e),nt=e=>m.getFirstNGenerations(Je,e),rt=e=>m.getFirstNGenerations(Ze,e),at=e=>m.getFirstNGenerations($e,e),it=e=>m.getFirstNGenerations(Ke,e),ot=e=>m.getFirstNGenerations(Qe,e),vt=B("square",We(5)),Et=B("hexagonal",Ye(4)),wt=B("triangular",Ue(4)),mt=B("cairo",Xe(4)),Pt=B("rhombille",_e(4)),yt=B("snub-square",et(3)),Mt=B("trihexagonal",tt(3)),Vt=B("floret-pentagonal",st(3)),Bt=B("deltoidal-trihexagonal",nt(3)),Nt=B("portugal",rt(3)),Gt=B("rhombitrihexagonal",at(3)),Ct=B("prismatic-pentagonal",it(3)),St=B("elongated-triangular",ot(3));export{ve as A,P as B,I as C,Ee as D,we as E,m as F,me as G,Pe as H,ye as I,Se as J,Te as K,Fe as L,pt as M,De as N,Vt as O,Bt as P,Nt as Q,Gt as R,Ct as S,St as T,Ie as a,Re as b,Ae as c,be as d,ke as e,je as f,ze as g,Je as h,Ze as i,$e as j,Ke as k,Qe as l,he as m,ft as n,Z as o,fe as p,vt as q,wt as r,He as s,Et as t,Pt as u,mt as v,yt as w,Mt as x,ht as y,z};
