var He=Object.defineProperty;var Be=(F,n,e)=>n in F?He(F,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):F[n]=e;var L=(F,n,e)=>(Be(F,typeof n!="symbol"?n+"":n,e),e);import{o as me,c as be,D as Le,V as D,d as le,E as We,i as De,P as ue,B as Ye}from"./Vector2Property-DUQoL60W.js";import{W as ge,N as b,c as Ee,h as O,X as re,_ as q,P as R,Y as Ue,Z as Q,E as U,M as Ce,a as A,b as I,$ as Xe,L as Te,a0 as Fe,a1 as te,a2 as Pe,a3 as C,m as Ze,R as _e,p as Me,H as Ve,a4 as je,a5 as ze,C as Ne,j as ve,a6 as $e,a7 as ce,a8 as qe}from"./getCoordinateClusteredMap-CiLx8OtO.js";import{X as Ke,Y as xe,Z as Je,r as Ge,g as Re,_ as Qe,$ as et,a0 as tt,a1 as ot,a2 as st,a3 as rt,j as it}from"./PuzzleModel-D24vwq4z.js";const de=(F,n,e,t)=>{const s=new ge({mouseButton:0,fire:i=>{var l;return e&&e(F,(l=i.domEvent)!=null&&l.shiftKey?2:0)}}),o=new ge({mouseButton:2,fire:i=>{var l;return e&&e(F,(l=i.domEvent)!=null&&l.shiftKey?0:2)}}),d=new ge({mouseButton:1,fire:i=>e&&e(F,1)});n.addInputListener(s),n.addInputListener(o),n.addInputListener(d),n.cursor="pointer",s.isHighlightedProperty.lazyLink(i=>{t&&t(F,i)}),n.disposeEmitter.addListener(()=>{s.dispose(),o.dispose(),d.dispose()})};class he extends b{constructor(n,e,t,s){const o=me()({useBackgroundOffsetStroke:!1,backgroundOffsetDistance:.3,facePressListener:()=>{},faceHoverListener:()=>{}},s);super({pickableProperty:Ke}),this.outerBoundary=n,this.innerBoundaries=e,this.style=t,de(null,this,o.facePressListener,o.faceHoverListener);const d=n.map(u=>u.start.viewCoordinates),i=o.useBackgroundOffsetStroke,l=o.backgroundOffsetDistance,c=Ee(d)>0?-l:l,a=u=>{const w=new Ue;w.addShape(0,u),w.computeSimplifiedFaces(),w.computeFaceInclusion(P=>P[0]>0);const g=w.createFilledSubGraph(),f=g.facesToShape();return w.dispose(),g.dispose(),f},p=he.getOffsetBackgroundShape(n,i,l),h=e.map(u=>{const w=u.map(f=>f.start.viewCoordinates),g=O.polygon(w);if(i)return a(g.getOffsetShape(c));{const P=g.getStrokedShape(new re({lineWidth:2*l})).subpaths.map(y=>new O([y]));return a(q.minBy(P,y=>y.getArea()))}});this.children=[new R(p,{fill:t.theme.puzzleBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}),...h.map(u=>new R(u,{fill:t.theme.playAreaBackgroundColorProperty,stroke:t.theme.puzzleBackgroundStrokeColorProperty,lineWidth:.03}))]}static getOffsetBackgroundShape(n,e,t){const s=n.map(l=>l.start.viewCoordinates),o=O.polygon(s),i=Ee(s)>0?-t:t;if(e)return o.getOffsetShape(i).getSimplifiedAreaShape();{const l=o.getStrokedShape(new re({lineWidth:2*t})),r=l.subpaths.map(c=>new O([c]));try{return l.bounds.width===9.718028227819117?O.bounds(l.bounds):q.maxBy(r,c=>c.getArea()).getSimplifiedAreaShape()}catch{return O.bounds(l.bounds)}}}}class nt extends b{constructor(n,e,t,s){super(),this.vertex=n;const o=new Q([e,s.verticesVisibleProperty],(r,c)=>c&&n.edges.every(a=>r.getEdgeState(a)!==U.BLACK));this.disposeEmitter.addListener(()=>o.dispose());const d=new R(null,{translation:n.viewCoordinates,fill:s.theme.vertexColorProperty,visibleProperty:o});this.addChild(d);const i=Ce.multilink([s.vertexStyleProperty,s.smallVertexProperty],(r,c)=>{const a=c?.03:.05;r==="round"?d.shape=O.circle(a):r==="square"?d.shape=O.rect(-a,-a,2*a,2*a):A()&&I(!1,`unhandled vertex style: ${r}`)});this.disposeEmitter.addListener(()=>i.dispose());const l=r=>{this.visible=!r};t.link(l),this.disposeEmitter.addListener(()=>t.unlink(l))}}class at extends b{constructor(n,e,t,s){const o=me()({textOptions:{font:xe,maxWidth:.9,maxHeight:.9},facePressListener:()=>{},faceHoverListener:()=>{}},s);super({}),this.face=n;const d=O.polygon(n.vertices.map(r=>r.viewCoordinates));this.mouseArea=d,this.touchArea=d,de(n,this,o.facePressListener,o.faceHoverListener);const i=new Xe("",be({subScale:.7},o==null?void 0:o.textOptions)),l=Ce.multilink([e,t.faceValueStyleProperty,t.theme.faceValueColorProperty,t.theme.faceValueCompletedColorProperty,t.theme.faceValueErrorColorProperty,t.theme.faceValueRatioColorProperty,t.faceStateVisibleProperty],(r,c,a,p,h,u,w)=>{const g=r.getFaceValue(n);this.visible=!w;let f,P,y=!1,v=!1;if(g===null)f="",P=null;else{let S=0,T=0;for(const E of n.edges){const k=r.getEdgeState(E);k===U.BLACK?S++:k===U.WHITE&&T++}if(c==="static"||g===0)f=`${g}`;else if(c==="remaining")f=`${g-S}`,y=S>0;else if(c==="ratio")g-S===0?f="0":(f=`${g-S}<sub style="color: ${u.toCSS()};">/<sub>${T}</sub></sub>`,v=!0),y=S>0;else throw new Error(`unhandled faceValueStyle: ${c}`);S<g?P=a:S===g?P=p:P=h}i.string=f,i.fill=P,i.maxWidth=v?.8:.9,i.maxHeight=v?.8:.9,i.center=n.viewCoordinates,this.children=[i]});this.disposeEmitter.addListener(()=>l.dispose())}}class ct extends b{constructor(n,e,t,s,o){super({}),this.edge=n;const d=new Q([e],S=>S.getEdgeState(n));this.disposeEmitter.addListener(()=>d.dispose());const i=n.start.viewCoordinates,l=n.end.viewCoordinates,r=i.average(l),c=.06,a=new O().moveTo(-c,-c).lineTo(c,c).moveTo(-c,c).lineTo(c,-c),p=new Q([t,s.redXsVisibleProperty],(S,T)=>!S&&T);this.disposeEmitter.addListener(()=>p.dispose());const h=new R(a,{stroke:s.theme.xColorProperty,lineWidth:.02,center:r,visibleProperty:p}),u=S=>{h.rotation=S?l.minus(i).getAngle():0};s.redXsAlignedProperty.link(u),this.disposeEmitter.addListener(()=>s.redXsAlignedProperty.unlink(u));const w=new Q([t,s.whiteLineVisibleProperty],(S,T)=>!S&&T);this.disposeEmitter.addListener(()=>w.dispose());const g=new Te(i.x,i.y,l.x,l.y,{lineWidth:.02,stroke:s.theme.whiteLineColorProperty,visibleProperty:w}),f=new Q([t,s.redLineVisibleProperty],(S,T)=>T);this.disposeEmitter.addListener(()=>f.dispose());const P=new R(null,{lineWidth:.02,stroke:s.theme.redLineColorProperty,lineDash:[.03,.05],visibleProperty:f}),y=S=>{S==="middle"?P.shape=new O().moveToPoint(r.blend(i,.35)).lineToPoint(r.blend(l,.35)).makeImmutable():S==="gap"?P.shape=new O().moveToPoint(i).lineToPoint(i.blend(r,.35)).moveToPoint(l.blend(r,.35)).lineToPoint(l).makeImmutable():S==="full"?P.shape=new O().moveToPoint(i).lineToPoint(l).makeImmutable():A()&&I(!1,`Unknown red line style: ${S}`)};s.redLineStyleProperty.link(y),this.disposeEmitter.addListener(()=>s.redLineStyleProperty.unlink(y));const v=o==null?void 0:o.edgePressListener;if(v){const S=new O;if(n.faces.length===2)S.polygon([i,n.faces[0].viewCoordinates,l,n.faces[1].viewCoordinates]);else{A()&&I(n.faces.length===1,"EdgeNode only supports edges with 1 or 2 faces");const T=n.forwardHalf.face===null?n.forwardHalf:n.reversedHalf;A()&&I(T.previous.face===null),A()&&I(T.next.face===null);const E=T.start.viewCoordinates,k=T.end.viewCoordinates,H=T.previous.start.viewCoordinates,N=T.next.end.viewCoordinates,M=(z,V,X)=>{const $=V.minus(z).normalized(),Y=X.minus(V).normalized();let Z=$.minus(Y);return Z.getMagnitude()<1e-6?Z=$.getPerpendicular():Z=Z.normalized(),Le.triangleAreaSigned(z,V,V.plus(Z))<0&&(Z=Z.negated()),Z},m=M(H,E,k),j=M(E,k,N);S.polygon([E,n.faces[0].viewCoordinates,k,k.plus(j.times(o.backgroundOffsetDistance)),E.plus(m.times(o.backgroundOffsetDistance))])}this.mouseArea=this.touchArea=S,de(n,this,v,o.edgeHoverListener)}d.link(S=>{S===U.WHITE?this.children=[g]:S===U.BLACK?this.children=[]:this.children=[P,h]})}}class lt extends b{constructor(e,t,s){super({pickable:!1,visibleProperty:s.edgesVisibleProperty});L(this,"simpleRegionNodeMap",new Map);L(this,"regionIdMap",new Map);L(this,"weirdEdgeNodeMap",new Map);L(this,"regionContainer",new b);L(this,"weirdEdgeContainer",new b);L(this,"adjacentFacesMap",new Map);this.board=e,this.style=s,e.faces.forEach(i=>{this.adjacentFacesMap.set(i,i.edges.map(l=>l.getOtherFace(i)).filter(l=>l!==null))}),this.children=[this.weirdEdgeContainer,this.regionContainer],t.value.getSimpleRegions().forEach(i=>this.addRegion(i)),t.value.getWeirdEdges().forEach(i=>this.addWeirdEdge(i)),this.updateHues();const o=(i,l)=>{const r=l.getSimpleRegions(),c=i.getSimpleRegions(),a=l.getWeirdEdges(),p=i.getWeirdEdges(),h=[],u=[];Fe(r,c,h,u,[]);const g=new Set(h);for(const f of u)if(this.regionIdMap.has(f.id)){const P=this.regionIdMap.get(f.id);this.replaceRegion(P,f),g.delete(P)}else this.addRegion(f);for(const f of g)this.removeRegion(f);for(const f of a)p.includes(f)||this.removeWeirdEdge(f);for(const f of p)a.includes(f)||this.addWeirdEdge(f);(u.length||h.length)&&this.updateHues()};t.lazyLink(o),this.disposeEmitter.addListener(()=>t.unlink(o)),this.disposeEmitter.addListener(()=>{for(;this.simpleRegionNodeMap.size;)this.removeRegion(this.simpleRegionNodeMap.keys().next().value)});const d=()=>this.updateHues();s.theme.simpleRegionHueLUTProperty.link(d),s.edgesHaveColorsProperty.lazyLink(d),this.disposeEmitter.addListener(()=>{s.theme.simpleRegionHueLUTProperty.unlink(d),s.edgesHaveColorsProperty.unlink(d)})}addRegion(e){const t=new ee(e,this.style);this.simpleRegionNodeMap.set(e,t),this.regionIdMap.set(e.id,e),this.regionContainer.addChild(t)}replaceRegion(e,t){A()&&I(e.id===t.id);const s=this.simpleRegionNodeMap.get(e);s.updateRegion(t),this.simpleRegionNodeMap.delete(e),this.simpleRegionNodeMap.set(t,s),this.regionIdMap.delete(e.id),this.regionIdMap.set(t.id,t)}removeRegion(e){const t=this.simpleRegionNodeMap.get(e);this.regionContainer.removeChild(t),this.simpleRegionNodeMap.delete(e),this.regionIdMap.delete(e.id),t.dispose()}addWeirdEdge(e){const t=e.start.viewCoordinates,s=e.end.viewCoordinates,o=new Te(t.x,t.y,s.x,s.y,{lineWidth:.1,stroke:this.style.theme.edgeWeirdColorProperty,lineCap:"square"});this.weirdEdgeNodeMap.set(e,o),this.weirdEdgeContainer.addChild(o)}removeWeirdEdge(e){const t=this.weirdEdgeNodeMap.get(e);this.weirdEdgeContainer.removeChild(t),this.weirdEdgeNodeMap.delete(e)}updateHues(){const e=[...this.simpleRegionNodeMap.values()];if(e.length<2)return;const t=new D(0,0),s=()=>{for(const c of e)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(1,0)},o=new Map,d=[];this.board.faces.forEach(c=>{o.set(c,[])});for(const c of e){const a=new Set;for(const h of c.simpleRegion.edges)for(const u of h.faces)a.add(u);const p=new Set;for(const h of a){p.add(h);for(const u of this.adjacentFacesMap.get(h))p.add(u)}for(const h of p){const u=o.get(h);if(u.length)for(const w of u){let g=!1;for(const f of d)if(f.a===w&&f.b===c){f.weight++,g=!0;break}g||d.push({a:w,b:c,weight:1})}u.push(c)}}const i=new Map;for(const c of e)i.set(c,D.ZERO.copy());const l=(c,a,p)=>{const h=i.get(c),u=i.get(a),w=c.hueVector.dot(a.hueVector),g=t.set(a.hueVector).subtract(c.hueVector);if(g.magnitude>1e-9){g.normalize();const f=.3,P=p*((Math.max(f,w)-f)/(1-f))**3;g.multiplyScalar(P),h.subtract(g),u.add(g)}};let r=1;for(let c=0;c<100;c++){r*=.99;for(const a of e)i.get(a).setXY(0,0);for(const a of d){const p=a.a,h=a.b,u=a.weight;l(p,h,u)}if(e.length<8)for(let a=0;a<e.length;a++){const p=e[a];for(let h=a+1;h<e.length;h++)l(p,e[h],.2)}for(const a of e){const p=i.get(a);p.multiplyScalar(r/a.edgeCount),a.hueVector.add(p),i.get(a).setXY(0,0)}s()}for(const c of e)c.updateHue()}}class ee extends R{constructor(e,t){const s=D.createPolar(1,le.nextDoubleBetween(0,2*Math.PI));super(ee.toShape(e),{stroke:ee.hueVectorToPaint(s,t),lineWidth:.1,lineCap:"square",lineJoin:"round"});L(this,"hueVector");L(this,"edgeCount");this.simpleRegion=e,this.style=t,this.hueVector=s,this.edgeCount=e.edges.length;const o=i=>{this.lineJoin=i};t.joinedLinesJoinProperty.link(o),this.disposeEmitter.addListener(()=>t.joinedLinesJoinProperty.unlink(o));const d=i=>{this.lineCap=i};t.joinedLinesCapProperty.link(d),this.disposeEmitter.addListener(()=>t.joinedLinesCapProperty.unlink(d))}updateHue(){this.stroke=ee.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.style)}updateRegion(e){this.simpleRegion=e,this.shape=ee.toShape(e),this.edgeCount=e.edges.length}static hueVectorToPaint(e,t){const s=t.theme.simpleRegionHueLUTProperty.value,o=(Math.round(e.getAngle()*180/Math.PI)+360)%360;return A()&&I(o>=0&&o<s.length),t.edgesHaveColorsProperty.value?s[o]:t.theme.blackLineColorProperty}static toShape(e){const t=new O;let s=!0;for(const o of e.halfEdges)s&&(s=!1,t.moveToPoint(o.start.viewCoordinates)),t.lineToPoint(o.end.viewCoordinates);return e.isSolved&&t.close(),t.makeImmutable()}}class dt extends b{constructor(e,t,s){const o=new b;super({pickable:!1,children:[o]});L(this,"faceColorNodeMap",new Map);L(this,"faceColorIdMap",new Map);L(this,"adjacentFacesMap",new Map);L(this,"faceColorNodeContainer");L(this,"dualColorViews",new Set);this.board=e,this.stateProperty=t,this.style=s,this.faceColorNodeContainer=o,e.faces.forEach(r=>{this.adjacentFacesMap.set(r,r.edges.map(c=>c.getOtherFace(r)).filter(c=>c!==null))});{const r=t.value.getFaceColors();for(const c of r)this.addFaceColor(c,t.value.getFacesWithColor(c));this.addDualColorViews(t.value,r)}this.updateHues();let d=t.value.clone();const i=r=>{const c=d;d=r.clone();const a=c.getFaceColors(),p=r.getFaceColors(),h=[],u=[],w=[];Fe(a,p,h,u,w);const g=new Set(h),f=this.removeInvalidDualColorViews(r),P=[...f];for(const y of u)if(f.add(y),this.faceColorIdMap.has(y.id)){const v=this.faceColorIdMap.get(y.id);this.replaceFaceColor(v,y,r.getFacesWithColor(y)),g.delete(v)}else this.addFaceColor(y,r.getFacesWithColor(y));for(const y of w)this.updateFaceColor(y,r.getFacesWithColor(y));for(const y of g)f.delete(y),this.removeFaceColor(y);this.addDualColorViews(r,[...f]),(u.length||h.length||P.length)&&this.updateHues()};t.lazyLink(i),this.disposeEmitter.addListener(()=>t.unlink(i)),this.disposeEmitter.addListener(()=>{for(;this.faceColorNodeMap.size;)this.removeFaceColor(this.faceColorNodeMap.keys().next().value)});const l=()=>this.updateHues();s.theme.faceColorBasicHueLUTProperty.lazyLink(l),s.theme.faceColorLightHueLUTProperty.lazyLink(l),s.theme.faceColorDarkHueLUTProperty.lazyLink(l),s.theme.faceColorInsideColorProperty.lazyLink(l),s.theme.faceColorOutsideColorProperty.lazyLink(l),s.theme.faceColorDefaultColorProperty.lazyLink(l),s.faceColorThresholdProperty.lazyLink(l),this.updateHues(),this.disposeEmitter.addListener(()=>{s.theme.faceColorBasicHueLUTProperty.unlink(l),s.theme.faceColorLightHueLUTProperty.unlink(l),s.theme.faceColorDarkHueLUTProperty.unlink(l),s.theme.faceColorInsideColorProperty.unlink(l),s.theme.faceColorOutsideColorProperty.unlink(l),s.theme.faceColorDefaultColorProperty.unlink(l),s.faceColorThresholdProperty.unlink(l)})}addFaceColor(e,t){const s=new oe(e,t,this.style);this.faceColorNodeMap.set(e,s),this.faceColorIdMap.set(e.id,e),this.faceColorNodeContainer.addChild(s)}replaceFaceColor(e,t,s){A()&&I(e.id===t.id);const o=this.faceColorNodeMap.get(e);o.updateFaceColor(t,s),this.faceColorNodeMap.delete(e),this.faceColorNodeMap.set(t,o),this.faceColorIdMap.delete(e.id),this.faceColorIdMap.set(t.id,t)}updateFaceColor(e,t){const s=this.faceColorNodeMap.get(e);let o=s.faces.length!==t.length;if(!o)for(let d=0;d<t.length;d++){const i=s.faces[d],l=t[d];if(i!==l){o=!0;break}}o&&s.updateFaceColor(e,t)}removeFaceColor(e){const t=this.faceColorNodeMap.get(e);this.faceColorNodeContainer.removeChild(t),this.faceColorNodeMap.delete(e),this.faceColorIdMap.delete(e.id),t.dispose()}addDualColorViews(e,t){const s=new Set(t);for(;s.size;){const o=s.values().next().value;s.delete(o);const d=this.faceColorNodeMap.get(o);A()&&I(d);const i=e.getOppositeFaceColor(o);if(i){A()&&I(s.has(i)),s.delete(i);const l=this.faceColorNodeMap.get(i);A()&&I(l),this.dualColorViews.add(new ke([d,l],this.style))}else this.dualColorViews.add(new ke([d],this.style))}}removeInvalidDualColorViews(e){const t=new Set,s=new Set(e.getFaceColors());for(const o of[...this.dualColorViews])if(!o.isStillValidInState(this.stateProperty.value,s)){for(const d of o.colorNodes)t.add(d.faceColor);this.dualColorViews.delete(o),o.dispose()}return t}updateHues(){const e=[...this.dualColorViews].filter(t=>t.colorNodes[0].faceColor.colorState!==te.UNDECIDED&&this.style.theme.faceColorOutsideColorProperty.value.alpha===1&&this.style.theme.faceColorInsideColorProperty.value.alpha===1?!1:t.faceCount>=this.style.faceColorThresholdProperty.value);if(e.length>=2){const t=new D(0,0),s=()=>{for(const c of e)c.hueVector.getMagnitude()>1e-6?c.hueVector.normalize():c.hueVector.setXY(le.nextDouble()-.5,le.nextDouble()-.5).normalize()},o=new Map,d=[];this.board.faces.forEach(c=>{o.set(c,[])});for(const c of e){const a=new Set;for(const h of c.faces)a.add(h);const p=new Set;for(const h of a){p.add(h);for(const u of this.adjacentFacesMap.get(h))p.add(u)}for(const h of p){const u=o.get(h);if(u.length)for(const w of u){let g=!1;for(const f of d)if(f.a===w&&f.b===c){f.weight++,g=!0;break}g||d.push({a:w,b:c,weight:1})}u.push(c)}}const i=new Map;for(const c of e)i.set(c,D.ZERO.copy());const l=(c,a,p)=>{const h=i.get(c),u=i.get(a),w=c.hueVector.dot(a.hueVector),g=t.set(a.hueVector).subtract(c.hueVector).normalize(),f=.2,P=Math.abs(w),y=p*((Math.max(f,P)-f)/(1-f))**3;g.multiplyScalar(y),h.subtract(g),u.add(g)};let r=1;for(let c=0;c<100;c++){r*=.99;for(const a of e)i.get(a).setXY(0,0);for(const a of d){const p=a.a,h=a.b,u=a.weight;l(p,h,u)}if(e.length<8)for(let a=0;a<e.length;a++){const p=e[a];for(let h=a+1;h<e.length;h++)l(p,e[h],.2)}for(const a of e){const p=i.get(a);p.multiplyScalar(r/a.faceCount),a.hueVector.add(p),i.get(a).setXY(0,0)}s()}}for(const t of this.dualColorViews)t.updateHue()}}const _=class _ extends We{};L(_,"BASIC",new _),L(_,"PRIMARY",new _),L(_,"SECONDARY",new _),L(_,"enumeration",new De(_));let W=_;class ke{constructor(n,e){L(this,"hueVector");L(this,"faceCount");if(this.colorNodes=n,this.style=e,A()&&I(n.length===1||n.length===2),this.faceCount=q.sum(this.colorNodes.map(t=>t.faceCount)),n.forEach(t=>{t.dualColorView=this}),n.length===1)n[0].type=W.BASIC,this.hueVector=n[0].hueVector.copy();else{const t=n[0].faceCount>n[1].faceCount?n[0]:n[1],s=t===n[0]?n[1]:n[0];let o;t.type===W.PRIMARY?o=t:s.type===W.PRIMARY||t.type===W.SECONDARY?o=s:(s.type,W.SECONDARY,o=t);const d=o===t?s:t;this.hueVector=t.hueVector.copy(),o.type=W.PRIMARY,d.type=W.SECONDARY}}get faces(){return this.colorNodes.flatMap(n=>n.faces)}isStillValidInState(n,e){for(const t of this.colorNodes)if(!e.has(t.faceColor))return!1;return this.colorNodes.length===1?n.getOppositeFaceColor(this.colorNodes[0].faceColor)===null:n.getOppositeFaceColor(this.colorNodes[0].faceColor)===this.colorNodes[1].faceColor}updateHue(){for(const n of this.colorNodes)n.hueVector.set(this.hueVector),n.updateHue(this.faceCount>=this.style.faceColorThresholdProperty.value)}dispose(){for(const n of this.colorNodes)n.dualColorView=null}}class oe extends R{constructor(e,t,s){const o=D.createPolar(1,le.nextDoubleBetween(0,2*Math.PI));super(oe.toShape(t));L(this,"hueVector");L(this,"faceCount");L(this,"dualColorView",null);L(this,"type",W.BASIC);this.faceColor=e,this.faces=t,this.style=s,this.hueVector=o,this.faceCount=t.length}updateHue(e){e||this.faceColor.colorState!==te.UNDECIDED?this.fill=oe.hueVectorToPaint(this.hueVector.getMagnitude()>1e-6?this.hueVector:D.X_UNIT,this.faceColor.colorState,this.type,this.style):this.fill=this.style.theme.faceColorDefaultColorProperty}updateFaceColor(e,t){const s=t.length-this.faceCount;this.faceColor=e,this.faces=t,this.shape=oe.toShape(t),this.faceCount=t.length,this.dualColorView&&(this.dualColorView.faceCount+=s)}static hueVectorToPaint(e,t,s,o){const d=s===W.BASIC?o.theme.faceColorBasicHueLUTProperty.value:s===W.PRIMARY?o.theme.faceColorLightHueLUTProperty.value:o.theme.faceColorDarkHueLUTProperty.value,i=(Math.round(e.getAngle()*180/Math.PI)+360)%360;A()&&I(i>=0&&i<d.length);const l=d[i];if(t===te.UNDECIDED)return l;{const c=(t===te.INSIDE?o.theme.faceColorInsideColorProperty:o.theme.faceColorOutsideColorProperty).value,a=c.alpha,p=new Pe(l);return new Pe((1-a)*p.red+a*c.red,(1-a)*p.green+a*c.green,(1-a)*p.blue+a*c.blue).toCSS()}}static toShape(e){const t=new O;for(const s of e)t.polygon(s.vertices.map(o=>o.viewCoordinates));return t.makeImmutable()}}const se=class se extends b{constructor(n,e,t,s){super(),this.sector=n;const o=n.start.viewCoordinates,d=n.end.viewCoordinates,i=n.next.end.viewCoordinates,l=o.minus(d),r=i.minus(d),c=l.normalized(),a=r.normalized(),p=l.angle;let h=r.angle;h<p&&(h+=2*Math.PI);const u=a.minus(c).angle+Math.PI/2,w=h-p,g=.2,f=.3,P=.02,y=.04,v=D.createPolar(.2,u),S=se.getSectorBaseShape(n,s.backgroundOffsetDistance);this.mouseArea=S,this.touchArea=S,de(n,this,s.sectorPressListener,s.sectorHoverListener);const T=(x,B)=>(x.moveToPoint(c.timesScalar(B)),x.arcPoint(D.ZERO,B,p,h,!0),x),E=(x,B)=>{const J=Le.linear(0,2*Math.PI,B*.5,0,Math.abs(2*Math.PI-w)),ie=c.timesScalar(B),ne=a.timesScalar(B),ae=D.createPolar(J,u).timesScalar(2).minus(ie.average(ne));return x.moveToPoint(ie),x.quadraticCurveToPoint(ae,ne),x},k=(x,B,J)=>(x.moveTo(B.x+J,B.y),x.circle(B,J),x),H=T(new O,g).makeImmutable(),N=T(T(new O,g+P),g-P).makeImmutable();E(new O,f).makeImmutable(),E(E(new O,f+y),f-y).makeImmutable();const M=k(new O,v,.05).makeImmutable(),m=k(k(k(new O,v,.05),v,.03),v,.01).makeImmutable(),j=new O().moveTo(v.x-.05,v.y-.05).lineTo(v.x+.05,v.y+.05).moveTo(v.x-.05,v.y+.05).lineTo(v.x+.05,v.y-.05).makeImmutable(),z=new O().moveToPoint(c.timesScalar(.1).plus(v.timesScalar(.7))).lineToPoint(v.timesScalar(.7)).lineToPoint(a.timesScalar(.1).plus(v.timesScalar(.7))).makeImmutable(),V=new Map([[C.NONE,j],[C.ONLY_ZERO,M],[C.ONLY_ONE,H],[C.ONLY_TWO,z],[C.NOT_ZERO,N],[C.NOT_ONE,N],[C.NOT_TWO,H],[C.ANY,m]]),X=[.02,.02],$=new Map([[C.NONE,[]],[C.ONLY_ZERO,[]],[C.ONLY_ONE,[]],[C.ONLY_TWO,[]],[C.NOT_ZERO,X],[C.NOT_ONE,[]],[C.NOT_TWO,X],[C.ANY,[]]]),Y=new R(null,{translation:d,lineWidth:.01,lineCap:"butt",visibleProperty:t.sectorsVisibleProperty});this.addChild(Y);const Z=Ce.multilink([e,t.sectorsNextToEdgesVisibleProperty,t.sectorsTrivialVisibleProperty],(x,B,J)=>{const ie=x.getEdgeState(n.edge),ne=x.getEdgeState(n.next.edge),G=x.getSectorState(n);let ae=null,we=null,pe=[],Se=.01;if(B||ie===U.WHITE&&ne===U.WHITE){let ye=C.trivialStates.includes(G);if(G===C.NOT_ONE){const Ae=n.end.edges.filter(fe=>x.getEdgeState(fe)===U.BLACK),Ie=n.end.edges.filter(fe=>x.getEdgeState(fe)===U.WHITE);Ae.length===0&&Ie.length===2&&(ye=!0)}(J||!ye)&&(ae=V.get(G)??null,we=se.getStrokeFromStyle(G,t)??null,pe=$.get(G)??[],pe.length&&(Se=.015))}Y.shape=ae,Y.stroke=we,Y.lineDash=pe,Y.lineWidth=Se});this.disposeEmitter.addListener(()=>Z.dispose())}static getSectorBaseShape(n,e){const t=n.start.viewCoordinates,s=n.end.viewCoordinates,o=n.next.end.viewCoordinates,d=t.minus(s),i=o.minus(s),l=d.normalized(),c=i.normalized().minus(l).angle+Math.PI/2,a=n.face?n.face.viewCoordinates:D.createPolar(e,c).plus(s),p=t.average(s),h=o.average(s);return O.polygon([p,s,h,a]).makeImmutable()}static getSectorArcShape(n,e){const t=n.start.viewCoordinates,s=n.end.viewCoordinates,o=n.next.end.viewCoordinates,d=t.minus(s),i=o.minus(s),l=d.normalized(),r=d.angle;let c=i.angle;return c<r&&(c+=2*Math.PI),new O().moveToPoint(s).lineToPoint(l.timesScalar(e).plus(s)).arcPoint(s,e,r,c,!0).close().makeImmutable()}static getStrokeFromStyle(n,e){return n===C.ONLY_ONE?e.theme.sectorOnlyOneColorProperty:n===C.NOT_ZERO?e.theme.sectorNotZeroColorProperty:n===C.NOT_ONE?e.theme.sectorNotOneColorProperty:n===C.NOT_TWO?e.theme.sectorNotTwoColorProperty:e.theme.sectorOtherColorProperty}};L(se,"nameMap",new Map([[C.NONE,"Invalid"],[C.ONLY_ZERO,"No Lines"],[C.ONLY_ONE,"Only One Line"],[C.ONLY_TWO,"Both Lines"],[C.NOT_ZERO,"At Least One Line"],[C.NOT_ONE,"Zero or Two Lines"],[C.NOT_TWO,"Less Than Two Lines"],[C.ANY,"Any Lines"]]));let K=se;const ht=new re({lineWidth:.2,lineCap:"round",lineJoin:"round"});class pt extends b{constructor(n,e,t){let s;if(Je.value)if(n.type==="edge-state"){const o=new O().moveToPoint(n.edge.start.viewCoordinates).lineToPoint(n.edge.end.viewCoordinates);s=[new R(o.getStrokedShape(ht),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else if(n.type==="face-color")if(n.face){const o=O.polygon(n.face.vertices.map(i=>i.viewCoordinates));s=[new R(o.getOffsetShape(-.1),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else s=[];else if(n.type==="sector"){const o=K.getSectorArcShape(n.sector,.5);s=[new R(o.getOffsetShape(.05),{stroke:t.theme.hoverHighlightColorProperty,lineWidth:.02})]}else s=[];else s=[];super({children:s}),this.hoverHighlight=n}}class ft extends b{constructor(n,e,t,s){let o=[];try{let d=new O;for(const l of n.faces)d.polygon(l.vertices.map(r=>r.viewCoordinates));if(n.faceColor.colorState===te.OUTSIDE)try{const l=O.polygon(e.outerBoundary.map(a=>a.start.viewCoordinates)),c=he.getOffsetBackgroundShape(e.outerBoundary,s.useBackgroundOffsetStroke,s.backgroundOffsetDistance).shapeDifference(l);d=d.shapeUnion(c)}catch(l){console.error(l)}const i=new R(d.getOffsetShape(-.07).getSimplifiedAreaShape(),{stroke:t.theme.selectedFaceColorHighlightColorProperty,lineWidth:.03});o.push(i)}catch(d){console.error(d)}super({children:o}),this.selectedFaceColorHighlight=n}}class ut extends b{constructor(n,e,t,s){const o=[],d=[],i=n.sector,l=n.currentState,r=K.getSectorArcShape(i,.5),c=new R(r.getOffsetShape(.05),{stroke:t.theme.selectedSectorEditColorProperty,lineWidth:.02});o.push(c);const a=[];if(l===C.ANY&&(a.push(C.NOT_ZERO),a.push(C.NOT_ONE),a.push(C.NOT_TWO)),l.one&&l!==C.ONLY_ONE&&a.push(C.ONLY_ONE),a.length){const p=a.map(w=>{const g=K.getStrokeFromStyle(w,t);return new Ze({accessibleName:K.nameMap.get(w),content:new _e(0,0,25,25),listener:()=>{s.sectorSetListener&&s.sectorSetListener(i,w)},buttonAppearanceStrategy:Ge,baseColor:g,xMargin:10.4,yMargin:6.5,mouseAreaXDilation:5,mouseAreaYDilation:5,touchAreaXDilation:5,touchAreaYDilation:5})});d.push(...p);const h=new Me(new Ve({children:p,spacing:10}),{xMargin:10,yMargin:10,fill:t.theme.uiBackgroundColorProperty,stroke:t.theme.uiForegroundColorProperty,scale:.01});d.push(h);const u=.1;o.push(h),h.centerBottom=c.centerTop.plusXY(0,-.15),h.top<e.top+u&&(h.centerTop=c.centerBottom.plusXY(0,.15)),h.left<e.left+u&&(h.left=e.left+u),h.right>e.right-u&&(h.right=e.right-u)}super({children:o}),this.selectedSectorEdit=n,this.disposeEmitter.addListener(()=>{d.forEach(p=>p.dispose())})}}class Oe extends b{constructor(e,t){const s=me()({textOptions:{font:xe,maxWidth:.9,maxHeight:.9},edgePressListener:()=>{},edgeHoverListener:()=>{},facePressListener:()=>{},faceHoverListener:()=>{},sectorPressListener:()=>{},sectorHoverListener:()=>{},sectorSetListener:()=>{},backgroundOffsetDistance:.3,hoverHighlightProperty:new ue(null),selectedFaceColorHighlightProperty:new ue(null),selectedSectorEditProperty:new ue(null),style:Re},t),o=s.style,d=new b({visibleProperty:o.faceColorsVisibleProperty}),i=new b({pickableProperty:Qe}),l=new b({pickableProperty:et}),r=new b({pickableProperty:tt}),c=new b({pickableProperty:ot}),a=new b,p=new b({pickable:!1}),h=new b({pickable:!1}),u=new b({pickable:!1}),w=new b({pickable:!1}),g=new b({pickable:!1}),f=new b,P=new Q([e.stateProperty],E=>{if(E.getWeirdEdges().length||E.hasInvalidFaceColors())return!1;const k=E.getSimpleRegions();return k.length===1&&k[0].isSolved});d.addChild(new dt(e.board,e.stateProperty,o)),e.board.faces.forEach(E=>{i.addChild(new at(E,e.stateProperty,o,s)),h.addChild(new st(E,e.stateProperty,P,o))});const y=new he(e.board.outerBoundary,e.board.innerBoundaries,o,s);e.board.vertices.forEach(E=>{c.addChild(new nt(E,e.stateProperty,P,o)),p.addChild(new rt(E,e.stateProperty,P,o))}),e.board.edges.forEach(E=>{r.addChild(new ct(E,e.stateProperty,P,o,s))}),e.board.halfEdges.forEach(E=>{l.addChild(new K(E,e.stateProperty,o,s))}),a.addChild(new lt(e.board,e.stateProperty,o));super(be({children:[y,d,i,l,r,c,a,p,h,u,w,g,f]},s));L(this,"annotationContainer");L(this,"backgroundNode");this.puzzle=e,this.annotationContainer=u;const v=E=>{g.children.forEach(k=>k.dispose()),E&&g.addChild(new pt(E,s.backgroundOffsetDistance,o))};s.hoverHighlightProperty.link(v),this.disposeEmitter.addListener(()=>s.hoverHighlightProperty.unlink(v));const S=E=>{w.children.forEach(k=>k.dispose()),E&&w.addChild(new ft(E,e.board,o,s))};s.selectedFaceColorHighlightProperty.link(S),this.disposeEmitter.addListener(()=>s.selectedFaceColorHighlightProperty.unlink(S));const T=E=>{f.children.forEach(k=>k.dispose()),E&&f.addChild(new ut(E,y,o,s))};s.selectedSectorEditProperty.link(T),this.disposeEmitter.addListener(()=>s.selectedSectorEditProperty.unlink(T)),this.disposeEmitter.addListener(()=>{[d,i,r,c,a,p,h,l].forEach(k=>{k.children.forEach(H=>H.dispose()),k.dispose()}),P.dispose()}),this.backgroundNode=y}addAnnotationNode(e){this.annotationContainer.addChild(e)}removeAnnotationNode(e){this.annotationContainer.removeChild(e)}clearAnnotationNodes(){this.annotationContainer.removeAllChildren()}getBackgroundBounds(){return this.backgroundNode.bounds}}const gt=(F,n)=>{je(ze,F,n,!0)};class yt extends b{constructor(n,e,t,s=null){let o;const d=r=>new O().moveToPoint(r.start.viewCoordinates).lineToPoint(r.end.viewCoordinates).getStrokedShape(new re({lineWidth:.2,lineCap:"round"})).getStrokedShape(new re({lineWidth:.02})),i=(r,c)=>new R(d(r),{fill:c}),l=[];if(e.type==="ForcedLine")o=[i(e.whiteEdge,"red"),i(e.blackEdge,"blue")];else if(e.type==="AlmostEmptyToRed")o=[i(e.whiteEdge,"red"),...e.redEdges.map(r=>i(r,"blue"))];else if(e.type==="JointToRed")o=[...e.whiteEdges.map(r=>i(r,"red")),...e.blackEdges.map(r=>i(r,"blue"))];else if(e.type==="FaceSatisfied")o=[...e.whiteEdges.map(r=>i(r,"red")),...e.blackEdges.map(r=>i(r,"blue"))];else if(e.type==="FaceAntiSatisfied")o=[...e.whiteEdges.map(r=>i(r,"red")),...e.redEdges.map(r=>i(r,"blue"))];else if(e.type==="ForcedSolveLoop")o=[...e.regionEdges.map(r=>i(r,"blue")),...e.pathEdges.map(r=>i(r,"red"))];else if(e.type==="PrematureForcedLoop")o=[...e.regionEdges.map(r=>i(r,"blue")),...e.pathEdges.map(r=>i(r,"red"))];else if(e.type==="CompletingEdgesAfterSolve")o=[...e.whiteEdges.map(r=>i(r,"red"))];else if(e.type==="FaceColoringBlackEdge")o=[i(e.edge,"red")];else if(e.type==="FaceColoringRedEdge")o=[i(e.edge,"red")];else if(e.type==="FaceColorToBlack")o=[i(e.edge,"red")];else if(e.type==="FaceColorToRed")o=[i(e.edge,"red")];else if(e.type==="FaceColorNoTrivialLoop")o=[...e.face.edges.map(r=>i(r,"red"))];else if(e.type==="FaceColorMatchToRed"||e.type==="FaceColorMatchToBlack"||e.type==="FaceColorBalance")o=[...e.balancedPairs.flatMap((r,c)=>{const a=["green","blue","black"][c%3],p=["magenta","orange","yellow"][c%3];return[...r[0].map(h=>i(h,a)),...r[1].map(h=>i(h,p))]})],e.type==="FaceColorMatchToRed"?o.push(...e.matchingEdges.map(r=>i(r,"red"))):e.type==="FaceColorMatchToBlack"?o.push(...e.matchingEdges.map(r=>i(r,"red"))):e.type==="FaceColorBalance"&&(o.push(...e.matchingEdges.map(r=>i(r,"orange"))),o.push(...e.oppositeEdges.map(r=>i(r,"red"))));else if(e.type==="DoubleMinusOneFaces")o=[...e.toBlackEdges.map(r=>i(r,"red")),...e.toRedEdges.map(r=>i(r,"red"))];else if(e.type==="SingleEdgeToSector"||e.type==="DoubleEdgeToSector")o=[e.sector.edge,e.sector.next.edge].map(r=>i(r,"red"));else if(e.type==="ForcedSector"){const r=[...e.toRedEdges,...e.toBlackEdges];o=[e.sector.edge,e.sector.next.edge].map(c=>i(c,r.includes(c)?"red":"blue"))}else if(e.type==="StaticFaceSectors")o=q.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>i(r,"red"));else if(e.type==="VertexState")o=e.vertex.edges.map(r=>i(r,"blue"));else if(e.type==="VertexStateToEdge")o=[...e.toBlackEdges.map(r=>i(r,"red")),...e.toRedEdges.map(r=>i(r,"red"))];else if(e.type==="VertexStateToSector")o=q.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>i(r,"red"));else if(e.type==="VertexStateToSameFaceColor"||e.type==="VertexStateToOppositeFaceColor")o=q.uniq([...e.facesA,...e.facesB].flatMap(r=>r.edges)).map(r=>i(r,"red"));else if(e.type==="FaceState")o=e.face.edges.map(r=>i(r,"red"));else if(e.type==="FaceStateToEdge")o=[...e.toBlackEdges.map(r=>i(r,"red")),...e.toRedEdges.map(r=>i(r,"red"))];else if(e.type==="FaceStateToSector")o=q.uniq(e.sectors.flatMap(r=>[r.edge,r.next.edge])).map(r=>i(r,"red"));else if(e.type==="FaceStateToSameFaceColor"||e.type==="FaceStateToOppositeFaceColor"){const r=new Set([...e.facesA,...e.facesB].flatMap(a=>a.edges)),c=e.face.edges.filter(a=>!r.has(a));o=[...[...r].map(a=>i(a,"red")),...c.map(a=>i(a,"blue"))]}else if(e.type==="FaceStateToVertexState")o=e.face.edges.filter(c=>e.vertices.includes(c.start)||e.vertices.includes(c.end)).map(c=>i(c,"red"));else if(e.type==="Pattern"){const r=new Set(e.affectedEdges);if(e.affectedSectors.forEach(a=>{r.add(a.edge),r.add(a.next.edge)}),e.affectedFaces.forEach(a=>{a.edges.forEach(p=>r.add(p))}),o=[new b({children:[...r].map(a=>i(a,"red"))})],s){const a=Ye.NOTHING.copy();[e.input,e.output].forEach(N=>{N.faceValues.forEach(M=>{M.face&&M.face.vertices.forEach(m=>{a.addPoint(m.viewCoordinates)})}),[N.blackEdges,N.redEdges].forEach(M=>{M.forEach(m=>{a.addPoint(m.start.viewCoordinates),a.addPoint(m.end.viewCoordinates)})}),[N.sectorsNotZero,N.sectorsNotOne,N.sectorsNotTwo,N.sectorsOnlyOne].forEach(M=>{M.forEach(m=>{a.addPoint(m.edge.start.viewCoordinates),a.addPoint(m.edge.end.viewCoordinates),a.addPoint(m.next.edge.end.viewCoordinates)})}),N.faceColorDuals.forEach(M=>{[M.primaryFaces,M.secondaryFaces].forEach(m=>{m.forEach(j=>{j&&j.vertices.forEach(z=>{a.addPoint(z.viewCoordinates)})})})})});const p=Ne.empty(n),h=Ne.empty(n),u=(N,M)=>{M.faceValues.forEach(m=>{m.face&&N.setFaceValue(m.face,m.value)}),M.blackEdges.forEach(m=>{N.setEdgeState(m,U.BLACK)}),M.redEdges.forEach(m=>{N.setEdgeState(m,U.RED)}),M.sectorsNotZero.forEach(m=>{N.setSectorState(m,C.NOT_ZERO)}),M.sectorsNotOne.forEach(m=>{N.setSectorState(m,C.NOT_ONE)}),M.sectorsNotTwo.forEach(m=>{N.setSectorState(m,C.NOT_TWO)}),M.sectorsOnlyOne.forEach(m=>{N.setSectorState(m,C.ONLY_ONE)}),M.faceColorDuals.forEach(m=>{const j=(V,X)=>{const $=V?N.getFaceColor(V):N.getOutsideColor(),Y=X?N.getFaceColor(X):N.getOutsideColor();new $e(ce(N,$),ce(N,Y)).apply(N)},z=(V,X)=>{const $=V?N.getFaceColor(V):N.getOutsideColor(),Y=X?N.getFaceColor(X):N.getOutsideColor();new qe(ce(N,$),ce(N,Y)).apply(N)};for(let V=1;V<m.primaryFaces.length;V++)j(m.primaryFaces[V-1],m.primaryFaces[V]);for(let V=1;V<m.secondaryFaces.length;V++)j(m.secondaryFaces[V-1],m.secondaryFaces[V]);m.secondaryFaces.length&&z(m.primaryFaces[0],m.secondaryFaces[0])}),gt(n,N)};u(p,e.input),u(h,e.output);const w=new Oe(new ve(n,p)),g=new Oe(new ve(n,h));l.push(()=>{w.dispose(),g.dispose()});const f=.2,P=.5,y=.5,v=a.dilated(f),S=O.roundRectangle(v.x,v.y,v.width,v.height,P,P),T=new b({children:[w],clipArea:S,scale:y}),E=new b({children:[g],clipArea:S,scale:y}),k=new Me(new Ve({spacing:.2,children:[T,E]}),{cornerRadius:P*(y+.2),xMargin:.1,yMargin:.1,lineWidth:.05,stroke:null,fill:Re.theme.patternAnnotationBackgroundColorProperty}),H=f+.05;k.centerBottom=a.centerTop.plusXY(0,-.15),k.top<s.top+H&&(k.centerTop=a.centerBottom.plusXY(0,.15)),k.left<s.left+H&&(k.left=s.left+H),k.right>s.right-H&&(k.right=s.right-H),o.push(k)}}else o=[],console.log(`unknown type: ${e.type}`);super({children:o,pickable:!1}),this.board=n,this.annotation=e,this.style=t,this.disposeEmitter.addListener(()=>l.forEach(r=>r()))}static getHintNode(n){return new it(n.type)}}export{yt as A,Oe as P,gt as s};
