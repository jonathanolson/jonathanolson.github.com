var j=Object.defineProperty;var D=(l,t,e)=>t in l?j(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var m=(l,t,e)=>(D(l,typeof t!="symbol"?t+"":t,e),e);import{l as P}from"./Vector2Property-DCXaH-JP.js";import{a as b,b as f,_ as A}from"./getCoordinateClusteredMap-DCjAm76-.js";import{B as T,a as L,F as O,P as $}from"./FeatureSet-DDOmfIdB.js";import{q as C}from"./patternBoards-Hmq_9LOt.js";import{P as q}from"./PatternRule-CrjXMziT.js";import{F as k,R as w,I as V,B as H,S as U,a as Z,b as G}from"./FaceColorDualFeature-DKZsSiFX.js";import{G as W,H as z}from"./HighlanderPruner-DdNF9lmw.js";const K={...T,featureLimit:Number.POSITIVE_INFINITY,hitFeatureLimitCallback:null,includeFaceValueZero:!1,prefilterRules:null,logModulo:1e6,vertexOrderLimit:null};class x{constructor(t,e){this.numAttributes=t,this.data=e}or(t){b()&&f(this.numAttributes===t.numAttributes),this.data=this.data|t.data}and(t){b()&&f(this.numAttributes===t.numAttributes),this.data=this.data&t.data}not(){this.data=(1n<<BigInt(this.numAttributes))-1n-this.data}set(t){b()&&f(t<this.numAttributes&&t>=0),this.data|=1n<<BigInt(t)}clear(t){this.data&=~(1n<<BigInt(t))}isLessThan(t){return b()&&f(this.numAttributes===t.numAttributes),this.data<t.data}isLessThanOrEqual(t){return b()&&f(this.numAttributes===t.numAttributes),this.data<=t.data}isLessThanI(t,e){if(b()&&f(this.numAttributes===t.numAttributes),!t.hasAttribute(e)||this.hasAttribute(e))return!1;const n=~((1n<<BigInt(e+1))-1n),s=this.data&n,r=t.data&n;return s===r}union(t){return b()&&f(this.numAttributes===t.numAttributes),new x(this.numAttributes,this.data|t.data)}intersection(t){return b()&&f(this.numAttributes===t.numAttributes),new x(this.numAttributes,this.data&t.data)}complement(){return new x(this.numAttributes,(1n<<BigInt(this.numAttributes))-1n-this.data)}clone(){return new x(this.numAttributes,this.data)}equals(t){return this.data===t.data}isSubsetOf(t){return(this.data&t.data)===this.data}isProperSubsetOf(t){return this.isSubsetOf(t)&&!this.equals(t)}isEmpty(){return this.data===0n}getCardinality(){let t=0n,e=this.data;for(;e;)t+=e&1n,e>>=1n;return Number(t)}withAttribute(t){return new x(this.numAttributes,this.data|1n<<BigInt(t))}withLowestBitSet(t){return new x(this.numAttributes,this.data&~((1n<<BigInt(t))-1n)|1n<<BigInt(t))}hasAttribute(t){return(this.data&1n<<BigInt(t))!==0n}getAttributes(){const t=[];for(let e=0;e<this.numAttributes;e++)this.hasAttribute(e)&&t.push(e);return t}toString(){return`[${A.range(0,this.numAttributes).map(t=>this.hasAttribute(t)?"1":"0").join("")} (${this.getAttributes().join(",")}) #${this.numAttributes}]`}static getEmpty(t){return new x(t,0n)}static getFull(t){return new x(t,(1n<<BigInt(t))-1n)}static fromBinary(t,e){return b()&&f(e<1n<<BigInt(t)&&e>=0n),new x(t,e)}static fromCallback(t,e){let n=0n;for(let s=0;s<t;s++)e(s)&&(n|=1n<<BigInt(s));return new x(t,n)}}class y extends x{constructor(e,n,s){super(e,n);m(this,"optionalDataComplement");m(this,"withOptionalData");this.optionalData=s,this.optionalDataComplement=(1n<<BigInt(e))-1n-this.optionalData,this.withOptionalData=n|this.optionalData,b()&&f((n&s)===0n)}hasOptionalAttribute(e){return(this.optionalData&1n<<BigInt(e))!==0n}getOptionalAttributes(){const e=[];for(let n=0;n<this.numAttributes;n++)this.hasOptionalAttribute(n)&&e.push(n);return e}toString(){const e=`OPT: [${A.range(0,this.numAttributes).map(n=>this.hasOptionalAttribute(n)?"1":"0").join("")} (${this.getOptionalAttributes().join(",")})`;return`${super.toString()} ${e})`}static fromSolutionBinary(e,n,s){return new y(e,n,s)}static solutionClosure(e,n,s){let r=(1n<<BigInt(e))-1n;const i=n.length;for(let a=0;a<i;a++){const o=n[a];(s&o.withOptionalData)===s&&(r&=o.data|s&o.optionalData)}return r}}class N{constructor(t,e){this.antecedent=t,this.consequent=e}toString(){return`${this.antecedent.toString()} -> ${this.consequent.toString()}`}static implicationSetClosure(t,e){let n=e,s=!0;for(;s;){s=!1;const r=t.length;for(let i=0;i<r;i++){const a=t[i],o=a.antecedent,c=a.consequent,h=n;(o&h)===o&&o!==h&&(c&h)!==c&&(n|=c,s=!0)}}return n}static implicationSetClosureLessThanI(t,e,n){if((e&1n<<BigInt(n))!==0n)return null;let s=e&~((1n<<BigInt(n))-1n)|1n<<BigInt(n),i=~((1n<<BigInt(n+1))-1n)&~s,a=!0;for(;a;){a=!1;const o=t.length;for(let c=0;c<o;c++){const h=t[c],u=h.antecedent,g=h.consequent;if((u&s)===u&&u!==s&&(g&s)!==g){if(g&i)return null;s|=g,a=!0}}}return s}}class Y{static forEachImplication(t,e,n,s){const r=(s==null?void 0:s.logModulo)??1e6,i=s==null?void 0:s.logModuloCallback,a=[];let o=0n;const c=new Array(t).fill(0n);let h=0;const u=Date.now();for(;o!==null;){h++,h%r===0&&i&&i(h,o,a,Math.round((Date.now()-u)/1e3));const g=e(o);if(o!==g){const p=new N(o,g);n(p),a.push(p);let I=o;if(I!==0n&&(I&I-1n)===0n){let B=0;for(;I>1n;)I>>=1n,B++;const S=~((1n<<BigInt(B+1))-1n);c[B]|=S&g}}let d=null;for(let p=0;p<t;p++){if((o&c[p])!==c[p])continue;const I=N.implicationSetClosureLessThanI(a,o,p);if(I!==null){d=I;break}}if(d!==null)o=d;else break}}}const v=(l,t)=>(l.withOptionalData&1n<<BigInt(t))!==0n;class J{constructor(t,e){m(this,"singleAttributeObjectsMap");m(this,"doubleAttributeObjectsMap");this.numAttributes=t,this.solutionAttributeSets=e,e.length>350?(this.singleAttributeObjectsMap=A.range(0,t).map(n=>e.filter(s=>v(s,n))),console.log(`single filter size: ${A.sum(this.singleAttributeObjectsMap.map(n=>n.length))}`),e.length>1500?(this.doubleAttributeObjectsMap=A.range(0,t).map(n=>A.range(n+1,t).map(s=>this.singleAttributeObjectsMap[n].filter(r=>v(r,s)))),console.log(`double filter size: ${A.sum(this.doubleAttributeObjectsMap.map(n=>A.sum(n.map(s=>s.length))))}`)):this.doubleAttributeObjectsMap=null):(this.singleAttributeObjectsMap=null,this.doubleAttributeObjectsMap=null)}getSolutionAttributeSets(t){let e=this.solutionAttributeSets;if(this.singleAttributeObjectsMap){let n=[],s=t,r=0;for(;s>0n;)s&1n&&n.push(r),s>>=1n,r++;if(this.doubleAttributeObjectsMap&&n.length>=2)for(let i=0;i<n.length-1;i++){const a=n[i],o=n[i+1],c=this.doubleAttributeObjectsMap[a][o-(a+1)];c.length<e.length&&(e=c)}else if(n.length>=1)for(let i=0;i<n.length;i++){const a=this.singleAttributeObjectsMap[n[i]];a.length<e.length&&(e=a)}}return e}}class Q{constructor(t,e){m(this,"numAttributes");m(this,"numNonExitEdges");m(this,"sectorBaseIndex");m(this,"facePairBaseIndex");m(this,"extraPairs",[]);m(this,"primaryFeatures",[]);m(this,"allFeatures",[]);m(this,"empty",0n);m(this,"full");this.patternBoard=t;const n=L.get(t);let s=0,r=0;if(e.solveEdges)for(const i of t.edges)if(i.isExit){b()&&f(r===i.index+s),r++;const a=new w(i);this.primaryFeatures.push(a),this.allFeatures.push([a])}else{b()&&f(r===2*i.index),s++,r+=2;const a=new w(i),o=new H(i);this.primaryFeatures.push(a),this.primaryFeatures.push(o),this.allFeatures.push([a]),this.allFeatures.push([o])}if(this.sectorBaseIndex=r,e.solveSectors)for(const i of t.sectors){b()&&f(r===3*i.index+this.sectorBaseIndex),r+=3;const a=new U(i),o=new Z(i),c=new G(i);this.primaryFeatures.push(a),this.primaryFeatures.push(o),this.primaryFeatures.push(c),this.allFeatures.push([a]),this.allFeatures.push([o]),this.allFeatures.push([c])}if(this.facePairBaseIndex=r,e.solveFaceColors)for(const i of n.connectedFacePairs){const a=k.fromPrimarySecondaryFaces([i.a,i.b],[]),o=k.fromPrimarySecondaryFaces([i.a],[i.b]);e.solveEdges&&i.shortestPath.length===1?(this.allFeatures[this.getNonExitRedIndex(i.shortestPath[0])].push(a),this.allFeatures[this.getNonExitBlackIndex(i.shortestPath[0])].push(o)):(this.extraPairs.push(i),r+=2,this.primaryFeatures.push(a),this.primaryFeatures.push(o),this.allFeatures.push([a]),this.allFeatures.push([o]))}this.numNonExitEdges=s,this.numAttributes=r,this.full=(1n<<BigInt(this.numAttributes))-1n}getSolutionAttributeSet(t){let e=0n,n=0n;const s=r=>t.has(r);for(let r=0;r<this.numAttributes;r++){const i=this.primaryFeatures[r];i instanceof w&&i.edge.isExit?i.edge.exitVertex.edges.every(a=>!s(a))?n|=1n<<BigInt(r):s(i.edge)||(e|=1n<<BigInt(r)):i.isPossibleWith(s)&&(e|=1n<<BigInt(r))}return y.fromSolutionBinary(this.numAttributes,e,n)}getFeatureSetBits(t){let e=0n;for(let n=0;n<this.numAttributes;n++){const s=this.primaryFeatures[n];t.impliesFeature(s)&&(e|=1n<<BigInt(n))}return e}bitsHaveIndex(t,e){return(t&1n<<BigInt(e))!==0n}getBitsIndices(t){const e=[];for(let n=0;n<this.numAttributes;n++)this.bitsHaveIndex(t,n)&&e.push(n);return e}getBitsPrimaryFeatures(t){const e=[];for(let n=0;n<this.numAttributes;n++)this.bitsHaveIndex(t,n)&&e.push(this.primaryFeatures[n]);return e}getBitsFeatureSet(t){if(t===this.full)return null;const e=O.empty(this.patternBoard);for(let n=0;n<this.numAttributes;n++)if(this.bitsHaveIndex(t,n)){const s=this.primaryFeatures[n];try{e.addFeature(s)}catch(r){if(r instanceof V)return null;throw r}}return e}getBinaryString(t){return A.range(0,this.numAttributes).map(e=>this.bitsHaveIndex(t,e)?"1":"0").join("")}getIndicesString(t){return this.getBitsIndices(t).join(",")}getFeaturesString(t){return this.getBitsPrimaryFeatures(t).map(e=>e.toCanonicalString()).join(", ")}getFeaturesSetString(t){const e=this.getBitsFeatureSet(t);return e?e.toCanonicalString():"null"}getNonExitRedIndex(t){return 2*t.index}getNonExitBlackIndex(t){return 2*t.index+1}getExitIndex(t){return this.numNonExitEdges+t.index}getSectorNotZeroIndex(t){return 3*t.index+this.sectorBaseIndex}getSectorNotOneIndex(t){return 3*t.index+this.sectorBaseIndex+1}getSectorNotTwoIndex(t){return 3*t.index+this.sectorBaseIndex+2}getNonExitEdgeRedMask(t){return 1n<<BigInt(2*t.index)}getNonExitEdgeBlackMask(t){return 1n<<BigInt(2*t.index+1)}getNonExitEdgeMask(t){return 3n<<BigInt(2*t.index)}getExitEdgeMask(t){return 1n<<BigInt(this.numNonExitEdges+t.index)}getEdgeMask(t){return t.isExit?this.getExitEdgeMask(t):this.getNonExitEdgeMask(t)}getSectorNotZeroMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex)}getSectorNotOneMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+1)}getSectorNotTwoMask(t){return 1n<<BigInt(3*t.index+this.sectorBaseIndex+2)}getSectorMask(t){return 7n<<BigInt(3*t.index+this.sectorBaseIndex)}}class X extends W{constructor(e,n,s,r){b()&&f(e===n.patternBoard);super(e,s,r);m(this,"solutionAttributeSet");this.patternBoard=e,this.binaryFeatureMap=n,this.solution=s,this.solutionAttributeSet=n.getSolutionAttributeSet(this.solutionSet)}toDebugString(){return`[${this.binaryFeatureMap.getBinaryString(this.solutionAttributeSet.data)}] (${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.data)}) opt:(${this.binaryFeatureMap.getFeaturesString(this.solutionAttributeSet.optionalData)}) ${this.vertexConnectionKey??""}`}}const _={logModulo:1e6},tt=(l,t,e,n,s,r)=>{const i=P()({},_,r),a={solveEdges:t,solveSectors:e,solveFaceColors:n,highlander:s},o=l.patternBoard,c=l.getFeaturesArray(),h=new Q(o,a),u=h.numAttributes,d=$.getSolutions(o,c).map(S=>new X(o,h,S,a.highlander));let p;if(s){const S=new z(l,h,d);p=F=>{const E=S.getSolutionAttributeSets(F);return y.solutionClosure(u,E,F)}}else{const S=new J(u,d.map(F=>h.getSolutionAttributeSet(F.solutionSet)));p=F=>{const E=S.getSolutionAttributeSets(F);return y.solutionClosure(u,E,F)}}const I=(1n<<BigInt(u))-1n,B=[];return Y.forEachImplication(u,p,S=>{if(S.consequent===I)return;const F=l.clone(),E=l.clone(),M=h.getBitsFeatureSet(S.antecedent);F.applyFeaturesFrom(M);const R=h.getBitsFeatureSet(S.consequent);E.applyFeaturesFrom(R),!F.equals(E)&&B.push(new q(o,F,E,s))},{logModulo:i.logModulo,logModuloCallback:(S,F,E,M)=>{console.log(`${S.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")} [${h.getBinaryString(F)}] (${h.getIndicesString(F)}) ${E.length} ${M}s`)}}),B},lt=(l,t)=>{const e=P()({},K,t);b()&&f(!isFinite(e.featureLimit));const n=C(l,l),s=e.highlander?l.faces.filter(u=>{if(!u.isExit||u.edges.length!==1)return!1;const d=u.edges[0].faces.find(p=>p!==u);return d?!d.isExit:!1}):[],r=[],i=[...l.faces.filter(u=>!u.isExit),...s],a=(u,g)=>{if(g===i.length)u.isCanonicalWith(n)&&r.push(u);else{const d=i[g],p=d.isExit?[]:A.range(e.includeFaceValueZero?0:1,d.edges.length);e.highlander&&p.push(null),a(u,g+1);for(const I of p){const B=u.clone();B.addFaceValue(d,I),a(B,g+1)}}},o=e.vertexOrderLimit===null?O.empty(l):O.emptyWithVertexOrderLimit(l,e.vertexOrderLimit);a(o,0);const c=(e.prefilterRules??[]).flatMap(u=>u.getEmbeddedRules(C(u.patternBoard,l))),h=[];for(const u of r){console.log(u.toCanonicalString());const g=tt(u,e.solveEdges,e.solveSectors,e.solveFaceColors,e.highlander,{logModulo:e.logModulo});for(const d of g)d.isRedundant(c)||(h.push(d),c.push(...d.getEmbeddedRules(n)))}return A.sortBy(h,u=>u.inputFeatureSet.getInputDifficultyScoreA())};export{Q as B,X as R,lt as g};
